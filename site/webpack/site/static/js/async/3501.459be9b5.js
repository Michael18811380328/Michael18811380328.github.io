"use strict";(self.webpackChunk=self.webpackChunk||[]).push([["3501"],{9737:function(e,n,s){s.r(n),s.d(n,{default:function(){return l}});var c=s(6469),d=s(8809);function r(e){let n=Object.assign({h1:"h1",a:"a",p:"p",code:"code",img:"img",h3:"h3",blockquote:"blockquote",pre:"pre",ol:"ol",li:"li",h4:"h4",ul:"ul"},(0,d.ah)(),e.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(n.h1,{id:"带你深度解锁webpack系列进阶篇",children:["带你深度解锁Webpack系列(进阶篇)",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#带你深度解锁webpack系列进阶篇",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"统计信息：字数 29666  阅读60分钟"}),"\n",(0,c.jsx)(n.p,{children:"掘金"}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.a,{href:"https://juejin.cn/user/3368559358523944/posts",target:"_blank",rel:"noopener noreferrer",children:"无名之苝"})}),"\n",(0,c.jsx)(n.p,{children:"2020-03-0947,221阅读15分钟"}),"\n",(0,c.jsxs)(n.p,{children:["三篇长文，带你解锁 ",(0,c.jsx)(n.code,{children:"Webpack"})," ，希望读完这三篇文章，你能够对 ",(0,c.jsx)(n.code,{children:"webpack"})," 的各项配置有一个更为清晰的认识。"]}),"\n",(0,c.jsxs)(n.p,{children:["本文是第二篇，如果你还没有阅读",(0,c.jsx)(n.a,{href:"https://juejin.cn/post/6844904079219490830",target:"_blank",rel:"noopener noreferrer",children:"《带你深度解锁Webpack系列(基础篇)》"}),"，建议阅读之后，再继续阅读本文。"]}),"\n",(0,c.jsxs)(n.p,{children:["本文会引入更多的 ",(0,c.jsx)(n.code,{children:"webpack"})," 配置，如果文中有任何错误，欢迎在评论区指正，我会尽快修正。 ",(0,c.jsx)(n.code,{children:"webpack"})," 优化部分放在了下一篇。"]}),"\n",(0,c.jsx)(n.p,{children:"推荐大家参考本文一步一步进行配置，不要总是想着找什么最佳配置，掌握之后，根据自己的需求配置出来的，就是最佳配置。"}),"\n",(0,c.jsxs)(n.p,{children:["本文对应的项目地址(编写本文时使用) 供参考：",(0,c.jsx)(n.a,{href:"https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FYvetteLau%2Fwebpack%2Ftree%2Fmaster%2Fwebpack-second",target:"_blank",rel:"noopener noreferrer",children:"github.com/YvetteLau/w…"})]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.img,{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/9/170bae7ee866b278~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp",alt:"img"})}),"\n",(0,c.jsxs)(n.h3,{id:"1-静态资源拷贝",children:["1. 静态资源拷贝",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-静态资源拷贝",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["有些时候，我们需要使用已有的JS文件、CSS文件（本地文件），但是不需要 ",(0,c.jsx)(n.code,{children:"webpack"})," 编译。例如，我们在 ",(0,c.jsx)(n.code,{children:"public/index.html"})," 中引入了 ",(0,c.jsx)(n.code,{children:"public"})," 目录下的 ",(0,c.jsx)(n.code,{children:"js"})," 或 ",(0,c.jsx)(n.code,{children:"css"})," 文件。这个时候，如果直接打包，那么在构建出来之后，肯定是找不到对应的 ",(0,c.jsx)(n.code,{children:"js"})," / ",(0,c.jsx)(n.code,{children:"css"})," 了。"]}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"public"})," 目录结构"]}),"\n"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"├── public\n│   ├── config.js\n│   ├── index.html\n│   ├── js\n│   │   ├── base.js\n│   │   └── other.js\n│   └── login.html\n"})}),"\n",(0,c.jsxs)(n.p,{children:["现在，我们在 ",(0,c.jsx)(n.code,{children:"index.html"})," 中引入了 ",(0,c.jsx)(n.code,{children:"./js/base.js"}),"。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:'\x3c!-- index.html --\x3e\n<script src="./js/base.js"><\/script>\n'})}),"\n",(0,c.jsxs)(n.p,{children:["这时候，我们 ",(0,c.jsx)(n.code,{children:"npm run dev"}),"，会发现有找不到该资源文件的报错信息。"]}),"\n",(0,c.jsxs)(n.p,{children:["对于这个问题，我们可以手动将其拷贝至构建目录，然后在配置 ",(0,c.jsx)(n.code,{children:"CleanWebpackPlugin"})," 时，注意不要清空对应的文件或文件夹即可，但是如若这个静态文件时不时的还会修改下，那么依赖于手动拷贝，是很容易出问题的。"]}),"\n",(0,c.jsx)(n.p,{children:"不要过于相信自己的记性，依赖于手动拷贝的方式，大多数人应该都有过忘记拷贝的经历，你要是说你从来没忘过。"}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.img,{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/9/170bae7eedad0932~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp",alt:"050a81c7-59e4-4596-b08f-62cefce353d0.jpg"})}),"\n",(0,c.jsxs)(n.p,{children:["幸运的是，",(0,c.jsx)(n.code,{children:"webpack"})," 为我们这些记性不好又爱偷懒的人提供了好用的插件 ",(0,c.jsx)(n.a,{href:"https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.js.org%2Fplugins%2Fcopy-webpack-plugin%2F",target:"_blank",rel:"noopener noreferrer",children:"CopyWebpackPlugin"}),"，它的作用就是将单个文件或整个目录复制到构建目录。"]}),"\n",(0,c.jsx)(n.p,{children:"首先安装一下依赖："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"npm install copy-webpack-plugin -D\n"})}),"\n",(0,c.jsxs)(n.p,{children:["修改配置(当前，需要做的是将 ",(0,c.jsx)(n.code,{children:"public/js"})," 目录拷贝至 ",(0,c.jsx)(n.code,{children:"dist/js"})," 目录)："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"//webpack.config.js\nconst CopyWebpackPlugin = require('copy-webpack-plugin');\nmodule.exports = {\n    //...\n    plugins: [\n        new CopyWebpackPlugin([\n            {\n                from: 'public/js/*.js',\n                to: path.resolve(__dirname, 'dist', 'js'),\n                flatten: true,\n            },\n            //还可以继续配置其它要拷贝的文件\n        ])\n    ]\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["此时，重新执行 ",(0,c.jsx)(n.code,{children:"npm run dev"}),"，报错信息已经消失。"]}),"\n",(0,c.jsxs)(n.p,{children:["这里说一下 ",(0,c.jsx)(n.code,{children:"flatten"})," 这个参数，设置为 ",(0,c.jsx)(n.code,{children:"true"}),"，那么它只会拷贝文件，而不会把文件夹路径都拷贝上，大家可以不设置 ",(0,c.jsx)(n.code,{children:"flatten"})," 时，看下构建结果。"]}),"\n",(0,c.jsxs)(n.p,{children:["另外，如果我们要拷贝一个目录下的很多文件，但是想过滤掉某个或某些文件，那么 ",(0,c.jsx)(n.code,{children:"CopyWebpackPlugin"})," 还为我们提供了 ",(0,c.jsx)(n.code,{children:"ignore"})," 参数。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"//webpack.config.js\nconst CopyWebpackPlugin = require('copy-webpack-plugin');\nmodule.exports = {\n    //...\n    plugins: [\n        new CopyWebpackPlugin([\n            {\n                from: 'public/js/*.js',\n                to: path.resolve(__dirname, 'dist', 'js'),\n                flatten: true,\n            }\n        ], {\n            ignore: ['other.js']\n        })\n    ]\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["例如，这里我们忽略掉 ",(0,c.jsx)(n.code,{children:"js"})," 目录下的 ",(0,c.jsx)(n.code,{children:"other.js"})," 文件，使用 ",(0,c.jsx)(n.code,{children:"npm run build"})," 构建，可以看到 ",(0,c.jsx)(n.code,{children:"dist/js"})," 下不会出现 ",(0,c.jsx)(n.code,{children:"other.js"})," 文件。 ",(0,c.jsx)(n.code,{children:"CopyWebpackPlugin"})," 还提供了很多其它的参数，如果当前的配置不能满足你，可以查阅文档进一步修改配置。"]}),"\n",(0,c.jsxs)(n.h3,{id:"2provideplugin",children:["2.ProvidePlugin",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2provideplugin",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"ProvidePlugin"})," 在我看来，是为懒人准备的，不过也别过度使用，毕竟全局变量不是什么“好东西”。",(0,c.jsx)(n.code,{children:"ProvidePlugin"})," 的作用就是不需要 ",(0,c.jsx)(n.code,{children:"import"})," 或 ",(0,c.jsx)(n.code,{children:"require"})," 就可以在项目中到处使用。"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"ProvidePlugin"})," 是 ",(0,c.jsx)(n.code,{children:"webpack"})," 的内置插件，使用方式如下："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"new webpack.ProvidePlugin({\n  identifier1: 'module1',\n  identifier2: ['module2', 'property2']\n});\n"})}),"\n",(0,c.jsxs)(n.p,{children:["默认寻找路径是当前文件夹 ",(0,c.jsx)(n.code,{children:"./**"})," 和 ",(0,c.jsx)(n.code,{children:"node_modules"}),"，当然啦，你可以指定全路径。"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"React"})," 大家都知道的，使用的时候，要在每个文件中引入 ",(0,c.jsx)(n.code,{children:"React"}),"，不然立刻抛错给你看。还有就是 ",(0,c.jsx)(n.code,{children:"jquery"}),", ",(0,c.jsx)(n.code,{children:"lodash"})," 这样的库，可能在多个文件中使用，但是懒得每次都引入，好嘛，一起来偷个懒，修改下 ",(0,c.jsx)(n.code,{children:"webpack"})," 的配置:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"const webpack = require('webpack');\nmodule.exports = {\n    //...\n    plugins: [\n        new webpack.ProvidePlugin({\n            React: 'react',\n            Component: ['react', 'Component'],\n            Vue: ['vue/dist/vue.esm.js', 'default'],\n            $: 'jquery',\n            _map: ['lodash', 'map']\n        })\n    ]\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["这样配置之后，你就可以在项目中随心所欲的使用 ",(0,c.jsx)(n.code,{children:"$"}),"、",(0,c.jsx)(n.code,{children:"_map"}),"了，并且写 ",(0,c.jsx)(n.code,{children:"React"})," 组件时，也不需要 ",(0,c.jsx)(n.code,{children:"import"})," ",(0,c.jsx)(n.code,{children:"React"})," 和 ",(0,c.jsx)(n.code,{children:"Component"})," 了，如果你想的话，你还可以把 ",(0,c.jsx)(n.code,{children:"React"})," 的 ",(0,c.jsx)(n.code,{children:"Hooks"})," 都配置在这里。"]}),"\n",(0,c.jsxs)(n.p,{children:["另外呢，",(0,c.jsx)(n.code,{children:"Vue"})," 的配置后面多了一个 ",(0,c.jsx)(n.code,{children:"default"}),"，这是因为 ",(0,c.jsx)(n.code,{children:"vue.esm.js"})," 中使用的是 ",(0,c.jsx)(n.code,{children:"export default"})," 导出的，对于这种，必须要指定 ",(0,c.jsx)(n.code,{children:"default"}),"。",(0,c.jsx)(n.code,{children:"React"})," 使用的是 ",(0,c.jsx)(n.code,{children:"module.exports"})," 导出的，因此不要写 ",(0,c.jsx)(n.code,{children:"default"}),"。"]}),"\n",(0,c.jsxs)(n.p,{children:["另外，就是如果你项目启动了 ",(0,c.jsx)(n.code,{children:"eslint"})," 的话，记得修改下 ",(0,c.jsx)(n.code,{children:"eslint"})," 的配置文件，增加以下配置："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:'{\n    "globals": {\n        "React": true,\n        "Vue": true,\n        //....\n    }\n}\n'})}),"\n",(0,c.jsx)(n.p,{children:"当然啦，偷懒要有个度，你要是配一大堆全局变量，最终可能会给自己带来麻烦，对自己配置的全局变量一定要负责到底。"}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.img,{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/9/170bae7ef26d2ca3~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp",alt:"u=2243033496,1576809017&fm=15&gp=0.jpg"})}),"\n",(0,c.jsxs)(n.h3,{id:"3抽离css",children:["3.抽离CSS",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3抽离css",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"CSS打包我们前面已经说过了，不过呢，有些时候，我们可能会有抽离CSS的需求，即将CSS文件单独打包，这可能是因为打包成一个JS文件太大，影响加载速度，也有可能是为了缓存(例如，只有JS部分有改动)，还有可能就是“我高兴”：我想抽离就抽离，谁也管不着。"}),"\n",(0,c.jsx)(n.p,{children:"不管你是因为什么原因要抽离CSS，只要你有需求，我们就可以去实现。"}),"\n",(0,c.jsxs)(n.p,{children:["首先，安装 ",(0,c.jsx)(n.code,{children:"loader"}),":"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"npm install mini-css-extract-plugin -D\n"})}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"mini-css-extract-plugin"})," 和 ",(0,c.jsx)(n.code,{children:"extract-text-webpack-plugin"})," 相比:"]}),"\n"]}),"\n",(0,c.jsxs)(n.ol,{children:["\n",(0,c.jsx)(n.li,{children:"异步加载"}),"\n",(0,c.jsx)(n.li,{children:"不会重复编译(性能更好)"}),"\n",(0,c.jsx)(n.li,{children:"更容易使用"}),"\n",(0,c.jsx)(n.li,{children:"只适用CSS"}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"修改我们的配置文件："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"//webpack.config.js\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin');\nmodule.exports = {\n    plugins: [\n        new MiniCssExtractPlugin({\n            filename: 'css/[name].css'\n            //个人习惯将css文件放在单独目录下\n            //publicPath:'../'   //如果你的output的publicPath配置的是 './' 这种相对路径，那么如果将css文件放在单独目录下，记得在这里指定一下publicPath \n        })\n    ],\n    module: {\n        rules: [\n            {\n                test: /\\.(le|c)ss$/,\n                use: [\n                    MiniCssExtractPlugin.loader, //替换之前的 style-loader\n                    'css-loader', {\n                        loader: 'postcss-loader',\n                        options: {\n                            plugins: function () {\n                                return [\n                                    require('autoprefixer')({\n                                        \"overrideBrowserslist\": [\n                                            \"defaults\"\n                                        ]\n                                    })\n                                ]\n                            }\n                        }\n                    }, 'less-loader'\n                ],\n                exclude: /node_modules/\n            }\n        ]\n    }\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["现在，我们重新编译：",(0,c.jsx)(n.code,{children:"npm run build"}),"，目录结构如下所示:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:".\n├── dist\n│   ├── assets\n│   │   ├── alita_e09b5c.jpg\n│   │   └── thor_e09b5c.jpeg\n│   ├── css\n│   │   ├── index.css\n│   │   └── index.css.map\n│   ├── bundle.fb6d0c.js\n│   ├── bundle.fb6d0c.js.map\n│   └── index.html\n"})}),"\n",(0,c.jsxs)(n.p,{children:["前面说了最好新建一个 ",(0,c.jsx)(n.code,{children:".browserslistrc"})," 文件，这样可以多个 ",(0,c.jsx)(n.code,{children:"loader"})," 共享配置，所以，动手在根目录下新建文件 (",(0,c.jsx)(n.code,{children:".browserslistrc"}),")，内容如下（你可以根据自己项目需求，修改为其它的配置）:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"last 2 version\n> 0.25%\nnot dead\n"})}),"\n",(0,c.jsxs)(n.p,{children:["修改 ",(0,c.jsx)(n.code,{children:"webpack.config.js"}),"："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"//webpack.config.js\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin');\nmodule.exports = {\n    //...\n    plugins: [\n        new MiniCssExtractPlugin({\n            filename: 'css/[name].css' \n        })\n    ],\n    module: {\n        rules: [\n            {\n                test: /\\.(c|le)ss$/,\n                use: [\n                    MiniCssExtractPlugin.loader,\n                    'css-loader', {\n                        loader: 'postcss-loader',\n                        options: {\n                            plugins: function () {\n                                return [\n                                    require('autoprefixer')()\n                                ]\n                            }\n                        }\n                    }, 'less-loader'\n                ],\n                exclude: /node_modules/\n            },\n        ]\n    }\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["要测试自己的 ",(0,c.jsx)(n.code,{children:".browserlistrc"})," 有没有生效也很简单，直接将文件内容修改为 ",(0,c.jsx)(n.code,{children:"last 1 Chrome versions"})," ，然后对比修改前后的构建出的结果，就能看出来啦。"]}),"\n",(0,c.jsxs)(n.p,{children:["可以查看更多[browserslistrc]配置项(",(0,c.jsx)(n.a,{href:"https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fbrowserslist%2Fbrowserslist",target:"_blank",rel:"noopener noreferrer",children:"github.com/browserslis…"}),")"]}),"\n",(0,c.jsxs)(n.p,{children:["更多配置项，可以查看",(0,c.jsx)(n.a,{href:"https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fwebpack-contrib%2Fmini-css-extract-plugin",target:"_blank",rel:"noopener noreferrer",children:"mini-css-extract-plugin"})]}),"\n",(0,c.jsxs)(n.h4,{id:"将抽离出来的css文件进行压缩",children:["将抽离出来的css文件进行压缩",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#将抽离出来的css文件进行压缩",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["使用 ",(0,c.jsx)(n.code,{children:"mini-css-extract-plugin"}),"，",(0,c.jsx)(n.code,{children:"CSS"})," 文件默认不会被压缩，如果想要压缩，需要配置 ",(0,c.jsx)(n.code,{children:"optimization"}),"，首先安装 ",(0,c.jsx)(n.code,{children:"optimize-css-assets-webpack-plugin"}),"."]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"npm install optimize-css-assets-webpack-plugin -D\n"})}),"\n",(0,c.jsx)(n.p,{children:"修改webpack配置："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"//webpack.config.js\nconst OptimizeCssPlugin = require('optimize-css-assets-webpack-plugin');\n\nmodule.exports = {\n    entry: './src/index.js',\n    //....\n    plugins: [\n        new OptimizeCssPlugin()\n    ],\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["注意，这里将 ",(0,c.jsx)(n.code,{children:"OptimizeCssPlugin"})," 直接配置在 ",(0,c.jsx)(n.code,{children:"plugins"})," 里面，那么 ",(0,c.jsx)(n.code,{children:"js"})," 和 ",(0,c.jsx)(n.code,{children:"css"})," 都能够正常压缩，如果你将这个配置在 ",(0,c.jsx)(n.code,{children:"optimization"}),"，那么需要再配置一下 ",(0,c.jsx)(n.code,{children:"js"})," 的压缩(开发环境下不需要去做CSS的压缩，因此后面记得将其放到 ",(0,c.jsx)(n.code,{children:"webpack.config.prod.js"})," 中哈)。"]}),"\n",(0,c.jsxs)(n.p,{children:["配置完之后，测试的时候发现，抽离之后，修改 ",(0,c.jsx)(n.code,{children:"css"})," 文件时，第一次页面会刷新，但是第二次页面不会刷新 —— 好嘛，我平时的业务中用不着抽离 ",(0,c.jsx)(n.code,{children:"css"}),"，这个问题搁置了好多天(准确来说是忘记了)。"]}),"\n",(0,c.jsxs)(n.p,{children:["3月8号再次修改这篇文章的时候，正好看到了 ",(0,c.jsx)(n.code,{children:"MiniCssExtractPlugin.loader"})," 对应的 ",(0,c.jsx)(n.code,{children:"option"})," 设置，我们再次修改下对应的 ",(0,c.jsx)(n.code,{children:"rule"}),"。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"module.exports = {\n    rules: [\n        {\n            test: /\\.(c|le)ss$/,\n            use: [\n                {\n                    loader: MiniCssExtractPlugin.loader,\n                    options: {\n                        hmr: isDev,\n                        reloadAll: true,\n                    }\n                },\n                //...\n            ],\n            exclude: /node_modules/\n        }\n    ]\n}\n"})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.img,{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/9/170bae7ef4ea39dd~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp",alt:"img"})}),"\n",(0,c.jsxs)(n.h3,{id:"4按需加载",children:["4.按需加载",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4按需加载",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["很多时候我们不需要一次性加载所有的JS文件，而应该在不同阶段去加载所需要的代码。",(0,c.jsx)(n.code,{children:"webpack"}),"内置了强大的分割代码的功能可以实现按需加载。"]}),"\n",(0,c.jsxs)(n.p,{children:["比如，我们在点击了某个按钮之后，才需要使用使用对应的JS文件中的代码，需要使用 ",(0,c.jsx)(n.code,{children:"import()"})," 语法："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"document.getElementById('btn').onclick = function() {\n    import('./handle').then(fn => fn.default());\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"import()"})," 语法，需要 ",(0,c.jsx)(n.code,{children:"@babel/plugin-syntax-dynamic-import"})," 的插件支持，但是因为当前 ",(0,c.jsx)(n.code,{children:"@babel/preset-env"})," 预设中已经包含了 ",(0,c.jsx)(n.code,{children:"@babel/plugin-syntax-dynamic-import"}),"，因此我们不需要再单独安装和配置。"]}),"\n",(0,c.jsxs)(n.p,{children:["直接 ",(0,c.jsx)(n.code,{children:"npm run build"})," 进行构建，构建结果如下："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.img,{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/9/170bae7ef6dc0875~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp",alt:"WechatIMG1121.jpeg"})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"webpack"})," 遇到 ",(0,c.jsx)(n.code,{children:"import(****)"})," 这样的语法的时候，会这样处理："]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["以**** 为入口新生成一个 ",(0,c.jsx)(n.code,{children:"Chunk"})]}),"\n",(0,c.jsxs)(n.li,{children:["当代码执行到 ",(0,c.jsx)(n.code,{children:"import"})," 所在的语句时，才会加载该 ",(0,c.jsx)(n.code,{children:"Chunk"})," 所对应的文件（如这里的1.bundle.8bf4dc.js）"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["大家可以在浏览器中的控制台中，在 ",(0,c.jsx)(n.code,{children:"Network"})," 的 ",(0,c.jsx)(n.code,{children:"Tab页"})," 查看文件加载的情况，只有点击之后，才会加载对应的 ",(0,c.jsx)(n.code,{children:"JS"})," 。"]}),"\n",(0,c.jsxs)(n.h3,{id:"5热更新",children:["5.热更新",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#5热更新",children:"#"})]}),"\n",(0,c.jsxs)(n.ol,{children:["\n",(0,c.jsxs)(n.li,{children:["首先配置 ",(0,c.jsx)(n.code,{children:"devServer"})," 的 ",(0,c.jsx)(n.code,{children:"hot"})," 为 ",(0,c.jsx)(n.code,{children:"true"})]}),"\n",(0,c.jsxs)(n.li,{children:["并且在 ",(0,c.jsx)(n.code,{children:"plugins"})," 中增加 ",(0,c.jsx)(n.code,{children:"new webpack.HotModuleReplacementPlugin()"})]}),"\n"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"//webpack.config.js\nconst webpack = require('webpack');\nmodule.exports = {\n    //....\n    devServer: {\n        hot: true\n    },\n    plugins: [\n        new webpack.HotModuleReplacementPlugin() //热更新插件\n    ]\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["我们配置了 ",(0,c.jsx)(n.code,{children:"HotModuleReplacementPlugin"})," 之后，会发现，此时我们修改代码，仍然是整个页面都会刷新。不希望整个页面都刷新，还需要修改入口文件："]}),"\n",(0,c.jsxs)(n.ol,{children:["\n",(0,c.jsx)(n.li,{children:"在入口文件中新增:"}),"\n"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"if(module && module.hot) {\n    module.hot.accept()\n}\n"})}),"\n",(0,c.jsx)(n.p,{children:"此时，再修改代码，不会造成整个页面的刷新。"}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.img,{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/9/170bae7ef7c6718b~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp",alt:"img"})}),"\n",(0,c.jsxs)(n.h3,{id:"6多页应用打包",children:["6.多页应用打包",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#6多页应用打包",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["有时，我们的应用不一定是一个单页应用，而是一个多页应用，那么如何使用 ",(0,c.jsx)(n.code,{children:"webpack"})," 进行打包呢。为了生成目录看起来清晰，不生成单独的 ",(0,c.jsx)(n.code,{children:"map"})," 文件。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"//webpack.config.js\nconst path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\nmodule.exports = {\n    entry: {\n        index: './src/index.js',\n        login: './src/login.js'\n    },\n    output: {\n        path: path.resolve(__dirname, 'dist'),\n        filename: '[name].[hash:6].js'\n    },\n    //...\n    plugins: [\n        new HtmlWebpackPlugin({\n            template: './public/index.html',\n            filename: 'index.html' //打包后的文件名\n        }),\n        new HtmlWebpackPlugin({\n            template: './public/login.html',\n            filename: 'login.html' //打包后的文件名\n        }),\n    ]\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["如果需要配置多个 ",(0,c.jsx)(n.code,{children:"HtmlWebpackPlugin"}),"，那么 ",(0,c.jsx)(n.code,{children:"filename"})," 字段不可缺省，否则默认生成的都是 ",(0,c.jsx)(n.code,{children:"index.html"}),"，如果你希望 ",(0,c.jsx)(n.code,{children:"html"})," 的文件名中也带有 ",(0,c.jsx)(n.code,{children:"hash"}),"，那么直接修改 ",(0,c.jsx)(n.code,{children:"fliename"})," 字段即可，例如: ",(0,c.jsx)(n.code,{children:"filename: 'login.[hash:6].html'"}),"。"]}),"\n",(0,c.jsx)(n.p,{children:"生成目录如下:"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:".\n├── dist\n│   ├── 2.463ccf.js\n│   ├── assets\n│   │   └── thor_e09b5c.jpeg\n│   ├── css\n│   │   ├── index.css\n│   │   └── login.css\n│   ├── index.463ccf.js\n│   ├── index.html\n│   ├── js\n│   │   └── base.js\n│   ├── login.463ccf.js\n│   └── login.html\n"})}),"\n",(0,c.jsxs)(n.p,{children:["看起来，似乎是OK了，不过呢，查看 ",(0,c.jsx)(n.code,{children:"index.html"})," 和 ",(0,c.jsx)(n.code,{children:"login.html"})," 会发现，都同时引入了 ",(0,c.jsx)(n.code,{children:"index.f7d21a.js"})," 和 ",(0,c.jsx)(n.code,{children:"login.f7d21a.js"}),"，通常这不是我们想要的，我们希望，",(0,c.jsx)(n.code,{children:"index.html"})," 中只引入 ",(0,c.jsx)(n.code,{children:"index.f7d21a.js"}),"，",(0,c.jsx)(n.code,{children:"login.html"})," 只引入 ",(0,c.jsx)(n.code,{children:"login.f7d21a.js"}),"。"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"HtmlWebpackPlugin"})," 提供了一个 ",(0,c.jsx)(n.code,{children:"chunks"})," 的参数，可以接受一个数组，配置此参数仅会将数组中指定的js引入到html文件中，此外，如果你需要引入多个JS文件，仅有少数不想引入，还可以指定 ",(0,c.jsx)(n.code,{children:"excludeChunks"})," 参数，它接受一个数组。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"//webpack.config.js\nmodule.exports = {\n    //...\n    plugins: [\n        new HtmlWebpackPlugin({\n            template: './public/index.html',\n            filename: 'index.html', //打包后的文件名\n            chunks: ['index']\n        }),\n        new HtmlWebpackPlugin({\n            template: './public/login.html',\n            filename: 'login.html', //打包后的文件名\n            chunks: ['login']\n        }),\n    ]\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["执行 ",(0,c.jsx)(n.code,{children:"npm run build"}),"，可以看到 ",(0,c.jsx)(n.code,{children:"index.html"})," 中仅引入了 ",(0,c.jsx)(n.code,{children:"index"})," 的 ",(0,c.jsx)(n.code,{children:"JS"})," 文件，而 ",(0,c.jsx)(n.code,{children:"login.html"})," 中也仅引入了 ",(0,c.jsx)(n.code,{children:"login"})," 的 ",(0,c.jsx)(n.code,{children:"JS"})," 文件，符合我们的预期。"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.img,{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/9/170bae7f6f69cfb5~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp",alt:"img"})}),"\n",(0,c.jsxs)(n.h3,{id:"7resolve-配置",children:["7.resolve 配置",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#7resolve-配置",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"resolve"})," 配置 ",(0,c.jsx)(n.code,{children:"webpack"})," 如何寻找模块所对应的文件。",(0,c.jsx)(n.code,{children:"webpack"})," 内置 ",(0,c.jsx)(n.code,{children:"JavaScript"})," 模块化语法解析功能，默认会采用模块化标准里约定好的规则去寻找，但你可以根据自己的需要修改默认的规则。"]}),"\n",(0,c.jsxs)(n.ol,{children:["\n",(0,c.jsx)(n.li,{children:"modules"}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"resolve.modules"})," 配置 ",(0,c.jsx)(n.code,{children:"webpack"})," 去哪些目录下寻找第三方模块，默认情况下，只会去 ",(0,c.jsx)(n.code,{children:"node_modules"})," 下寻找，如果你我们项目中某个文件夹下的模块经常被导入，不希望写很长的路径，那么就可以通过配置 ",(0,c.jsx)(n.code,{children:"resolve.modules"})," 来简化。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"//webpack.config.js\nmodule.exports = {\n    //....\n    resolve: {\n        modules: ['./src/components', 'node_modules'] //从左到右依次查找\n    }\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["这样配置之后，我们 ",(0,c.jsx)(n.code,{children:"import Dialog from 'dialog'"}),"，会去寻找 ",(0,c.jsx)(n.code,{children:"./src/components/dialog"}),"，不再需要使用相对路径导入。如果在 ",(0,c.jsx)(n.code,{children:"./src/components"})," 下找不到的话，就会到 ",(0,c.jsx)(n.code,{children:"node_modules"})," 下寻找。"]}),"\n",(0,c.jsxs)(n.ol,{children:["\n",(0,c.jsx)(n.li,{children:"alias"}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"resolve.alias"})," 配置项通过别名把原导入路径映射成一个新的导入路径，例如："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"//webpack.config.js\nmodule.exports = {\n    //....\n    resolve: {\n        alias: {\n            'react-native': '@my/react-native-web' //这个包名是我随便写的哈\n        }\n    }\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["例如，我们有一个依赖 ",(0,c.jsx)(n.code,{children:"@my/react-native-web"})," 可以实现 ",(0,c.jsx)(n.code,{children:"react-native"})," 转 ",(0,c.jsx)(n.code,{children:"web"}),"。我们代码一般下面这样:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"import { View, ListView, StyleSheet, Animated } from 'react-native';\n"})}),"\n",(0,c.jsxs)(n.p,{children:["配置了别名之后，在转 web 时，会从 ",(0,c.jsx)(n.code,{children:"@my/react-native-web"})," 寻找对应的依赖。"]}),"\n",(0,c.jsxs)(n.p,{children:["当然啦，如果某个依赖的名字太长了，你也可以给它配置一个短一点的别名，这样用起来比较爽，尤其是带有 ",(0,c.jsx)(n.code,{children:"scope"})," 的包。"]}),"\n",(0,c.jsxs)(n.ol,{children:["\n",(0,c.jsx)(n.li,{children:"extensions"}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["适配多端的项目中，可能会出现 ",(0,c.jsx)(n.code,{children:".web.js"}),", ",(0,c.jsx)(n.code,{children:".wx.js"}),"，例如在转web的项目中，我们希望首先找 ",(0,c.jsx)(n.code,{children:".web.js"}),"，如果没有，再找 ",(0,c.jsx)(n.code,{children:".js"}),"。我们可以这样配置:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"//webpack.config.js\nmodule.exports = {\n    //....\n    resolve: {\n        extensions: ['web.js', '.js'] //当然，你还可以配置 .json, .css\n    }\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["首先寻找 ",(0,c.jsx)(n.code,{children:"../dialog.web.js"})," ，如果不存在的话，再寻找 ",(0,c.jsx)(n.code,{children:"../dialog.js"}),"。这在适配多端的代码中非常有用，否则，你就需要根据不同的平台去引入文件(以牺牲了速度为代价)。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"import dialog from '../dialog';\n"})}),"\n",(0,c.jsxs)(n.p,{children:["当然，配置 ",(0,c.jsx)(n.code,{children:"extensions"}),"，我们就可以缺省文件后缀，在导入语句没带文件后缀时，会自动带上",(0,c.jsx)(n.code,{children:"extensions"})," 中配置的后缀后，去尝试访问文件是否存在，因此要将高频的后缀放在前面，并且数组不要太长，减少尝试次数。如果没有配置 ",(0,c.jsx)(n.code,{children:"extensions"}),"，默认只会找对对应的js文件。"]}),"\n",(0,c.jsxs)(n.ol,{children:["\n",(0,c.jsx)(n.li,{children:"enforceExtension"}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["如果配置了 ",(0,c.jsx)(n.code,{children:"resolve.enforceExtension"})," 为 ",(0,c.jsx)(n.code,{children:"true"}),"，那么导入语句不能缺省文件后缀。"]}),"\n",(0,c.jsxs)(n.ol,{children:["\n",(0,c.jsx)(n.li,{children:"mainFields"}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["有一些第三方模块会提供多份代码，例如 ",(0,c.jsx)(n.code,{children:"bootstrap"}),"，可以查看 ",(0,c.jsx)(n.code,{children:"bootstrap"})," 的 ",(0,c.jsx)(n.code,{children:"package.json"})," 文件："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:'{\n    "style": "dist/css/bootstrap.css",\n    "sass": "scss/bootstrap.scss",\n    "main": "dist/js/bootstrap",\n}\n'})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"resolve.mainFields"})," 默认配置是 ",(0,c.jsx)(n.code,{children:"['browser', 'main']"}),"，即首先找对应依赖 ",(0,c.jsx)(n.code,{children:"package.json"})," 中的 ",(0,c.jsx)(n.code,{children:"brower"})," 字段，如果没有，找 ",(0,c.jsx)(n.code,{children:"main"})," 字段。"]}),"\n",(0,c.jsxs)(n.p,{children:["如：",(0,c.jsx)(n.code,{children:"import 'bootstrap'"})," 默认情况下，找得是对应的依赖的 ",(0,c.jsx)(n.code,{children:"package.json"})," 的 ",(0,c.jsx)(n.code,{children:"main"})," 字段指定的文件，即 ",(0,c.jsx)(n.code,{children:"dist/js/bootstrap"}),"。"]}),"\n",(0,c.jsxs)(n.p,{children:["假设我们希望，",(0,c.jsx)(n.code,{children:"import 'bootsrap'"})," 默认去找 ",(0,c.jsx)(n.code,{children:"css"})," 文件的话，可以配置 ",(0,c.jsx)(n.code,{children:"resolve.mainFields"})," 为:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"//webpack.config.js\nmodule.exports = {\n    //....\n    resolve: {\n        mainFields: ['style', 'main'] \n    }\n}\n"})}),"\n",(0,c.jsxs)(n.h3,{id:"8区分不同的环境",children:["8.区分不同的环境",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#8区分不同的环境",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["目前为止我们 ",(0,c.jsx)(n.code,{children:"webpack"})," 的配置，都定义在了 ",(0,c.jsx)(n.code,{children:"webpack.config.js"})," 中，对于需要区分是开发环境还是生产环境的情况，我们根据 ",(0,c.jsx)(n.code,{children:"process.env.NODE_ENV"})," 去进行了区分配置，但是配置文件中如果有多处需要区分环境的配置，这种显然不是一个好办法。"]}),"\n",(0,c.jsxs)(n.p,{children:["更好的做法是创建多个配置文件，如: ",(0,c.jsx)(n.code,{children:"webpack.base.js"}),"、",(0,c.jsx)(n.code,{children:"webpack.dev.js"}),"、",(0,c.jsx)(n.code,{children:"webpack.prod.js"}),"。"]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"webpack.base.js"})," 定义公共的配置"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"webpack.dev.js"}),"：定义开发环境的配置"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"webpack.prod.js"}),"：定义生产环境的配置"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.a,{href:"https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fwebpack-merge",target:"_blank",rel:"noopener noreferrer",children:"webpack-merge"})," 专为 ",(0,c.jsx)(n.code,{children:"webpack"})," 设计，提供了一个 ",(0,c.jsx)(n.code,{children:"merge"})," 函数，用于连接数组，合并对象。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"npm install webpack-merge -D\nconst merge = require('webpack-merge');\nmerge({\n    devtool: 'cheap-module-eval-source-map',\n    module: {\n        rules: [\n            {a: 1}\n        ]\n    },\n    plugins: [1,2,3]\n}, {\n    devtool: 'none',\n    mode: \"production\",\n    module: {\n        rules: [\n            {a: 2},\n            {b: 1}\n        ]\n    },\n    plugins: [4,5,6],\n});\n//合并后的结果为\n{\n    devtool: 'none',\n    mode: \"production\",\n    module: {\n        rules: [\n            {a: 1},\n            {a: 2},\n            {b: 1}\n        ]\n    },\n    plugins: [1,2,3,4,5,6]\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"webpack.config.base.js"})," 中是通用的 ",(0,c.jsx)(n.code,{children:"webpack"})," 配置，以 ",(0,c.jsx)(n.code,{children:"webpack.config.dev.js"})," 为例，如下："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"//webpack.config.dev.js\nconst merge = require('webpack-merge');\nconst baseWebpackConfig = require('./webpack.config.base');\n\nmodule.exports = merge(baseWebpackConfig, {\n    mode: 'development'\n    //...其它的一些配置\n});\n"})}),"\n",(0,c.jsxs)(n.p,{children:["然后修改我们的 ",(0,c.jsx)(n.code,{children:"package.json"}),"，指定对应的 ",(0,c.jsx)(n.code,{children:"config"})," 文件："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:'//package.json\n{\n    "scripts": {\n        "dev": "cross-env NODE_ENV=development webpack-dev-server --config=webpack.config.dev.js",\n        "build": "cross-env NODE_ENV=production webpack --config=webpack.config.prod.js"\n    },\n}\n'})}),"\n",(0,c.jsxs)(n.p,{children:["你可以使用 ",(0,c.jsx)(n.code,{children:"merge"})," 合并，也可以使用 ",(0,c.jsx)(n.code,{children:"merge.smart"})," 合并，",(0,c.jsx)(n.code,{children:"merge.smart"})," 在合并",(0,c.jsx)(n.code,{children:"loader"}),"时，会将同一匹配规则的进行合并，",(0,c.jsx)(n.code,{children:"webpack-merge"})," 的说明文档中给出了详细的示例。"]}),"\n",(0,c.jsxs)(n.h3,{id:"9定义环境变量",children:["9.定义环境变量",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#9定义环境变量",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["很多时候，我们在开发环境中会使用预发环境或者是本地的域名，生产环境中使用线上域名，我们可以在 ",(0,c.jsx)(n.code,{children:"webpack"})," 定义环境变量，然后在代码中使用。"]}),"\n",(0,c.jsxs)(n.p,{children:["使用 ",(0,c.jsx)(n.code,{children:"webpack"})," 内置插件 ",(0,c.jsx)(n.code,{children:"DefinePlugin"})," 来定义环境变量。"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"DefinePlugin"})," 中的每个键，是一个标识符."]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["如果 ",(0,c.jsx)(n.code,{children:"value"})," 是一个字符串，会被当做 ",(0,c.jsx)(n.code,{children:"code"})," 片段"]}),"\n",(0,c.jsxs)(n.li,{children:["如果 ",(0,c.jsx)(n.code,{children:"value"})," 不是一个字符串，会被",(0,c.jsx)(n.code,{children:"stringify"})]}),"\n",(0,c.jsxs)(n.li,{children:["如果 ",(0,c.jsx)(n.code,{children:"value"})," 是一个对象，正常对象定义即可"]}),"\n",(0,c.jsxs)(n.li,{children:["如果 ",(0,c.jsx)(n.code,{children:"key"})," 中有 ",(0,c.jsx)(n.code,{children:"typeof"}),"，它只针对 ",(0,c.jsx)(n.code,{children:"typeof"})," 调用定义"]}),"\n"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"//webpack.config.dev.js\nconst webpack = require('webpack');\nmodule.exports = {\n    plugins: [\n        new webpack.DefinePlugin({\n            DEV: JSON.stringify('dev'), //字符串\n            FLAG: 'true' //FLAG 是个布尔类型\n        })\n    ]\n}\n//index.js\nif(DEV === 'dev') {\n    //开发环境\n}else {\n    //生产环境\n}\n"})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.img,{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/9/170bae7f724b6757~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp",alt:"img"})}),"\n",(0,c.jsxs)(n.h3,{id:"10利用webpack解决跨域问题",children:["10.利用webpack解决跨域问题",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#10利用webpack解决跨域问题",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["假设前端在3000端口，服务端在4000端口，我们通过 ",(0,c.jsx)(n.code,{children:"webpack"})," 配置的方式去实现跨域。"]}),"\n",(0,c.jsxs)(n.p,{children:["首先，我们在本地创建一个 ",(0,c.jsx)(n.code,{children:"server.js"}),"："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"let express = require('express');\n\nlet app = express();\n\napp.get('/api/user', (req, res) => {\n    res.json({name: '刘小夕'});\n});\n\napp.listen(4000);\n"})}),"\n",(0,c.jsxs)(n.p,{children:["执行代码(",(0,c.jsx)(n.code,{children:"run code"}),")，现在我们可以在浏览器中访问到此接口: ",(0,c.jsx)(n.code,{children:"http://localhost:4000/api/user"}),"。"]}),"\n",(0,c.jsxs)(n.p,{children:["在 ",(0,c.jsx)(n.code,{children:"index.js"})," 中请求 ",(0,c.jsx)(n.code,{children:"/api/user"}),"，修改 ",(0,c.jsx)(n.code,{children:"index.js"})," 如下:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:'//需要将 localhost:3000 转发到 localhost:4000（服务端） 端口\nfetch("/api/user")\n    .then(response => response.json())\n    .then(data => console.log(data))\n    .catch(err => console.log(err));\n'})}),"\n",(0,c.jsx)(n.p,{children:"我们希望通过配置代理的方式，去访问 4000 的接口。"}),"\n",(0,c.jsxs)(n.h4,{id:"配置代理",children:["配置代理",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#配置代理",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["修改 ",(0,c.jsx)(n.code,{children:"webpack"})," 配置:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:'//webpack.config.js\nmodule.exports = {\n    //...\n    devServer: {\n        proxy: {\n            "/api": "http://localhost:4000"\n        }\n    }\n}\n'})}),"\n",(0,c.jsxs)(n.p,{children:["重新执行 ",(0,c.jsx)(n.code,{children:"npm run dev"}),"，可以看到控制台打印出来了 ",(0,c.jsx)(n.code,{children:'{name: "刘小夕"}'}),"，实现了跨域。"]}),"\n",(0,c.jsxs)(n.p,{children:["大多情况，后端提供的接口并不包含 ",(0,c.jsx)(n.code,{children:"/api"}),"，即：",(0,c.jsx)(n.code,{children:"/user"}),"，",(0,c.jsx)(n.code,{children:"/info"}),"、",(0,c.jsx)(n.code,{children:"/list"})," 等，配置代理时，我们不可能罗列出每一个api。"]}),"\n",(0,c.jsx)(n.p,{children:"修改我们的服务端代码，并重新执行。"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"//server.js\nlet express = require('express');\n\nlet app = express();\n\napp.get('/user', (req, res) => {\n    res.json({name: '刘小夕'});\n});\n\napp.listen(4000);\n"})}),"\n",(0,c.jsxs)(n.p,{children:["尽管后端的接口并不包含 ",(0,c.jsx)(n.code,{children:"/api"}),"，我们在请求后端接口时，仍然以 ",(0,c.jsx)(n.code,{children:"/api"})," 开头，在配置代理时，去掉 ",(0,c.jsx)(n.code,{children:"/api"}),"，修改配置:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"//webpack.config.js\nmodule.exports = {\n    //...\n    devServer: {\n        proxy: {\n            '/api': {\n                target: 'http://localhost:4000',\n                pathRewrite: {\n                    '/api': ''\n                }\n            }\n        }\n    }\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["重新执行 ",(0,c.jsx)(n.code,{children:"npm run dev"}),"，在浏览器中访问： ",(0,c.jsx)(n.code,{children:"http://localhost:3000/"}),"，控制台中也打印出了",(0,c.jsx)(n.code,{children:'{name: "刘小夕"}'}),"，跨域成功，"]}),"\n",(0,c.jsxs)(n.h3,{id:"11前端模拟数据",children:["11.前端模拟数据",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#11前端模拟数据",children:"#"})]}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"简单数据模拟"}),"\n"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"module.exports = {\n    devServer: {\n        before(app) {\n            app.get('/user', (req, res) => {\n                res.json({name: '刘小夕'})\n            })\n        }\n    }\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["在 ",(0,c.jsx)(n.code,{children:"src/index.js"})," 中直接请求 ",(0,c.jsx)(n.code,{children:"/user"})," 接口。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:'fetch("user")\n    .then(response => response.json())\n    .then(data => console.log(data))\n    .catch(err => console.log(err));\n'})}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"使用 mocker-api mock数据接口"}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"mocker-api 为 REST API 创建模拟 API。在没有实际 REST API 服务器的情况下测试应用程序时，它会很有用。"}),"\n",(0,c.jsxs)(n.ol,{children:["\n",(0,c.jsxs)(n.li,{children:["安装 ",(0,c.jsx)(n.a,{href:"https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fmocker-api",target:"_blank",rel:"noopener noreferrer",children:"mocker-api"}),":"]}),"\n"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"npm install mocker-api -D\n"})}),"\n",(0,c.jsxs)(n.ol,{children:["\n",(0,c.jsx)(n.li,{children:"在项目中新建mock文件夹，新建 mocker.js.文件，文件如下:"}),"\n"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"module.exports = {\n    'GET /user': {name: '刘小夕'},\n    'POST /login/account': (req, res) => {\n        const { password, username } = req.body\n        if (password === '888888' && username === 'admin') {\n            return res.send({\n                status: 'ok',\n                code: 0,\n                token: 'sdfsdfsdfdsf',\n                data: { id: 1, name: '刘小夕' }\n            })\n        } else {\n            return res.send({ status: 'error', code: 403 })\n        }\n    }\n}\n"})}),"\n",(0,c.jsxs)(n.ol,{children:["\n",(0,c.jsxs)(n.li,{children:["修改 ",(0,c.jsx)(n.code,{children:"webpack.config.base.js"}),":"]}),"\n"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"const apiMocker = require('mocker-api');\nmodule.export = {\n    //...\n    devServer: {\n        before(app){\n            apiMocker(app, path.resolve('./mock/mocker.js'))\n        }\n    }\n}\n"})}),"\n",(0,c.jsx)(n.p,{children:"这样，我们就可以直接在代码中像请求后端接口一样对mock数据进行请求。"}),"\n",(0,c.jsxs)(n.ol,{children:["\n",(0,c.jsxs)(n.li,{children:["重启 ",(0,c.jsx)(n.code,{children:"npm run dev"}),"，可以看到，控制台成功打印出来 ",(0,c.jsx)(n.code,{children:"{name: '刘小夕'}"})]}),"\n",(0,c.jsxs)(n.li,{children:["我们再修改下 ",(0,c.jsx)(n.code,{children:"src/index.js"}),"，检查下POST接口是否成功"]}),"\n"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"//src/index.js\nfetch(\"/login/account\", {\n    method: \"POST\",\n    headers: {\n        'Accept': 'application/json',\n        'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({\n        username: \"admin\",\n        password: \"888888\"\n    })\n})\n    .then(response => response.json())\n    .then(data => console.log(data))\n    .catch(err => console.log(err));\n"})}),"\n",(0,c.jsx)(n.p,{children:"可以在控制台中看到接口返回的成功的数据。"}),"\n",(0,c.jsx)(n.p,{children:"进阶篇就到这里结束啦，最后一篇是优化篇，下周一带上小板凳和瓜子来约。"}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.img,{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/9/170bae92e83c51e3~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp",alt:"img"})}),"\n",(0,c.jsxs)(n.h3,{id:"最后",children:["最后",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#最后",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"如果本文对你有帮助的话，给本文点个赞吧。"}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.a,{href:"https://juejin.cn/post/6844904093463347208",target:"_blank",rel:"noopener noreferrer",children:"带你深度解锁Webpack系列(优化篇)"})})]})}function i(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,d.ah)(),e.components);return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(r,{...e})}):r(e)}let l=i;i.__RSPRESS_PAGE_META={},i.__RSPRESS_PAGE_META["webpack%2F11-%E6%B7%B1%E5%BA%A6%E8%A7%A3%E9%94%81Webpack%E7%B3%BB%E5%88%97(%E8%BF%9B%E9%98%B6%E7%AF%87)02.md"]={toc:[{text:"1. 静态资源拷贝",id:"1-静态资源拷贝",depth:3},{text:"2.ProvidePlugin",id:"2provideplugin",depth:3},{text:"3.抽离CSS",id:"3抽离css",depth:3},{text:"将抽离出来的css文件进行压缩",id:"将抽离出来的css文件进行压缩",depth:4},{text:"4.按需加载",id:"4按需加载",depth:3},{text:"5.热更新",id:"5热更新",depth:3},{text:"6.多页应用打包",id:"6多页应用打包",depth:3},{text:"7.resolve 配置",id:"7resolve-配置",depth:3},{text:"8.区分不同的环境",id:"8区分不同的环境",depth:3},{text:"9.定义环境变量",id:"9定义环境变量",depth:3},{text:"10.利用webpack解决跨域问题",id:"10利用webpack解决跨域问题",depth:3},{text:"配置代理",id:"配置代理",depth:4},{text:"11.前端模拟数据",id:"11前端模拟数据",depth:3},{text:"最后",id:"最后",depth:3}],title:"带你深度解锁Webpack系列(进阶篇)",frontmatter:{}}}}]);