"use strict";(self.webpackChunk=self.webpackChunk||[]).push([["1252"],{3252:function(n,e,a){a.r(e),a.d(e,{default:function(){return r}});var s=a(6469),p=a(8809);function o(n){let e=Object.assign({h1:"h1",a:"a",p:"p",h4:"h4",pre:"pre",code:"code"},(0,p.ah)(),n.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(e.h1,{id:"happypack多个进程处理loader-happypack优化构建九",children:["HappyPack多个进程处理loader-HappyPack优化构建(九)",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#happypack多个进程处理loader-happypack优化构建九",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"统计信息：字数 7182  阅读15分钟"}),"\n",(0,s.jsxs)(e.h4,{id:"什么是happypack-作用是什么",children:["什么是HappyPack? 作用是什么？",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#什么是happypack-作用是什么",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"Webpack是允许在NodeJS中的，它是单线程模型的，因此webpack在构建文件时，比如js，css，图片及字体时，它需要一个一个去解析和编译，不能同时处理多个任务。"}),"\n",(0,s.jsx)(e.p,{children:"特别当文件数量变多后，webpack构建慢的问题会显得更为严重。"}),"\n",(0,s.jsx)(e.p,{children:"因此HappyPack出现了，它能让webpack同时处理多个任务，它将任务分解给多个子进程去并发执行，子进程处理完成后再将结果发送给主进程中。"}),"\n",(0,s.jsxs)(e.h4,{id:"happypack的基本原理",children:["HappyPack的基本原理?",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#happypack的基本原理",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"在webpack构建过程中，我们需要使用Loader对js，css，图片，字体等文件做转换操作，并且转换的文件数据量也是非常大的，且这些转换操作不能并发处理文件，而是需要一个个文件进行处理，HappyPack的基本原理是将这部分任务分解到多个子进程中去并行处理，子进程处理完成后把结果发送到主进程中，从而减少总的构建时间。"}),"\n",(0,s.jsx)(e.p,{children:"使用案例\n安装依赖库"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"npm i -D happypack\n"})}),"\n",(0,s.jsx)(e.p,{children:"webpack.config.js 配置如何使用 happypack\n在plugin中配置happypack实例\n在loader中使用 happypack 创建的进程"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:'// 引入HappyPack插件 \nconst HappyPack = require(\'happypack\');\nconst os = require(\'os\');\nconst happyThreadPool = HappyPack.ThreadPool({size: os.cpus().length});\nconsole.log("happyThreadPool:" + happyThreadPool)\n// 构造出共享进程池，在进程池中包含 5 个子进程\n// const happyThreadPool = HappyPack.ThreadPool({ size : 5 }) ;\n\nmodule.exports = {\n  mode: "development",\n  // mode: "production",\n  entry: {\n    main: "./main.js"\n    // lodash: \'./src/template/lodash.js\'\n  },\n  output: {\n    path: path.resolve(__dirname, "dist"),\n    filename: "main.js"\n  },\n  resolve: {\n    // 定义路径别名\n    alias: {\n      "@": path.resolve(__dirname, "./"),\n      // @src 代表 “工程目录/src”\n      "@src": path.resolve(__dirname, "./src"),\n      // @component 代表 “工程目录/src/components”\n      "@component": path.resolve(__dirname, "./src/components")\n    },\n    // 指定第三方模块加载的路径，例如 jquery 、lodash等\n    modules: ["node_modules", "./lib/components"],\n    // 如果引入的文件没有后缀名，默认会优先去找 js文件，如果没有就去找 ts文件，如果没有就找json文件，依次类推，默认是 js\n    extensions: [".js", ".ts", ".json"]\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        // 排除 node_modules 和 bower_components 下的文件\n        exclude: /(node_modules|bower_components)/,\n        use: {\n          // loader: "babel-loader",\n          loader: \'happypack/loader?id=babel\',\n          // options: {\n          //   presets: [\n          //     [\n          //       "@babel/preset-env",\n          //       {\n          //         // 只引用使用了新特性 polyfill\n          //         // useBuiltIns: \'usage\'\n          //       }\n          //     ]\n          //   ]\n          // }\n        }\n      },\n      {\n        test: /\\.(eot|svg|ttf|woff|woff2)(\\?\\S*)?$/,\n        use: {\n          loader: "file-loader",\n          options: {\n            esModule: false, // 这里设置为false\n            outputPath: "fonts/", // 指定字体输入的文件夹，打包地址是 “/dist/fonts/字体文件”\n            publicPath: "/fonts" // 指定字体的路径，即打包结果引入的地址是 "/fonts/字体文件名"\n          }\n        }\n      },\n      {\n        test: /\\.(png|jpg|gif)$/,\n        use: [\n          {\n            loader: \'happypack/loader?id=image\',\n						// loader: "url-loader",\n            // options: {\n            //   esModule: false, // 这里设置为false\n            //   outputPath: "images/", // 指定图片输入的文件夹， 打包地址是 “/dist/images/图片名字”\n            //   publicPath: "/images", // 指定获取图片的路径，即打包结果引入的地址是 "/images/图片名字"\n            //   // limit  (如果小于 8192字节 ，则转为base64，否则返回一个url地址)\n            //   limit: 8192,\n            //   name: "[name].[hash:8].[ext]" // 输入的图片名\n            // }\n          }\n        ]\n      },\n      {\n        test: /\\.(scss|css)$/,\n        /**\n         * loader 是从又向做执行\n         * 1. 最先执行 sass-loader ，将 sass 文件转为css\n         * 2. css-loader 将转换后的css文件转为 js模块\n         * 3. style-loader 将 css 插入到HTML中的<style>标签中\n         */\n        use: [\n          devMode\n            ? {\n                loader: "style-loader" // 将 JS 字符串生成为 style 节点\n              }\n            : MiniCssExtractPlugin.loader,\n          {\n            // loader: "css-loader" // 将 CSS 转化成 CommonJS 模块\n            loader: \'happypack/loader?id=css-pack\' // 将 CSS 转化成 CommonJS 模块\n          },\n          {\n            loader: "sass-loader" // 将 Sass 编译成 CSS\n          }\n        ]\n        // 等价于\n        // use: ["style-loader", "css-loader", "sass-loader"]\n      }\n    ]\n  },\n  plugins: [\n    new CleanWebpackPlugin(), //删除上次打包文件，默认目录\'./dist\'\n    \n    /****   使用HappyPack实例化    *****/\n    new HappyPack({\n      // 用唯一的标识符id来代表当前的HappyPack 处理一类特定的文件\n      id: \'babel\',\n      // 使用共享进程池中的子进程去处理任务。\n      // threadPool: happyThreadPool,\n      // 如何处理.js文件，用法和Loader配置是一样的\n      loaders: [{\n        loader: \'babel-loader\',\n        options: {\n          presets: [\n            [\n              "@babel/preset-env",\n              {\n                // 只引用使用了新特性 polyfill\n                // useBuiltIns: \'usage\'\n              }\n            ]\n          ]\n        }\n      }]\n    }),\n    new HappyPack({\n      id: \'image\',\n      // threadPool: happyThreadPool,\n      loaders: [{\n        loader: \'url-loader\',\n        options: {\n          esModule: false, // 这里设置为false\n          outputPath: "images/", // 指定图片输入的文件夹， 打包地址是 “/dist/images/图片名字”\n          publicPath: "/images", // 指定获取图片的路径，即打包结果引入的地址是 "/images/图片名字"\n          // limit  (如果小于 8192字节 ，则转为base64，否则返回一个url地址)\n          limit: 8192,\n          name: "[name].[hash:8].[ext]" // 输入的图片名\n        }\n      }]\n    }),\n    // 处理css文件\n    new HappyPack({\n      id: \'css-pack\',\n      // threadPool: happyThreadPool,\n      loaders: [{\n        loader: \'css-loader\'\n      }]\n    })\n  ],\n\n};\n'})}),"\n",(0,s.jsxs)(e.h4,{id:"配置说明",children:["配置说明",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#配置说明",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"happypack/loader?id=xx 紧跟的id=xxx,就是告诉happy-loader选择哪个happyPack的实列处理文件。"}),"\n",(0,s.jsx)(e.p,{children:"在plugin插件配置中新增了HappyPack的实列，作用是告诉HappyPack如何处理该文件"}),"\n",(0,s.jsx)(e.p,{children:"webpack配置问题：HappyPack: plugin for the loader ‘1’ could not be found？"}),"\n",(0,s.jsx)(e.p,{children:"用了 happypack 之后，不能在 rules 里面的相关 loader 中配置 options，相反只能在 happypack 插件中配置 options"})]})}function l(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,p.ah)(),n.components);return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(o,{...n})}):o(n)}let r=l;l.__RSPRESS_PAGE_META={},l.__RSPRESS_PAGE_META["webpack%2F%E6%8F%92%E4%BB%B6%20webpack%20HappyPack%E5%A4%9A%E4%B8%AA%E8%BF%9B%E7%A8%8B%E5%A4%84%E7%90%86loader.md"]={toc:[{text:"什么是HappyPack? 作用是什么？",id:"什么是happypack-作用是什么",depth:4},{text:"HappyPack的基本原理?",id:"happypack的基本原理",depth:4},{text:"配置说明",id:"配置说明",depth:4}],title:"HappyPack多个进程处理loader-HappyPack优化构建(九)",frontmatter:{}}}}]);