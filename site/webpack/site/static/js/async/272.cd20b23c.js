"use strict";(self.webpackChunk=self.webpackChunk||[]).push([["272"],{5763:function(e,n,r){r.r(n),r.d(n,{default:function(){return l}});var t=r(6469),i=r(8809);function s(e){let n=Object.assign({h1:"h1",a:"a",p:"p",blockquote:"blockquote",ul:"ul",li:"li",code:"code",h2:"h2",strong:"strong",pre:"pre",h3:"h3"},(0,i.ah)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.h1,{id:"code-splitting",children:["Code Splitting",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#code-splitting",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"统计信息：字数 14615  阅读30分钟"}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["This guide extends the examples provided in ",(0,t.jsx)(n.a,{href:"https://webpack.js.org/guides/getting-started",target:"_blank",rel:"noopener noreferrer",children:"Getting Started"})," and ",(0,t.jsx)(n.a,{href:"https://webpack.js.org/guides/output-management",target:"_blank",rel:"noopener noreferrer",children:"Output Management"}),". Please make sure you are at least familiar with the examples provided in them."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Code splitting is one of the most compelling features of webpack. This feature allows you to split your code into various bundles which can then be loaded on demand or in parallel. It can be used to achieve smaller bundles and control resource load prioritization which, if used correctly, can have a major impact on load time."}),"\n",(0,t.jsx)(n.p,{children:"There are three general approaches to code splitting available:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Entry Points: Manually split code using ",(0,t.jsx)(n.a,{href:"https://webpack.js.org/configuration/entry-context",target:"_blank",rel:"noopener noreferrer",children:(0,t.jsx)(n.code,{children:"entry"})})," configuration."]}),"\n",(0,t.jsxs)(n.li,{children:["Prevent Duplication: Use the ",(0,t.jsx)(n.a,{href:"https://webpack.js.org/plugins/split-chunks-plugin/",target:"_blank",rel:"noopener noreferrer",children:(0,t.jsx)(n.code,{children:"SplitChunksPlugin"})})," to dedupe and split chunks."]}),"\n",(0,t.jsx)(n.li,{children:"Dynamic Imports: Split code via inline function calls within modules."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"代码分割注意点"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"入口：使用entry配置项手动设置分割代码的入口"}),"\n",(0,t.jsx)(n.li,{children:"阻止重复代码：使用 splitchunkPlugin 插件可以减少重复代码（locash）其他的插件可以压缩CSS部分；bundle-loader 支持拆分的代码懒加载"}),"\n",(0,t.jsx)(n.li,{children:"动态导入：使用import语法（不使用commonJS语法）可以动态导入需要的组件（注意可能老浏览器不兼容这样的写法）"}),"\n"]}),"\n",(0,t.jsxs)(n.h2,{id:"entry-points",children:["Entry Points",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#entry-points",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"This is by far the easiest and most intuitive way to split code. However, it is more manual and has some pitfalls we will go over. Let's take a look at how we might split another module from the main bundle:"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"project"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-diff",children:"webpack-demo\n|- package.json\n|- webpack.config.js\n|- /dist\n|- /src\n  |- index.js\n+ |- another-module.js\n|- /node_modules\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"another-module.js"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"import _ from 'lodash';\n\nconsole.log(\n  _.join(['Another', 'module', 'loaded!'], ' ')\n);\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"webpack.config.js"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-diff",children:"const path = require('path');\n\nmodule.exports = {\n  mode: 'development',\n  entry: {\n    index: './src/index.js',\n+   another: './src/another-module.js',\n  },\n  output: {\n    filename: '[name].bundle.js',\n    path: path.resolve(__dirname, 'dist'),\n  },\n};\n"})}),"\n",(0,t.jsx)(n.p,{children:"This will yield the following build result:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"...\n            Asset     Size   Chunks             Chunk Names\nanother.bundle.js  550 KiB  another  [emitted]  another\n  index.bundle.js  550 KiB    index  [emitted]  index\nEntrypoint index = index.bundle.js\nEntrypoint another = another.bundle.js\n...\n"})}),"\n",(0,t.jsx)(n.p,{children:"As mentioned there are some pitfalls to this approach:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"If there are any duplicated modules between entry chunks they will be included in both bundles."}),"\n",(0,t.jsx)(n.li,{children:"It isn't as flexible and can't be used to dynamically split code with the core application logic."}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["The first of these two points is definitely an issue for our example, as ",(0,t.jsx)(n.code,{children:"lodash"})," is also imported within ",(0,t.jsx)(n.code,{children:"./src/index.js"})," and will thus be duplicated in both bundles. Let's remove this duplication by using the ",(0,t.jsx)(n.a,{href:"https://webpack.js.org/plugins/split-chunks-plugin/",target:"_blank",rel:"noopener noreferrer",children:(0,t.jsx)(n.code,{children:"SplitChunksPlugin"})}),"."]}),"\n",(0,t.jsxs)(n.h2,{id:"prevent-duplication",children:["Prevent Duplication",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#prevent-duplication",children:"#"})]}),"\n",(0,t.jsxs)(n.h3,{id:"entry-dependencies",children:["Entry dependencies",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#entry-dependencies",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsxs)(n.a,{href:"https://webpack.js.org/configuration/entry-context/#dependencies",target:"_blank",rel:"noopener noreferrer",children:[(0,t.jsx)(n.code,{children:"dependOn"})," option"]})," allows to share the modules between the chunks"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-diff",children:"  const path = require('path');\n\n  module.exports = {\n    mode: 'development',\n    entry: {\n-     index: './src/index.js',\n-     another: './src/another-module.js',\n+     index: { import: './src/index.js', dependOn: 'shared' },\n+     another: { import: './src/another-module.js', dependOn: 'shared' },\n+     shared: 'lodash',\n    },\n    output: {\n      filename: '[name].bundle.js',\n      path: path.resolve(__dirname, 'dist'),\n    },\n  };\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"splitchunksplugin",children:[(0,t.jsx)(n.code,{children:"SplitChunksPlugin"}),(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#splitchunksplugin",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.a,{href:"https://webpack.js.org/plugins/split-chunks-plugin/",target:"_blank",rel:"noopener noreferrer",children:(0,t.jsx)(n.code,{children:"SplitChunksPlugin"})})," allows us to extract common dependencies into an existing entry chunk or an entirely new chunk. Let's use this to de-duplicate the ",(0,t.jsx)(n.code,{children:"lodash"})," dependency from the previous example:"]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"CommonsChunkPlugin"})," has been removed in webpack v4 legato. To learn how chunks are treated in the latest version, check out the ",(0,t.jsx)(n.a,{href:"https://webpack.js.org/plugins/split-chunks-plugin/",target:"_blank",rel:"noopener noreferrer",children:(0,t.jsx)(n.code,{children:"SplitChunksPlugin"})}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"webpack.config.js"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-diff",children:"  const path = require('path');\n\n  module.exports = {\n    mode: 'development',\n    entry: {\n      index: './src/index.js',\n      another: './src/another-module.js',\n    },\n    output: {\n      filename: '[name].bundle.js',\n      path: path.resolve(__dirname, 'dist'),\n    },\n+   optimization: {\n+     splitChunks: {\n+       chunks: 'all',\n+     },\n+   },\n  };\n"})}),"\n",(0,t.jsxs)(n.p,{children:["With the ",(0,t.jsx)(n.a,{href:"https://webpack.js.org/plugins/split-chunks-plugin/#optimizationsplitchunks",target:"_blank",rel:"noopener noreferrer",children:(0,t.jsx)(n.code,{children:"optimization.splitChunks"})})," configuration option in place, we should now see the duplicate dependency removed from our ",(0,t.jsx)(n.code,{children:"index.bundle.js"})," and ",(0,t.jsx)(n.code,{children:"another.bundle.js"}),". The plugin should notice that we've separated ",(0,t.jsx)(n.code,{children:"lodash"})," out to a separate chunk and remove the dead weight from our main bundle. Let's do an ",(0,t.jsx)(n.code,{children:"npm run build"})," to see if it worked:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"...\n                          Asset      Size                 Chunks             Chunk Names\n              another.bundle.js  5.95 KiB                another  [emitted]  another\n                index.bundle.js  5.89 KiB                  index  [emitted]  index\nvendors~another~index.bundle.js   547 KiB  vendors~another~index  [emitted]  vendors~another~index\nEntrypoint index = vendors~another~index.bundle.js index.bundle.js\nEntrypoint another = vendors~another~index.bundle.js another.bundle.js\n...\n"})}),"\n",(0,t.jsx)(n.p,{children:"Here are some other useful plugins and loaders provided by the community for splitting code:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"https://webpack.js.org/plugins/mini-css-extract-plugin",target:"_blank",rel:"noopener noreferrer",children:(0,t.jsx)(n.code,{children:"mini-css-extract-plugin"})}),": Useful for splitting CSS out from the main application."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"https://webpack.js.org/loaders/bundle-loader",target:"_blank",rel:"noopener noreferrer",children:(0,t.jsx)(n.code,{children:"bundle-loader"})}),": Used to split code and lazy load the resulting bundles."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"https://github.com/gaearon/promise-loader",target:"_blank",rel:"noopener noreferrer",children:(0,t.jsx)(n.code,{children:"promise-loader"})}),": Similar to the ",(0,t.jsx)(n.code,{children:"bundle-loader"})," but uses promises."]}),"\n"]}),"\n",(0,t.jsxs)(n.h2,{id:"dynamic-imports",children:["Dynamic Imports",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#dynamic-imports",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["Two similar techniques are supported by webpack when it comes to dynamic code splitting. The first and recommended approach is to use the ",(0,t.jsxs)(n.a,{href:"https://webpack.js.org/api/module-methods/#import-1",target:"_blank",rel:"noopener noreferrer",children:[(0,t.jsx)(n.code,{children:"import()"})," syntax"]})," that conforms to the ",(0,t.jsx)(n.a,{href:"https://github.com/tc39/proposal-dynamic-import",target:"_blank",rel:"noopener noreferrer",children:"ECMAScript proposal"})," for dynamic imports. The legacy, webpack-specific approach is to use ",(0,t.jsx)(n.a,{href:"https://webpack.js.org/api/module-methods/#requireensure",target:"_blank",rel:"noopener noreferrer",children:(0,t.jsx)(n.code,{children:"require.ensure"})}),". Let's try using the first of these two approaches..."]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"import()"})," calls use ",(0,t.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",target:"_blank",rel:"noopener noreferrer",children:"promises"})," internally. If you use ",(0,t.jsx)(n.code,{children:"import()"})," with older browsers, remember to shim ",(0,t.jsx)(n.code,{children:"Promise"})," using a polyfill such as ",(0,t.jsx)(n.a,{href:"https://github.com/stefanpenner/es6-promise",target:"_blank",rel:"noopener noreferrer",children:"es6-promise"})," or ",(0,t.jsx)(n.a,{href:"https://github.com/taylorhakes/promise-polyfill",target:"_blank",rel:"noopener noreferrer",children:"promise-polyfill"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Before we start, let's remove the extra ",(0,t.jsx)(n.a,{href:"https://webpack.js.org/concepts/entry-points/",target:"_blank",rel:"noopener noreferrer",children:(0,t.jsx)(n.code,{children:"entry"})})," and ",(0,t.jsx)(n.a,{href:"https://webpack.js.org/plugins/split-chunks-plugin",target:"_blank",rel:"noopener noreferrer",children:(0,t.jsx)(n.code,{children:"optimization.splitChunks"})})," from our configuration as they won't be needed for this next demonstration:"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"webpack.config.js"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-diff",children:"  const path = require('path');\n\n  module.exports = {\n    mode: 'development',\n    entry: {\n      index: './src/index.js',\n-     another: './src/another-module.js',\n    },\n    output: {\n      filename: '[name].bundle.js',\n+     chunkFilename: '[name].bundle.js',\n      publicPath: 'dist/',\n      path: path.resolve(__dirname, 'dist'),\n    },\n-   optimization: {\n-     splitChunks: {\n-       chunks: 'all',\n-     },\n-   },\n  };\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Note the use of ",(0,t.jsx)(n.code,{children:"chunkFilename"}),", which determines the name of non-entry chunk files. For more information on ",(0,t.jsx)(n.code,{children:"chunkFilename"}),", see ",(0,t.jsx)(n.a,{href:"https://webpack.js.org/configuration/output/#outputchunkfilename",target:"_blank",rel:"noopener noreferrer",children:"output documentation"}),". We'll also update our project to remove the now unused files:"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"project"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-diff",children:"webpack-demo\n|- package.json\n|- webpack.config.js\n|- /dist\n|- /src\n  |- index.js\n- |- another-module.js\n|- /node_modules\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Now, instead of statically importing ",(0,t.jsx)(n.code,{children:"lodash"}),", we'll use dynamic importing to separate a chunk:"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"src/index.js"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-diff",children:"- import _ from 'lodash';\n-\n- function component() {\n+ function getComponent() {\n-   const element = document.createElement('div');\n-\n-   // Lodash, now imported by this script\n-   element.innerHTML = _.join(['Hello', 'webpack'], ' ');\n+   return import(/* webpackChunkName: \"lodash\" */ 'lodash').then(({ default: _ }) => {\n+     const element = document.createElement('div');\n+\n+     element.innerHTML = _.join(['Hello', 'webpack'], ' ');\n+\n+     return element;\n+\n+   }).catch(error => 'An error occurred while loading the component');\n  }\n\n- document.body.appendChild(component());\n+ getComponent().then(component => {\n+   document.body.appendChild(component);\n+ })\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The reason we need ",(0,t.jsx)(n.code,{children:"default"})," is that since webpack 4, when importing a CommonJS module, the import will no longer resolve to the value of ",(0,t.jsx)(n.code,{children:"module.exports"}),", it will instead create an artificial namespace object for the CommonJS module. For more information on the reason behind this, read ",(0,t.jsx)(n.a,{href:"https://medium.com/webpack/webpack-4-import-and-commonjs-d619d626b655",target:"_blank",rel:"noopener noreferrer",children:"webpack 4: import() and CommonJs"})]}),"\n",(0,t.jsxs)(n.p,{children:["Note the use of ",(0,t.jsx)(n.code,{children:"webpackChunkName"})," in the comment. This will cause our separate bundle to be named ",(0,t.jsx)(n.code,{children:"lodash.bundle.js"})," instead of just ",(0,t.jsx)(n.code,{children:"[id].bundle.js"}),". For more information on ",(0,t.jsx)(n.code,{children:"webpackChunkName"})," and the other available options, see the ",(0,t.jsxs)(n.a,{href:"https://webpack.js.org/api/module-methods/#import-1",target:"_blank",rel:"noopener noreferrer",children:[(0,t.jsx)(n.code,{children:"import()"})," documentation"]}),". Let's run webpack to see ",(0,t.jsx)(n.code,{children:"lodash"})," separated out to a separate bundle:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"...\n                   Asset      Size          Chunks             Chunk Names\n         index.bundle.js  7.88 KiB           index  [emitted]  index\nvendors~lodash.bundle.js   547 KiB  vendors~lodash  [emitted]  vendors~lodash\nEntrypoint index = index.bundle.js\n...\n"})}),"\n",(0,t.jsxs)(n.p,{children:["As ",(0,t.jsx)(n.code,{children:"import()"})," returns a promise, it can be used with ",(0,t.jsxs)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function",target:"_blank",rel:"noopener noreferrer",children:[(0,t.jsx)(n.code,{children:"async"})," functions"]}),". However, this requires using a pre-processor like Babel and the ",(0,t.jsx)(n.a,{href:"https://babeljs.io/docs/plugins/syntax-dynamic-import/#installation",target:"_blank",rel:"noopener noreferrer",children:"Syntax Dynamic Import Babel Plugin"}),". Here's how it would simplify the code:"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"src/index.js"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-diff",children:"- function getComponent() {\n+ async function getComponent() {\n-   return import(/* webpackChunkName: \"lodash\" */ 'lodash').then(({ default: _ }) => {\n-     const element = document.createElement('div');\n-\n-     element.innerHTML = _.join(['Hello', 'webpack'], ' ');\n-\n-     return element;\n-\n-   }).catch(error => 'An error occurred while loading the component');\n+   const element = document.createElement('div');\n+   const { default: _ } = await import(/* webpackChunkName: \"lodash\" */ 'lodash');\n+\n+   element.innerHTML = _.join(['Hello', 'webpack'], ' ');\n+\n+   return element;\n  }\n\n  getComponent().then(component => {\n    document.body.appendChild(component);\n  });\n"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["It is possible to provide a ",(0,t.jsx)(n.a,{href:"https://webpack.js.org/api/module-methods/#dynamic-expressions-in-import",target:"_blank",rel:"noopener noreferrer",children:"dynamic expression"})," to ",(0,t.jsx)(n.code,{children:"import()"})," when you might need to import specific module based on a computed variable later."]}),"\n"]}),"\n",(0,t.jsxs)(n.h2,{id:"prefetchingpreloading-modules",children:["Prefetching/Preloading modules",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#prefetchingpreloading-modules",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"webpack 4.6.0+ adds support for prefetching and preloading."}),"\n",(0,t.jsx)(n.p,{children:"Using these inline directives while declaring your imports allows webpack to output “Resource Hint” which tells the browser that for:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"prefetch: resource is probably needed for some navigation in the future"}),"\n",(0,t.jsx)(n.li,{children:"preload: resource might be needed during the current navigation"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Simple prefetch example can be having a ",(0,t.jsx)(n.code,{children:"HomePage"})," component, which renders a ",(0,t.jsx)(n.code,{children:"LoginButton"})," component which then on demand loads a ",(0,t.jsx)(n.code,{children:"LoginModal"})," component after being clicked."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"LoginButton.js"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"//...\nimport(/* webpackPrefetch: true */ 'LoginModal');\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This will result in `` being appended in the head of the page, which will instruct the browser to prefetch in idle time the ",(0,t.jsx)(n.code,{children:"login-modal-chunk.js"})," file."]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"webpack will add the prefetch hint once the parent chunk has been loaded."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Preload directive has a bunch of differences compared to prefetch:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"A preloaded chunk starts loading in parallel to the parent chunk. A prefetched chunk starts after the parent chunk finishes loading."}),"\n",(0,t.jsx)(n.li,{children:"A preloaded chunk has medium priority and is instantly downloaded. A prefetched chunk is downloaded while the browser is idle."}),"\n",(0,t.jsx)(n.li,{children:"A preloaded chunk should be instantly requested by the parent chunk. A prefetched chunk can be used anytime in the future."}),"\n",(0,t.jsx)(n.li,{children:"Browser support is different."}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Simple preload example can be having a ",(0,t.jsx)(n.code,{children:"Component"})," which always depends on a big library that should be in a separate chunk."]}),"\n",(0,t.jsxs)(n.p,{children:["Let's imagine a component ",(0,t.jsx)(n.code,{children:"ChartComponent"})," which needs huge ",(0,t.jsx)(n.code,{children:"ChartingLibrary"}),". It displays a ",(0,t.jsx)(n.code,{children:"LoadingIndicator"})," when rendered and instantly does an on demand import of ",(0,t.jsx)(n.code,{children:"ChartingLibrary"}),":"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"ChartComponent.js"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"//...\nimport(/* webpackPreload: true */ 'ChartingLibrary');\n"})}),"\n",(0,t.jsxs)(n.p,{children:["When a page which uses the ",(0,t.jsx)(n.code,{children:"ChartComponent"})," is requested, the charting-library-chunk is also requested via ``. Assuming the page-chunk is smaller and finishes faster, the page will be displayed with a ",(0,t.jsx)(n.code,{children:"LoadingIndicator"}),", until the already requested ",(0,t.jsx)(n.code,{children:"charting-library-chunk"})," finishes. This will give a little load time boost since it only needs one round-trip instead of two. Especially in high-latency environments."]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Using webpackPreload incorrectly can actually hurt performance, so be careful when using it."}),"\n"]}),"\n",(0,t.jsxs)(n.h2,{id:"bundle-analysis",children:["Bundle Analysis",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#bundle-analysis",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["Once you start splitting your code, it can be useful to analyze the output to check where modules have ended up. The ",(0,t.jsx)(n.a,{href:"https://github.com/webpack/analyse",target:"_blank",rel:"noopener noreferrer",children:"official analyze tool"})," is a good place to start. There are some other community-supported options out there as well:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"https://alexkuz.github.io/webpack-chart/",target:"_blank",rel:"noopener noreferrer",children:"webpack-chart"}),": Interactive pie chart for webpack stats."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"https://chrisbateman.github.io/webpack-visualizer/",target:"_blank",rel:"noopener noreferrer",children:"webpack-visualizer"}),": Visualize and analyze your bundles to see which modules are taking up space and which might be duplicates."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"https://github.com/webpack-contrib/webpack-bundle-analyzer",target:"_blank",rel:"noopener noreferrer",children:"webpack-bundle-analyzer"}),": A plugin and CLI utility that represents bundle content as a convenient interactive zoomable treemap."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"https://webpack.jakoblind.no/optimize",target:"_blank",rel:"noopener noreferrer",children:"webpack bundle optimize helper"}),": This tool will analyze your bundle and give you actionable suggestions on what to improve to reduce your bundle size."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"https://github.com/bundle-stats/bundle-stats",target:"_blank",rel:"noopener noreferrer",children:"bundle-stats"}),": Generate a bundle report(bundle size, assets, modules) and compare the results between different builds."]}),"\n"]})]})}function o(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(s,{...e})}):s(e)}let l=o;o.__RSPRESS_PAGE_META={},o.__RSPRESS_PAGE_META["webpack%2F%E6%8F%92%E4%BB%B6%20webpack%20Code%20Splitting.md"]={toc:[{text:"Entry Points",id:"entry-points",depth:2},{text:"Prevent Duplication",id:"prevent-duplication",depth:2},{text:"Entry dependencies",id:"entry-dependencies",depth:3},{text:"`SplitChunksPlugin`",id:"splitchunksplugin",depth:3},{text:"Dynamic Imports",id:"dynamic-imports",depth:2},{text:"Prefetching/Preloading modules",id:"prefetchingpreloading-modules",depth:2},{text:"Bundle Analysis",id:"bundle-analysis",depth:2}],title:"Code Splitting",frontmatter:{}}}}]);