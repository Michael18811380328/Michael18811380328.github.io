"use strict";(self.webpackChunk=self.webpackChunk||[]).push([["4067"],{3020:function(e,n,r){r.r(n),r.d(n,{default:function(){return d}});var a=r(6469),c=r(8809);function s(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",code:"code",ul:"ul",li:"li",pre:"pre",h3:"h3"},(0,c.ah)(),e.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.h1,{id:"webpack-构建分析",children:["webpack 构建分析",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#webpack-构建分析",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"统计信息：字数 8363  阅读17分钟"}),"\n",(0,a.jsx)(n.p,{children:"create time 2020-01-01"}),"\n",(0,a.jsx)(n.p,{children:"last modify time 2024-04-15"}),"\n",(0,a.jsx)(n.p,{children:"【课程主题】从源码探究构建工具之手动实现webpack"}),"\n",(0,a.jsx)(n.p,{children:"1、webpack基本使用：从模块谈起，到底什么是 webpack"}),"\n",(0,a.jsx)(n.p,{children:"2、打包文件分析：分析 bundle.min.js 源码"}),"\n",(0,a.jsx)(n.p,{children:"3、读完源码我们来写简易 webpack"}),"\n",(0,a.jsxs)(n.h2,{id:"webpack-在哪里使用",children:["webpack 在哪里使用",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#webpack-在哪里使用",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"create-react-app、vue-cli 等脚手架已经打包了webpack工具，所以高级框架不会直接配置 webpack。"}),"\n",(0,a.jsx)(n.p,{children:"我们如果不依赖 脚手架，需要直接开发一个前端项目，需要安装 webpack webpack-cli 等工具。"}),"\n",(0,a.jsx)(n.p,{children:"为什么使用 webpack?"}),"\n",(0,a.jsx)(n.p,{children:"因为浏览器不能直接读取 JS 的引用关系，不能识别 require 等语法，所以需要打包成一个文件，这样浏览器读取打包后的文件，可以正常运行。打包后是一个 IIFE 立即执行函数，不同函数（模块）作为立即执行的参数传入。"}),"\n",(0,a.jsxs)(n.p,{children:["新建配置文件 ",(0,a.jsx)(n.code,{children:"webpack.config.js"})," 包括："]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"entry 入口模块"}),"\n",(0,a.jsx)(n.li,{children:"module 一个模块即为一个文件，从 entry 模块递归找出所有的依赖模块"}),"\n",(0,a.jsx)(n.li,{children:"chunk 代码块，一个代码块由多个模块组合而成，用于代码的合并和分割"}),"\n",(0,a.jsx)(n.li,{children:"loader 模块转换器"}),"\n",(0,a.jsx)(n.li,{children:"plugin 插件"}),"\n",(0,a.jsx)(n.li,{children:"output 输出结果"}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const path = require('path');\n\nmodule.exports = {\n  mode: 'none',\n  entry: './src/index.js',\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: 'bundle.min.js'\n  }\n};\n"})}),"\n",(0,a.jsx)(n.p,{children:"执行流程"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"01 开始\n\n02 加载入口函数（index.js）\n\n03 执行 webpackBootstrap\n\n04 __webpack_require__ require 函数转换\n\n05 执行模块\n\n（如果有其他依赖模块，递归执行第34步）\n\n06 结束\n"})}),"\n",(0,a.jsxs)(n.h2,{id:"webpack-的作用",children:["webpack 的作用",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#webpack-的作用",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"依赖文件（模块）搜集；分析依赖关系"}),"\n",(0,a.jsx)(n.p,{children:"内部实现 require 函数重写（浏览器不支持require）"}),"\n",(0,a.jsx)(n.p,{children:"入口文件ID是0，按照顺序存入函数的参数，然后webpack依次require，根据不同的依赖关系，执行不同的函数"}),"\n",(0,a.jsxs)(n.h3,{id:"官方解释",children:["官方解释",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#官方解释",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"webpack 是模块打包机：分析项目结构，找到 JS 模块和其他浏览器不能直接运行的扩展语言（Sass TS）并将其打包成合适的合适以供浏览器使用。"}),"\n",(0,a.jsx)(n.p,{children:"构建：把源代码转换成线上可实行的CSS JS HTML代码"}),"\n",(0,a.jsxs)(n.h3,{id:"具体作用",children:["具体作用",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#具体作用",children:"#"})]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"代码转换：TS SaSS 编译成 JS CSS\n\n文件优化：压缩JS文件，压缩合并图片\n\n代码分割：提取多个页面的公共代码，提取首屏加载不需要的代码，并将其异步加载实现首屏优化\n\n模块合并：将多个模块合并成一个文件\n\n自动刷新：监听本地源代码的变化，自动重新构建，刷新浏览器\n\n代码校验：检验代码规范，单元测试\n\n自动发布：自动构建线上发布代码，并传输到发布系统\n"})}),"\n",(0,a.jsxs)(n.h3,{id:"bundlemainjs-结构分析",children:["bundle.main.js 结构分析",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#bundlemainjs-结构分析",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"首先把函数内部折叠，分析整理的结构和关系"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"(function(modules) {\n  // IEFF 自执行函数\n})\n([]);\n"})}),"\n",(0,a.jsx)(n.p,{children:"下面看传参，传参是一个数组，数组的每一项是一个模块，对应一个ID"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"(function(modules) {\n  //\n})\n([\n  (function(module, exports, __webpack_require__) {\n    const fn = __webpack_require__(1);\n    fn();\n  }),\n  (function(module, exports, __webpack_require__) {\n    const name = __webpack_require__(2);\n    const fn = () => {\n      console.log(name);\n    }\n    module.exports = fn;\n  }),\n  (function(module, exports) {\n    const name = 'Michael An';\n    module.exports = name;\n  })\n]);\n"})}),"\n",(0,a.jsx)(n.p,{children:"函数体，实现 require 转换"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"// 内部自执行函数和改写的require方法\n(function(modules) {\n  // cache(缓存，如果已经处理过的模块，直接从缓存中读取)\n  var installedModules = {};\n  \n  // 改写的 require 函数\n  function __webpack_require__(moduleId) {\n    // check if module is in cache\n    if (installedModules[moduleId]) {\n      return installedModules[moduleId].exports;\n    }\n    // 如果不在缓存中，创建新的模块并放到缓存中（计算斐波那契数列也使用缓存）\n    // (扩展：算法中凡是能重复计算的部分，可以使用对象存储缓存)\n    var module = installedModules[moduleId] = {\n      i: moduleId,\n      l: false,\n      exports: {}\n    };\n    // 执行模块的方法\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    \n    // 将模块标记为已加载（flag：动词，标记）\n    module.l = true;\n    return module.exports;\n  }\n  __webpack_require__.m = modules;\n  // ...\n  // 加载模块的入口\n  return __webpack_require__(__webpack_require__.s = 0);\n})([module1, module2, module3]);\n"})}),"\n",(0,a.jsxs)(n.h2,{id:"自定义简易webpack",children:["自定义简易webpack",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#自定义简易webpack",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"分析依赖关系前，首先把不同的JS代码读入，然后获取require部分，需要使用AST"}),"\n",(0,a.jsx)(n.p,{children:"AST（抽象语法树）编译原理  babel 也会用到AST（astexplorer.net 可以在线把字符串转换成AST）高级语言执行，需要编译器，编译成为二进制代码。如果写语言，需要会编译原理。"}),"\n",(0,a.jsx)(n.p,{children:"词法分析（扫描）代码去掉注释，一个一个字母读代码，移除空白，分割成tokens。"}),"\n",(0,a.jsx)(n.p,{children:"语法分析 解析器 把 tokens 一维数组，转换成树，监测语法错误，删除不完整的括号。"}),"\n",(0,a.jsx)(n.p,{children:"如果直接读文件（结果是字符串），然后使用正则表达式处理依赖关系，模块很大就复杂了。所以使用AST构建文件结构。"}),"\n",(0,a.jsx)(n.p,{children:"读取文件后，转换成AST，然后一步一步处理文件内容。"}),"\n",(0,a.jsx)(n.p,{children:"新建项目和脚本 package.json"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"npm init\nnpm install -D @babel/core @babel/genarator @babel/parser @babel/traverse\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:"{\n  \"name\": 'test',\n  \"version\": '1.0.0',\n  \"main\": 'index.js',\n  \"scripts\": {\n    \"wypack\": 'node wypack/wypack.js'\n  },\n  'devDependencies': {\n    'webpack': '^4.41.6',\n    'webpack-cli': '^3.3.11'\n  }\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"下面是脚本 wypack.js"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const fs = require('fs');\nconst path = require('path');\nconst parser = require('@babel/parser');\nconst babel = require('@babel/core');\nconst traverse = require('@babel/traverse').default;\nconst generator = require('@babel/generator');\nconst ejs = require('ejs');\nconst config = require('../wypack.json');\nconst entry = config.entry;\nlet id = 0;\n\n// AST\nconst createAST = filePath => {\n  // 默认读取文件的结果是 array Buffer，这里需要设置格式utf-8\n  const content = fs.readFileSync(filePath, 'utf-8');\n  \n  // parse 用来转换成AST\n  const ast = parser.parse(content, {\n    sourceType: 'module'\n  });\n  \n  // 单文件的依赖放在一个数组\n  let dependencies = [];\n  // 依赖搜集：@babel/travers用来遍历更新@babel/parser生成的AST\n  traverse(ast, {\n    CallExpression(p) {\n      const node = p.node;\n      if (node.callee.name === \"require\") {\n        node.callee.name = '__webpack_require__';\n        let resultPath = node.arguments[0].value;\n        // 判断是否有后缀名，如果没有加上JS后缀名\n        resultPath = resultPath + (path.extname(resultPath) ? '' : 'js');\n        dependencies.push(resultPath);\n      }\n    }\n  });\n  // 重新生成代码\n  let code = generator(ast).code;\n  let moduleId = id++;\n  return {\n    moduleId,\n    filePath,\n    code,\n    dependencies\n  };\n};\n\n// 处理多个文件的依赖\nconst createGraph = entry => {\n  const ast = createAST(entry);\n  const queue = [ast];\n  // 处理文件绝对路径\n  for (const item of queue) {\n    const dirname = path.dirname(ast.filePath);\n    item.dependencies.map(relativePath => {\n      const absolutePath = path.join(dirname, relativePath);\n      const child = createAST(absolutePath);\n      queue.push(child);\n    });\n  }\n  console.log(queue);\n  return queue;\n}\n\nconst modules = createGraph(entry);\nconst entryId = modules[0].moduleId;\n\nlet code = [];\nmodules.map((item, index) => {\n  const packCode = {\n    id: modules[index].mapping,\n    code: modules[index].code,\n  };\n  code.push(packCode);\n});\n\nlet reg = new RegExp(/__webpack_require__\\((.+?)\\)/g);\n\ncode = code.map((item, index) => {\n  if (item.code.match(reg)) {\n    item = item.code.replace(\n      reg,\n			`__webpack_require__(${Object.values(item.id)})`\n    );\n  } else {\n    item = item.code;\n  }\n  return item;\n});\nconsole.log(code);\n\nlet { path, filename } = config.output; \nlet output = `${path}\\\\${filename}`;\nlet template = fs.readFileSync('./wypack/template.ejs', 'utf-8');\n\nlet package = ejs.render(template, {\n  entryId,\n  code\n});\n\ncreateAST(entry);\nfs.writFileSync(output, package);\n"})}),"\n",(0,a.jsx)(n.p,{children:"这就是实现的简易 mypack"})]})}function l(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(s,{...e})}):s(e)}let d=l;l.__RSPRESS_PAGE_META={},l.__RSPRESS_PAGE_META["webpack%2F04-%E7%BD%91%E6%98%93webpack%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90.md"]={toc:[{text:"webpack 在哪里使用",id:"webpack-在哪里使用",depth:2},{text:"webpack 的作用",id:"webpack-的作用",depth:2},{text:"官方解释",id:"官方解释",depth:3},{text:"具体作用",id:"具体作用",depth:3},{text:"bundle.main.js 结构分析",id:"bundlemainjs-结构分析",depth:3},{text:"自定义简易webpack",id:"自定义简易webpack",depth:2}],title:"webpack 构建分析",frontmatter:{}}}}]);