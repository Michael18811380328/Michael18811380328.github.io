"use strict";(self.webpackChunk=self.webpackChunk||[]).push([["8549"],{775:function(e,n,s){s.r(n),s.d(n,{default:function(){return d}});var r=s(6469),c=s(8809);function a(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",pre:"pre",code:"code",ul:"ul",li:"li"},(0,c.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"webpack-打包-ts-文件",children:["Webpack 打包 TS 文件",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#webpack-打包-ts-文件",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"统计信息：字数 7981  阅读16分钟"}),"\n",(0,r.jsxs)(n.h2,{id:"前言",children:["前言",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"这篇文章我们主要讲解如何使用TS与已经使用React以及webpack的项目结合使用。"}),"\n",(0,r.jsxs)(n.h2,{id:"正文",children:["正文",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#正文",children:"#"})]}),"\n",(0,r.jsxs)(n.h2,{id:"初始化项目结构",children:["初始化项目结构",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#初始化项目结构",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"首先我们新建一个名字为myTsProj的文件夹（这里使用 demo-04），命令如下："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"mkdir myTsProj\ncd myTsProj\n"})}),"\n",(0,r.jsx)(n.p,{children:"接下来创建src文件夹，用来放TS文件。然后在src文件夹里面创建components文件夹，用来放我们自己自定义的组件。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"mkdir src\ncd src\nmkdir components\ncd ..\n"})}),"\n",(0,r.jsx)(n.p,{children:"Webpack会帮助我们生成dist目录。经webpack处理，会生成bundle.js文件放在dist目录下。"}),"\n",(0,r.jsx)(n.p,{children:"最后看到的文件如下："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"proj/\n├─dist/\n└─ src/   \n  └─components/\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"初始化工程",children:["初始化工程",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#初始化工程",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"安装，使用默认值就可以了，也可以在生成的 package.json文件里修改。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"npm init\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"安装依赖",children:["安装依赖",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#安装依赖",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"1、要确保我们有安装webpack,如果没有安装，执行下面的命令："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"npm install -D webpack webpack-cli\n"})}),"\n",(0,r.jsx)(n.p,{children:"Webpack可以将所有代码和可选择地将依赖捆绑成一个单独的.js文件"}),"\n",(0,r.jsx)(n.p,{children:"2、接着添加React和React-DOM以及它们的声明文件到package.json文件里做为依赖，执行下面命令："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"npm install --save react react-dom @types/react @types/react-dom\n"})}),"\n",(0,r.jsx)(n.p,{children:'（说明： 这个命令使用 @types/前缀 表示要额外获取 React 和 React-DOM 的声明文件。 通常导入像 "react"这样的路径，它会查看react包； 然而，并不是所有的包都包含了声明文件，所以TS还会查看 @types/react包。 之后将不必在意这些了。）'}),"\n",(0,r.jsx)(n.p,{children:"3、最后，我们要添加开发时依赖 awesome-typescript-loader 和 source-map-loader 。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"npm install --save-dev typescript awesome-typescript-loader source-map-loader\n"})}),"\n",(0,r.jsx)(n.p,{children:"Loader说明："}),"\n",(0,r.jsx)(n.p,{children:"awesome-typescript-loader 可以让 Webpack 使用 TypeScript 的标准配置文件 tsconfig.json 编译 TypeScript 代码。"}),"\n",(0,r.jsx)(n.p,{children:"source-map-loader使用 TypeScript 输出的 sourcemap 文件来告诉 webpack 何时生成自己的sourcemaps。 这就允许我们在调试最终生成的文件时就好像在调试TypeScript源码一样。"}),"\n",(0,r.jsxs)(n.h2,{id:"添加typescript配置文件",children:["添加TypeScript配置文件",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#添加typescript配置文件",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"我们想将我们写的源码和必要的TypeScript文件整合到一起，这就需要创建一个tsconfig.json文件。（包含了输入文件列表以及编译选项）"}),"\n",(0,r.jsx)(n.p,{children:"在myTsProj的根目录下新建 tsconfig.json文件，里面配置如下："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{ \n  "compilerOptions":{        \n    "outDir": "./dist/",        \n    "sourceMap": true,\n    "noImplicitAny": true,\n    "module": "commonjs",        \n    "target": "es5",\n    "jsx": "react"    \n  },   \n  "include": [\n    "./src/**/*"\n  ]\n}\n'})}),"\n",(0,r.jsxs)(n.h2,{id:"编写代码",children:["编写代码",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#编写代码",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"首先在 src/components目录下创建一个Demo.tsx 的文件，代码如下："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:'import * as React from "react";\nexport interface DemoProps { \n  compiler: string;\n  framework: string;\n}\nexport const Demo = (props: DemoProps) => <h1>Hello from {props.compiler} and {props.framework}!</h1>;\n'})}),"\n",(0,r.jsx)(n.p,{children:"这个例子使用了无状态的功能组件，我们可以让它更像一点类。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:"import * as React from \"react\";\n\nexport interface DemoProps {\n  compiler: string;\n  framework: string;\n}\n\n// 'DemoProps ' describes the shape of props.\n// State is never set so we use the '{}' type.\nexport class Demo extends React.Component<DemoProps , {}> {\n  render() {\n    return (<h1>Hello from {this.props.compiler} and {this.props.framework}!</h1>);\n  }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"接下来，在src下创建index.tsx文件，代码如下："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:'import * as React from "react";\nimport * as ReactDOM from "react-dom";\nimport { Demo } from "./components/Demo";\n\nReactDOM.render(<Demo compiler="TypeScript" framework="React" />, document.getElementById("app"));\n'})}),"\n",(0,r.jsx)(n.p,{children:'注意:\n我们仅仅将Demo组件导入index.tsx。 不同于 "react"或"react-dom"，我们使用Demo.tsx的相对路径 - 这很重要。 如果不这样做，TypeScript只会尝试在 node_modules文件夹里查找。'}),"\n",(0,r.jsx)(n.p,{children:"我们还缺一个页面来显示Demo组件。 在myTsProj根目录创建一个名为index.html的文件，代码如下："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-html",children:'<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset="UTF-8" />\n    <title>React TS Demo!</title>\n  </head>    \n  <body>        \n    <div id="app"></div>        \n    \x3c!-- Dependencies --\x3e\n    <script src="./node_modules/react/umd/react.development.js"><\/script>\n    <script src="./node_modules/react-dom/umd/react-dom.development.js"><\/script>        \n    \x3c!-- Main --\x3e        \n    <script src="./dist/bundle.js"><\/script>    \n  </body>\n</html>\n'})}),"\n",(0,r.jsx)(n.p,{children:"需要注意一点我们是从node_modules引入的文件。 React和React-DOM的npm包里包含了独立的 .js文件，你可以在页面上引入它们，这里我们为了快捷就直接引用了。 可以随意地将它们拷贝到其它目录下，或者从CDN上引用。"}),"\n",(0,r.jsxs)(n.h2,{id:"创建webpack配置文件",children:["创建webpack配置文件",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#创建webpack配置文件",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"做到这里，我们还差最后一步。\n在myTsProj根目录下创建webpack.config.js文件，代码如下："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'module.exports = {\n  entry: "./src/index.tsx",\n  output: {\n    filename: "bundle.js",\n    path: __dirname + "/dist"\n  },\n\n  // Enable sourcemaps for debugging webpack\'s output.\n  devtool: "source-map",\n\n  resolve: {\n    // Add \'.ts\' and \'.tsx\' as resolvable extensions.\n    extensions: [".ts", ".tsx", ".js", ".json"]\n  },\n\n  module: {\n    rules: [\n      // All files with a \'.ts\' or \'.tsx\' extension will be handled by \'awesome-typescript-loader\'.\n      { test: /\\.tsx?$/, loader: "awesome-typescript-loader" },\n\n      // All output \'.js\' files will have any sourcemaps re-processed by \'source-map-loader\'.\n      { enforce: "pre", test: /\\.js$/, loader: "source-map-loader" }\n    ]\n  },\n\n  // When importing a module whose path matches one of the following, just\n  // assume a corresponding global variable exists and use that instead.\n  // This is important because it allows us to avoid bundling all of our\n  // dependencies, which allows browsers to cache those libraries between builds.\n  externals: {\n    "react": "React",\n    "react-dom": "ReactDOM"\n  },\n};\n'})}),"\n",(0,r.jsx)(n.p,{children:"之所以添加externals字段，因为我们想要避免把所有的React都放到一个文件里，那样会增加编译时间并且浏览器还能够缓存没有发生改变的库文件。"}),"\n",(0,r.jsx)(n.p,{children:'webpack允许我们使用通过这种方式写的代码库。 通过我们的设置 "react": "React"，webpack会神奇地将所有对"react"的导入转换成从React全局变量中加载。'}),"\n",(0,r.jsxs)(n.h2,{id:"运行",children:["运行",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#运行",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"最后我们只需要执行一个命令："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"webpack\n"})}),"\n",(0,r.jsx)(n.p,{children:"在浏览器里打开index.html，应该已经可以用了！ 你可以看到页面上显示着: “Hello from TypeScript and React!”"}),"\n",(0,r.jsxs)(n.p,{children:["相信大家对TS已经有一定了解了，可以到官网深入学习TS了。",(0,r.jsx)(n.a,{href:"https://github.com/Microsoft/TypeScript-React-Starter#typescript-react-starter",target:"_blank",rel:"noopener noreferrer",children:"官网链接"})]}),"\n",(0,r.jsxs)(n.h2,{id:"michael-笔记",children:["Michael 笔记",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#michael-笔记",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"已实现"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"执行 npx webpack 可以把 src 下面的 ts 打包到 dist 下面的 js, 然后手动打开根目录下面的 index.html 即可打开界面"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["npm start 打开 webpack-dev-server 本地服务器，更新代码后，可以热更新，但是界面不会自动渲染：原因：webpack-dev-server 会把编译后的文件直接放在内存中，而不是放在当前的目录下面，所以代码更新后，刷新界面，HTML 引用的还是旧的 dist 目录下面的 js，内容不会变化（可以把引用路径改一下 ",(0,r.jsx)(n.code,{children:'<script src="/bundle.js"><\/script>'})," ）。稍后把 html 移动到 dist 下面，这样实时打开的 bundle 就是正常的。——已经解决"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"html 在根目录显示，并不是在 dist 下面显示，最好使用 html-webpack-plugin 插件处理一下，把 src 中的模板直接拷贝到 dist 打包目录下面，然后自动插入打包后的 bundle.js ，这样避免 HTML 再次引入问题。——已经解决"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"代码中关键的配置，应该自己走一遍，写一下注释"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"存在的问题"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"HTML 中还手动引入 react react-dom 这个应该可以自动实现打包——这里需要 babel 处理等"}),"\n"]})]})}function t(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}let d=t;t.__RSPRESS_PAGE_META={},t.__RSPRESS_PAGE_META["webpack%2F45-TS%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8Webpack.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"正文",id:"正文",depth:2},{text:"初始化项目结构",id:"初始化项目结构",depth:2},{text:"初始化工程",id:"初始化工程",depth:2},{text:"安装依赖",id:"安装依赖",depth:2},{text:"添加TypeScript配置文件",id:"添加typescript配置文件",depth:2},{text:"编写代码",id:"编写代码",depth:2},{text:"创建webpack配置文件",id:"创建webpack配置文件",depth:2},{text:"运行",id:"运行",depth:2},{text:"Michael 笔记",id:"michael-笔记",depth:2}],title:"Webpack 打包 TS 文件",frontmatter:{}}}}]);