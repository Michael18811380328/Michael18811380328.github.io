"use strict";(self.webpackChunk=self.webpackChunk||[]).push([["1880"],{4230:function(n,e,l){l.r(e),l.d(e,{default:function(){return o}});var s=l(6469),r=l(8809);function d(n){let e=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",code:"code",h3:"h3",pre:"pre",ol:"ol",li:"li",img:"img",strong:"strong",ul:"ul"},(0,r.ah)(),n.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(e.h1,{id:"js打包工具rollup完全入门指南",children:["JS打包工具rollup——完全入门指南",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#js打包工具rollup完全入门指南",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"统计信息：字数 48147  阅读97分钟"}),"\n",(0,s.jsx)(e.p,{children:"官网教程"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.a,{href:"https://rollupjs.org/guide/en/",target:"_blank",rel:"noopener noreferrer",children:"https://rollupjs.org/guide/en/"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.a,{href:"https://www.rollupjs.com/guide/tutorial",target:"_blank",rel:"noopener noreferrer",children:"https://www.rollupjs.com/guide/tutorial"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.a,{href:"https://www.rollupjs.com/guide/big-list-of-options",target:"_blank",rel:"noopener noreferrer",children:"https://www.rollupjs.com/guide/big-list-of-options"})}),"\n",(0,s.jsxs)(e.p,{children:["博客链接：",(0,s.jsx)(e.a,{href:"https://segmentfault.com/a/1190000010628352",target:"_blank",rel:"noopener noreferrer",children:"https://segmentfault.com/a/1190000010628352"})]}),"\n",(0,s.jsx)(e.p,{children:"发布于 2017-08-12（以最新的官方文档为准）"}),"\n",(0,s.jsx)(e.p,{children:"文档没有具体看（部分插件版本更新了）"}),"\n",(0,s.jsxs)(e.h2,{id:"前言",children:["前言",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"最近在做一个提供给浏览器和node同时使用的js的url模板工具类，在用什么打包工具上纠结了一段时间，正好有一天在知乎上看到了关于rollup的介绍，在自己试了试之后，就决定用rollup.js来打包自己的工具类了。"}),"\n",(0,s.jsx)(e.p,{children:"这篇文章主要是为了让对rollup.js也有兴趣的同学能够快速入门rollup的使用方式而写的，文章除了开始对rollup.js的基本介绍之外，主要用多个demo来介绍rollup.js的不同使用方法，以及介绍一些比较常用的rollup插件。读者可以选择自己有兴趣的部分查看。"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.a,{href:"https://link.segmentfault.com/?enc=stSl1SdmyWPkNFfQJOJB9g%3D%3D.n3CqV0SR%2FFRMLV1OfvaOkve1P6nn5vRja0kdHDYO4qs2VYefJG4gNrxjS%2BC7Zlfyh2xc5wkaux5dUJhk4gvEQl%2BN96yFSnStl5Hf7pcLaCCNTtxmKDl2zF0mMdmWVyI8bDSTRli55WqAzn7zLDYiQYqtETyfBW0HERNIl5Wq8M6g9Gm1eAZ5tpSFut1NJHHc",target:"_blank",rel:"noopener noreferrer",children:"文章博客链接"})}),"\n",(0,s.jsxs)(e.p,{children:["本教程相关的所有demo都已上传到github，",(0,s.jsx)(e.a,{href:"https://link.segmentfault.com/?enc=au2%2BHs1WWDpbS10kEZqmiw%3D%3D.IoKA0wo22faXhnqpbAE1u5r4B0upu6DLiUJgo3dghN6JroeDi0s1zW%2FZ5jLcryts",target:"_blank",rel:"noopener noreferrer",children:"rollup-demos"}),"，欢迎star。"]}),"\n",(0,s.jsxs)(e.h2,{id:"rollupjs简介",children:["rollup.js简介",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#rollupjs简介",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"首先简单介绍一下rollup.JS。根据官方的介绍，rollup.js是一个模块打包工具，可以帮助你从一个入口文件开始，将所有使用到的模块文件都打包到一个最终的发布文件中（极其适合构建一个工具库，这也是我选择用rollup来打包的原因）。"}),"\n",(0,s.jsxs)(e.p,{children:["rollup.js有两个重要的特性，其中一个就是它使用ES6的模块标准，这意味着你可以直接使用",(0,s.jsx)(e.code,{children:"import"}),"和",(0,s.jsx)(e.code,{children:"export"}),"而不需要引入babel（当然，在现在的项目中，babel可以说是必用的工具了）。"]}),"\n",(0,s.jsx)(e.p,{children:"rollup.js的另一个重要特性叫做'tree-shaking'，这个特性可以帮助你将无用代码（即没有使用到的代码）从最终的生成文件中删去。举个例子，我在A.js文件中定义了A1和A2两个方法，同时在B文件中引入了这两个方法，但是在B文件中只引入了A文件中的A1方法，那么在最后打包B文件时，rollup就不会将A2方法引入到最终文件中。（这个特性是基于ES6模块的静态分析的，也就是说，只有export而没有import的变量是不会被打包到最终代码中的）"}),"\n",(0,s.jsxs)(e.h2,{id:"rollupjs实例",children:["rollup.js实例",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#rollupjs实例",children:"#"})]}),"\n",(0,s.jsxs)(e.h3,{id:"demo0-开始使用rollup",children:["demo0 开始使用rollup",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#demo0-开始使用rollup",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"初始化一个工程，创建一个依赖模块文件lib.js和入口文件index.js。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"export function logA() {\n    console.log('function logA called')\n}\n\nexport function logB() {\n    console.log('function logB called')\n}\nimport { logA } from './lib'\n\nlogA()\n"})}),"\n",(0,s.jsx)(e.p,{children:"现在我们要把lib.js和index.js打包成dist.js，首先要做的就是安装rollup.js。"}),"\n",(0,s.jsx)(e.p,{children:"在这里我们有两种安装方法："}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"全局安装："}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["打开你的命令行，输入",(0,s.jsx)(e.code,{children:"npm install rollup -g"}),"，等待rollup安装完毕。安装完成之后，试着输入",(0,s.jsx)(e.code,{children:"rollup -v"}),"来查看一下rollup是否安装成功了"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{src:"https://segmentfault.com/img/bVSKQD?w=518&h=63",alt:"查看rollup版本"})}),"\n",(0,s.jsxs)(e.p,{children:["成功安装完rollup之后，进入到工程目录下，输入打包命令",(0,s.jsx)(e.code,{children:"rollup index.js -o dist.js"}),"，index.js 是我们的入口文件， -o 表示输出文件的路径，在 -o 后面跟着的 dist.js 就是我们要生成的最终打包文件了。（其实这里本来应该加上一个参数-i，用来表示入口文件的路径，但rollup是会把没有加参数的文件默认为是入口文件，因此我们在这里省略了这个参数）"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{src:"https://segmentfault.com/img/bVSKQE?w=504&h=73",alt:"使用全局rollup进行打包"})}),"\n",(0,s.jsx)(e.p,{children:"显示出这条信息之后，我们发现目录下已经多出了一个 dist.js 文件，打开文件，我们发现里面的代码是这样的"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ada",children:"function logA() {\n    console.log('function logA called');\n}\n\nlogA();\n"})}),"\n",(0,s.jsx)(e.p,{children:"此时我们就已经完成了打包作业，可以将dist.js引入到HTML文件或是node模块中了"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"项目本地安装："}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["进入到项目目录，打开命令行输入",(0,s.jsx)(e.code,{children:"npm install rollup --save-dev"}),"，把rollup加入到开发依赖中，然后在命令行中输入",(0,s.jsx)(e.code,{children:"./node_modules/.bin/rollup index.js -o dist.js"})]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{src:"https://segmentfault.com/img/bVSKQ9?w=494&h=75",alt:"使用项目本地rollup进行打包"})}),"\n",(0,s.jsxs)(e.p,{children:["或者在",(0,s.jsx)(e.code,{children:"package.json"}),"文件中添加npm scripts命令",(0,s.jsx)(e.code,{children:'"build": "rollup index.js -o dist.js"'}),"，在命令行中输入",(0,s.jsx)(e.code,{children:"npm run build"}),"来进行打包"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{src:"https://segmentfault.com/img/bVSKRe?w=543&h=133",alt:"使用项目本地rollup进行打包"})}),"\n",(0,s.jsx)(e.p,{children:"在打包完成之后，我们查看一下效果，新建一个index.html文件，在这个文件中引入我们打包出来的dist.js文件"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'<!DOCTYPE html>\n<html lang="en">\n    <head>\n        <title>rollup 打包测试</title>\n        <meta charset="UTF-8">\n        <meta name="viewport" content="width=device-width, initial-scale=1">\n    </head>\n    <body>\n        <script src="./dist.js"><\/script>\n    </body>\n</html>\n'})}),"\n",(0,s.jsx)(e.p,{children:"用浏览器打开index.html文件，打开控制台，我们可以看到控制台上输出了一行文字"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{src:"https://segmentfault.com/img/bVSKRf?w=428&h=124",alt:"rollup打包文件测试"})}),"\n",(0,s.jsx)(e.p,{children:"使用命令行运行dist.js文件，我们也可以看到命令行中输出了一行文字"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{src:"https://segmentfault.com/img/bVSKRm?w=496&h=65",alt:"rollup打包文件测试"})}),"\n",(0,s.jsx)(e.p,{children:"这说明我们的打包文件dist.js是可以运行的，打包成功。"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"PS："})}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"接下来的demo中，默认在项目内安装了rollup"}),"\n",(0,s.jsx)(e.li,{children:"接下来的demo中，非必要情况下不会对打包结果进行运行结果测试，读者若需要验证打包效果，请自己编写其他测试代码。"}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"demo1-使用rollup进行模块化打包",children:["demo1 使用rollup进行模块化打包",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#demo1-使用rollup进行模块化打包",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["在之前打包的过程中，命令行中输出了一行",(0,s.jsx)(e.code,{children:"No format option was supplied – defaulting to 'es'"}),"，这表示rollup并没有收到任何模块化的格式指令，因此会用默认的es模块标准来对文件进行打包。"]}),"\n",(0,s.jsxs)(e.p,{children:["如果在demo0中的index.js文件中把",(0,s.jsx)(e.code,{children:"logA()"}),"改成",(0,s.jsx)(e.code,{children:"export default logA()"}),"，那么rollup最后的打包结果就会是"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function logA() {\n    console.log('function logA called');\n}\n\nvar index = logA();\n\nexport default index;\n"})}),"\n",(0,s.jsx)(e.p,{children:"显然这样的代码是不能直接在浏览器端和node端运行的，我们需要把原先的ES6模块转化成浏览器和node支持的形式。"}),"\n",(0,s.jsxs)(e.p,{children:["那么要去哪里找rollup把ES6代码转化成其他形式的方法呢？这里有两个方案，一是去",(0,s.jsx)(e.a,{href:"https://link.segmentfault.com/?enc=Hv4Gp2NV7yQkwAe6zj2lpQ%3D%3D.oKuW0JiDNnhSwBH2WrdX%2BKZHpeUJEL2MTU70ZKp%2FIyg%3D",target:"_blank",rel:"noopener noreferrer",children:"rollup的官网"}),"找相关的资料，二是使用rollup命令行的帮助命令，看看能不能找到相关的参数"]}),"\n",(0,s.jsxs)(e.p,{children:["我们使用rollup命令行的帮助命令，在命令行中输入",(0,s.jsx)(e.code,{children:"rollup -h"})]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{src:"https://segmentfault.com/img/bVSKRv?w=656&h=290",alt:"rollup命令行帮助"})}),"\n",(0,s.jsxs)(e.p,{children:["在这里我们可以看到类似版本号，帮助，使用配置文件等一系列参数。在这里我们可以找到",(0,s.jsx)(e.code,{children:"-f"}),"这个参数，他的说明是输出的类型（amd，cjs，es，iife，umd），从括号里的内容我们可以看出，使用这个参数可以确定打包完后的文件的模块处理方式。（如果你还不知道这几种模块之间的区别，建议先去找一下相关的资料学习一下）"]}),"\n",(0,s.jsxs)(e.p,{children:["接下来我们用rollup来打包一下，在demo0中的index.js文件里将",(0,s.jsx)(e.code,{children:"logA()"}),"改成",(0,s.jsx)(e.code,{children:"export default logA()"}),"，在package.json文件中写好不同模块的打包命令"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-n1ql",children:'"build:amd": "rollup index.js -f amd -o ./dist/dist.amd.js",\n"build:cjs": "rollup index.js -f cjs -o ./dist/dist.cjs.js",\n"build:es": "rollup index.js -f es -o ./dist/dist.es.js",\n"build:iife": "rollup index.js -f iife -n result -o ./dist/dist.iife.js",\n"build:umd": "rollup index.js -f umd -n result -o ./dist/dist.umd.js",\n"build:all": "npm run build:amd && npm run build:cjs && npm run build:es && npm run build:iife && npm run build:umd"\n'})}),"\n",(0,s.jsxs)(e.p,{children:["在这里我们发现在设置模块为iife（立即执行函数）和umd时，还加上了一个参数",(0,s.jsx)(e.code,{children:"-n"}),"，这是因为我们将logA()的结果设置为模块的输出结果，那么在使用iife和umd时，需要事先设定模块的名称，才能让其他人通过这个模块名称引用到你的模块的输出结果。"]}),"\n",(0,s.jsxs)(e.p,{children:["在命令行中输入",(0,s.jsx)(e.code,{children:"npm run build:all"}),"，运行所有打包命令，查看效果"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{src:"https://segmentfault.com/img/bVSKRB?w=153&h=162",alt:"demo1打包结果"})}),"\n",(0,s.jsx)(e.p,{children:"可以看到已经输出了5种不同模块标准的打包文件，由于字数原因，在这里我们只查看一个打包文件（dist.iife.js）的内容"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"var result = (function () {\n'use strict';\n\nfunction logA() {\n    console.log('function logA called');\n}\n\nvar index = logA();\n\nreturn index;\n\n}());\n"})}),"\n",(0,s.jsx)(e.p,{children:"可以看到所有代码都被打包到了一个立即执行函数中，并且将函数的返回值（模块的输出内容）赋值给了一个全局变量，而这个全局变量的名称就是我们之前设置的模块名称。"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"PS："})," 使用amd模块打包方式时，若不指定模块名称，则会打包成匿名函数，若想打包成一个具名函数，则需要使用",(0,s.jsx)(e.code,{children:"-u"}),"或",(0,s.jsx)(e.code,{children:"--id"}),"来指定具名函数名称。"]}),"\n",(0,s.jsx)(e.p,{children:"除了-f之外，还有许多其他的参数可以使用，看到这里可能有些同学会觉得麻烦了，这么多参数用起来好麻烦，每次都要输一长串的命令，那么有没有更好的方法来控制rollup的参数配置呢？"}),"\n",(0,s.jsx)(e.p,{children:"当然有，接下来我们就尝试使用配置文件来控制rollup打包。"}),"\n",(0,s.jsxs)(e.h2,{id:"demo2-使用配置文件来进行rollup打包",children:["demo2 使用配置文件来进行rollup打包",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#demo2-使用配置文件来进行rollup打包",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["创建一个demo2，沿用之前demo1的内容，我们在demo2的项目下创建一个文件，取名为",(0,s.jsx)(e.code,{children:"rollup.config.js"}),"，这个文件就是rollup的配置文件了，rollup根据配置文件的输出配置来进行打包，接下来我们在配置文件中输入配置代码:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-routeros",children:"export default {\n  entry: 'index.js',\n  format: 'cjs',\n  dest: './dist/dist.js'\n}\n"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"entry"}),"表示打包的入口文件，",(0,s.jsx)(e.code,{children:"format"}),"表示要打包成的模块类型，",(0,s.jsx)(e.code,{children:"dest"}),"表示输出文件的名称路径"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"PS："})," 若使用iife或umd模块打包，需要添加属性",(0,s.jsx)(e.code,{children:"moduleName"}),"，用来表示模块的名称；若用amd模块打包，可以配置amd相关的参数（使用umd模块模式时，也会使用到amd相关配置参数）："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"amd: {\n    id: 'amd-name',   // amd具名函数名称\n    define: 'def'     // 用来代替define函数的函数名称\n}\n"})}),"\n",(0,s.jsxs)(e.p,{children:["在这里我们发现配置文件也是使用了ES6语法，这是因为rollup可以自己处理配置文件，所以能够直接用ES6的模块输出（当然，你也可以选择使用node的",(0,s.jsx)(e.code,{children:"module.exports"}),"方式来输出配置。"]}),"\n",(0,s.jsx)(e.p,{children:"在package.json文件中编写npm scripts命令"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-json",children:'"build": "rollup -c"\n'})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"-c"}),"这个参数表示使用配置文件来进行打包，若后面没有指定使用的配置文件路径，则使用默认的配置文件名称",(0,s.jsx)(e.code,{children:"rollup.config.js"}),"。"]}),"\n",(0,s.jsxs)(e.p,{children:["在命令行中输入",(0,s.jsx)(e.code,{children:"npm run build"}),"，执行打包，可以看到生成了打包文件dist.js"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"'use strict';\n\nfunction logA() {\n    console.log('function logA called');\n}\n\nvar index = logA();\n\nmodule.exports = index;\n"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"进阶："})," 当rollup配置文件最终输出的不是一个对象而是一个数组时，rollup会把每一个数组元素当成一个配置输出结果，因此可以在一个配置文件内设置多种输出配置"]}),"\n",(0,s.jsx)(e.p,{children:"例如，我们添加一个indexB.js文件，在这个文件中我们将logA替换为logB，并将rollup配置文件改为："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-mel",children:"export default [{\n  entry: 'index.js',\n  format: 'cjs',\n  dest: './dist/distA.js'\n},{\n  entry: 'indexB.js',\n  format: 'iife',\n  moduleName: 'indexB',\n  dest: './dist/distB.js'\n}]\n"})}),"\n",(0,s.jsx)(e.p,{children:"运行打包命令，发现在dist目录下生成了distA.js和distB.js两个文件，说明多项配置打包成功。"}),"\n",(0,s.jsx)(e.p,{children:"除了上面这种输出一个配置数组之外，你还可以通过配置target属性来输出多个打包文件："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-sqf",children:"export default {\n  entry: 'index.js',\n  targets: [{\n      dest: 'dist/bundle.cjs.js',\n      format: 'cjs'\n    },\n    {\n      dest: 'dist/bundle.umd.js',\n      moduleName: 'res',\n      format: 'umd'\n    },\n    {\n      dest: 'dist/bundle.es.js',\n      format: 'es'\n    },\n  ]\n}\n"})}),"\n",(0,s.jsxs)(e.p,{children:["这样配置会在dist目录下面输出",(0,s.jsx)(e.code,{children:"bundle.cjs.js"}),"，",(0,s.jsx)(e.code,{children:"bundle.umd.js"}),"和",(0,s.jsx)(e.code,{children:"bundle.es.js"}),"三个打包文件，同时umd模块的名称会被定义成res。"]}),"\n",(0,s.jsxs)(e.h2,{id:"demo3-监听文件变化随时打包",children:["demo3 监听文件变化，随时打包",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#demo3-监听文件变化随时打包",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["我们在开发过程中，需要频繁对源文件进行修改，如果每次都自己手动输一遍打包命令，那真的是要烦死。因此，我们选择使用rollup提供的监听功能，安装",(0,s.jsx)(e.code,{children:"rollup-wacth"}),"模块，再在rollup命令后面加上",(0,s.jsx)(e.code,{children:"-w"}),"参数，就能让rollup监听文件变化，即时打包。"]}),"\n",(0,s.jsx)(e.p,{children:"安装watch包："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-sql",children:"npm i rollup-watch --save-dev\n// or\nyarn add rollup-watch --dev\n"})}),"\n",(0,s.jsx)(e.p,{children:"编写npm scripts："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-json",children:'"dev": "rollup -c -w"\n'})}),"\n",(0,s.jsxs)(e.p,{children:["执行",(0,s.jsx)(e.code,{children:"npm run dev"}),"，看到下面的提示："]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{src:"https://segmentfault.com/img/bVSKTL?w=518&h=142",alt:"rollup 监听文件变化"})}),"\n",(0,s.jsx)(e.p,{children:"好了，这个时候你就可以随便修改你的源文件了，rollup会自动为你打包的。"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"PS："})," 若是你不想监听某些文件，只要在配置文件中加上"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-applescript",children:"watch: {\n    exclude: ['path/to/file/which/you/want/to/ignore']\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"就行了,其中的exclude表示你想要忽略的文件的路径（支持glob模式匹配)"}),"\n",(0,s.jsxs)(e.h2,{id:"demo4-是时候写es6了",children:["demo4 是时候写ES6了",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#demo4-是时候写es6了",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["ES6可以说是现代JS开发100%会用到的技术了，rollup虽然支持了解析",(0,s.jsx)(e.code,{children:"import"}),"和",(0,s.jsx)(e.code,{children:"export"}),"两种语法，但是却不会将其他的ES6代码转化成ES5代码，因此我们在编写ES6代码的时候，需要引入插件来支持ES6代码的解析。"]}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"安装插件和你需要的babel preset："}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-sql",children:"npm i rollup-plugin-babel babel-preset-es2015 --save-dev\n// or\nyarn add rollup-plugin-babel babel-preset-es2015 --dev\n"})}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"创建.babalrc文件："}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-prolog",children:'{\n  "presets": [\n    ["es2015", {\n        "modules": false\n    }]\n  ]\n}\n'})}),"\n",(0,s.jsxs)(e.p,{children:["之所以使用",(0,s.jsx)(e.code,{children:"modules:false"}),"这个参数，是因为rollup默认是通过ES6模块语法来解析文件间的依赖，rollup默认是不支持解析common.js的模块规范的（怎么让rollup支持我会在接下来的demo中讲解），因此需要让babel不转化模块相关的语法，不然rollup在使用过程中会报错。"]}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"编写rollup配置文件："}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"import babel from 'rollup-plugin-babel';\n\nexport default [{\n  entry: 'index.js',\n  format: 'iife',\n  dest: './dist/dist.js',\n  plugins: [\n    babel({\n      exclude: 'node_modules/**'\n    })\n  ]\n}]\n"})}),"\n",(0,s.jsxs)(e.p,{children:["rollup的配置文件的plugins属性可以让你添加在rollup打包过程中所要用到的插件，但是要注意的是，",(0,s.jsx)(e.strong,{children:"插件的添加顺序决定了它们在打包过程中的使用顺序"}),"，因此要注意配置文件的插件使用顺序。"]}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"编写ES6代码"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"在这里我们新建三个文件，两个类Person和Man和一个入口文件index.js"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"export default class Person {\n    constructor (name, gender = '男') {\n        this.name = name\n        this.gender = gender\n    }\n\n    say () {\n        console.log(`我的名字是${this.name}，是一个${this.gender}生`)\n    }\n}\nimport Person from './Person'\n\nexport default class Man extends Person {\n    constructor (name) {\n        super(name, '男')\n    }\n}\nimport Man from './src/Man'\n\nnew Man('KainStar').say()\n"})}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["运行打包命令",(0,s.jsx)(e.code,{children:"npm run build"})]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{src:"https://segmentfault.com/img/bVSKUR?w=753&h=160",alt:"rollup babel打包1"})}),"\n",(0,s.jsxs)(e.p,{children:["可以看到rollup输出了一段提示文字，我们先不去管它，先看看打包出来的文件能不能运行，执行",(0,s.jsx)(e.code,{children:"node dist/dist.js"})]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{src:"https://segmentfault.com/img/bVSKUZ?w=315&h=58",alt:"rollup babel打包2"})}),"\n",(0,s.jsx)(e.p,{children:"可以看到代码运行成功了，那么我们回来继续看之前的提示文字，它的意思是'classCallCheck'这个babel helper函数使用了多次，rollup推荐我们使用external-helpers这个插件或es2015-rollup这个babel-preset来简化打包出来的代码。"}),"\n",(0,s.jsx)(e.p,{children:"我们查看一下打包出来的dist.js文件，发现_classCallCheck这个函数被定义了两次，分别被取名为_classCallCheck和_classCallCheck$1，这样的代码肯定是可以简化的，因此我们引入external-helpers这个插件："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-sql",children:"npm i babel-plugin-external-helpers --save-dev\n// or\nyarn add babel-plugin-external-helpers --dev\n"})}),"\n",(0,s.jsx)(e.p,{children:"修改.babelrc文件为"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-prolog",children:'{\n    "presets": [\n        ["es2015", {\n            "modules": false\n        }]\n    ],\n    "plugins": [\n        "external-helpers"\n    ]\n}\n'})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"或者"}),"在配置文件中使用babel配置"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-css",children:"plugins: [\n    babel({\n        plugins: ['external-helpers']\n    })\n]\n"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"注意！"})," 在rollup-plugin-babel的官方github仓库中有一段配置是这样的："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-yaml",children:"plugins: [\n    babel({\n      plugins: ['external-helpers'],\n      externalHelpers: true\n    })\n]\n"})}),"\n",(0,s.jsxs)(e.p,{children:["这段配置的使用要求是你需要设置全局的",(0,s.jsx)(e.code,{children:"babelHelpers"}),"对象，以此来将打包文件中的babel相关代码删除，所以一般情况下不需要使用",(0,s.jsx)(e.code,{children:"externalHelpers"}),"这个属性。"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"PS："})," 你也可以使用babel-preset-es2015-rollup这个包（搭配babel-core），它集成了babel-preset-es2015，babel-plugin-transform-es2015-modules-commonjs和babel-plugin-external-helpers三个模块，使用起来更加方便，只要将.babelrc文件修改成",(0,s.jsx)(e.code,{children:'{ "presets": ["es2015-rollup"] }'}),"就可以使用了。"]}),"\n",(0,s.jsxs)(e.h2,{id:"demo5-解析cjs打包第三方模块",children:["demo5 解析cjs，打包第三方模块",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#demo5-解析cjs打包第三方模块",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"有时候我们会引入一些其他模块的文件（第三方的或是自己编写的），但是这些第三方的模块为了能够直接使用，往往不是ES6模块而是用commonjs的模块方式编写的，这个时候我们需要将commonjs的模块转化为ES6模块，这样才能让rollup进行正确的解析。"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"解析commonjs"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["解析commonjs需要引入一个rollup插件——",(0,s.jsx)(e.code,{children:"rollup-plugin-commonjs"})]}),"\n",(0,s.jsx)(e.p,{children:"安装插件"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-sql",children:"npm i rollup-plugin-commonjs --save-dev\n// or\nyarn add rollup-plugin-commonjs --dev\n"})}),"\n",(0,s.jsx)(e.p,{children:"在配置文件中配置插件"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"import commonjs from 'rollup-plugin-commonjs'\n\nexport default {\n  entry: 'index_cjs.js',\n  format: 'iife',\n  dest: './js/dist_cjs.js',\n  plugins: [\n    commonjs()\n  ]\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"编写cjs模块的文件"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"exports.logA = function logA() {\n  console.log('function logA called')\n}\n\nexports.logB = function logB() {\n  console.log('function logB called')\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"执行打包，可以看到打包成功，也没有输出任何提示信息"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{src:"https://segmentfault.com/img/bVSKVi?w=525&h=95",alt:"rollup cjs打包"})}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"打包第三方模块"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["在打包第三方模块的过程中，rollup无法直接解析npm模块，因此需要引入插件",(0,s.jsx)(e.code,{children:"rollup-plugin-node-resolve"}),"并配合之前的commonjs插件来解析这些第三方模块"]}),"\n",(0,s.jsx)(e.p,{children:"安装插件和第三方模块"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-crmsh",children:"npm i rollup-plugin-node-resolve lodash --save-dev\n// or\nyarn add rollup-plugin-node-resolve lodash --dev\n"})}),"\n",(0,s.jsx)(e.p,{children:"在配置文件中配置插件"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"import commonjs from 'rollup-plugin-commonjs'\nimport resolve from 'rollup-plugin-node-resolve'\n\nexport default {\n  entry: 'index_module.js',\n  format: 'iife',\n  dest: './js/dist_module.js',\n  plugins: [\n    resolve({\n      jsnext: true,\n      main: true,\n      browser: true\n    }),\n    commonjs()\n  ]\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"jsnext表示将原来的node模块转化成ES6模块，main和browser则决定了要将第三方模块内的哪些代码打包到最终文件中。"}),"\n",(0,s.jsxs)(e.p,{children:["由于",(0,s.jsx)(e.a,{href:"https://link.segmentfault.com/?enc=UZQSxMK%2BU%2FO%2FFJxppk60SQ%3D%3D.L4noVYfBNpszlbPSBYeVT%2FA8kiEhhM%2F0U0I8uMqHnBN4caGqAfoiECGktNWpYmbUTXgupmg3n8uDdZIpUdrHLg%3D%3D",target:"_blank",rel:"noopener noreferrer",children:"commonjs"}),"和",(0,s.jsx)(e.a,{href:"https://link.segmentfault.com/?enc=0nVzyFCAIGBsugL75aXqCw%3D%3D.ibYkbQk2DVWyurKVZBjezOqVx%2F9KjEIRzemGnzEA8NdHRDlu3wEyhFBPNss9JtELoP8vh%2BV6VYeT4FR2LPNZ%2BQ%3D%3D",target:"_blank",rel:"noopener noreferrer",children:"node-resolve"}),"中的配置属性很多，因此不一一解释，希望了解更多的同学可以去官方仓库查看说明。"]}),"\n",(0,s.jsx)(e.p,{children:"编写入口文件"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"import compact from 'lodash/compact'\n\nconst array = [0, 1, false, 2, '', 3]\nconst compctedArray = compact(array)\nconsole.log(compctedArray)\n"})}),"\n",(0,s.jsx)(e.p,{children:"在这里我们只引用了lodash中的compact方法，那么在最终代码里，应该也只会添加compact方法的代码。"}),"\n",(0,s.jsx)(e.p,{children:"执行打包命令，查看打包出来的文件："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"(function () {\n'use strict';\n\n/**\n * Creates an array with all falsey values removed. The values `false`, `null`,\n * `0`, `\"\"`, `undefined`, and `NaN` are falsey.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to compact.\n * @returns {Array} Returns the new array of filtered values.\n * @example\n *\n * _.compact([0, 1, false, 2, '', 3]);\n * // => [1, 2, 3]\n */\nfunction compact(array) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (value) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\nvar compact_1$1 = compact;\n\nconst array = [0, 1, false, 2, '', 3];\nconst compctedArray = compact_1$1(array);\nconsole.log(compctedArray);\n\n}());\n"})}),"\n",(0,s.jsx)(e.p,{children:"确实只添加了compact方法的代码，而没有将lodash全部引入。"}),"\n",(0,s.jsxs)(e.h2,{id:"demo6-不要打包到一个文件为rollup设置外部模块和全局变量",children:["demo6 不要打包到一个文件，为rollup设置外部模块和全局变量",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#demo6-不要打包到一个文件为rollup设置外部模块和全局变量",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["在平时的开发中，我们经常会引入其他的模块，但是在使用的时候，我们又不想把它们打包到一个文件里，想让他们作为单独的模块（或文件）来使用，方便浏览器端进行缓存，这个时候就需要使用配置文件中的",(0,s.jsx)(e.code,{children:"external"}),"属性了"]}),"\n",(0,s.jsxs)(e.p,{children:["我们",(0,s.jsx)(e.strong,{children:"在demo5的基础上"}),"，把jquery安装到第三方模块中"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"npm i jquery --save-dev\n// or\nyarn add jquery --dev\n"})}),"\n",(0,s.jsx)(e.p,{children:"将配置文件改成"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"import commonjs from 'rollup-plugin-commonjs'\nimport resolve from 'rollup-plugin-node-resolve'\n\nexport default {\n  entry: 'index.js',\n  format: 'iife',\n  dest: './js/dist.js',\n  external: ['jquery'],\n  plugins: [\n    resolve({\n      jsnext: true,\n      main: true,\n      browser: true\n    }),\n    commonjs()\n  ]\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"external用来表示一个模块是否要被当成外部模块使用，属性的值可以是一个字符串数组或一个方法，当传入的是一个字符串数组时，所有数组内的模块名称都会被当成是外部模块，不会被打包到最终文件中"}),"\n",(0,s.jsx)(e.p,{children:"当传入的是一个方法时，方法有一个参数id，表示解析的模块的名称，我们可以自定义解析方式，若是要当做外部模块不打包到最终文件中，则返回true，若要一起打包到最终文件中，则返回false"}),"\n",(0,s.jsx)(e.p,{children:"在这里我们把jquery当成一个外部模块，执行打包命令："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{src:"https://segmentfault.com/img/bVSKVx?w=723&h=136",alt:"rollup 添加外部模块"})}),"\n",(0,s.jsx)(e.p,{children:"检查打包出来的文件，我们发现lodash的compact方法依旧被打包进了最终文件中，但是jquery却没有被打包进去，而是以$的全局变量形式被传入到了立即执行函数中。"}),"\n",(0,s.jsx)(e.p,{children:"在这里rollup又给我们输出了一条提示信息，意思是我们没有在配置文件中给外部模块jquery设置全局变量名称，因此rollup自己猜测了一个名称$，当成是依赖的全局变量名。"}),"\n",(0,s.jsxs)(e.p,{children:["如果直接使用全局的$的话，可能会因为变量$被其他引入的代码覆盖而报错，因此我们要将$替换为不容易冲突的jQuery变量，在配置文件中添加",(0,s.jsx)(e.code,{children:"globals"}),"属性："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-css",children:"globals: {\n    jquery: 'jQuery'\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"globals的值是一个对象，key表示使用的模块名称（npm模块名），value表示在打包文件中引用的全局变量名，在这里我们就是把jquery模块的全局变量名设置为jQuery，重新打包"}),"\n",(0,s.jsxs)(e.p,{children:["在重新打包出来的文件中，我们发现最后传入的参数已经由",(0,s.jsx)(e.code,{children:"$"}),"变为了",(0,s.jsx)(e.code,{children:"jQuery"}),"，而且rollup也没有输出提示信息。"]}),"\n",(0,s.jsxs)(e.h2,{id:"demo7-打包node内置模块",children:["demo7 打包node内置模块",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#demo7-打包node内置模块",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["有时候我们想要在浏览器端使用node自带的一些内置模块，一般情况下会使用",(0,s.jsx)(e.code,{children:"browserify"}),"这个工具来打包，但是browserify打包出来的文件实在太大，因此我们用rollup选择性地导入我们需要的node内置模块"]}),"\n",(0,s.jsx)(e.p,{children:"安装插件"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-crmsh",children:"npm i rollup-plugin-node-builtins --save-dev\n// or\nyarn add rollup-plugin-node-builtins --dev\n"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"PS："})," node-builtins对不同的node内置模块支持不同，有些模块可能需要使用其他的插件（例如",(0,s.jsx)(e.a,{href:"https://link.segmentfault.com/?enc=JHkG6C6WK8UjmeEIFdBRfg%3D%3D.xVFKncO4qNsJh%2B7IP3Q9vNpxAtq3beX8YJKCl0EucJLr6FxzEzUpN%2FtyIYQMjVTg76tiv4kH%2Fz0nFQF%2FRhj4nA%3D%3D",target:"_blank",rel:"noopener noreferrer",children:"rollup-plugin-node-globals"}),"）才能正常打包，具体的支持情况可以查看node-builtins的",(0,s.jsx)(e.a,{href:"https://link.segmentfault.com/?enc=oGqWgwmXAl8zuDCmdohsXg%3D%3D.4ZTyuPmIe7HAG9ze1h98Bb04PAA6gmJAn87Iop2phhq4SLx1fO8R8JlAG9eluzNmq1Zoo3xSgZlkZaCn8fuSlQ%3D%3D",target:"_blank",rel:"noopener noreferrer",children:"官方仓库"}),"。"]}),"\n",(0,s.jsx)(e.p,{children:"编写配置文件"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"import builtins from 'rollup-plugin-node-builtins'\n\nexport default {\n  entry: 'index.js',\n  format: 'iife',\n  dest: './dist/dist.js',\n  plugins: [\n    builtins()\n  ]\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"编写入口文件"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"import { join } from 'path'\n\nconst path_base = 'E://node'\nconst path_joined = join(path_basem, 'bin')\nconsole.log(path_joined)\n"})}),"\n",(0,s.jsx)(e.p,{children:"在这里我们使用node内置的path模块，运行打包命令，发现dist.js文件中引入了额外的100多行代码，这100多行代码就实现了path模块的join方法供我们使用。"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"PS："})," 我建议，如果不是必要的情况，最好能够使用其他人编写的第三方实现库或自己造轮子实现，而不是使用node内置的模块，因为在引用某些模块时，node-builtins可能会引入过多的代码，这样会大大增加最后打包的文件的大小，使用他人的第三方库或自己的实现可控性更高"]}),"\n",(0,s.jsxs)(e.h2,{id:"demo8-配合cdn来使用rollup",children:["demo8 配合CDN来使用rollup",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#demo8-配合cdn来使用rollup",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["有时候我们可能会使用CDN服务器上的js文件，但是又不想在本地安装一个相同的模块（也有可能没有对应的模块），可能在版本升级的时候会产生一些问题，这个时候我们就需要使用rollup的",(0,s.jsx)(e.code,{children:"paths"}),"属性了，这个属性可以帮助你把依赖的代码文件地址注入到打包之后的文件里。"]}),"\n",(0,s.jsx)(e.p,{children:"编写配置文件"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-dart",children:"export default {\n  entry: 'index.js',\n  format: 'amd',\n  dest: './dist/dist.js',\n  external: ['jquery'],\n  paths: {\n    jquery: 'https://cdn.bootcss.com/jquery/3.2.1/jquery.js'\n  }\n}\n"})}),"\n",(0,s.jsxs)(e.p,{children:["在这里我们要使用cdn上的jquery文件，paths属性的值可以是一个对象或用法与",(0,s.jsx)(e.code,{children:"external"}),"属性方法相似的方法（只是返回的不是boolean值而是文件的地址）。若使用对象来表示，则key值为需要引入的模块名称，value值为对应的文件地址"]}),"\n",(0,s.jsx)(e.p,{children:"编写源文件"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"import $ from 'jquery'\n\n$('#p').html('rollup 使用paths属性配合CDN')\n"})}),"\n",(0,s.jsx)(e.p,{children:"执行打包命令，最后打包出来的文件内容是："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"define(['https://cdn.bootcss.com/jquery/3.2.1/jquery.js'], function ($) { 'use strict';\n\n$ = $ && $.hasOwnProperty('default') ? $['default'] : $;\n\n$('#p').html('rollup 使用paths属性配合CDN');\n\n});\n"})}),"\n",(0,s.jsx)(e.p,{children:"可以看到rollup已经把我们需要的CDN地址作为依赖加入到了打包文件中。"}),"\n",(0,s.jsxs)(e.h2,{id:"demo9-最小化你的代码",children:["demo9 最小化你的代码",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#demo9-最小化你的代码",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"代码发布时，我们经常会把自己的代码压缩到最小，以减少网络请求中的传输文件大小。"}),"\n",(0,s.jsxs)(e.p,{children:["rollup的插件",(0,s.jsx)(e.code,{children:"rollup-plugin-uglify"}),"就是来帮助你压缩代码的，我们接下来就用这个插件来压缩一下我们的代码"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-sql",children:"npm i rollup-plugin-uglify --save-dev\n// or\nyarn add rollup-plugin-uglify --dev\n"})}),"\n",(0,s.jsx)(e.p,{children:"编写配置文件"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"import uglify from 'rollup-plugin-uglify'\n\nexport default {\n  entry: 'index.js',\n  format: 'iife',\n  dest: './dist/dist.js',\n  plugins: [\n    uglify()\n  ]\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"运行打包命令，查看dist.js文件，发现代码已经被压缩了"}),"\n",(0,s.jsx)(e.p,{children:"但是，压缩过的代码在debug时会带来很大的不便，因此我们需要在压缩代码的同时生成一个sourceMap文件"}),"\n",(0,s.jsx)(e.p,{children:"幸运的是，rollup自己就支持sourceMap文件的生成，不需要我们去引入其他插件，只需要在配置文件中加上："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-yaml",children:"sourceMap: true\n"})}),"\n",(0,s.jsx)(e.p,{children:"就可以了。"}),"\n",(0,s.jsxs)(e.p,{children:["重新打包，我们发现不仅生成了dist.js.map文件，而且dist文件最后加上了一行",(0,s.jsx)(e.code,{children:"//# sourceMappingURL=dist.js.map"}),"，并且在浏览器中可以正确加载源文件"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{src:"https://segmentfault.com/img/bVSKVA?w=583&h=244",alt:"rollup sourceMap"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"PS："})," 若是将sourceMap属性的值设置为",(0,s.jsx)(e.code,{children:"inline"}),"，则会将sourceMap的内容添加到打包文件的最后。"]}),"\n",(0,s.jsxs)(e.h2,{id:"demo10-为你的代码添eslint检查",children:["demo10 为你的代码添eslint检查",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#demo10-为你的代码添eslint检查",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["在大型工程的团队开发中，我们需要保证团队代码风格的一致性，因此需要引入eslint，而且在打包时需要检测源文件是否符合eslint设置的规范，若是不符合则抛出异常并停止打包。在这里我们使用rollup的eslint插件",(0,s.jsx)(e.code,{children:"rollup-plugin-eslint"}),":"]}),"\n",(0,s.jsx)(e.p,{children:"安装插件"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-sql",children:"npm i eslint rollup-plugin-eslint --save-dev\n// or\nyarn add eslint rollup-plugin-eslint --dev\n"})}),"\n",(0,s.jsxs)(e.p,{children:["编写eslint配置文件",(0,s.jsx)(e.code,{children:".eslintrc"})]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-json",children:'{\n  "env": {\n    "browser": true,\n    "commonjs": true,\n    "es6": true,\n    "node": true\n  },\n  "parserOptions": {\n    "ecmaFeatures": {\n      "jsx": false\n    },\n    "sourceType": "module"\n  },\n  "rules": {\n    "semi": ["error","never"]\n  }\n}\n'})}),"\n",(0,s.jsx)(e.p,{children:"在这里我们强制要求不使用分号，然后在源文件中加上一个分号"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"foo(element);\n"})}),"\n",(0,s.jsx)(e.p,{children:"编写rollup配置文件"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"import eslint from 'rollup-plugin-eslint';\n\nexport default {\n  entry: './src/index.js',\n  format: 'iife',\n  dest: './dist/dist.js',\n  plugins: [\n    eslint({\n      throwOnError: true,\n      throwOnWarning: true,\n      include: ['src/**'],\n      exclude: ['node_modules/**']\n    })\n  ]\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"eslint插件有两个属性需要说明：throwOnError和throwOnWarning设置为true时，如果在eslint的检查过程中发现了error或warning，就会抛出异常，阻止打包继续执行（如果设置为false，就只会输出eslint检测结果，而不会停止打包）"}),"\n",(0,s.jsx)(e.p,{children:"执行打包命令，发现eslint在输出了检查结果之后抛出了异常，而且dist.js文件也没有生成"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{src:"https://segmentfault.com/img/bVSKV2?w=753&h=443",alt:"rollup eslint抛出异常"})}),"\n",(0,s.jsx)(e.p,{children:"删除index.js文件中的分号，重新打包，发现打包成功"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"进阶："})," 在平时的开发过程中，我们经常会使用IDE或编辑器的eslint插件，以便提早发现问题，但是有时候这些插件会去检查打包完的文件，导致你的提示框里一直会有eslint检测到错误的消息"]}),"\n",(0,s.jsxs)(e.p,{children:["我们现在有两种解决方案，一是创建一个",(0,s.jsx)(e.code,{children:".eslintignore"}),"文件，将打包文件加进去，让eslint忽略这个文件"]}),"\n",(0,s.jsxs)(e.p,{children:["还有一种就是让rollup在打包文件的开始和最后自动生成注释来阻止eslint检测代码，使用这种方法时，需要使用rollup配置文件的两个属性：banner和footer，这两个属性会在",(0,s.jsx)(e.strong,{children:"生成文件"}),"的开头和结尾插入一段你自定义的字符串。我们利用这个属性，在打包文件的开头添加",(0,s.jsx)(e.code,{children:"/*eslint-disable */"}),"注释，让eslint不检测这个文件。"]}),"\n",(0,s.jsx)(e.p,{children:"添加banner和footer属性"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-vbnet",children:"banner: '/*eslint-disable */'\n"})}),"\n",(0,s.jsx)(e.p,{children:"重新打包，我们发现打包文件的开头被插入了这段注释字符串，而且eslint插件也不报dist.js文件的错了"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"/*eslint-disable */\n(function () {\n'use strict';\n\n// 具体代码\n\n}());\n"})}),"\n",(0,s.jsxs)(e.h2,{id:"demo11-控制开发环境和生产环境下的配置",children:["demo11 控制开发环境和生产环境下的配置",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#demo11-控制开发环境和生产环境下的配置",children:"#"})]}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"配置文件的开发/生产环境配置"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["有时候我们会需要区分开发环境和生产环境，针对不同的打包要求输出不同的打包配置，但是我们又不想写",(0,s.jsx)(e.code,{children:"rollup.config.dev.js"}),"和",(0,s.jsx)(e.code,{children:"rollup.config.prod.js"}),"两个文件，因为可能两者之间的区别只是一个uglify插件。"]}),"\n",(0,s.jsxs)(e.p,{children:["因此，我们就需要用变量来控制配置文件的输出内容，rollup命令行给我们提供了一个设置环境变量的参数",(0,s.jsx)(e.code,{children:"--environment"}),"，在这个参数后面加上你需要设置的环境变量，不同变量间用逗号分隔，用冒号后面的字符串表示对应变量的值（若不加冒号，则默认将值设为字符串true）："]}),"\n",(0,s.jsx)(e.p,{children:"在package.json文件中编写对应的npm scripts命令："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-json",children:'"dev": "rollup -c --environment NODE_ENV:development",\n"build": "rollup -c --environment NODE_ENV:production"\n'})}),"\n",(0,s.jsx)(e.p,{children:"最后修改我们的rollup配置文件"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"import uglify from 'rollup-plugin-uglify'\n\nlet isProd = process.env.NODE_ENV === 'production'\n\n// 通用的插件\nconst basePlugins = []\n// 开发环境需要使用的插件\nconst devPlugins = []\n// 生产环境需要使用的插件\nconst prodPlugins = [uglify()]\n\nlet plugins = [...basePlugins].concat(isProd ? prodPlugins:devPlugins)\nlet destFilePath = isProd ? './dist/dist.min.js': './dist/dist.js'\n\nexport default {\n  entry: 'index.js',\n  format: 'iife',\n  dest: destFilePath,\n  sourceMap: isProd,\n  plugins: plugins\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"我们分别运行两个npm scripts命令，查看打包的结果："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{src:"https://segmentfault.com/img/bVSKWa?w=245&h=109",alt:"rollup 开发环境和生产环境打包结果"})}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"源文件开发/生产环境信息注入"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"上面是在配置文件里通过变量来改变输出的配置类型，但是我们有时候需要将生产环境信息添加到源文件里，这个时候就需要使用rollup的配置属性intro和outro了"}),"\n",(0,s.jsx)(e.p,{children:"如果说banner和footer是在文件开始和结尾添加字符串，那么intro和outro就是在被打包的代码开头和结尾添加字符串了，以iife模式来举例，如果我们配置了这四个属性，那么输出结果就会是："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"// banner字符串\n(function () {\n'use strict';\n// intro字符串\n\n// 被打包的代码\n\n// outro字符串\n}());\n// footer字符串\n"})}),"\n",(0,s.jsx)(e.p,{children:"这样的形式"}),"\n",(0,s.jsx)(e.p,{children:"下面我们实际使用一下，在index.js文件里加上一段需要依赖的代码"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"if (DEVELOPMENT) {\n    console.log('处于开发环境')\n} else {\n    console.log('处于生产环境')\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"然后在我们的rollup配置文件里添加："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-erlang-repl",children:"intro: 'var DEVELOPMENT = ' + !isProd,\n"})}),"\n",(0,s.jsx)(e.p,{children:"这样，当我们最后生成的代码时，就会输出开发环境或生产环境的提示："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{src:"https://segmentfault.com/img/bVSKWm?w=497&h=213",alt:"rollup 开发环境和生产环境信息打包结果"})}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"源文件开发/生产环境信息替换"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["有时候我们会把开发/生产环境的信息直接写在源文件里面，这个时候用intro来注入代码的方式就不适合了。这个时候我们就需要使用",(0,s.jsx)(e.code,{children:"rollup-plugin-replace"}),"插件来对源代码的变量值进行替换："]}),"\n",(0,s.jsx)(e.p,{children:"安装插件"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"npm i rollup-plugin-replace --save-dev\n// or\nyarn add rollup-plugin-replace --dev\n"})}),"\n",(0,s.jsx)(e.p,{children:"编写配置文件"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"const basePlugins = [replace({\n  DEVELOPMENT: !isProd\n})]\n\n// 将intro属性注释掉\n// intro: 'var DEVELOPMENT = ' + !isProd,\n"})}),"\n",(0,s.jsxs)(e.p,{children:["这里我们使用replace插件，以key-value对象的形式，将",(0,s.jsx)(e.code,{children:"DEVELOPMENT"}),"的值替换为",(0,s.jsx)(e.code,{children:"!isProd"}),"的值"]}),"\n",(0,s.jsx)(e.p,{children:"执行打包命令，并检查打包结果："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{src:"https://segmentfault.com/img/bVSKWr?w=591&h=448",alt:"rollup 开发环境和生产环境信息打包结果"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"进阶："})," replace除了直接使用key-value的形式替换对应key同名变量的方法之外，还可以通过配置",(0,s.jsx)(e.code,{children:"delimiters"}),"参数来实现模板功能："]}),"\n",(0,s.jsx)(e.p,{children:"配置replace插件参数"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-apache",children:"VERSION: '1.0.0',\ndelimiters: ['{{', '}}']\n"})}),"\n",(0,s.jsxs)(e.p,{children:["通过这个配置，在打包过程中，",(0,s.jsx)(e.code,{children:"{{VERSION}}"}),"会被替换成",(0,s.jsx)(e.code,{children:"1.0.0"})]}),"\n",(0,s.jsx)(e.p,{children:"在index.js文件内添加相关代码"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"var version = '{{VERSION}}'\nconsole.log('版本 v' + version)\n"})}),"\n",(0,s.jsx)(e.p,{children:"打包的结果"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"var version = '1.0.0';\nconsole.log('版本 v' + version);\n"})}),"\n",(0,s.jsxs)(e.h2,{id:"demo12-使用rollup的api",children:["demo12 使用rollup的API",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#demo12-使用rollup的api",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"有时候我们会需要在打包的前后执行一些其他的代码，但是又不想引入其他构建工具（例如gulp），那么就可以使用rollup提供的node API来编写你自己的打包流程。"}),"\n",(0,s.jsxs)(e.p,{children:["rollup模块只提供了一个rollup函数，这个函数的参数和我们编写配置文件时导出的参数不同，减少了很多配置属性，留下来的主要是一些输入相关的配置。（具体的配置属性可以查看rollup wiki的",(0,s.jsx)(e.a,{href:"https://link.segmentfault.com/?enc=V62VLCuPYH99jChH0wPlzw%3D%3D.tKnVVDRNpEvgdkHZ2Ng1s4Zd4dvkrj%2F8vPnJ3plVvEDIINNs2woddYjrtr0ipjSvd89U2dYs2VMfVSr4Ze6YrA%3D%3D",target:"_blank",rel:"noopener noreferrer",children:"javascript API"}),"一节）"]}),"\n",(0,s.jsxs)(e.p,{children:["执行这个函数返回的是一个Promise，并且在then方法中提供一个bundle对象作为参数，这个对象保存了rollup对源文件编译一次之后的结果，而且提供了",(0,s.jsx)(e.code,{children:"generate"}),"和",(0,s.jsx)(e.code,{children:"write"}),"两个方法"]}),"\n",(0,s.jsx)(e.p,{children:"write方法提供了编译并将打包结果输出到文件里的功能，返回的是一个没有参数的Promise，可以让你自定义接下来执行的代码"}),"\n",(0,s.jsx)(e.p,{children:"generate方法是只提供了编译的功能，返回一个Promise，这个Promise有一个对象参数，包含了code（编译完之后的代码）和map（分析出来的sourceMap对象）两个属性，一般用在插件开发中"}),"\n",(0,s.jsxs)(e.p,{children:["write和gengerate方法都接受有编译相关属性的对象作为传入的编译参数，而write方法还额外接受",(0,s.jsx)(e.code,{children:"dset"}),"属性作为导出文件的名称。"]}),"\n",(0,s.jsx)(e.p,{children:"在这里我们只使用write方法来编写一个为所有模块类型打包，并输出打包完毕提示的文件，至于generate的使用方法我们会放在编写插件一节中介绍。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"const rollup = require('rollup').rollup\n\nrollup({\n  entry: 'index.js'\n}).then(bundle => {\n\n  // 保存所有Promise的列表\n  let writePromiseList = []\n  // 声明所有需要打包的模块类型\n  let moduleTypesList = ['es','cjs','amd','umd','iife']\n\n  moduleTypesList.forEach(function(moduleType) {\n    writePromiseList.push(bundle.write({\n      dest: './dist/dist.' + moduleType + '.js',\n      format: moduleType,\n      sourceMap: true\n    }))\n  })\n\n  return Promise.all(writePromiseList)\n\n}).then(() => {\n  console.log('全部模块格式打包完毕')\n  // 其他代码\n})\n"})}),"\n",(0,s.jsx)(e.p,{children:"将package.json文件内的npm scripts命令修改为"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-json",children:'"build": "node rollup.js"\n'})}),"\n",(0,s.jsx)(e.p,{children:"执行打包命令，查看打包结果"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{src:"https://segmentfault.com/img/bVSKWD?w=557&h=123",alt:"rollup 自定义打包结果1"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{src:"https://segmentfault.com/img/bVSKWN?w=268&h=262",alt:"rollup 自定义打包结果2"})}),"\n",(0,s.jsx)(e.p,{children:"在这里我们可以看到，一个bundle可以被重复使用多次，因此我们可以用Promise.all方法来等待所有模块打包完成后再输出打包完毕的提示。"}),"\n",(0,s.jsxs)(e.h2,{id:"demo13-除了打包js我们还能",children:["demo13 除了打包JS，我们还能……",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#demo13-除了打包js我们还能",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"一个web项目内肯定不会只有js文件，还有css、html（也可能是模板文件）和其他类型的文件，那么我们在打包的时候能不能把这些文件一起打包呢？"}),"\n",(0,s.jsx)(e.p,{children:"我们需要区分一下，在这里的打包有两种意思，一种是让这些文件可以像JS文件一样，在源代码中被import并使用；还有一种是通过在源文件中import这些文件，最后将它们合并到一起并导出到一个最终文件内。"}),"\n",(0,s.jsx)(e.p,{children:"不同的rollup插件有不同的效果，在使用的时候一定要查看插件的相关说明"}),"\n",(0,s.jsx)(e.p,{children:"安装插件"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-sql",children:"npm i rollup-plugin-scss --save-dev\n// or\nyarn add rollup-plugin-scss --dev\n"})}),"\n",(0,s.jsx)(e.p,{children:"编写配置文件"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"import scss from 'rollup-plugin-scss'\n\nexport default {\n  entry: './src/js/index.js',\n  format: 'iife',\n  dest: './dist/js/dist.js',\n  sourceMap: true,\n  plugins: [\n    scss({\n      output: './dist/css/style.css'\n    })\n  ]\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"在这里我们尝试编译和打包scss文件，将其合并成一个style.css文件，并输出到dist/css目录下"}),"\n",(0,s.jsx)(e.p,{children:"编写scss文件"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-css",children:"$blue: #69c4eb;\n\n.bg-blue {\n  background-color: $blue\n}\n$white: #fff;\n\n.text-white {\n  color: $white;\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"然后在源文件中引用这两个scss文件"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"import '../scss/text.scss'\nimport '../scss/bg.scss'\n\nvar html = `\n<div class=\"bg-blue\">\n<p class=\"text-white\">测试文字</p>\n</div>\n`\n\ndocument.body.innerHTML = html\n"})}),"\n",(0,s.jsx)(e.p,{children:"执行打包命令，查看效果"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{src:"https://segmentfault.com/img/bVSKWY?w=259&h=125",alt:"rollup 打包scss效果"})}),"\n",(0,s.jsxs)(e.h2,{id:"extra-编写你自己的rollup插件",children:["extra 编写你自己的rollup插件",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#extra-编写你自己的rollup插件",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["有时候我们可能需要自己编写rollup插件来实现需求，rollup官方在wiki上提供了关于",(0,s.jsx)(e.a,{href:"https://link.segmentfault.com/?enc=TIpDOKteuyVfjiywl8r61g%3D%3D.ecIrdpJ6txGEQImXiVRhSELRyqr234nPtyELaNokmNha9NWp8Bu5P7H6vh2otj2LsmEnbzDI1410YUj3deVV%2Fg%3D%3D",target:"_blank",rel:"noopener noreferrer",children:"编写插件的一些介绍"}),"，下面我们就根据这些介绍来写一个自己的rollup插件。"]}),"\n",(0,s.jsxs)(e.p,{children:["我们在这里仿照scss插件编写一个stylus的rollup插件，让使用者可以import stylus文件，并编译打包导出到指定的目录下（为了节省代码量，只写了输出到指定路径的功能代码，其他的功能可以参考",(0,s.jsx)(e.a,{href:"https://link.segmentfault.com/?enc=ABY2zQB2R%2F5ISnpF6LLMBg%3D%3D.RY%2BVIHWtp4g7OLkOTo9nOuEh%2Bo%2BETjAFt%2BBY2NcUktR7IXm4rFFcZHK78A%2BSfQJu",target:"_blank",rel:"noopener noreferrer",children:"scss插件"}),"的具体代码）。"]}),"\n",(0,s.jsx)(e.p,{children:"首先创建项目，在package.json文件中，除了一般信息之外，还要加上"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-json",children:'"main": "index.cjs.js",\n"module": "index.es.js",\n"jsnext:main": "index.es.js"\n'})}),"\n",(0,s.jsx)(e.p,{children:"这些信息用来区分使用不同模块规范时使用的文件"}),"\n",(0,s.jsx)(e.p,{children:"安装我们需要用到的模块"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-sql",children:"npm i rollup rollup-plugin-babel babel-preset-es2015-rollup babel-core --save-dev\nnpm i rollup-pluginutils stylus --save\n// or\nyarn add rollup rollup-plugin-babel babel-preset-es2015-rollup babel-core --dev\nyarn add rollup-pluginutils stylus\n"})}),"\n",(0,s.jsxs)(e.p,{children:["rollup-pluginutils和stylus是我们运行时需要的两个模块，stylus用来解析stylus文件，",(0,s.jsx)(e.a,{href:"https://link.segmentfault.com/?enc=GCW6EwtADuLK27E92QGCrg%3D%3D.n9hr9uvU%2F05wJ64nfC26AKfKFnjYm%2Beh0bpgVG9pqP54cFP8DrmN4BouLQSaIYVc",target:"_blank",rel:"noopener noreferrer",children:"pluginutils"}),"则提供给了我们一些编写插件常用的函数"]}),"\n",(0,s.jsx)(e.p,{children:"编写rollup配置文件"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"import babel from 'rollup-plugin-babel'\n\nexport default {\n    entry: './index.es.js',\n    dest: './index.cjs.js',\n    format: 'cjs',\n    plugins: [\n        babel()\n    ]\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"rollup插件需要一个含有指定属性的对象作为插件内容，rollup官方建议我们在编写插件的时候，export一个返回值为插件对象的函数，这样可以方便使用者指定插件的参数。"}),"\n",(0,s.jsx)(e.p,{children:"rollup会将解析的部分结果作为参数调用插件返回的对象中的一些函数属性，这些函数会在合适的时候被rollup调用（相当于rollup在执行各个操作时的钩子函数），下面我们介绍一些常用的属性："}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"name：插件的名称，提供给rollup进行相关信息的输出"}),"\n",(0,s.jsx)(e.li,{children:"load：不指定这个属性时，解析模块会默认去读取对应路径文件的内容；而当该值为函数（id => code）时，可以将函数最后的返回值作为文件的内容提供给rollup（可以用来生成自定义格式的代码）"}),"\n",(0,s.jsx)(e.li,{children:"resolveId：一个（ (importee, importer) => id）形式的函数，用来解析ES6的import语句，最后需要返回一个模块的id"}),"\n",(0,s.jsxs)(e.li,{children:["transform：最常使用的属性，是一个函数，当rollup解析一个import时，会获取到对应路径文件的内容，并将内容和模块的名称作为参数提供给我们；这个函数执行完毕之后，需要返回一个作为代码的字符串或是类似",(0,s.jsx)(e.code,{children:"{ code, map }"}),"结构的对象，用来表示解析完之后该模块的实际内容，map指的是sourceMap，而如果我们没有要导出的sourceMap，就可以将返回的map值设为",(0,s.jsx)(e.code,{children:"{mappings: ''}"})]}),"\n",(0,s.jsx)(e.li,{children:"ongenerate：当我们或rollup调用generate方法时，会被调用的一个钩子函数，接受generate的option作为参数"}),"\n",(0,s.jsx)(e.li,{children:"onwrite：和ongenerate一样，调用write方法时，会被调用的一个钩子函数，接受write的option作为参数"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"一般情况下，我们通过transform函数来获取文件的id和内容，并对内容做一些处理，若需要输出文件则使用ongenerate或onwrite在rollup打包的最后阶段来做相应的输出。"}),"\n",(0,s.jsx)(e.p,{children:"load和resolveId在一般情况下不会使用，除非你有特殊的需求（例如对路径、模块id进行修改等)"}),"\n",(0,s.jsx)(e.p,{children:"根据上面这些内容，我们编写具体的插件内容"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"import { createFilter } from 'rollup-pluginutils'\nimport fs from 'fs'\nimport path from 'path'\nimport stylus from 'stylus'\n\n// 递归创建文件夹\nfunction mkdirs(dir) {\n  return new Promise((resolve, reject) => {\n    fs.exists(dir, (exist) => {\n      if (exist) {\n        resolve()\n      } else {\n        mkdirs(path.dirname(dir)).then(() => {\n          fs.mkdir(dir, (err) => {\n            if (err) {\n              reject()\n            } else {\n              resolve()\n            }\n          })\n        })\n      }\n    })\n  })\n}\n\n// 导出一个function\nexport default function stylusPlugin(options = {}) {\n  // 创建一个文件过滤器，过滤以css，styl结尾的文件\n  const stylusFilter = createFilter(options.include || ['**/*.css', '**/*.styl'], options.exclude)\n\n  // dest用来保存指定的输出路径\n  let dest = options.output,\n      // styleNodes用来暂存不同文件的css代码\n      styleNodes = {}\n\n  // 编译stylus文件\n  function complier(str, stylusOpt) {\n    return new Promise((resolve, reject) => {\n      stylus.render(str, stylusOpt, (err, css) => {\n        if (err) {\n          reject(err)\n        } else {\n          resolve(css)\n        }\n      })\n    })\n  }\n\n  return {\n    // 插件名称\n    name: 'rollup-plugin-stylus',\n\n    // 解析import时调用，获取文件名称和具体代码，将它们保存起来\n    transform (code, id) {\n      if (!stylusFilter(id)) {\n        return\n      }\n\n      styleNodes[id] = code\n      return ''\n    },\n    // generate时调用，用stylus解析代码，并输出到指定目录中\n    async ongenerate (genOpt) {\n      let css = ''\n      for (let id in styleNodes) {\n        // 合并所有css代码\n        css += styleNodes[id] || ''\n      }\n\n      // 编译stylus代码\n      if (css.length) {\n        try {\n          css = await complier(css, Object.assign({}, options.stylusOpt))\n        } catch (error) {\n          console.log(error)\n        }\n      }\n\n      // 没有指定输出文件路径时，设置一个默认文件\n      if (typeof dest !== 'string') {\n        if (!css.length) {\n          return\n        }\n\n        dest = genOpt.dest || 'bundle.js'\n        if (dest.endsWith('.js')) {\n          dest = dest.slice(0, -3)\n        }\n        dest = dest + '.css'\n      }\n\n      // 创建目录，并将css写入到结果文件内\n      await mkdirs(path.dirname(dest))\n      return new Promise((resolve, reject) => {\n        fs.writeFile(dest, css, (err) => {\n          if (err) {\n            reject(err)\n          } else {\n            resolve()\n          }\n        })\n      })\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"这样，一个解析并打包stylus文件的rollup插件就写好了，你可以在你的工程中引用这个文件，也可以将其作为一个模块发布，以便于分享给其他人使用。"}),"\n",(0,s.jsxs)(e.h2,{id:"总结-and-一个完整的rollup项目的模板",children:["总结 and 一个完整的rollup项目的模板",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#总结-and-一个完整的rollup项目的模板",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"rollup在打包JS上是一个十分快捷方便的工具，但和webpack相比，他的生态圈还是不够强大，对于大型web工程的适应度相对不足"}),"\n",(0,s.jsx)(e.p,{children:"rollup的优点在于方便的配置，天然的ES6模块支持让我们可以直接使用import和export语法，在打包JS上，不实现自己的模块机制，而是使用目前常见的模块规范有助于其他工具（例如requirejs）来引用打包文件；tree-shaking的特性也有助于减少代码量，因此我认为rollup比起构建应用工程项目，更适合用来构建一个JS库或node模块"}),"\n",(0,s.jsxs)(e.p,{children:["我将上面介绍的插件集合到一起，添加了测试的支持，制作了一个较为完整的rollup工程模板。放在",(0,s.jsx)(e.code,{children:"rollup-project-template"}),"目录下，需要的同学可以自取（你也可以增加或删除任意你需要的模块，来组建属于你自己的rollup项目模板）"]}),"\n",(0,s.jsxs)(e.h2,{id:"参考资料",children:["参考资料",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#参考资料",children:"#"})]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"https://link.segmentfault.com/?enc=cAiaNmyJdFXZidH%2Fzp2XDA%3D%3D.MgNlh9yKsVyk7aHs0NPQ%2F1e7hKBqhBO1Vft70gIb%2B2IzmauAb5f%2F0B8SmtnkrgN%2F",target:"_blank",rel:"noopener noreferrer",children:"rollup官方wiki"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"https://link.segmentfault.com/?enc=n%2Bw7uKb9X0C90V4bYMtVcg%3D%3D.ZhY69cQ%2FH9p31tpOZgtudVB1WAgC6j%2F5arV0Rmk9T31JiTHUuOw9c9a0t5CBGcYC",target:"_blank",rel:"noopener noreferrer",children:"rollup插件合集"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"https://link.segmentfault.com/?enc=pM6LmXFLTblbDodQ2OABIQ%3D%3D.o0QcXUrAocze7kxYf0Y1sdewW4ITe2GmPL6i33UzVCK78kEgH1lbDq8mRZHbSKnt",target:"_blank",rel:"noopener noreferrer",children:"如何通过 Rollup.js 打包 JavaScript —— 知乎专栏"})}),"\n"]})]})}function i(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,r.ah)(),n.components);return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(d,{...n})}):d(n)}let o=i;i.__RSPRESS_PAGE_META={},i.__RSPRESS_PAGE_META["rollup%2F28-rollup%E5%AE%8C%E5%85%A8%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"rollup.js简介",id:"rollupjs简介",depth:2},{text:"rollup.js实例",id:"rollupjs实例",depth:2},{text:"demo0 开始使用rollup",id:"demo0-开始使用rollup",depth:3},{text:"demo1 使用rollup进行模块化打包",id:"demo1-使用rollup进行模块化打包",depth:2},{text:"demo2 使用配置文件来进行rollup打包",id:"demo2-使用配置文件来进行rollup打包",depth:2},{text:"demo3 监听文件变化，随时打包",id:"demo3-监听文件变化随时打包",depth:2},{text:"demo4 是时候写ES6了",id:"demo4-是时候写es6了",depth:2},{text:"demo5 解析cjs，打包第三方模块",id:"demo5-解析cjs打包第三方模块",depth:2},{text:"demo6 不要打包到一个文件，为rollup设置外部模块和全局变量",id:"demo6-不要打包到一个文件为rollup设置外部模块和全局变量",depth:2},{text:"demo7 打包node内置模块",id:"demo7-打包node内置模块",depth:2},{text:"demo8 配合CDN来使用rollup",id:"demo8-配合cdn来使用rollup",depth:2},{text:"demo9 最小化你的代码",id:"demo9-最小化你的代码",depth:2},{text:"demo10 为你的代码添eslint检查",id:"demo10-为你的代码添eslint检查",depth:2},{text:"demo11 控制开发环境和生产环境下的配置",id:"demo11-控制开发环境和生产环境下的配置",depth:2},{text:"demo12 使用rollup的API",id:"demo12-使用rollup的api",depth:2},{text:"demo13 除了打包JS，我们还能……",id:"demo13-除了打包js我们还能",depth:2},{text:"extra 编写你自己的rollup插件",id:"extra-编写你自己的rollup插件",depth:2},{text:"总结 and 一个完整的rollup项目的模板",id:"总结-and-一个完整的rollup项目的模板",depth:2},{text:"参考资料",id:"参考资料",depth:2}],title:"JS打包工具rollup——完全入门指南",frontmatter:{}}}}]);