"use strict";(self.webpackChunk=self.webpackChunk||[]).push([["8854"],{2256:function(e,n,r){r.r(n),r.d(n,{default:function(){return l}});var s=r(6469),t=r(8809);function d(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h3:"h3",pre:"pre",code:"code",ul:"ul",li:"li",h2:"h2"},(0,t.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"webpack-主要概念",children:["webpack 主要概念",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#webpack-主要概念",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"统计信息：字数 3558  阅读8分钟"}),"\n",(0,s.jsx)(n.p,{children:"create time 2019-01-01"}),"\n",(0,s.jsx)(n.p,{children:"last modify time 2024-04-12"}),"\n",(0,s.jsxs)(n.p,{children:["官网文档链接：",(0,s.jsx)(n.a,{href:"https://webpack.docschina.org/concepts/plugins/",target:"_blank",rel:"noopener noreferrer",children:"https://webpack.docschina.org/concepts/plugins/"})]}),"\n",(0,s.jsx)(n.p,{children:"webpack 静态文件打包：首先构建一个依赖图（dependency graph），然后生成一个或者多个包（bundle）。"}),"\n",(0,s.jsxs)(n.h3,{id:"入口entry",children:["入口（entry）",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#入口entry",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"这里表示 webpack 构建依赖图的开始的文件（通常是 src/index.js）"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// webpack-config.js 这里指定了入口文件是 test.js\nmodule.exports =\n  entry: './src/test.js'\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://webpack.docschina.org/concepts/entry-points/",target:"_blank",rel:"noopener noreferrer",children:"https://webpack.docschina.org/concepts/entry-points/"})}),"\n",(0,s.jsx)(n.p,{children:"入口配置简单：入口配置分为单页面和多页面："}),"\n",(0,s.jsx)(n.p,{children:"通常一个 SPA 项目使用一个入口文件；"}),"\n",(0,s.jsx)(n.p,{children:"如果功能复杂，实际是多个页面，后端根据不同路由进入不同的界面，那么可以设置多个入口文件（多个入口可以复用组件）。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"module.exports = {\n  entry: './src/index.js'\n};\n\nmodule.exports = {\n  entry: {\n    main: './src/main.js',\n    share: './src/share.js',\n    form: './src/form/form-edit.js'\n  }\n};\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"出口output",children:["出口（output）",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#出口output",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"表示打包后的文件的输出位置（默认是./dist/main.js），可以输出多个打包文件"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// webpack-config.js\nconst path = require('path'); // 这里是nodeJS的文件模块，可以获取本地文件的路径\n\n// 设置输出的文件路径是 根路径+dist；输出的一个打包文件是 test.bundle.js\nmodule.exports = {\n  entry: './src/index.js',\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: 'test.bundle.js',\n  },\n};\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"loader",children:["loader",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#loader",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"webpack 默认可以打包 js json 文件，但是对于 css less sass ts 等文件不能直接打包。loader 可以对不同文件进行预处理，并转换成有效的模块。需要在 module-rules 添加 loader（注意路径）。"}),"\n",(0,s.jsx)(n.p,{children:"Loader 参数有两个："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"test 是正则表达式，可以匹配不同类型的文件（根据文件名的后缀匹配文件）注：正则表达式不能加入引号。"}),"\n",(0,s.jsx)(n.li,{children:"use 是一个数组，表示对于不同类型的文件使用不同的 loader，一步一步进行处理。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"loader 针对常见的文件都有对应的loader。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const path = require('path');\n\nmodule.exports = {\n  entry: './src/index.js',\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: 'test.bundle.js',\n  },\n  module: {\n    // 这里表示：正则匹配到的 txt 结尾的文件，使用 raw-loader 预处理一下（转换）\n    rules: [\n      {\n        test: /\\.txt$/,\n        use: 'raw-loader'\n      }\n    ]\n  }\n};\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"插件plugin",children:["插件（plugin）",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#插件plugin",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"loader 可以解决不同文件的处理方法，plugin 可以支持更多功能，例如配置环境变量，或者新生成一个文件（目前没有用到）。插件很多很复杂，目的是解决loader无法解决的事情。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const path = require('path');\nconst webpack = require('webpack');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n  entry: './src/index.js',\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: 'test.bundle.js',\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.txt$/,\n        use: 'raw-loader'\n      }\n    ]\n  },\n  plguins: [\n    new HtmlWebpackPlugin({ template: './src/index.html' })\n  ]\n};\n// 这个插件的作用是，生成一个 index.html 文件，并自动注入打包好的 bundle.js 文件。\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"模式-mode",children:["模式 mode",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#模式-mode",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"默认是 production、还有 development 或者 none。这个设置后不需要变化（通常不用none）。"}),"\n",(0,s.jsxs)(n.h2,{id:"总结",children:["总结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"webpack 主要概念：bundle、block、entry、output、loader、plugin、mode"})]})}function a(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,t.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}let l=a;a.__RSPRESS_PAGE_META={},a.__RSPRESS_PAGE_META["webpack%2F01-webpack%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.md"]={toc:[{text:"入口（entry）",id:"入口entry",depth:3},{text:"出口（output）",id:"出口output",depth:3},{text:"loader",id:"loader",depth:3},{text:"插件（plugin）",id:"插件plugin",depth:3},{text:"模式 mode",id:"模式-mode",depth:3},{text:"总结",id:"总结",depth:2}],title:"webpack 主要概念",frontmatter:{}}}}]);