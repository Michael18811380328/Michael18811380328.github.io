"use strict";(self.webpackChunk=self.webpackChunk||[]).push([["6985"],{8617:function(e,n,c){c.r(n),c.d(n,{default:function(){return i}});var d=c(6469),l=c(8809);function r(e){let n=Object.assign({h2:"h2",a:"a",p:"p",code:"code",h3:"h3",pre:"pre"},(0,l.ah)(),e.components);return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsxs)(n.h2,{id:"更好用的前端-npm-link-工具-yalc",children:["更好用的前端 npm link 工具-yalc",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#更好用的前端-npm-link-工具-yalc",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"统计信息：字数 2564  阅读6分钟"}),"\n",(0,d.jsxs)(n.p,{children:["在组件依赖开发中，我的项目作为依赖库没方法独自间接运行，须要依赖进别的我的项目执行，这时候最罕用的形式就是",(0,d.jsx)(n.code,{children:"npm link"}),"。但用",(0,d.jsx)(n.code,{children:"npm link"}),"引入的依赖因为资源文件不在我的项目下，",(0,d.jsx)(n.code,{children:"webpack"}),"不会对其做预编译，导致理论构建或者运行时会报错，此时如果间接将文件复制进依赖目录则能失常运行。对于这样的状况，意外的碰到了一个很适宜的解决方案——yalc。"]}),"\n",(0,d.jsxs)(n.h3,{id:"yalc",children:["Yalc",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#yalc",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"yalc"})," 能够在本地将",(0,d.jsx)(n.code,{children:"npm包"}),"模仿公布，将公布后的资源寄存在一个全局存储中。而后能够通过",(0,d.jsx)(n.code,{children:"yalc"}),"将包增加进须要援用的我的项目中。"]}),"\n",(0,d.jsxs)(n.p,{children:["这时候",(0,d.jsx)(n.code,{children:"package.json"}),"的依赖表中会多出一个",(0,d.jsx)(n.code,{children:"file:.yalc/..."}),"的依赖包，这就是",(0,d.jsx)(n.code,{children:"yalc"}),"创立的非凡援用。同时也会在我的项目根目录创立一个",(0,d.jsx)(n.code,{children:"yalc.lock"}),"确保援用资源的一致性。因而，测试完我的项目还须要执行删除",(0,d.jsx)(n.code,{children:"yalc"}),"包的操作，能力失常应用。"]}),"\n",(0,d.jsxs)(n.p,{children:["整个过程绝对于",(0,d.jsx)(n.code,{children:"npm link"}),"会更加繁琐一些，要通过发包、增加依赖，完结后也须要做革除操作，但也正因而才防止了",(0,d.jsx)(n.code,{children:"npm link"}),"的一些问题。"]}),"\n",(0,d.jsxs)(n.h3,{id:"装置",children:["装置",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#装置",children:"#"})]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:"NPM:\nnpm i yalc -g\n\nYarn:\nyarn global add yalc\n"})}),"\n",(0,d.jsxs)(n.h3,{id:"公布依赖",children:["公布依赖",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#公布依赖",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"在所开发的依赖我的项目下执行公布操作"}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:"yalc publish\n"})}),"\n",(0,d.jsxs)(n.p,{children:["此时如果存在",(0,d.jsx)(n.code,{children:"npm 生命周期"}),"脚本：",(0,d.jsx)(n.code,{children:"prepublish"}),"、",(0,d.jsx)(n.code,{children:"prepare"}),"、",(0,d.jsx)(n.code,{children:"prepublishOnly"}),"、",(0,d.jsx)(n.code,{children:"prepack"}),"、",(0,d.jsx)(n.code,{children:"preyalcpublish"}),"，会按此程序逐个执行。如果存在：",(0,d.jsx)(n.code,{children:"postyalcpublish"}),"、",(0,d.jsx)(n.code,{children:"postpack"}),"、",(0,d.jsx)(n.code,{children:"publish"}),"、",(0,d.jsx)(n.code,{children:"postpublish"}),"，也会按此程序逐个执行。"]}),"\n",(0,d.jsx)(n.p,{children:"想要齐全禁用脚本执行须要应用"}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:"yalc publish --no-scripts\n"})}),"\n",(0,d.jsx)(n.p,{children:"此时就曾经将依赖公布到本地了。"}),"\n",(0,d.jsxs)(n.h3,{id:"增加依赖",children:["增加依赖",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#增加依赖",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"进入到我的项目执行"}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:"yalc add 我的项目名\n"})}),"\n",(0,d.jsxs)(n.p,{children:["能够看到我的项目中增加了",(0,d.jsx)(n.code,{children:"yalc.lock"}),"文件，",(0,d.jsx)(n.code,{children:"package.json"}),"对应的包名会有个地址为",(0,d.jsx)(n.code,{children:"file:.yalc/"}),"结尾的我的项目。\n也能够应用"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:"yalc add 我的项目名@版本号\n"})}),"\n",(0,d.jsx)(n.p,{children:"将版本锁定，防止因为本地新包推送产生影响。"}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"--dev"}),"将依赖增加进",(0,d.jsx)(n.code,{children:"dependency"}),"中。",(0,d.jsx)(n.code,{children:"--pure"}),"不会影响",(0,d.jsx)(n.code,{children:"package.json"}),"文件。"]}),"\n",(0,d.jsxs)(n.p,{children:["除此之外，还能应用",(0,d.jsx)(n.code,{children:"link"}),"形式援用依赖包。"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:"yalc add 我的项目名 --link\n"})}),"\n",(0,d.jsxs)(n.h3,{id:"更新依赖",children:["更新依赖",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#更新依赖",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"当有新批改的包须要公布时，应用推送命令能够疾速的更新所有依赖"}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:"yalc publish --push\n"})}),"\n",(0,d.jsx)(n.p,{children:"或是简写"}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:"yalc push\n"})}),"\n",(0,d.jsxs)(n.h3,{id:"移除依赖",children:["移除依赖",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#移除依赖",children:"#"})]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:"yalc remove 我的项目名\n"})}),"\n",(0,d.jsx)(n.p,{children:"或是移除所有"}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:"yalc remove --all\n"})})]})}function h(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,l.ah)(),e.components);return n?(0,d.jsx)(n,{...e,children:(0,d.jsx)(r,{...e})}):r(e)}let i=h;h.__RSPRESS_PAGE_META={},h.__RSPRESS_PAGE_META["git%2Fyalc.md"]={toc:[{text:"更好用的前端 npm link 工具-yalc",id:"更好用的前端-npm-link-工具-yalc",depth:2},{text:"Yalc",id:"yalc",depth:3},{text:"装置",id:"装置",depth:3},{text:"公布依赖",id:"公布依赖",depth:3},{text:"增加依赖",id:"增加依赖",depth:3},{text:"更新依赖",id:"更新依赖",depth:3},{text:"移除依赖",id:"移除依赖",depth:3}],title:"",frontmatter:{}}}}]);