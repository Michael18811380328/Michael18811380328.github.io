"use strict";(self.webpackChunk=self.webpackChunk||[]).push([["7902"],{981:function(e,n,s){s.r(n),s.d(n,{default:function(){return l}});var c=s(6469),r=s(8809);function i(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h4:"h4",blockquote:"blockquote",pre:"pre",code:"code",img:"img",h5:"h5",h6:"h6",ul:"ul",li:"li"},(0,r.ah)(),e.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(n.h1,{id:"webpack5-和-webpack4-的区别有哪些",children:["webpack5 和 webpack4 的区别有哪些",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#webpack5-和-webpack4-的区别有哪些",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"统计信息：字数 9773  阅读20分钟"}),"\n",(0,c.jsxs)(n.p,{children:["原文链接：",(0,c.jsx)(n.a,{href:"https://juejin.cn/post/6990869970385109005",target:"_blank",rel:"noopener noreferrer",children:"https://juejin.cn/post/6990869970385109005"})]}),"\n",(0,c.jsxs)(n.h4,{id:"1tree-shaking",children:["1、Tree Shaking",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1tree-shaking",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"作用： 如果我们的项目中引入了 lodash 包，但是我只有了其中的一个方法。其他没有用到的方法是不是冗余的？此时 tree-shaking 就可以把没有用的那些东西剔除掉，来减少最终的bundle体积。"}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"usedExports : true, 标记没有用的叶子"}),"\n"]}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"minimize: true, 摇掉那些没有用的叶子"}),"\n"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"// webpack.config.js中\nmodule.exports = {\n  optimization: {\n    usedExports: true, //只导出被使用的模块\n    minimize : true // 启动压缩\n  }\n}\n"})}),"\n",(0,c.jsx)(n.p,{children:"由于 tree shaking 只支持 esmodule ，如果你打包出来的是 commonjs，此时 tree-shaking 就失效了。不过当前大家都用的是 vue，react 等框架，他们都是用 babel-loader 编译，以下配置就能够保证他一定是 esmodule"}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.img,{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e85782f62e154a2d9971cce084d61103~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp",alt:"image.png"})}),"\n",(0,c.jsx)(n.p,{children:"webpack5的 mode=“production” 自动开启 tree-shaking。"}),"\n",(0,c.jsxs)(n.h4,{id:"2压缩代码",children:["2、压缩代码",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2压缩代码",children:"#"})]}),"\n",(0,c.jsxs)(n.h5,{id:"1webpack4",children:["1.webpack4",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1webpack4",children:"#"})]}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"webpack4 上需要下载安装 terser-webpack-plugin 插件，并且需要以下配置："}),"\n"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"const TerserPlugin = require('terser-webpack-plugin')\n\nmodule.exports = { \n// ...other config\noptimization: {\n  minimize: !isDev,\n  minimizer: [\n    new TerserPlugin({\n      extractComments: false, \n      terserOptions: { \n        compress: { \n          pure_funcs: ['console.log'] \n        }\n      }\n    }) ]\n }\n"})}),"\n",(0,c.jsxs)(n.h5,{id:"2webpack5",children:["2.webpack5",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2webpack5",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"内部本身就自带 js 压缩功能，他内置了 terser-webpack-plugin 插件，我们不用再下载安装。而且在 mode=“production” 的时候会自动开启 js 压缩功能。"}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"如果你要在开发环境使用，就用下面："}),"\n"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"// webpack.config.js中\nmodule.exports = {\n  optimization: {\n    usedExports: true, //只导出被使用的模块\n    minimize : true // 启动压缩\n  }\n}\n"})}),"\n",(0,c.jsxs)(n.h5,{id:"3js-压缩失效问题",children:["3.js 压缩失效问题",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3js-压缩失效问题",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"当你下载 optimize-css-assets-webpack-plugin ，执行 css 压缩以后，你会发现 webpack5 默认的 js 压缩功能失效了。先说 optimize-css-assets-webpack-plugin 的配置："}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"npm install optimize-css-assets-webpack-plugin -D"}),"\n"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"module.exports = { \n  optimization: { \n    minimizer: [ \n      new OptimizeCssAssetsPlugin() \n    ]\n  },\n}\n"})}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"此时的压缩插件 optimize-css-assets-webpack-plugin 可以配置到 plugins 里面去，也可以如图配置到到 optimization 里面。区别如下："}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"配置到 plugins 中，那么这个插件在任何情况下都会工作。 而配置在 optimization 表示只有 minimize 为 true 的时候才能工作。"}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"当安装 optimize-css-assets-webpack-plugin 以后你去打包会发现原来可以压缩的 js 文件，现在不能压缩了。原因是你指定的压缩器是"}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"optimize-css-assets-webpack-plugin 导致默认的 terser-webpack-plugin 就会失效。解决办法如下："}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"npm install terser-webpack-plugin -D"}),"\n"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:" optimization: {\n    minimizer: [\n      new TerserPlugin({\n        extractComments: false,\n        terserOptions: {\n          compress: { pure_funcs: ['console.log'] },\n        },\n      }),\n      new OptimiazeCssAssetPlugin(),\n    ]\n  },\n"})}),"\n",(0,c.jsx)(n.p,{children:"即便在 webpack5 中，你也要像 webpack4 中一样使用 js 压缩。"}),"\n",(0,c.jsxs)(n.h5,{id:"4注意事项",children:["4.注意事项",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4注意事项",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"在webpack5里面使用 optimize-css-assets-webpack-plugin 又是会报错，因为官方已经打算要废除了，请使用替换方案："}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"npm i css-assets-webpack-plugin -D"}),"\n"]}),"\n",(0,c.jsxs)(n.h4,{id:"3合并模块",children:["3、合并模块",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3合并模块",children:"#"})]}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"普通打包只是将一个模块最终放到一个单独的立即执行函数中，如果你有很多模块，那么就有很多立即执行函数。concatenateModules 可以要所有的模块都合并到一个函数里面去。"}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"optimization.concatenateModules = true"}),"\n",(0,c.jsx)(n.p,{children:"配置如下："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"module.exports = {\n  optimization: {\n    usedExports: true,\n    concatenateModules: true,\n    minimize: true\n  }\n}\n"})}),"\n",(0,c.jsx)(n.p,{children:"此时配合 tree-shaking 你会发现打包的体积会减小很多。"}),"\n",(0,c.jsxs)(n.h4,{id:"4副作用-sideeffects",children:["4、副作用 sideEffects",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4副作用-sideeffects",children:"#"})]}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"webpack4 新增了一个 sideEffects 的功能，容许我们通过配置来标识我们的代码是否有副作用。"}),"\n"]}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"这个特性只有在开发 npm 包的时候用到"}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"副作用的解释： 在utils文件夹下面有index.js文件，用于系统导出utils里面其他文件，作用就是写的少， 不管 utils 里面有多少方法，我都只需要引入 utils 即可。"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"// utils/index.js\n  export * from './getXXX.js';\n  export * from './getAAA.js';\n  export * from './getBBB.js';\n  export * from './getCCC.js';\n\n\n // 在其他文件使用 getXXX 引入\n  import {getXX} from '../utils'\n"})}),"\n",(0,c.jsx)(n.p,{children:"此时，如果文件 getBBB 在外界没有用到，而 tree-shaking 又不能把它摇掉咋办？这个 getBBB 就是副作用。你或许要问 tree-shaking 为什么不能奈何他？原因就是：他在 utils/index.js 里面使用了。只能开启副作用特性。如下："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"// package.json中\n{\n  name：“项目名称”,\n  ....\n  sideEffects: false\n}\n\n\n// webpack.config.js\n\nmodule.exports = {\n  mode: 'none',\n  ....\n  optimization: {\n    sideEffects: true\n  }\n}\n"})}),"\n",(0,c.jsx)(n.p,{children:"副作用开启："}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"(1)optimization.sideEffects = true 开启副作用功能"}),"\n"]}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"(2)package.json 中设置 sideEffects : false 标记所有模块无副作用"}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"说明： webpack 打包前都会检查项目所属的 package.json 文件中的 sideEffects 标识，如果没有副作用，那些没有用到的模块就不需要打包，反之亦然。此时，在webpack.config.js 里面开启 sideEffects。"}),"\n",(0,c.jsxs)(n.h4,{id:"5webpack-缓存",children:["5、webpack 缓存",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#5webpack-缓存",children:"#"})]}),"\n",(0,c.jsxs)(n.h6,{id:"1webpack4-缓存配置",children:["1.webpack4 缓存配置",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1webpack4-缓存配置",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"支持缓存在内存中"}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"npm install hard-source-webpack-plugin -D"}),"\n"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"const HardSourceWebpackPlugin = require('hard-source-webpack-plugin') \n\nmodule.exports = { \nplugins: [\n  // 其它 plugin... \n  new HardSourceWebpackPlugin(), \n] }\n"})}),"\n",(0,c.jsxs)(n.h6,{id:"2-webpack5-缓存配置",children:["2. webpack5 缓存配置",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-webpack5-缓存配置",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"webpack5 内部内置了 cache 缓存机制。直接配置即可。"}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"cache 会在开发模式下被设置成 type： memory 而且会在生产模式把cache 给禁用掉。"}),"\n"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"// webpack.config.js\nmodule.exports= {\n  // 使用持久化缓存\n  cache: {\n    type: 'filesystem'，\n    cacheDirectory: path.join(__dirname, 'node_modules/.cac/webpack')\n  }\n}\n\n\n"})}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"type 的可选值为： memory 使用内容缓存，filesystem 使用文件缓存。"}),"\n"]}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"当 type=filesystem的时候设置cacheDirectory才生效。用于设置你需要的东西缓存放在哪里？"}),"\n"]}),"\n",(0,c.jsxs)(n.h4,{id:"6对loader的优化",children:["6、对loader的优化",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#6对loader的优化",children:"#"})]}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"webpack 4 加载资源需要用不同的 loader"}),"\n"]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"raw-loader 将文件导入为字符串"}),"\n",(0,c.jsx)(n.li,{children:"url-loader 将文件作为 data url 内联到 bundle文件中"}),"\n",(0,c.jsx)(n.li,{children:"file-loader 将文件发送到输出目录中"}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.img,{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6abf7458ff1649fc81bbe2943887e539~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp",alt:"image.png"})}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"webpack5 的资源模块类型替换 loader"}),"\n"]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"asset/resource 替换 file-loader(发送单独文件)"}),"\n",(0,c.jsx)(n.li,{children:"asset/inline 替换 url-loader （导出 url）"}),"\n",(0,c.jsx)(n.li,{children:"asset/source 替换 raw-loader（导出源代码）"}),"\n",(0,c.jsx)(n.li,{children:"asset"}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.img,{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/280823192f3e4348af944c3f6a3ec4fc~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp",alt:"image.png"})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.a,{href:"https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.docschina.org%2Fguides%2Fasset-modules%2F",target:"_blank",rel:"noopener noreferrer",children:"webpack5"})}),"\n",(0,c.jsxs)(n.h4,{id:"7启动服务的差别",children:["7、启动服务的差别",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#7启动服务的差别",children:"#"})]}),"\n",(0,c.jsxs)(n.h6,{id:"1webpack4-启动服务",children:["1.webpack4 启动服务",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1webpack4-启动服务",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"通过 webpack-dev-server 启动服务"}),"\n",(0,c.jsxs)(n.h6,{id:"2webpack5-启动服务",children:["2.webpack5 启动服务",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2webpack5-启动服务",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"内置使用 webpack serve 启动，但是他的日志不是很好，所以一般都加都喜欢用 webpack-dev-server 优化。"}),"\n",(0,c.jsxs)(n.h4,{id:"8-模块联邦微前端",children:["8. 模块联邦（微前端）",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#8-模块联邦微前端",children:"#"})]}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"webpack 可以实现 应用程序和应用程序之间的引用。"}),"\n"]}),"\n",(0,c.jsxs)(n.h4,{id:"9devtool的差别",children:["9.devtool的差别",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#9devtool的差别",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"sourceMap需要在 webpack.config.js里面直接配置 devtool 就可以实现了。而 devtool有很多个选项值，不同的选项值，不同的选项产生的 .map 文件不同，打包速度不同。"}),"\n",(0,c.jsx)(n.p,{children:"一般情况下，我们一般在开发环境配置用“cheap-eval-module-source-map”，在生产环境用‘none’。"}),"\n",(0,c.jsx)(n.p,{children:"devtool在webpack4和webpack5上也是有区别的"}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"v4: devtool: 'cheap-eval-module-source-map'"}),"\n"]}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"v5: devtool: 'eval-cheap-module-source-map'"}),"\n"]}),"\n",(0,c.jsxs)(n.h4,{id:"10热更新差别",children:["10.热更新差别",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#10热更新差别",children:"#"})]}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"webpack4设置"}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.img,{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/171d53563efd40439c8f61969ca1d12d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp",alt:"image.png"})}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"webpack5 设置"}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"如果你使用的是bable6，按照上述设置，你会发现热更新无效，需要添加配置："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"  module.hot.accept('需要热启动的文件',(source)=>{\n     //自定义热启动\n  })\n"})}),"\n",(0,c.jsx)(n.p,{children:"当前最新版的babel里面的 babel-loader已经帮我们处理的热更新失效的问题。所以不必担心，直接使用即可。"}),"\n",(0,c.jsx)(n.p,{children:"如果你引入 mini-css-extract-plugin 以后你会发现 样式的热更新也会失效。"}),"\n",(0,c.jsx)(n.p,{children:"只能在开发环境使用style-loader，而在生产环境用MinicssExtractPlugin.loader。 如下："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.img,{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/944a741135ea41478f335d1a9cd2ba5d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp",alt:"image.png"})}),"\n",(0,c.jsxs)(n.h4,{id:"11使用-webpack-merge-的差别",children:["11、使用 webpack-merge 的差别",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#11使用-webpack-merge-的差别",children:"#"})]}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"webpack4 导入"}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"const merge = require('webpack-merge);"}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"webpack 5 导入"}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"const {merge} = require('webpack-merge');"}),"\n",(0,c.jsx)(n.p,{children:"12、 使用 copy-webpack-plugin 的差别"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"//webpack.config.js\nconst CopyWebpackPlugin = require('copy-webpack-plugin');\n\nmodule.exports = {\n  plugins: [\n    // webpack 4\n    new CopyWebpackPlugin(['public']),\n    \n    // webpack 5\n    new CopyWebpackPlugin({\n      patterns: [{\n        from: './public',\n        to: './dist/public'\n      }]\n    })\n  ]\n}\n\n\n"})}),"\n",(0,c.jsx)(n.p,{children:"webpack5 支持的新版本里面需要配置的更加清楚。"})]})}function a(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(i,{...e})}):i(e)}let l=a;a.__RSPRESS_PAGE_META={},a.__RSPRESS_PAGE_META["webpack%2F08-webpack5%20%E5%92%8C%20webpack4%20%E7%9A%84%E5%8C%BA%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B.md"]={toc:[{text:"1、Tree Shaking",id:"1tree-shaking",depth:4},{text:"2、压缩代码",id:"2压缩代码",depth:4},{text:"3、合并模块",id:"3合并模块",depth:4},{text:"4、副作用 sideEffects",id:"4副作用-sideeffects",depth:4},{text:"5、webpack 缓存",id:"5webpack-缓存",depth:4},{text:"6、对loader的优化",id:"6对loader的优化",depth:4},{text:"7、启动服务的差别",id:"7启动服务的差别",depth:4},{text:"8. 模块联邦（微前端）",id:"8-模块联邦微前端",depth:4},{text:"9.devtool的差别",id:"9devtool的差别",depth:4},{text:"10.热更新差别",id:"10热更新差别",depth:4},{text:"11、使用 webpack-merge 的差别",id:"11使用-webpack-merge-的差别",depth:4}],title:"webpack5 和 webpack4 的区别有哪些",frontmatter:{}}}}]);