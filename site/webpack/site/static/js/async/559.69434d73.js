"use strict";(self.webpackChunk=self.webpackChunk||[]).push([["559"],{4078:function(e,n,s){s.r(n),s.d(n,{default:function(){return a}});var r=s(6469),t=s(8809);function o(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",pre:"pre",code:"code"},(0,t.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"webpack-脚本说明",children:["webpack 脚本说明",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#webpack-脚本说明",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"统计信息：字数 20612  阅读42分钟"}),"\n",(0,r.jsx)(n.p,{children:"按照 craete-react-app 的说明，运行 npm run eject 后，会弹出 webpack 等配置，主要的文件如下。"}),"\n",(0,r.jsx)(n.p,{children:"注意：需要判断不同的 cra 版本，对应的 webpack 345 版本也不同。下面代码比较早，以最新为准。"}),"\n",(0,r.jsxs)(n.h2,{id:"环境说明-envjs",children:["环境说明 env.js",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#环境说明-envjs",children:"#"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"'use strict';\n\nconst fs = require('fs');\nconst path = require('path');\nconst paths = require('./paths');\n\n// Make sure that including paths.js after env.js will read .env variables.\ndelete require.cache[require.resolve('./paths')];\n\nconst NODE_ENV = process.env.NODE_ENV;\nif (!NODE_ENV) {\n  throw new Error('The NODE_ENV environment variable is required but was not specified.');\n}\n\n// https://github.com/bkeepers/dotenv#what-other-env-files-can-i-use\nvar dotenvFiles = [\n  `${paths.dotenv}.${NODE_ENV}.local`,\n  `${paths.dotenv}.${NODE_ENV}`,\n  // Don't include `.env.local` for `test` environment\n  // since normally you expect tests to produce the same\n  // results for everyone\n  NODE_ENV !== 'test' && `${paths.dotenv}.local`,\n  paths.dotenv,\n].filter(Boolean);\n\n// Load environment variables from .env* files. Suppress warnings using silent\n// if this file is missing. dotenv will never modify any environment variables\n// that have already been set.  Variable expansion is supported in .env files.\n// https://github.com/motdotla/dotenv\n// https://github.com/motdotla/dotenv-expand\ndotenvFiles.forEach(dotenvFile => {\n  if (fs.existsSync(dotenvFile)) {\n    require('dotenv-expand')(\n      require('dotenv').config({\n        path: dotenvFile,\n      })\n    );\n  }\n});\n\n// We support resolving modules according to `NODE_PATH`.\n// This lets you use absolute paths in imports inside large monorepos:\n// https://github.com/facebook/create-react-app/issues/253.\n// It works similar to `NODE_PATH` in Node itself:\n// https://nodejs.org/api/modules.html#modules_loading_from_the_global_folders\n// Note that unlike in Node, only *relative* paths from `NODE_PATH` are honored.\n// Otherwise, we risk importing Node.js core modules into an app instead of Webpack shims.\n// https://github.com/facebook/create-react-app/issues/1023#issuecomment-265344421\n// We also resolve them to make sure all tools using them work consistently.\nconst appDirectory = fs.realpathSync(process.cwd());\nprocess.env.NODE_PATH = (process.env.NODE_PATH || '')\n  .split(path.delimiter)\n  .filter(folder => folder && !path.isAbsolute(folder))\n  .map(folder => path.resolve(appDirectory, folder))\n  .join(path.delimiter);\n\n// Grab NODE_ENV and REACT_APP_* environment variables and prepare them to be\n// injected into the application via DefinePlugin in Webpack configuration.\nconst REACT_APP = /^REACT_APP_/i;\n\nfunction getClientEnvironment(publicUrl) {\n  const raw = Object.keys(process.env)\n    .filter(key => REACT_APP.test(key))\n    .reduce(\n      (env, key) => {\n        env[key] = process.env[key];\n        return env;\n      },\n      {\n        // Useful for determining whether we’re running in production mode.\n        // Most importantly, it switches React into the correct mode.\n        NODE_ENV: process.env.NODE_ENV || 'development',\n        // Useful for resolving the correct path to static assets in `public`.\n        // For example, <img src={process.env.PUBLIC_URL + '/img/logo.png'} />.\n        // This should only be used as an escape hatch. Normally you would put\n        // images into the `src` and `import` them in code to get their paths.\n        PUBLIC_URL: publicUrl,\n      }\n    );\n  // Stringify all values so we can feed into Webpack DefinePlugin\n  const stringified = {\n    'process.env': Object.keys(raw).reduce((env, key) => {\n      env[key] = JSON.stringify(raw[key]);\n      return env;\n    }, {}),\n  };\n\n  return { raw, stringified };\n}\n\nmodule.exports = getClientEnvironment;\n\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"路径说明-pathjs",children:["路径说明 path.js",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#路径说明-pathjs",children:"#"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"'use strict';\n\nconst path = require('path');\nconst fs = require('fs');\nconst url = require('url');\n\n// 确保项目文件夹中的所有符号链接被解决\n// https://github.com/facebook/create-react-app/issues/637\n// fs.realpathSync 同步获取真实路径\nconst appDirectory = fs.realpathSync(process.cwd());\n\n// 组合路径函数：把真实路径和相对路径组合\n// path.resolve 把一个路径或路径片段的序列解析为一个绝对路径\n// path.join 使用平台特定的分隔符把全部给定的 path 片段连接到一起，并规范化生成的路径\n// join直接拼接字段，resolve解析路径并返回\nconst resolveApp = (relativePath) => {\n  return path.resolve(appDirectory, relativePath);\n}\n\n// 用于转换 Windows 反斜杠路径转换为正斜杠路径\nfunction ensureSlash(inputPath, needsSlash) {\n  // 如果输入路径是/结尾，那么就是true\n  const hasSlash = inputPath.endsWith('/');\n  // 如果有斜杠，不需要斜杠，那么删除最后一个字符\n  if (hasSlash && !needsSlash) {\n    return inputPath.substr(0, inputPath.length - 1);\n  }\n  // 如果没有斜杠，需要斜杠，那么加上一个字符\n  else if (!hasSlash && needsSlash) {\n    return `${inputPath}/`;\n  }\n  // 其他情况直接返回\n  else {\n    return inputPath;\n  }\n}\n\n// 公共URL\nconst envPublicUrl = process.env.PUBLIC_URL;\n\n// 获取公共URL函数\n// We use `PUBLIC_URL` environment variable or \"homepage\" field to infer \"public path\" at which the app is served.\n// webpack 使用\"PUBLIC_URL\"环境变量或“homepage”字段来推断在其中提供应用程序的“公共路径”。\nconst getPublicUrl = (appPackageJson) => {\n  return envPublicUrl || require(appPackageJson).homepage;\n}\n\n// Webpack需要知道将正确的<script> hrefs放入HTML的方法，即使是在单页应用程序中\n// 该应用程序可能会为诸如 /todos/42 之类的嵌套URL提供index.html。 \n// 我们无法在HTML中使用相对路径，因为我们不想加载 /todos/42/static/js/bundle.7289d.js 的内容，我们必须知道根源。\nfunction getServedPath(appPackageJson) {\n  const publicUrl = getPublicUrl(appPackageJson);\n  const servedUrl = envPublicUrl || (publicUrl ? url.parse(publicUrl).pathname : '/');\n  return ensureSlash(servedUrl, true);\n}\n\n// 模块文件扩展名\nconst moduleFileExtensions = [\n  'web.mjs',\n  'mjs',\n  'web.js',\n  'js',\n  'web.ts',\n  'ts',\n  'web.tsx',\n  'tsx',\n  'json',\n  'web.jsx',\n  'jsx',\n];\n\n// 以 webpack 相同的顺序解析文件路径\nconst resolveModule = (resolveFn, filePath) => {\n  const extension = moduleFileExtensions.find(extension =>\n    fs.existsSync(resolveFn(`${filePath}.${extension}`))\n  );\n  if (extension) {\n    return resolveFn(`${filePath}.${extension}`);\n  }\n  return resolveFn(`${filePath}.js`);\n};\n\n// config after eject: we're in ./config/\n// 弹出后配置\nmodule.exports = {\n  dotenv: resolveApp('.env'),\n  appPath: resolveApp('.'),\n  appBuild: resolveApp('build'),\n  appPublic: resolveApp('public'),\n  appHtml: resolveApp('public/index.html'),\n  appIndexJs: resolveModule(resolveApp, 'src/index.local'),\n  appPackageJson: resolveApp('package.json'),\n  appSrc: resolveApp('src'),\n  appTsConfig: resolveApp('tsconfig.json'),\n  appJsConfig: resolveApp('jsconfig.json'),\n  yarnLockFile: resolveApp('yarn.lock'),\n  testsSetup: resolveModule(resolveApp, 'src/setupTests'),\n  proxySetup: resolveApp('src/setupProxy.js'),\n  appNodeModules: resolveApp('node_modules'),\n  publicUrl: getPublicUrl(resolveApp('package.json')),\n  servedPath: getServedPath(resolveApp('package.json')),\n};\n\nmodule.exports.moduleFileExtensions = moduleFileExtensions;\n\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"测试脚本",children:["测试脚本",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#测试脚本",children:"#"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"'use strict';\n\n// 首先设置环境变量（其他的代码可以正确运行）使用 process.env 对象表示 package.json 文件\nprocess.env.BABEL_ENV = 'test';\nprocess.env.NODE_ENV = 'test';\nprocess.env.PUBLIC_URL = '';\n\n// 使脚本在未处理错误抛出异常时崩溃，而不是默默地忽略它们。\n// 将来，未处理的 Promise 拒绝，将以非零退出代码终止Node.js进程。\nprocess.on('unhandledRejection', err => {\n  throw err;\n});\n\n// 确保读取环境变量.\nrequire('../config/env');\n\n// 使用 jest 测试框架\nconst jest = require('jest');\n\n// child_process NodeJS 使用同步方式创建子进程\n// 详见http://nodejs.cn/api/child_process.html\n// http://nodejs.cn/api/child_process.html#child_process_child_process_execsync_command_options\nconst execSync = require('child_process').execSync;\n\n// process.argv 属性返回一个数组，其中包含当启动 Node.js 进程时传入的命令行参数。\n// 运行的命令是 node scripts/test.js --env=jsdom\n// 这里从 index = 2 获取传入的命令行参数--env=jsdom（node执行配置的参数）\n// console.log(process.argv)\n// [\n//   '/usr/local/bin/node',\n//   '/workroom/Michael/scripts/test.js',\n//   '--env=jsdom'\n// ]\n// 详见 http://nodejs.cn/api/process/process_argv.html\nlet argv = process.argv.slice(2);\n\n// 判断是否在git中\nfunction isInGitRepository() {\n  try {\n    execSync('git rev-parse --is-inside-work-tree', { stdio: 'ignore' });\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n// 判断是否在水星?仓库中\nfunction isInMercurialRepository() {\n  try {\n    execSync('hg --cwd . root', { stdio: 'ignore' });\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n// Watch unless on CI or explicitly running all tests\nif (!process.env.CI && argv.indexOf('--watchAll') === -1) {\n  // https://github.com/facebook/create-react-app/issues/5210\n  // npm test fails if the project doesn't have git\n  const hasSourceControl = isInGitRepository() || isInMercurialRepository();\n  // 如果在git环境中，那么需要加入 --watch 参数；否则需要加入 --watchAll 参数\n  argv.push(hasSourceControl ? '--watch' : '--watchAll');\n}\n// 加上 --watchAll 可以选择性的运行下面的脚本\n// No tests found related to files changed since last commit.\n// Press `a` to run all tests, or run Jest with `--watchAll`.\n\n// Watch Usage\n//  › Press a to run all tests.\n//  › Press f to run only failed tests.\n//  › Press p to filter by a filename regex pattern.\n//  › Press t to filter by a test name regex pattern.\n//  › Press q to quit watch mode.\n//  › Press Enter to trigger a test run.\n\n// 默认的测试环境是 jsdom 如果不加这个也可以运行\n// jest.run('--env=jsdom')\njest.run(argv);\n\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"开发脚本-startjs",children:["开发脚本 start.js",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#开发脚本-startjs",children:"#"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// test出现过的代码这里不说明\n'use strict';\n\n// 环境配置\nprocess.env.BABEL_ENV = 'development';\nprocess.env.NODE_ENV = 'development';\nprocess.on('unhandledRejection', err => {\n  throw err;\n});\n\nrequire('../config/env');\n\nconst fs = require('fs');\nconst chalk = require('react-dev-utils/chalk');\nconst webpack = require('webpack');\nconst WebpackDevServer = require('webpack-dev-server');\nconst clearConsole = require('react-dev-utils/clearConsole');\nconst checkRequiredFiles = require('react-dev-utils/checkRequiredFiles');\nconst { choosePort, createCompiler, prepareProxy, prepareUrls } = require('react-dev-utils/WebpackDevServerUtils');\nconst openBrowser = require('react-dev-utils/openBrowser');\nconst paths = require('../config/paths');\nconst configFactory = require('../config/webpack.config');\nconst createDevServerConfig = require('../config/webpackDevServer.config');\n\nconst useYarn = fs.existsSync(paths.yarnLockFile);\nconst isInteractive = process.stdout.isTTY;\n\n// Warn and crash if required files are missing\nif (!checkRequiredFiles([paths.appHtml, paths.appIndexJs])) {\n  process.exit(1);\n}\n\n// Tools like Cloud9 rely on this.\nconst DEFAULT_PORT = parseInt(process.env.PORT, 10) || 3000;\nconst HOST = process.env.HOST || '0.0.0.0';\n\nif (process.env.HOST) {\n  console.log(chalk.cyan(`Attempting to bind to HOST environment variable: ${chalk.yellow(chalk.bold(process.env.HOST))}`));\n  console.log(`If this was unintentional, check that you haven't mistakenly set it in your shell.`);\n  console.log(`Learn more here: ${chalk.yellow('https://bit.ly/CRA-advanced-config')}`);\n}\n\n// We require that you explicitly set browsers and do not fall back to\n// browserslist defaults.\nconst { checkBrowsers } = require('react-dev-utils/browsersHelper');\ncheckBrowsers(paths.appPath, isInteractive)\n  .then(() => {\n    // We attempt to use the default port but if it is busy, we offer the user to\n    // run on a different port. `choosePort()` Promise resolves to the next free port.\n    return choosePort(HOST, DEFAULT_PORT);\n  })\n  .then(port => {\n    if (port == null) {\n      // We have not found a port.\n      return;\n    }\n    const config = configFactory('development');\n    const protocol = process.env.HTTPS === 'true' ? 'https' : 'http';\n    const appName = require(paths.appPackageJson).name;\n    const useTypeScript = fs.existsSync(paths.appTsConfig);\n    const urls = prepareUrls(protocol, HOST, port);\n    const devSocket = {\n      warnings: warnings =>\n        devServer.sockWrite(devServer.sockets, 'warnings', warnings),\n      errors: errors =>\n        devServer.sockWrite(devServer.sockets, 'errors', errors),\n    };\n    // Create a webpack compiler that is configured with custom messages.\n    const compiler = createCompiler({\n      appName,\n      config,\n      devSocket,\n      urls,\n      useYarn,\n      useTypeScript,\n      webpack,\n    });\n    // Load proxy config\n    const proxySetting = require(paths.appPackageJson).proxy;\n    const proxyConfig = prepareProxy(proxySetting, paths.appPublic);\n    // Serve webpack assets generated by the compiler over a web server.\n    const serverConfig = createDevServerConfig(\n      proxyConfig,\n      urls.lanUrlForConfig\n    );\n    const devServer = new WebpackDevServer(compiler, serverConfig);\n    // Launch WebpackDevServer.\n    devServer.listen(port, HOST, err => {\n      if (err) {\n        return console.log(err);\n      }\n      if (isInteractive) {\n        clearConsole();\n      }\n\n      // We used to support resolving modules according to `NODE_PATH`.\n      // This now has been deprecated in favor of jsconfig/tsconfig.json\n      // This lets you use absolute paths in imports inside large monorepos:\n      if (process.env.NODE_PATH) {\n        console.log(chalk.yellow(\n          'Setting NODE_PATH to resolve modules absolutely has been deprecated in favor of setting baseUrl in jsconfig.json (or tsconfig.json if you are using TypeScript) and will be removed in a future major release of create-react-app.'\n        ));\n      }\n      console.log(chalk.cyan('Starting the development server...\\n'));\n      openBrowser(urls.localUrlForBrowser);\n    });\n\n    ['SIGINT', 'SIGTERM'].forEach(function(sig) {\n      process.on(sig, function() {\n        devServer.close();\n        process.exit();\n      });\n    });\n  })\n  .catch(err => {\n    if (err && err.message) {\n      console.log(err.message);\n    }\n    process.exit(1);\n  });\n\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"部署脚本-buildjs",children:["部署脚本 build.js",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#部署脚本-buildjs",children:"#"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"\n'use strict';\n\nprocess.env.BABEL_ENV = 'production';\nprocess.env.NODE_ENV = 'production';\n\nprocess.on('unhandledRejection', err => {\n  throw err;\n});\n\nrequire('../config/env');\n\n\nconst path = require('path');\nconst chalk = require('react-dev-utils/chalk');\nconst fs = require('fs-extra');\nconst webpack = require('webpack');\nconst configFactory = require('../config/webpack.config');\nconst paths = require('../config/paths');\nconst checkRequiredFiles = require('react-dev-utils/checkRequiredFiles');\nconst formatWebpackMessages = require('react-dev-utils/formatWebpackMessages');\nconst printHostingInstructions = require('react-dev-utils/printHostingInstructions');\nconst FileSizeReporter = require('react-dev-utils/FileSizeReporter');\nconst printBuildError = require('react-dev-utils/printBuildError');\n\nconst measureFileSizesBeforeBuild = FileSizeReporter.measureFileSizesBeforeBuild;\nconst printFileSizesAfterBuild = FileSizeReporter.printFileSizesAfterBuild;\nconst useYarn = fs.existsSync(paths.yarnLockFile);\n\n// These sizes are pretty large. We'll warn for bundles exceeding them.\nconst WARN_AFTER_BUNDLE_GZIP_SIZE = 512 * 1024;\nconst WARN_AFTER_CHUNK_GZIP_SIZE = 1024 * 1024;\n\nconst isInteractive = process.stdout.isTTY;\n\n// Warn and crash if required files are missing\nif (!checkRequiredFiles([paths.appHtml, paths.appIndexJs])) {\n  process.exit(1);\n}\n\n// Generate configuration\nconst config = configFactory('production');\n\n// We require that you explicitly set browsers and do not fall back to\n// browserslist defaults.\nconst { checkBrowsers } = require('react-dev-utils/browsersHelper');\ncheckBrowsers(paths.appPath, isInteractive)\n  .then(() => {\n    // First, read the current file sizes in build directory.\n    // This lets us display how much they changed later.\n    return measureFileSizesBeforeBuild(paths.appBuild);\n  })\n  .then(previousFileSizes => {\n    // Remove all content but keep the directory so that\n    // if you're in it, you don't end up in Trash\n    fs.emptyDirSync(paths.appBuild);\n    // Merge with the public folder\n    copyPublicFolder();\n    // Start the webpack build\n    return build(previousFileSizes);\n  })\n  .then(\n    ({ stats, previousFileSizes, warnings }) => {\n      if (warnings.length) {\n        console.log(chalk.yellow('Compiled with warnings.\\n'));\n        console.log(warnings.join('\\n\\n'));\n        console.log(\n          '\\nSearch for the ' +\n            chalk.underline(chalk.yellow('keywords')) +\n            ' to learn more about each warning.'\n        );\n        console.log(\n          'To ignore, add ' +\n            chalk.cyan('// eslint-disable-next-line') +\n            ' to the line before.\\n'\n        );\n      } else {\n        console.log(chalk.green('Compiled successfully.\\n'));\n      }\n\n      console.log('File sizes after gzip:\\n');\n      printFileSizesAfterBuild(\n        stats,\n        previousFileSizes,\n        paths.appBuild,\n        WARN_AFTER_BUNDLE_GZIP_SIZE,\n        WARN_AFTER_CHUNK_GZIP_SIZE\n      );\n      console.log();\n\n      const appPackage = require(paths.appPackageJson);\n      const publicUrl = paths.publicUrl;\n      const publicPath = config.output.publicPath;\n      const buildFolder = path.relative(process.cwd(), paths.appBuild);\n      printHostingInstructions(\n        appPackage,\n        publicUrl,\n        publicPath,\n        buildFolder,\n        useYarn\n      );\n    },\n    err => {\n      console.log(chalk.red('Failed to compile.\\n'));\n      printBuildError(err);\n      process.exit(1);\n    }\n  )\n  .catch(err => {\n    if (err && err.message) {\n      console.log(err.message);\n    }\n    process.exit(1);\n  });\n\n// Create the production build and print the deployment instructions.\nfunction build(previousFileSizes) {\n  // We used to support resolving modules according to `NODE_PATH`.\n  // This now has been deprecated in favor of jsconfig/tsconfig.json\n  // This lets you use absolute paths in imports inside large monorepos:\n  if (process.env.NODE_PATH) {\n    console.log(\n      chalk.yellow(\n        'Setting NODE_PATH to resolve modules absolutely has been deprecated in favor of setting baseUrl in jsconfig.json (or tsconfig.json if you are using TypeScript) and will be removed in a future major release of create-react-app.'\n      )\n    );\n    console.log();\n  }\n\n  console.log('Creating an optimized production build...');\n\n  const compiler = webpack(config);\n  return new Promise((resolve, reject) => {\n    compiler.run((err, stats) => {\n      let messages;\n      if (err) {\n        if (!err.message) {\n          return reject(err);\n        }\n        messages = formatWebpackMessages({\n          errors: [err.message],\n          warnings: [],\n        });\n      } else {\n        messages = formatWebpackMessages(\n          stats.toJson({ all: false, warnings: true, errors: true })\n        );\n      }\n      if (messages.errors.length) {\n        // Only keep the first error. Others are often indicative\n        // of the same problem, but confuse the reader with noise.\n        if (messages.errors.length > 1) {\n          messages.errors.length = 1;\n        }\n        return reject(new Error(messages.errors.join('\\n\\n')));\n      }\n      if (\n        process.env.CI &&\n        (typeof process.env.CI !== 'string' ||\n          process.env.CI.toLowerCase() !== 'false') &&\n        messages.warnings.length\n      ) {\n        console.log(\n          chalk.yellow(\n            '\\nTreating warnings as errors because process.env.CI = true.\\n' +\n              'Most CI servers set it automatically.\\n'\n          )\n        );\n        return reject(new Error(messages.warnings.join('\\n\\n')));\n      }\n\n      return resolve({\n        stats,\n        previousFileSizes,\n        warnings: messages.warnings,\n      });\n    });\n  });\n}\n\nfunction copyPublicFolder() {\n  fs.copySync(paths.appPublic, paths.appBuild, {\n    dereference: true,\n    filter: file => file !== paths.appHtml,\n  });\n}\n\n"})})]})}function i(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,t.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(o,{...e})}):o(e)}let a=i;i.__RSPRESS_PAGE_META={},i.__RSPRESS_PAGE_META["webpack%2F46-webpack%20%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E5%AD%A6%E4%B9%A0.md"]={toc:[{text:"环境说明 env.js",id:"环境说明-envjs",depth:2},{text:"路径说明 path.js",id:"路径说明-pathjs",depth:2},{text:"测试脚本",id:"测试脚本",depth:2},{text:"开发脚本 start.js",id:"开发脚本-startjs",depth:2},{text:"部署脚本 build.js",id:"部署脚本-buildjs",depth:2}],title:"webpack 脚本说明",frontmatter:{}}}}]);