"use strict";(self.webpackChunk=self.webpackChunk||[]).push([["4982"],{9339:function(e,n,r){r.r(n),r.d(n,{default:function(){return a}});var c=r(6469),s=r(8809);function i(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h6:"h6",img:"img",h2:"h2",code:"code",pre:"pre",strong:"strong",ul:"ul",li:"li",em:"em"},(0,s.ah)(),e.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(n.h1,{id:"webpack-起步",children:["webpack 起步",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#webpack-起步",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"统计信息：字数 12971  阅读26分钟"}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.a,{href:"https://webpack.docschina.org/guides/getting-started/",target:"_blank",rel:"noopener noreferrer",children:"https://webpack.docschina.org/guides/getting-started/"})}),"\n",(0,c.jsxs)(n.p,{children:["webpack 用于编译 JavaScript 模块。一旦完成 ",(0,c.jsx)(n.a,{href:"https://webpack.docschina.org/guides/installation",target:"_blank",rel:"noopener noreferrer",children:"安装"}),"，你就可以通过 webpack ",(0,c.jsx)(n.a,{href:"https://webpack.docschina.org/api/cli",target:"_blank",rel:"noopener noreferrer",children:"CLI"})," 或 ",(0,c.jsx)(n.a,{href:"https://webpack.docschina.org/api/node",target:"_blank",rel:"noopener noreferrer",children:"API"})," 与其配合交互。如果你还不熟悉 webpack，请阅读 ",(0,c.jsx)(n.a,{href:"https://webpack.docschina.org/concepts",target:"_blank",rel:"noopener noreferrer",children:"核心概念"})," 和 ",(0,c.jsx)(n.a,{href:"https://webpack.docschina.org/comparison",target:"_blank",rel:"noopener noreferrer",children:"对比"}),"，了解为什么要使用 webpack，而不是社区中的其他工具。"]}),"\n",(0,c.jsxs)(n.h6,{id:"warning",children:["Warning",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#warning",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"运行 webpack 5 的 Node.js 最低版本是 10.13.0 (LTS)。"}),"\n",(0,c.jsxs)(n.h6,{id:"live-preview",children:["Live Preview",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#live-preview",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"Check out this guide live on StackBlitz."}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.a,{href:"https://stackblitz.com/github/webpack/webpack.js.org/tree/master/examples/getting-started?terminal=",target:"_blank",rel:"noopener noreferrer",children:(0,c.jsx)(n.img,{src:"https://webpack.docschina.org/open-in-stackblitz-button.8adfcecafae9c6fb6162.svg",alt:"Open in StackBlitz"})})}),"\n",(0,c.jsxs)(n.h2,{id:"基本安装",children:["基本安装",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#基本安装",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["首先我们创建一个目录，初始化 npm，然后 ",(0,c.jsx)(n.a,{href:"https://webpack.docschina.org/guides/installation#local-installation",target:"_blank",rel:"noopener noreferrer",children:"在本地安装 webpack"}),"，接着安装 ",(0,c.jsx)(n.a,{href:"https://github.com/webpack/webpack-cli",target:"_blank",rel:"noopener noreferrer",children:(0,c.jsx)(n.code,{children:"webpack-cli"})}),"（此工具用于在命令行中运行 webpack）："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"mkdir webpack-demo\ncd webpack-demo\nnpm init -y\nnpm install webpack webpack-cli --save-dev\n"})}),"\n",(0,c.jsxs)(n.p,{children:["在整个指南中，我们将使用 ",(0,c.jsx)(n.code,{children:"diff"})," 块，来展示对目录、文件和代码所做的修改。例如："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"+ this is a new line you shall copy into your code\n- and this is a line to be removed from your code\n  and this is a line not to touch.\n"})}),"\n",(0,c.jsx)(n.p,{children:"现在，我们将创建以下目录结构、文件和内容："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"project"})}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"  webpack-demo\n  |- package.json\n+ |- index.html\n+ |- /src\n+   |- index.js\n"})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"src/index.js"})}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"function component() {\n  const element = document.createElement('div');\n\n  // lodash（目前通过一个 script 引入）对于执行这一行是必需的\n  element.innerHTML = _.join(['Hello', 'webpack'], ' ');\n\n  return element;\n}\n\ndocument.body.appendChild(component());\n"})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"index.html"})}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:'<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset="utf-8" />\n    <title>起步</title>\n    <script src="https://unpkg.com/lodash@4.17.20"><\/script>\n  </head>\n  <body>\n    <script src="./src/index.js"><\/script>\n  </body>\n</html>\n'})}),"\n",(0,c.jsxs)(n.p,{children:["我们还需要调整 ",(0,c.jsx)(n.code,{children:"package.json"})," 文件，以便确保我们安装包是 ",(0,c.jsx)(n.code,{children:"private(私有的)"}),"，并且移除 ",(0,c.jsx)(n.code,{children:"main"})," 入口。这可以防止意外发布你的代码。"]}),"\n",(0,c.jsxs)(n.h6,{id:"tip",children:["Tip",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#tip",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["如果你想要了解 ",(0,c.jsx)(n.code,{children:"package.json"})," 内在机制的更多信息，我们推荐阅读 ",(0,c.jsx)(n.a,{href:"https://docs.npmjs.com/files/package.json",target:"_blank",rel:"noopener noreferrer",children:"npm 文档"}),"。"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"package.json"})}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:' {\n   "name": "webpack-demo",\n   "version": "1.0.0",\n   "description": "",\n-  "main": "index.js",\n+  "private": true,\n   "scripts": {\n     "test": "echo \\"Error: no test specified\\" && exit 1"\n   },\n   "keywords": [],\n   "author": "",\n   "license": "MIT",\n   "devDependencies": {\n     "webpack": "^5.38.1",\n     "webpack-cli": "^4.7.2",\n   }\n }\n'})}),"\n",(0,c.jsxs)(n.p,{children:["在此示例中，",(0,c.jsx)(n.code,{children:"<script>"})," 标签之间存在隐式依赖关系。在 ",(0,c.jsx)(n.code,{children:"index.js"})," 文件执行之前，还需要在页面中先引入 ",(0,c.jsx)(n.code,{children:"lodash"}),"。这是因为 ",(0,c.jsx)(n.code,{children:"index.js"})," 并未显式声明它需要 ",(0,c.jsx)(n.code,{children:"lodash"}),"，假定推测已经存在一个全局变量 ",(0,c.jsx)(n.code,{children:"_"}),"。"]}),"\n",(0,c.jsx)(n.p,{children:"使用这种方式去管理 JavaScript 项目会有一些问题："}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"无法直接体现，脚本的执行依赖于外部库。"}),"\n",(0,c.jsx)(n.li,{children:"如果依赖不存在，或者引入顺序错误，应用程序将无法正常运行。"}),"\n",(0,c.jsx)(n.li,{children:"如果依赖被引入但是并没有使用，浏览器将被迫下载无用代码。"}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"让我们使用 webpack 来管理这些脚本。"}),"\n",(0,c.jsxs)(n.h2,{id:"创建一个-bundle",children:["创建一个 bundle",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#创建一个-bundle",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["首先，我们稍微调整下目录结构，创建分发代码(",(0,c.jsx)(n.code,{children:"./dist"}),")文件夹用于存放分发代码，源代码(",(0,c.jsx)(n.code,{children:"./src"}),")文件夹仍存放源代码。源代码是指用于书写和编辑的代码。分发代码是指在构建过程中，经过最小化和优化后产生的输出结果，最终将在浏览器中加载。调整后目录结构如下："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"project"})}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"  webpack-demo\n  |- package.json\n+ |- /dist\n+   |- index.html\n- |- index.html\n  |- /src\n    |- index.js\n"})}),"\n",(0,c.jsxs)(n.h6,{id:"tip-1",children:["Tip",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#tip-1",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["你可能会发现，尽管 ",(0,c.jsx)(n.code,{children:"index.html"})," 目前放在 ",(0,c.jsx)(n.code,{children:"dist"})," 目录下，但它是手动创建的。在指南的",(0,c.jsx)(n.a,{href:"https://webpack.docschina.org/guides/output-management/#setting-up-htmlwebpackplugin",target:"_blank",rel:"noopener noreferrer",children:"后续章节"}),"中，我们会教你如何生成 ",(0,c.jsx)(n.code,{children:"index.html"})," 而非手动编辑它。如此做，便可安全地清空 ",(0,c.jsx)(n.code,{children:"dist"})," 目录并重新生成目录中的所有文件。"]}),"\n",(0,c.jsxs)(n.p,{children:["要在 ",(0,c.jsx)(n.code,{children:"index.js"})," 中打包 ",(0,c.jsx)(n.code,{children:"lodash"})," 依赖，我们需要在本地安装 library："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"npm install --save lodash\n"})}),"\n",(0,c.jsxs)(n.h6,{id:"tip-2",children:["Tip",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#tip-2",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["在安装一个 package，而此 package 要打包到生产环境 bundle 中时，你应该使用 ",(0,c.jsx)(n.code,{children:"npm install --save"}),"。如果你在安装一个用于开发环境的 package 时（例如，linter, 测试库等），你应该使用 ",(0,c.jsx)(n.code,{children:"npm install --save-dev"}),"。更多信息请查看 ",(0,c.jsx)(n.a,{href:"https://docs.npmjs.com/cli/install",target:"_blank",rel:"noopener noreferrer",children:"npm 文档"}),"。"]}),"\n",(0,c.jsxs)(n.p,{children:["现在，在我们的 script 中 import ",(0,c.jsx)(n.code,{children:"lodash"}),"："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"src/index.js"})}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"+import _ from 'lodash';\n+\n function component() {\n   const element = document.createElement('div');\n\n-  // lodash（目前通过一个 script 引入）对于执行这一行是必需的\n+  // lodash 在当前 script 中使用 import 引入\n   element.innerHTML = _.join(['Hello', 'webpack'], ' ');\n\n   return element;\n }\n\n document.body.appendChild(component());\n"})}),"\n",(0,c.jsxs)(n.p,{children:["现在，我们将会打包所有脚本，我们必须更新 ",(0,c.jsx)(n.code,{children:"index.html"})," 文件。由于现在是通过 ",(0,c.jsx)(n.code,{children:"import"})," 引入 lodash，所以要将 lodash ",(0,c.jsx)(n.code,{children:"<script>"})," 删除，然后修改另一个 ",(0,c.jsx)(n.code,{children:"<script>"})," 标签来加载 bundle，而不是原始的 ",(0,c.jsx)(n.code,{children:"./src"})," 文件："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"dist/index.html"})}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:' <!DOCTYPE html>\n <html>\n   <head>\n     <meta charset="utf-8" />\n     <title>起步</title>\n-    <script src="https://unpkg.com/lodash@4.17.20"><\/script>\n   </head>\n   <body>\n-    <script src="./src/index.js"><\/script>\n+    <script src="main.js"><\/script>\n   </body>\n </html>\n'})}),"\n",(0,c.jsxs)(n.p,{children:["在这个设置中，",(0,c.jsx)(n.code,{children:"index.js"})," 显式要求引入的 ",(0,c.jsx)(n.code,{children:"lodash"})," 必须存在，然后将它绑定为 ",(0,c.jsx)(n.code,{children:"_"}),"（没有全局作用域污染）。通过声明模块所需的依赖，webpack 能够利用这些信息去构建依赖图，然后使用图生成一个优化过的 bundle，并且会以正确顺序执行。"]}),"\n",(0,c.jsxs)(n.p,{children:["可以这样说，执行 ",(0,c.jsx)(n.code,{children:"npx webpack"}),"，会将我们的脚本 ",(0,c.jsx)(n.code,{children:"src/index.js"})," 作为 ",(0,c.jsx)(n.a,{href:"https://webpack.docschina.org/concepts/entry-points",target:"_blank",rel:"noopener noreferrer",children:"入口起点"}),"，也会生成 ",(0,c.jsx)(n.code,{children:"dist/main.js"})," 作为 ",(0,c.jsx)(n.a,{href:"https://webpack.docschina.org/concepts/output",target:"_blank",rel:"noopener noreferrer",children:"输出"}),"。Node 8.2/npm 5.2.0 以上版本提供的 ",(0,c.jsx)(n.code,{children:"npx"})," 命令，可以运行在初次安装的 webpack package 中的 webpack 二进制文件（即 ",(0,c.jsx)(n.code,{children:"./node_modules/.bin/webpack"}),"）："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"$ npx webpack\n[webpack-cli] Compilation finished\nasset main.js 69.3 KiB [emitted] [minimized] (name: main) 1 related asset\nruntime modules 1000 bytes 5 modules\ncacheable modules 530 KiB\n  ./src/index.js 257 bytes [built] [code generated]\n  ./node_modules/lodash/lodash.js 530 KiB [built] [code generated]\nwebpack 5.4.0 compiled successfully in 1851 ms\n"})}),"\n",(0,c.jsxs)(n.h6,{id:"tip-3",children:["Tip",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#tip-3",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"输出可能会稍有不同，但是只要构建成功，那么你就可以放心继续。"}),"\n",(0,c.jsxs)(n.p,{children:["在浏览器中打开 ",(0,c.jsx)(n.code,{children:"dist"})," 目录下的 ",(0,c.jsx)(n.code,{children:"index.html"}),"，如果一切正常，你应该能看到以下文本：",(0,c.jsx)(n.code,{children:"'Hello webpack'"}),"。"]}),"\n",(0,c.jsxs)(n.h2,{id:"模块",children:["模块",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#模块",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.a,{href:"https://babeljs.io/learn-es2015/",target:"_blank",rel:"noopener noreferrer",children:"ES2015"})," 中的 ",(0,c.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import",target:"_blank",rel:"noopener noreferrer",children:(0,c.jsx)(n.code,{children:"import"})})," 和 ",(0,c.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export",target:"_blank",rel:"noopener noreferrer",children:(0,c.jsx)(n.code,{children:"export"})})," 语句已经被标准化。虽然大多数浏览器还无法支持它们，但是 webpack 却能够提供开箱即用般的支持。"]}),"\n",(0,c.jsxs)(n.p,{children:["事实上，webpack 在幕后会将代码 “",(0,c.jsx)(n.strong,{children:"转译"}),"”，以便旧版本浏览器可以执行。如果你检查 ",(0,c.jsx)(n.code,{children:"dist/main.js"}),"，你可以看到 webpack 具体如何实现，这是独创精巧的设计！除了 ",(0,c.jsx)(n.code,{children:"import"})," 和 ",(0,c.jsx)(n.code,{children:"export"}),"，webpack 还能够很好地支持多种其他模块语法，更多信息请查看 ",(0,c.jsx)(n.a,{href:"https://webpack.docschina.org/api/module-methods",target:"_blank",rel:"noopener noreferrer",children:"模块 API"}),"。"]}),"\n",(0,c.jsxs)(n.p,{children:["注意，webpack 不会更改代码中除 ",(0,c.jsx)(n.code,{children:"import"})," 和 ",(0,c.jsx)(n.code,{children:"export"})," 语句以外的部分。如果你在使用其它 ",(0,c.jsx)(n.a,{href:"http://es6-features.org/",target:"_blank",rel:"noopener noreferrer",children:"ES2015 特性"}),"，请确保你在 webpack ",(0,c.jsx)(n.a,{href:"https://webpack.docschina.org/concepts/loaders/",target:"_blank",rel:"noopener noreferrer",children:"loader 系统"})," 中使用了一个像是 ",(0,c.jsx)(n.a,{href:"https://babel.docschina.org/",target:"_blank",rel:"noopener noreferrer",children:"Babel"})," 或 ",(0,c.jsx)(n.a,{href:"https://buble.surge.sh/guide/",target:"_blank",rel:"noopener noreferrer",children:"Bubl\xe9"})," 的 ",(0,c.jsx)(n.a,{href:"https://webpack.docschina.org/loaders/#transpiling",target:"_blank",rel:"noopener noreferrer",children:"transpiler(转译器)"}),"。"]}),"\n",(0,c.jsxs)(n.h2,{id:"使用一个配置文件",children:["使用一个配置文件",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#使用一个配置文件",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["在 webpack v4 中，可以无须任何配置，然而大多数项目会需要很复杂的设置，这就是为什么 webpack 仍然要支持 ",(0,c.jsx)(n.a,{href:"https://webpack.docschina.org/concepts/configuration",target:"_blank",rel:"noopener noreferrer",children:"配置文件"}),"。这比在 terminal(终端) 中手动输入大量命令要高效的多，所以让我们创建一个配置文件："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"project"})}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"  webpack-demo\n  |- package.json\n+ |- webpack.config.js\n  |- /dist\n    |- index.html\n  |- /src\n    |- index.js\n"})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"webpack.config.js"})}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"const path = require('path');\n\nmodule.exports = {\n  entry: './src/index.js',\n  output: {\n    filename: 'main.js',\n    path: path.resolve(__dirname, 'dist'),\n  },\n};\n"})}),"\n",(0,c.jsx)(n.p,{children:"现在，让我们通过新的配置文件再次执行构建："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"$ npx webpack --config webpack.config.js\n[webpack-cli] Compilation finished\nasset main.js 69.3 KiB [compared for emit] [minimized] (name: main) 1 related asset\nruntime modules 1000 bytes 5 modules\ncacheable modules 530 KiB\n  ./src/index.js 257 bytes [built] [code generated]\n  ./node_modules/lodash/lodash.js 530 KiB [built] [code generated]\nwebpack 5.4.0 compiled successfully in 1934 ms\n"})}),"\n",(0,c.jsxs)(n.h6,{id:"tip-4",children:["Tip",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#tip-4",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["如果 ",(0,c.jsx)(n.code,{children:"webpack.config.js"})," 存在，则 ",(0,c.jsx)(n.code,{children:"webpack"})," 命令将默认选择使用它。我们在这里使用 ",(0,c.jsx)(n.code,{children:"--config"})," 选项只是向你表明，可以传递任何名称的配置文件。这对于需要拆分成多个文件的复杂配置是非常有用的。"]}),"\n",(0,c.jsxs)(n.p,{children:["比起 CLI 这种简单直接的使用方式，配置文件具有更多的灵活性。我们可以通过配置方式指定 loader 规则(loader rule)、plugin(插件)、resolve 选项，以及许多其他增强功能。更多详细信息请查看 ",(0,c.jsx)(n.a,{href:"https://webpack.docschina.org/configuration",target:"_blank",rel:"noopener noreferrer",children:"配置文档"}),"。"]}),"\n",(0,c.jsxs)(n.h2,{id:"npm-scripts",children:["npm scripts",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#npm-scripts",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["考虑到用 CLI 这种方式来运行本地的 webpack 副本并不是特别方便，我们可以设置一个快捷方式。调整 ",(0,c.jsx)(n.em,{children:"package.json"})," 文件，添加一个 ",(0,c.jsx)(n.a,{href:"https://docs.npmjs.com/misc/scripts",target:"_blank",rel:"noopener noreferrer",children:"npm script"}),"："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"package.json"})}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:' {\n   "name": "webpack-demo",\n   "version": "1.0.0",\n   "description": "",\n   "private": true,\n   "scripts": {\n-    "test": "echo \\"Error: no test specified\\" && exit 1"\n+    "test": "echo \\"Error: no test specified\\" && exit 1",\n+    "build": "webpack"\n   },\n   "keywords": [],\n   "author": "",\n   "license": "ISC",\n   "devDependencies": {\n     "webpack": "^5.4.0",\n     "webpack-cli": "^4.2.0"\n   },\n   "dependencies": {\n     "lodash": "^4.17.20"\n   }\n }\n'})}),"\n",(0,c.jsxs)(n.p,{children:["现在，可以使用 ",(0,c.jsx)(n.code,{children:"npm run build"})," 命令，来替代我们之前使用的 ",(0,c.jsx)(n.code,{children:"npx"})," 命令。注意，使用 npm ",(0,c.jsx)(n.code,{children:"scripts"}),"，我们可以像使用 ",(0,c.jsx)(n.code,{children:"npx"})," 那样通过模块名引用本地安装的 npm packages。这是大多数基于 npm 的项目遵循的标准，因为它允许所有贡献者使用同一组通用脚本。"]}),"\n",(0,c.jsx)(n.p,{children:"现在运行以下命令，然后看看你的脚本别名是否正常运行："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"$ npm run build\n\n...\n\n[webpack-cli] Compilation finished\nasset main.js 69.3 KiB [compared for emit] [minimized] (name: main) 1 related asset\nruntime modules 1000 bytes 5 modules\ncacheable modules 530 KiB\n  ./src/index.js 257 bytes [built] [code generated]\n  ./node_modules/lodash/lodash.js 530 KiB [built] [code generated]\nwebpack 5.4.0 compiled successfully in 1940 ms\n"})}),"\n",(0,c.jsxs)(n.h6,{id:"tip-5",children:["Tip",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#tip-5",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["可以通过在 ",(0,c.jsx)(n.code,{children:"npm run build"})," 命令与参数之间添加两个连接符的方式向 webpack 传递自定义参数，例如：",(0,c.jsx)(n.code,{children:"npm run build -- --color"}),"。"]}),"\n",(0,c.jsxs)(n.h2,{id:"结论",children:["结论",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#结论",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["现在，你已经有了一个基础构建配置，你应该移至下一章节 ",(0,c.jsx)(n.a,{href:"https://webpack.docschina.org/guides/asset-management",target:"_blank",rel:"noopener noreferrer",children:(0,c.jsx)(n.code,{children:"资源管理"})})," 指南，以了解如何通过 webpack 来管理资源，例如 images、fonts。此刻你的项目看起来应该如下："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"project"})}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"webpack-demo\n|- package.json\n|- webpack.config.js\n|- /dist\n  |- main.js\n  |- index.html\n|- /src\n  |- index.js\n|- /node_modules\n"})}),"\n",(0,c.jsxs)(n.h6,{id:"tip-6",children:["Tip",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#tip-6",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["如果你使用的是 npm 5+，你可能还会在目录中看到一个 ",(0,c.jsx)(n.code,{children:"package-lock.json"})," 文件。"]}),"\n",(0,c.jsxs)(n.h6,{id:"warning-1",children:["Warning",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#warning-1",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"不要使用 webpack 编译不可信的代码。它可能会在你的计算机，远程服务器或者在你 web 应用程序使用者的浏览器中执行恶意代码。"}),"\n",(0,c.jsxs)(n.p,{children:["如果想要了解 webpack 设计思想，你应该看下 ",(0,c.jsx)(n.a,{href:"https://webpack.docschina.org/concepts",target:"_blank",rel:"noopener noreferrer",children:"基本概念"})," 和 ",(0,c.jsx)(n.a,{href:"https://webpack.docschina.org/configuration",target:"_blank",rel:"noopener noreferrer",children:"配置"})," 页面。此外，",(0,c.jsx)(n.a,{href:"https://webpack.docschina.org/api",target:"_blank",rel:"noopener noreferrer",children:"API"})," 章节可以深入了解 webpack 提供的各种接口。"]})]})}function d(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(i,{...e})}):i(e)}let a=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["webpack%2F07-webpack%20%E5%AE%98%E6%96%B9%E8%B5%B7%E6%AD%A5.md"]={toc:[{text:"基本安装",id:"基本安装",depth:2},{text:"创建一个 bundle",id:"创建一个-bundle",depth:2},{text:"模块",id:"模块",depth:2},{text:"使用一个配置文件",id:"使用一个配置文件",depth:2},{text:"npm scripts",id:"npm-scripts",depth:2},{text:"结论",id:"结论",depth:2}],title:"webpack 起步",frontmatter:{}}}}]);