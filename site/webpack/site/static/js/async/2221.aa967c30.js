"use strict";(self.webpackChunk=self.webpackChunk||[]).push([["2221"],{490:function(e,n,r){r.r(n),r.d(n,{default:function(){return i}});var c=r(6469),d=r(8809);function s(e){let n=Object.assign({h1:"h1",a:"a",p:"p",code:"code",pre:"pre",img:"img",h3:"h3",ul:"ul",li:"li",blockquote:"blockquote",h4:"h4"},(0,d.ah)(),e.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(n.h1,{id:"带你深度解锁webpack系列优化篇",children:["带你深度解锁Webpack系列(优化篇)",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#带你深度解锁webpack系列优化篇",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"统计信息：字数 24100  阅读49分钟"}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.a,{href:"https://juejin.cn/user/3368559358523944/posts",target:"_blank",rel:"noopener noreferrer",children:"无名之苝"})}),"\n",(0,c.jsx)(n.p,{children:"2020-03-1672,326阅读9分钟"}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.a,{href:"https://juejin.cn/post/6844904079219490830",target:"_blank",rel:"noopener noreferrer",children:"带你深度解锁Webpack系列(基础篇)"})," 和 ",(0,c.jsx)(n.a,{href:"https://juejin.cn/post/6844904084927938567",target:"_blank",rel:"noopener noreferrer",children:"带你深度解锁Webpack系列(进阶篇)"}),"，主要是讲解了 ",(0,c.jsx)(n.code,{children:"Webpack"})," 的配置，但是随着项目越来越大，构建速度可能会越来越慢，构建出来的js的体积也越来越大，此时就需要对 ",(0,c.jsx)(n.code,{children:"Webpack"})," 的配置进行优化。"]}),"\n",(0,c.jsxs)(n.p,{children:["本文罗列出了十多种优化方式，大家可以结合自己的项目，选择适当的方式进行优化。这些 ",(0,c.jsx)(n.code,{children:"Webpack"})," 插件的源码我大多也没有看过，主要是结合 ",(0,c.jsx)(n.code,{children:"Webpack"})," 官方文档以及项目实践，并且花了大量的时间验证后输出了本文，如果文中有错误的地方，欢迎在评论区指正。"]}),"\n",(0,c.jsxs)(n.p,{children:["鉴于前端技术变更迅速，祭出本篇文章基于 ",(0,c.jsx)(n.code,{children:"Webpack"})," 的版本号:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"├── webpack@4.41.5 \n└── webpack-cli@3.3.10 \n"})}),"\n",(0,c.jsxs)(n.p,{children:["本文对应的项目地址(编写本文时使用)供参考：",(0,c.jsx)(n.a,{href:"https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FYvetteLau%2Fwebpack%2Ftree%2Fmaster%2Fwebpack-optimize",target:"_blank",rel:"noopener noreferrer",children:"github.com/YvetteLau/w…"})]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.img,{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/9/170bae7ee866b278~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png",alt:"img"})}),"\n",(0,c.jsxs)(n.h3,{id:"量化",children:["量化",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#量化",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"有时，我们以为的优化是负优化，这时，如果有一个量化的指标可以看出前后对比，那将会是再好不过的一件事。"}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"speed-measure-webpack-plugin"})," 插件可以测量各个插件和",(0,c.jsx)(n.code,{children:"loader"}),"所花费的时间，使用之后，构建时，会得到类似下面这样的信息："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.img,{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/14/170d9bf274c164c1~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png",alt:"smp.jpeg"})}),"\n",(0,c.jsx)(n.p,{children:"对比前后的信息，来确定优化的效果。"}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.a,{href:"https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fspeed-measure-webpack-plugin",target:"_blank",rel:"noopener noreferrer",children:"speed-measure-webpack-plugin"})," 的使用很简单，可以直接用其来包裹 ",(0,c.jsx)(n.code,{children:"Webpack"})," 的配置:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:'//webpack.config.js\nconst SpeedMeasurePlugin = require("speed-measure-webpack-plugin");\nconst smp = new SpeedMeasurePlugin();\n\nconst config = {\n    //...webpack配置\n}\n\nmodule.exports = smp.wrap(config);\n'})}),"\n",(0,c.jsxs)(n.h3,{id:"1excludeinclude",children:["1.exclude/include",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1excludeinclude",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["我们可以通过 ",(0,c.jsx)(n.code,{children:"exclude"}),"、",(0,c.jsx)(n.code,{children:"include"})," 配置来确保转译尽可能少的文件。顾名思义，",(0,c.jsx)(n.code,{children:"exclude"})," 指定要排除的文件，",(0,c.jsx)(n.code,{children:"include"})," 指定要包含的文件。"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"exclude"})," 的优先级高于 ",(0,c.jsx)(n.code,{children:"include"}),"，在 ",(0,c.jsx)(n.code,{children:"include"})," 和 ",(0,c.jsx)(n.code,{children:"exclude"})," 中使用绝对路径数组，尽量避免 ",(0,c.jsx)(n.code,{children:"exclude"}),"，更倾向于使用 ",(0,c.jsx)(n.code,{children:"include"}),"。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"//webpack.config.js\nconst path = require('path');\nmodule.exports = {\n    //...\n    module: {\n        rules: [\n            {\n                test: /\\.js[x]?$/,\n                use: ['babel-loader'],\n                include: [path.resolve(__dirname, 'src')]\n            }\n        ]\n    },\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["下图是我未配置 ",(0,c.jsx)(n.code,{children:"include"})," 和配置了 ",(0,c.jsx)(n.code,{children:"include"})," 的构建结果对比："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.img,{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/14/170d9bf279131194~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png",alt:"include:exclude.jpeg"})}),"\n",(0,c.jsxs)(n.h3,{id:"2-cache-loader",children:["2. cache-loader",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-cache-loader",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["在一些性能开销较大的 ",(0,c.jsx)(n.code,{children:"loader"})," 之前添加 ",(0,c.jsx)(n.code,{children:"cache-loader"}),"，将结果缓存中磁盘中。默认保存在 ",(0,c.jsx)(n.code,{children:"node_modueles/.cache/cache-loader"})," 目录下。"]}),"\n",(0,c.jsx)(n.p,{children:"首先安装依赖："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"npm install cache-loader -D\n"})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"cache-loader"})," 的配置很简单，放在其他 ",(0,c.jsx)(n.code,{children:"loader"})," 之前即可。修改",(0,c.jsx)(n.code,{children:"Webpack"})," 的配置如下:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"module.exports = {\n    //...\n    \n    module: {\n        //我的项目中,babel-loader耗时比较长，所以我给它配置了`cache-loader`\n        rules: [\n            {\n                test: /\\.jsx?$/,\n                use: ['cache-loader','babel-loader']\n            }\n        ]\n    }\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["如果你跟我一样，只打算给 ",(0,c.jsx)(n.code,{children:"babel-loader"})," 配置 ",(0,c.jsx)(n.code,{children:"cache"})," 的话，也可以不使用 ",(0,c.jsx)(n.code,{children:"cache-loader"}),"，给 ",(0,c.jsx)(n.code,{children:"babel-loader"})," 增加选项 ",(0,c.jsx)(n.code,{children:"cacheDirectory"}),"。"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.img,{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/14/170d9bf279c1cd59~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png",alt:"cache-loader.jpeg"})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"cacheDirectory"}),"：默认值为 ",(0,c.jsx)(n.code,{children:"false"}),"。当有设置时，指定的目录将用来缓存 ",(0,c.jsx)(n.code,{children:"loader"})," 的执行结果。之后的 ",(0,c.jsx)(n.code,{children:"Webpack"})," 构建，将会尝试读取缓存，来避免在每次执行时，可能产生的、高性能消耗的 ",(0,c.jsx)(n.code,{children:"Babel"})," 重新编译过程。设置空值或者 ",(0,c.jsx)(n.code,{children:"true"})," 的话，使用默认缓存目录：",(0,c.jsx)(n.code,{children:"node_modules/.cache/babel-loader"}),"。开启 ",(0,c.jsx)(n.code,{children:"babel-loader"}),"的缓存和配置 ",(0,c.jsx)(n.code,{children:"cache-loader"}),"，我比对了下，构建时间很接近。"]}),"\n",(0,c.jsxs)(n.h3,{id:"3happypack",children:["3.happypack",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3happypack",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["由于有大量文件需要解析和处理，构建是文件读写和计算密集型的操作，特别是当文件数量变多后，",(0,c.jsx)(n.code,{children:"Webpack"})," 构建慢的问题会显得严重。文件读写和计算操作是无法避免的，那能不能让 ",(0,c.jsx)(n.code,{children:"Webpack"})," 同一时刻处理多个任务，发挥多核 CPU 电脑的威力，以提升构建速度呢？"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"HappyPack"})," 就能让 ",(0,c.jsx)(n.code,{children:"Webpack"})," 做到这点，它把任务分解给多个子进程去并发的执行，子进程处理完后再把结果发送给主进程。"]}),"\n",(0,c.jsxs)(n.p,{children:["首先需要安装 ",(0,c.jsx)(n.code,{children:"happypack"}),":"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"npm install happypack -D\n"})}),"\n",(0,c.jsx)(n.p,{children:"修改配置文件:"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"const Happypack = require('happypack');\nmodule.exports = {\n    //...\n    module: {\n        rules: [\n            {\n                test: /\\.js[x]?$/,\n                use: 'Happypack/loader?id=js',\n                include: [path.resolve(__dirname, 'src')]\n            },\n            {\n                test: /\\.css$/,\n                use: 'Happypack/loader?id=css',\n                include: [\n                    path.resolve(__dirname, 'src'),\n                    path.resolve(__dirname, 'node_modules', 'bootstrap', 'dist')\n                ]\n            }\n        ]\n    },\n    plugins: [\n        new Happypack({\n            id: 'js', //和rule中的id=js对应\n            //将之前 rule 中的 loader 在此配置\n            use: ['babel-loader'] //必须是数组\n        }),\n        new Happypack({\n            id: 'css',//和rule中的id=css对应\n            use: ['style-loader', 'css-loader','postcss-loader'],\n        })\n    ]\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"happypack"})," 默认开启 ",(0,c.jsx)(n.code,{children:"CPU核数 - 1"})," 个进程，当然，我们也可以传递 ",(0,c.jsx)(n.code,{children:"threads"})," 给 ",(0,c.jsx)(n.code,{children:"Happypack"}),"。"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.img,{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/14/170d9bf27caaa71c~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png",alt:"happypack.jpeg"})}),"\n",(0,c.jsxs)(n.p,{children:["说明：当 ",(0,c.jsx)(n.code,{children:"postcss-loader"})," 配置在 ",(0,c.jsx)(n.code,{children:"Happypack"})," 中，必须要在项目中创建 ",(0,c.jsx)(n.code,{children:"postcss.config.js"}),"。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"//postcss.config.js\nmodule.exports = {\n    plugins: [\n        require('autoprefixer')()\n    ]\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["否则，会抛出错误: ",(0,c.jsx)(n.code,{children:"Error: No PostCSS Config found"})]}),"\n",(0,c.jsxs)(n.p,{children:["另外，当你的项目不是很复杂时，不需要配置 ",(0,c.jsx)(n.code,{children:"happypack"}),"，因为进程的分配和管理也需要时间，并不能有效提升构建速度，甚至会变慢。"]}),"\n",(0,c.jsxs)(n.h3,{id:"4thread-loader",children:["4.thread-loader",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4thread-loader",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["除了使用 ",(0,c.jsx)(n.code,{children:"Happypack"})," 外，我们也可以使用 ",(0,c.jsx)(n.code,{children:"thread-loader"})," ，把 ",(0,c.jsx)(n.code,{children:"thread-loader"})," 放置在其它 ",(0,c.jsx)(n.code,{children:"loader"})," 之前，那么放置在这个 ",(0,c.jsx)(n.code,{children:"loader"})," 之后的 ",(0,c.jsx)(n.code,{children:"loader"})," 就会在一个单独的 ",(0,c.jsx)(n.code,{children:"worker"})," 池中运行。"]}),"\n",(0,c.jsx)(n.p,{children:"在 worker 池(worker pool)中运行的 loader 是受到限制的。例如："}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["这些 ",(0,c.jsx)(n.code,{children:"loader"})," 不能产生新的文件。"]}),"\n",(0,c.jsxs)(n.li,{children:["这些 ",(0,c.jsx)(n.code,{children:"loader"})," 不能使用定制的 ",(0,c.jsx)(n.code,{children:"loader"})," API（也就是说，通过插件）。"]}),"\n",(0,c.jsxs)(n.li,{children:["这些 ",(0,c.jsx)(n.code,{children:"loader"})," 无法获取 ",(0,c.jsx)(n.code,{children:"webpack"})," 的选项设置。"]}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"首先安装依赖："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"npm install thread-loader -D\n"})}),"\n",(0,c.jsx)(n.p,{children:"修改配置:"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"module.exports = {\n    module: {\n        //我的项目中,babel-loader耗时比较长，所以我给它配置 thread-loader\n        rules: [\n            {\n                test: /\\.jsx?$/,\n                use: ['thread-loader', 'cache-loader', 'babel-loader']\n            }\n        ]\n    }\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"thread-loader"})," 和 ",(0,c.jsx)(n.code,{children:"Happypack"})," 我对比了一下，构建时间基本没什么差别。不过 ",(0,c.jsx)(n.code,{children:"thread-loader"})," 配置起来为简单。"]}),"\n",(0,c.jsxs)(n.h3,{id:"5开启-js-多进程压缩",children:["5.开启 JS 多进程压缩",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#5开启-js-多进程压缩",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["虽然很多 ",(0,c.jsx)(n.code,{children:"webpack"})," 优化的文章上会提及多进程压缩的优化，不管是 ",(0,c.jsx)(n.code,{children:"webpack-parallel-uglify-plugin"})," 或者是 ",(0,c.jsx)(n.code,{children:"uglifyjs-webpack-plugin"})," 配置 ",(0,c.jsx)(n.code,{children:"parallel"}),"。不过这里我要说一句，没必要单独安装这些插件，它们并不会让你的 ",(0,c.jsx)(n.code,{children:"Webpack"})," 构建速度提升。"]}),"\n",(0,c.jsxs)(n.p,{children:["当前 ",(0,c.jsx)(n.code,{children:"Webpack"})," 默认使用的是 ",(0,c.jsx)(n.code,{children:"TerserWebpackPlugin"}),"，默认就开启了多进程和缓存，构建时，你的项目中可以看到 ",(0,c.jsx)(n.code,{children:"terser"})," 的缓存文件 ",(0,c.jsx)(n.code,{children:"node_modules/.cache/terser-webpack-plugin"}),"。"]}),"\n",(0,c.jsxs)(n.h3,{id:"6hardsourcewebpackplugin",children:["6.HardSourceWebpackPlugin",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#6hardsourcewebpackplugin",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"HardSourceWebpackPlugin"})," 为模块提供中间缓存，缓存默认的存放路径是: ",(0,c.jsx)(n.code,{children:"node_modules/.cache/hard-source"}),"。"]}),"\n",(0,c.jsxs)(n.p,{children:["配置 ",(0,c.jsx)(n.code,{children:"hard-source-webpack-plugin"}),"，首次构建时间没有太大变化，但是第二次开始，构建时间大约可以节约 80%。"]}),"\n",(0,c.jsx)(n.p,{children:"首先安装依赖:"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"npm install hard-source-webpack-plugin -D\n"})}),"\n",(0,c.jsxs)(n.p,{children:["修改 ",(0,c.jsx)(n.code,{children:"webpack"})," 的配置："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"//webpack.config.js\nvar HardSourceWebpackPlugin = require('hard-source-webpack-plugin');\nmodule.exports = {\n    //...\n    plugins: [\n        new HardSourceWebpackPlugin()\n    ]\n}\n"})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.img,{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/14/170d9bf27e20fd0e~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png",alt:"img"})}),"\n",(0,c.jsxs)(n.p,{children:["用另外一个比较大的项目测试了下，配置了 ",(0,c.jsx)(n.code,{children:"HardSourceWebpackPlugin"}),"，构建时间从 8S 左右降到了 2S 左右。"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.a,{href:"https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fhard-source-webpack-plugin",target:"_blank",rel:"noopener noreferrer",children:"HardSourceWebpackPlugin文档中"})," 列出了一些你可能会遇到的问题以及如何解决，例如热更新失效，或者某些配置不生效等。"]}),"\n",(0,c.jsxs)(n.h3,{id:"7noparse",children:["7.noParse",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#7noparse",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["如果一些第三方模块没有AMD/CommonJS规范版本，可以使用 ",(0,c.jsx)(n.code,{children:"noParse"})," 来标识这个模块，这样 ",(0,c.jsx)(n.code,{children:"Webpack"})," 会引入这些模块，但是不进行转化和解析，从而提升 ",(0,c.jsx)(n.code,{children:"Webpack"})," 的构建性能 ，例如：",(0,c.jsx)(n.code,{children:"jquery"})," 、",(0,c.jsx)(n.code,{children:"lodash"}),"。"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.a,{href:"https://link.juejin.cn/?target=http%3A%2F%2Fwebpack.html.cn%2Fconfiguration%2Fmodule.html",target:"_blank",rel:"noopener noreferrer",children:"noParse"})," 属性的值是一个正则表达式或者是一个 ",(0,c.jsx)(n.code,{children:"function"}),"。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"//webpack.config.js\nmodule.exports = {\n    //...\n    module: {\n        noParse: /jquery|lodash/\n    }\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["我当前的 ",(0,c.jsx)(n.code,{children:"webpack-optimize"})," 项目中，没有使用 ",(0,c.jsx)(n.code,{children:"jquery"})," 或者是 ",(0,c.jsx)(n.code,{children:"lodash"}),"。"]}),"\n",(0,c.jsxs)(n.p,{children:["因此新建一个项目测试，只引入 ",(0,c.jsx)(n.code,{children:"jquery"})," 和 ",(0,c.jsx)(n.code,{children:"loadsh"}),"，然后配置 ",(0,c.jsx)(n.code,{children:"noParse"})," 和不配置 ",(0,c.jsx)(n.code,{children:"noParse"}),"，分别构建比对时间。"]}),"\n",(0,c.jsxs)(n.p,{children:["配置",(0,c.jsx)(n.code,{children:"noParse"})," 前，构建需要 ",(0,c.jsx)(n.code,{children:"2392ms"}),"。配置了 ",(0,c.jsx)(n.code,{children:"noParse"})," 之后，构建需要 ",(0,c.jsx)(n.code,{children:"1613ms"}),"。 如果你使用到了不需要解析的第三方依赖，那么配置 ",(0,c.jsx)(n.code,{children:"noParse"})," 很显然是一定会起到优化作用的。"]}),"\n",(0,c.jsxs)(n.h3,{id:"8resolve",children:["8.resolve",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#8resolve",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"resolve"})," 配置 ",(0,c.jsx)(n.code,{children:"webpack"})," 如何寻找模块所对应的文件。假设我们确定模块都从根目录下的 ",(0,c.jsx)(n.code,{children:"node_modules"})," 中查找，我们可以配置:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"//webpack.config.js\nconst path = require('path');\nmodule.exports = {\n    //...\n    resolve: {\n        modules: [path.resolve(__dirname, 'node_modules')],\n    }\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["需要记住的是，如果你配置了上述的 ",(0,c.jsx)(n.code,{children:"resolve.moudles"})," ，可能会出现问题，例如，你的依赖中还存在 ",(0,c.jsx)(n.code,{children:"node_modules"})," 目录，那么就会出现，对应的文件明明在，但是却提示找不到。因此呢，个人不推荐配置这个。如果其他同事不熟悉这个配置，遇到这个问题时，会摸不着头脑。"]}),"\n",(0,c.jsxs)(n.p,{children:["另外，",(0,c.jsx)(n.code,{children:"resolve"})," 的 ",(0,c.jsx)(n.code,{children:"extensions"})," 配置，默认是 ",(0,c.jsx)(n.code,{children:"['.js', '.json']"}),"，如果你要对它进行配置，记住将频率最高的后缀放在第一位，并且控制列表的长度，以减少尝试次数。"]}),"\n",(0,c.jsx)(n.p,{children:"本项目较小，因此测试时，此处优化效果不明显。"}),"\n",(0,c.jsxs)(n.h3,{id:"9ignoreplugin",children:["9.IgnorePlugin",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#9ignoreplugin",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"webpack"})," 的内置插件，作用是忽略第三方包指定目录。"]}),"\n",(0,c.jsxs)(n.p,{children:["例如: ",(0,c.jsx)(n.code,{children:"moment"})," (2.24.0版本) 会将所有本地化内容和核心功能一起打包，我们就可以使用 ",(0,c.jsx)(n.code,{children:"IgnorePlugin"})," 在打包时忽略本地化内容。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"//webpack.config.js\nmodule.exports = {\n    //...\n    plugins: [\n        //忽略 moment 下的 ./locale 目录\n        new webpack.IgnorePlugin(/^\\.\\/locale$/, /moment$/)\n    ]\n}\n"})}),"\n",(0,c.jsx)(n.p,{children:"在使用的时候，如果我们需要指定语言，那么需要我们手动的去引入语言包，例如，引入中文语言包:"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"import moment from 'moment';\nimport 'moment/locale/zh-cn';// 手动引入\n"})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"index.js"})," 中只引入 ",(0,c.jsx)(n.code,{children:"moment"}),"，打包出来的 ",(0,c.jsx)(n.code,{children:"bundle.js"})," 大小为 ",(0,c.jsx)(n.code,{children:"263KB"}),"，如果配置了 ",(0,c.jsx)(n.code,{children:"IgnorePlugin"}),"，单独引入 ",(0,c.jsx)(n.code,{children:"moment/locale/zh-cn"}),"，构建出来的包大小为 ",(0,c.jsx)(n.code,{children:"55KB"}),"。"]}),"\n",(0,c.jsxs)(n.h3,{id:"10externals",children:["10.externals",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#10externals",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["我们可以将一些JS文件存储在 ",(0,c.jsx)(n.code,{children:"CDN"})," 上(减少 ",(0,c.jsx)(n.code,{children:"Webpack"}),"打包出来的 ",(0,c.jsx)(n.code,{children:"js"})," 体积)，在 ",(0,c.jsx)(n.code,{children:"index.html"})," 中通过 ",(0,c.jsx)(n.code,{children:"<script>"})," 标签引入，如:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:'<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="X-UA-Compatible" content="ie=edge">\n    <title>Document</title>\n</head>\n<body>\n    <div id="root">root</div>\n    <script src="http://libs.baidu.com/jquery/2.0.0/jquery.min.js"><\/script>\n</body>\n</html>\n'})}),"\n",(0,c.jsxs)(n.p,{children:["我们希望在使用时，仍然可以通过 ",(0,c.jsx)(n.code,{children:"import"})," 的方式去引用(如 ",(0,c.jsx)(n.code,{children:"import $ from 'jquery'"}),")，并且希望 ",(0,c.jsx)(n.code,{children:"webpack"})," 不会对其进行打包，此时就可以配置 ",(0,c.jsx)(n.code,{children:"externals"}),"。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"//webpack.config.js\nmodule.exports = {\n    //...\n    externals: {\n        //jquery通过script引入之后，全局中即有了 jQuery 变量\n        'jquery': 'jQuery'\n    }\n}\n"})}),"\n",(0,c.jsxs)(n.h3,{id:"11dllplugin",children:["11.DllPlugin",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#11dllplugin",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["有些时候，如果所有的JS文件都打成一个JS文件，会导致最终生成的JS文件很大，这个时候，我们就要考虑拆分 ",(0,c.jsx)(n.code,{children:"bundles"}),"。"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"DllPlugin"})," 和 ",(0,c.jsx)(n.code,{children:"DLLReferencePlugin"})," 可以实现拆分 ",(0,c.jsx)(n.code,{children:"bundles"}),"，并且可以大大提升构建速度，",(0,c.jsx)(n.code,{children:"DllPlugin"})," 和 ",(0,c.jsx)(n.code,{children:"DLLReferencePlugin"})," 都是 ",(0,c.jsx)(n.code,{children:"webpack"})," 的内置模块。"]}),"\n",(0,c.jsxs)(n.p,{children:["我们使用 ",(0,c.jsx)(n.code,{children:"DllPlugin"})," 将不会频繁更新的库进行编译，当这些依赖的版本没有变化时，就不需要重新编译。我们新建一个 ",(0,c.jsx)(n.code,{children:"webpack"})," 的配置文件，来专门用于编译动态链接库，例如名为: ",(0,c.jsx)(n.code,{children:"webpack.config.dll.js"}),"，这里我们将 ",(0,c.jsx)(n.code,{children:"react"})," 和 ",(0,c.jsx)(n.code,{children:"react-dom"})," 单独打包成一个动态链接库。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"//webpack.config.dll.js\nconst webpack = require('webpack');\nconst path = require('path');\n\nmodule.exports = {\n    entry: {\n        react: ['react', 'react-dom']\n    },\n    mode: 'production',\n    output: {\n        filename: '[name].dll.[hash:6].js',\n        path: path.resolve(__dirname, 'dist', 'dll'),\n        library: '[name]_dll' //暴露给外部使用\n        //libraryTarget 指定如何暴露内容，缺省时就是 var\n    },\n    plugins: [\n        new webpack.DllPlugin({\n            //name和library一致\n            name: '[name]_dll', \n            path: path.resolve(__dirname, 'dist', 'dll', 'manifest.json') //manifest.json的生成路径\n        })\n    ]\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["在 ",(0,c.jsx)(n.code,{children:"package.json"})," 的 ",(0,c.jsx)(n.code,{children:"scripts"})," 中增加:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:'{\n    "scripts": {\n        "dev": "NODE_ENV=development webpack-dev-server",\n        "build": "NODE_ENV=production webpack",\n        "build:dll": "webpack --config webpack.config.dll.js"\n    },\n}\n'})}),"\n",(0,c.jsxs)(n.p,{children:["执行 ",(0,c.jsx)(n.code,{children:"npm run build:all"}),"，可以看到 ",(0,c.jsx)(n.code,{children:"dist"})," 目录如下，之所以将动态链接库单独放在 ",(0,c.jsx)(n.code,{children:"dll"})," 目录下，主要是为了使用 ",(0,c.jsx)(n.code,{children:"CleanWebpackPlugin"})," 更为方便的过滤掉动态链接库。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"dist\n└── dll\n    ├── manifest.json\n    └── react.dll.9dcd9d.js\n"})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"manifest.json"})," 用于让 ",(0,c.jsx)(n.code,{children:"DLLReferencePlugin"})," 映射到相关依赖上。"]}),"\n",(0,c.jsxs)(n.p,{children:["修改 ",(0,c.jsx)(n.code,{children:"webpack"})," 的主配置文件: ",(0,c.jsx)(n.code,{children:"webpack.config.js"})," 的配置："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"//webpack.config.js\nconst webpack = require('webpack');\nconst path = require('path');\nmodule.exports = {\n    //...\n    devServer: {\n        contentBase: path.resolve(__dirname, 'dist')\n    },\n    plugins: [\n        new webpack.DllReferencePlugin({\n            manifest: path.resolve(__dirname, 'dist', 'dll', 'manifest.json')\n        }),\n        new CleanWebpackPlugin({\n            cleanOnceBeforeBuildPatterns: ['**/*', '!dll', '!dll/**'] //不删除dll目录\n        }),\n        //...\n    ]\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["使用 ",(0,c.jsx)(n.code,{children:"npm run build"})," 构建，可以看到 ",(0,c.jsx)(n.code,{children:"bundle.js"})," 的体积大大减少。"]}),"\n",(0,c.jsxs)(n.p,{children:["修改 ",(0,c.jsx)(n.code,{children:"public/index.html"})," 文件，在其中引入 ",(0,c.jsx)(n.code,{children:"react.dll.js"})]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:'<script src="/dll/react.dll.9dcd9d.js"><\/script>\n'})}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"构建速度"}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.img,{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/14/170d9bf27efef7f5~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png",alt:"DllPlugin.jpeg"})}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"包体积"}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.img,{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/14/170d9bf2f995e7e2~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png",alt:"dll-size.jpeg"})}),"\n",(0,c.jsxs)(n.h3,{id:"12抽离公共代码",children:["12.抽离公共代码",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#12抽离公共代码",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"抽离公共代码是对于多页应用来说的，如果多个页面引入了一些公共模块，那么可以把这些公共的模块抽离出来，单独打包。公共代码只需要下载一次就缓存起来了，避免了重复下载。"}),"\n",(0,c.jsxs)(n.p,{children:["抽离公共代码对于单页应用和多页应该在配置上没有什么区别，都是配置在 ",(0,c.jsx)(n.code,{children:"optimization.splitChunks"})," 中。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"//webpack.config.js\nmodule.exports = {\n    optimization: {\n        splitChunks: {//分割代码块\n            cacheGroups: {\n                vendor: {\n                    //第三方依赖\n                    priority: 1, //设置优先级，首先抽离第三方模块\n                    name: 'vendor',\n                    test: /node_modules/,\n                    chunks: 'initial',\n                    minSize: 0,\n                    minChunks: 1 //最少引入了1次\n                },\n                //缓存组\n                common: {\n                    //公共模块\n                    chunks: 'initial',\n                    name: 'common',\n                    minSize: 100, //大小超过100个字节\n                    minChunks: 3 //最少引入了3次\n                }\n            }\n        }\n    }\n}\n"})}),"\n",(0,c.jsx)(n.p,{children:"即使是单页应用，同样可以使用这个配置，例如，打包出来的 bundle.js 体积过大，我们可以将一些依赖打包成动态链接库，然后将剩下的第三方依赖拆出来。这样可以有效减小 bundle.js 的体积大小。当然，你还可以继续提取业务代码的公共模块，此处，因为我项目中源码较少，所以没有配置。"}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.img,{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/14/170d9bf31f45e7a4~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png",alt:"splitChunks.jpeg"})}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"runtimeChunk"}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"runtimeChunk"})," 的作用是将包含 ",(0,c.jsx)(n.code,{children:"chunk"})," 映射关系的列表从 ",(0,c.jsx)(n.code,{children:"main.js"})," 中抽离出来，在配置了 ",(0,c.jsx)(n.code,{children:"splitChunk"})," 时，记得配置 ",(0,c.jsx)(n.code,{children:"runtimeChunk"}),"."]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"module.exports = {\n    //...\n    optimization: {\n        runtimeChunk: {\n            name: 'manifest'\n        }\n    }\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["最终构建出来的文件中会生成一个 ",(0,c.jsx)(n.code,{children:"manifest.js"}),"。"]}),"\n",(0,c.jsxs)(n.h4,{id:"借助-webpack-bundle-analyzer-进一步优化",children:["借助 webpack-bundle-analyzer 进一步优化",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#借助-webpack-bundle-analyzer-进一步优化",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["在做 ",(0,c.jsx)(n.code,{children:"webpack"})," 构建优化的时候，",(0,c.jsx)(n.code,{children:"vendor"})," 打出来超过了1M，",(0,c.jsx)(n.code,{children:"react"})," 和 ",(0,c.jsx)(n.code,{children:"react-dom"})," 已经打包成了DLL。"]}),"\n",(0,c.jsxs)(n.p,{children:["因此需要借助 ",(0,c.jsx)(n.code,{children:"webpack-bundle-analyzer"})," 查看一下是哪些包的体积较大。"]}),"\n",(0,c.jsx)(n.p,{children:"首先安装依赖："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"npm install webpack-bundle-analyzer -D\n"})}),"\n",(0,c.jsx)(n.p,{children:"使用也很简单，修改下我们的配置："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"//webpack.config.prod.js\nconst BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;\nconst merge = require('webpack-merge');\nconst baseWebpackConfig = require('./webpack.config.base');\nmodule.exports = merge(baseWebpackConfig, {\n    //....\n    plugins: [\n        //...\n        new BundleAnalyzerPlugin(),\n    ]\n})\n"})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"npm run build"})," 构建，会默认打开： ",(0,c.jsx)(n.code,{children:"http://127.0.0.1:8888/"}),"，可以看到各个包的体积："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.img,{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/14/170d9bf330fb2a0b~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png",alt:"W1.jpeg"})}),"\n",(0,c.jsxs)(n.p,{children:["进一步对 ",(0,c.jsx)(n.code,{children:"vendor"})," 进行拆分，将 ",(0,c.jsx)(n.code,{children:"vendor"})," 拆分成了4个(使用 ",(0,c.jsx)(n.code,{children:"splitChunks"})," 进行拆分即可)。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"module.exports = {\n    optimization: {\n    concatenateModules: false,\n    splitChunks: {//分割代码块\n      maxInitialRequests:6, //默认是5\n      cacheGroups: {\n        vendor: {\n          //第三方依赖\n          priority: 1,\n          name: 'vendor',\n          test: /node_modules/,\n          chunks: 'initial',\n          minSize: 100,\n          minChunks: 1 //重复引入了几次\n        },\n        'lottie-web': {\n          name: \"lottie-web\", // 单独将 react-lottie 拆包\n          priority: 5, // 权重需大于`vendor`\n          test: /[\\/]node_modules[\\/]lottie-web[\\/]/,\n          chunks: 'initial',\n          minSize: 100,\n          minChunks: 1 //重复引入了几次\n        },\n        //...\n      }\n    },\n  },\n}\n"})}),"\n",(0,c.jsx)(n.p,{children:"重新构建，结果如下所示："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.img,{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/14/170d9bf36fcad19c~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png",alt:"W2.jpeg"})}),"\n",(0,c.jsxs)(n.h3,{id:"13webpack自身的优化",children:["13.webpack自身的优化",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#13webpack自身的优化",children:"#"})]}),"\n",(0,c.jsxs)(n.h4,{id:"tree-shaking",children:["tree-shaking",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#tree-shaking",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["如果使用ES6的",(0,c.jsx)(n.code,{children:"import"})," 语法，那么在生产环境下，会自动移除没有使用到的代码。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"//math.js\nconst add = (a, b) => {\n    console.log('aaaaaa')\n    return a + b;\n}\n\nconst minus = (a, b) => {\n    console.log('bbbbbb')\n    return a - b;\n}\n\nexport {\n    add,\n    minus\n}\n//index.js\nimport {add, minus} from './math';\nadd(2,3);\n"})}),"\n",(0,c.jsxs)(n.p,{children:["构建的最终代码里，",(0,c.jsx)(n.code,{children:"minus"})," 函数不会被打包进去。"]}),"\n",(0,c.jsxs)(n.h4,{id:"scope-hosting-作用域提升",children:["scope hosting 作用域提升",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#scope-hosting-作用域提升",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"变量提升，可以减少一些变量声明。在生产环境下，默认开启。"}),"\n",(0,c.jsxs)(n.p,{children:["另外，大家测试的时候注意一下，",(0,c.jsx)(n.code,{children:"speed-measure-webpack-plugin"})," 和 ",(0,c.jsx)(n.code,{children:"HotModuleReplacementPlugin"})," 不能同时使用，否则会报错:"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.img,{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/14/170d9bf389ae1379~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png",alt:"img"})}),"\n",(0,c.jsxs)(n.h4,{id:"babel-配置的优化",children:["babel 配置的优化",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#babel-配置的优化",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["如果你对 ",(0,c.jsx)(n.code,{children:"babel"})," 还不太熟悉的话，那么可以阅读这篇文章：",(0,c.jsx)(n.a,{href:"https://juejin.cn/post/6844904008679686152",target:"_blank",rel:"noopener noreferrer",children:"不容错过的 Babel7 知识"}),"。"]}),"\n",(0,c.jsxs)(n.p,{children:["在不配置 ",(0,c.jsx)(n.code,{children:"@babel/plugin-transform-runtime"})," 时，",(0,c.jsx)(n.code,{children:"babel"})," 会使用很小的辅助函数来实现类似 ",(0,c.jsx)(n.code,{children:"_createClass"})," 等公共方法。默认情况下，它将被注入(",(0,c.jsx)(n.code,{children:"inject"}),")到需要它的每个文件中。但是这样的结果就是导致构建出来的JS体积变大。"]}),"\n",(0,c.jsxs)(n.p,{children:["我们也并不需要在每个 ",(0,c.jsx)(n.code,{children:"js"})," 中注入辅助函数，因此我们可以使用 ",(0,c.jsx)(n.code,{children:"@babel/plugin-transform-runtime"}),"，",(0,c.jsx)(n.code,{children:"@babel/plugin-transform-runtime"})," 是一个可以重复使用 ",(0,c.jsx)(n.code,{children:"Babel"})," 注入的帮助程序，以节省代码大小的插件。"]}),"\n",(0,c.jsxs)(n.p,{children:["因此我们可以在 ",(0,c.jsx)(n.code,{children:".babelrc"})," 中增加 ",(0,c.jsx)(n.code,{children:"@babel/plugin-transform-runtime"})," 的配置。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:'{\n    "presets": [],\n    "plugins": [\n        [\n            "@babel/plugin-transform-runtime"\n        ]\n    ]\n}\n'})}),"\n",(0,c.jsx)(n.p,{children:"以上就是我目前为止使用到的一些优化，如果你有更好的优化方式，欢迎在评论区留言，感谢阅读。"}),"\n",(0,c.jsxs)(n.p,{children:["看完这篇文之后，是时候去撸个脚手架了：",(0,c.jsx)(n.a,{href:"https://juejin.cn/post/6844903896163303438",target:"_blank",rel:"noopener noreferrer",children:"【中高级前端必备】手摸手教你撸一个脚手架"})]}),"\n",(0,c.jsxs)(n.h3,{id:"最后",children:["最后",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#最后",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.img,{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/14/170d9bf3c5cff80b~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png",alt:"掘金使用"})}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"参考文档："}),"\n"]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.a,{href:"https://juejin.cn/post/6844903974810681358",target:"_blank",rel:"noopener noreferrer",children:"webpack优化的一些基本方法"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.a,{href:"https://link.juejin.cn/?target=http%3A%2F%2Fwebpack.html.cn%2Fconfiguration%2Fmodule.html",target:"_blank",rel:"noopener noreferrer",children:"模块(Module)"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.a,{href:"https://link.juejin.cn/?target=http%3A%2F%2Fwebpack.html.cn%2Fplugins%2Fignore-plugin.html",target:"_blank",rel:"noopener noreferrer",children:"IgnorePlugin"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.a,{href:"https://link.juejin.cn/?target=http%3A%2F%2Fwebpack.html.cn%2Fplugins%2Fdll-plugin.html",target:"_blank",rel:"noopener noreferrer",children:"DllPlugin"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.a,{href:"https://juejin.cn/post/6844903777296728072",target:"_blank",rel:"noopener noreferrer",children:"使用 Webpack 的 DllPlugin 提升项目构建速度"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.a,{href:"https://link.juejin.cn/?target=http%3A%2F%2Fwww.xbhub.com%2Fwiki%2Fwebpack%2F4%E4%BC%98%E5%8C%96%2F4-3%E4%BD%BF%E7%94%A8HappyPack.html",target:"_blank",rel:"noopener noreferrer",children:"使用 HappyPack"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.a,{href:"https://link.juejin.cn/?target=https%3A%2F%2Fwww.cnblogs.com%2Fxieqian%2Fp%2F10973039.html",target:"_blank",rel:"noopener noreferrer",children:"webapck4抽取公共模块“SplitChunksPlugin”"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.a,{href:"https://link.juejin.cn/?target=https%3A%2F%2Fblog.csdn.net%2Fhope_It%2Farticle%2Fdetails%2F102691300",target:"_blank",rel:"noopener noreferrer",children:"webpack之优化篇（四）：hard-source-webpack-plugin,webpack DllPlugin配置的代替方案"})}),"\n"]})]})}function l(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,d.ah)(),e.components);return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(s,{...e})}):s(e)}let i=l;l.__RSPRESS_PAGE_META={},l.__RSPRESS_PAGE_META["webpack%2F12-%E6%B7%B1%E5%BA%A6%E8%A7%A3%E9%94%81Webpack%E7%B3%BB%E5%88%97(%E4%BC%98%E5%8C%96%E7%AF%87)03.md"]={toc:[{text:"量化",id:"量化",depth:3},{text:"1.exclude/include",id:"1excludeinclude",depth:3},{text:"2. cache-loader",id:"2-cache-loader",depth:3},{text:"3.happypack",id:"3happypack",depth:3},{text:"4.thread-loader",id:"4thread-loader",depth:3},{text:"5.开启 JS 多进程压缩",id:"5开启-js-多进程压缩",depth:3},{text:"6.HardSourceWebpackPlugin",id:"6hardsourcewebpackplugin",depth:3},{text:"7.noParse",id:"7noparse",depth:3},{text:"8.resolve",id:"8resolve",depth:3},{text:"9.IgnorePlugin",id:"9ignoreplugin",depth:3},{text:"10.externals",id:"10externals",depth:3},{text:"11.DllPlugin",id:"11dllplugin",depth:3},{text:"12.抽离公共代码",id:"12抽离公共代码",depth:3},{text:"借助 webpack-bundle-analyzer 进一步优化",id:"借助-webpack-bundle-analyzer-进一步优化",depth:4},{text:"13.webpack自身的优化",id:"13webpack自身的优化",depth:3},{text:"tree-shaking",id:"tree-shaking",depth:4},{text:"scope hosting 作用域提升",id:"scope-hosting-作用域提升",depth:4},{text:"babel 配置的优化",id:"babel-配置的优化",depth:4},{text:"最后",id:"最后",depth:3}],title:"带你深度解锁Webpack系列(优化篇)",frontmatter:{}}}}]);