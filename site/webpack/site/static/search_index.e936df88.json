[{"id":0,"title":"","content":"Babel 是什么？#\n\n统计信息：字数 3276 阅读7分钟\n\nBabel 是一个 JavaScript 编译器。Babel 是一个工具链，主要用于将 ECMAScript 2015+ 版本的代码转换为向后兼容的\nJavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中。下面列出的是 Babel 能为你做的事情：\n\n\n语法转换#\n\n通过 Polyfill 方式在目标环境中添加缺失的特性 (通过 @babel/polyfill 模块)\n\n\n\n有关编译器的精彩教程，请查看 the-super-tiny-compiler 项目，它解释了 Babel 的工作方式。\n\n\nES2015(ES6)#\n\nBabel 通过语法转换器来支持新版本的 JavaScript 语法。\n\n这些 插件 让你现在就能使用新的语法，无需等待浏览器的支持。\n\n\nJSX 与 React#\n\nBabel 能够转换 JSX 语法！查看 React preset 了解更多信息。通过和 babel-sublime\n一起使用还可以把语法高亮的功能提升到一个新的水平。\n\n通过以下命令安装此 preset\n\nnpm install --save-dev @babel/preset-react\n\n并将 @babel/preset-react 添加到你的 Babel 配置文件中。\n\n\n\n了解更多关于 JSX 的信息。\n\n\n类型注释 (Flow 和 TypeScript)#\n\nBabel 可以删除类型注释！查看 Flow preset 或 TypeScript preset 了解如何使用。务必牢记 Babel\n不做类型检查，你仍然需要安装 Flow 或 TypeScript 来执行类型检查的工作。\n\n通过以下命令安装 flow preset\n\nnpm install --save-dev @babel/preset-flow\n\n\n\n或通过以下命令安装 typescript preset\n\nnpm install --save-dev @babel/preset-typescript\n\n\n\n\n插件化#\n\nBabel 构建在插件之上。使用现有的或者自己编写的插件可以组成一个转换管道。通过使用或创建一个 preset 即可轻松使用一组插件。 了解更多 →\n\n利用 astexplorer.net 可以立即创建一个插件，或者使用 generator-babel-plugin 生成一个插件模板。\n\n\n\n\n可调试#\n\n由于 Babel 支持 Source map，因此你可以轻松调试编译后的代码。\n\n\n符合规范#\n\nBabel 尽最大可能遵循 ECMAScript 标准。不过，Babel 还提供了特定的选项来对标准和性能做权衡。\n\n\n代码紧凑#\n\nBabel 尽可能用最少的代码并且不依赖太大量的运行环境。有些情况是很难达成的这一愿望的，因此 Babel 提供了 \"loose\"\n参数，用以在特定的转换情况下在符合规范、文件大小和速度之间做折中。","routePath":"/site/webpack/site/babel/21-Babel is what","lang":"","toc":[{"text":"Babel 是什么？","id":"babel-是什么","depth":2,"charIndex":-1},{"text":"语法转换","id":"语法转换","depth":3,"charIndex":169},{"text":"ES2015(ES6)","id":"es2015es6","depth":3,"charIndex":293},{"text":"JSX 与 React","id":"jsx-与-react","depth":3,"charIndex":377},{"text":"类型注释 (Flow 和 TypeScript)","id":"类型注释-flow-和-typescript","depth":3,"charIndex":602},{"text":"插件化","id":"插件化","depth":3,"charIndex":891},{"text":"可调试","id":"可调试","depth":3,"charIndex":1045},{"text":"符合规范","id":"符合规范","depth":3,"charIndex":1093},{"text":"代码紧凑","id":"代码紧凑","depth":3,"charIndex":1160}],"domain":"","frontmatter":{},"version":""},{"id":1,"title":"Usage Guide","content":"#\n\n统计信息：字数 9242 阅读19分钟\n\nThere are quite a few tools in the Babel toolchain that try to make it easy for\nyou to use Babel whether you're an \"end-user\" or building an integration of\nBabel itself. This will be a quick introduction to those tools and you can read\nmore about them in the \"Usage\" section of the docs.\n\nIf you're using a framework, the work of configuring Babel might be different or\nactually already handled for you. Check out our interactive setup guide instead.\n\nbabel 工具链中有很多工具；这里简单介绍这些工具。\n\n\nOverview 概述#\n\nThis guide will show you how to compile your JavaScript application code that\nuses ES2015+ syntax into code that works in current browsers. That will involve\nboth transforming new syntax and polyfilling missing features.\n\n这个文档告诉你如何把ES6编译成浏览器可以识别的语言，包括转换新的语法和填充缺少的特性。\n\nThe entire process to set this up involves:下面是整个设置的过程：\n\nRunning these commands to install the packages:\n\n\n\nCreating a config file named babel.config.json in the root of your project with\nthis content:（babel.config.json）\n\n\n\nThe browsers list above is just an arbitrary example. You will have to adapt it\nfor the browsers you want to support.\n\nAnd running this command to compile all your code from the src directory to lib:\n编译文件\n\n\n\nYou can use the npm package runner that comes with npm@5.2.0 to shorten that\ncommand by replacing ./node_modules/.bin/babel with npx babel\n\nRead on for a step-by-step explanation of how this works and an introduction to\neach of the tools used.\n\n下面是对每一个工具的详细使用说明\n\n\nBasic usage with CLI 基本使用#\n\nAll the Babel modules you'll need are published as separate npm packages scoped\nunder @babel (since version 7). This modular design allows for various tools\neach designed for a specific use case. Here we'll look at @babel/core and\n@babel/cli.\n\n\nCore Library#\n\nThe core functionality of Babel resides at the @babel/core module. After\ninstalling it:\n\n\n\nyou can require it directly in your JavaScript program and use it like this:\n\n\n\nAs an end-user though, you'll probably want to install other tools that serve as\nan interface to @babel/core and integrate well with your development process.\nEven so, you might still want to check its documentation page to learn about the\noptions, most of which can be set from the other tools as well.\n\ncore 核心库可以转换JS代码到ES5，这个只能在JS文件中使用。所以需要一个CLI，可以直接在终端运行babel。\n\n\nCLI tool#\n\n@babel/cli is a tool that allows you to use babel from the terminal. Here's the\ninstallation command and a basic usage example:\n\n\n\nThis will parse all the JavaScript files in the src directory, apply any\ntransformations we have told it to, and output each file to the lib directory.\nSince we haven't told it to apply any transformations yet, the output code will\nbe identical to the input (exact code styling is not preserved). We can specify\nwhat transformations we want by passing them as options.\n\nWe used the --out-dir option above. You can view the rest of the options\naccepted by the cli tool by running it with --help. But the most important to us\nright now are --plugins and --presets.\n\n这是命令行执行编译的插件，可以使用 --out-dir 命令设置编译后文件的位置，使用 --plugins --presets 设置更重要的内容\n\n\nPlugins & Presets 插件和预设#\n\nTransformations come in the form of plugins, which are small JavaScript programs\nthat instruct Babel on how to carry out transformations to the code. You can\neven write your own plugins to apply any transformations you want to your code.\nTo transform ES2015+ syntax into ES5 we can rely on official plugins like\n@babel/plugin-transform-arrow-functions:\n\n\n\nNow any arrow functions in our code will be transformed into ES5 compatible\nfunction expressions:\n\n\n\nThat's a good start! But we also have other ES2015+ features in our code that we\nwant transformed. Instead of adding all the plugins we want one by one, we can\nuse a \"preset\" which is just a pre-determined set of plugins.\n\nJust like with plugins, you can create your own presets too to share any\ncombination of plugins you need. For our use case here, there's an excellent\npreset named env.\n\n\n\nWithout any configuration, this preset will include all plugins to support\nmodern JavaScript (ES2015, ES2016, etc.). But presets can take options too.\nRather than passing both cli and preset options from the terminal, let's look at\nanother way of passing options: configuration files.\n\n可以在terminal中传参，可以通过配置文件传参（参数很多很方便）\n\n\nConfiguration#\n\nThere are a few different ways to use configuration files depending on your\nneeds. Be sure to read our in-depth guide on how to configure Babel for more\ninformation.\n\nFor now, let's create a file called babel.config.json with the following\ncontent:\n\n\n\nNow the env preset will only load transformation plugins for features that are\nnot available in our target browsers. We're all set for syntax. Let's look at\npolyfills next.\n\n\nPolyfill#\n\n🚨 As of Babel 7.4.0, this package has been deprecated in favor of directly\nincluding core-js/stable (to polyfill ECMAScript features) and\nregenerator-runtime/runtime (needed to use transpiled generator functions):\n\n\n\nThe @babel/polyfill module includes core-js and a custom regenerator runtime to\nemulate(仿真) a full ES2015+ environment.\n\nThis means you can use new built-ins like Promise or WeakMap, static methods\nlike Array.from or Object.assign, instance methods like\nArray.prototype.includes, and generator functions (when used alongside the\nregenerator plugin). The polyfill adds to the global scope as well as native\nprototypes like String in order to do this.\n\nFor library/tool authors this may be too much. If you don't need the instance\nmethods like Array.prototype.includes you can do without polluting the global\nscope altogether by using the transform runtime plugin instead of\n@babel/polyfill.\n\nTo go one step further, if you know exactly what features you need polyfills\nfor, you can require them directly from core-js.\n\nSince we're building an application we can just install @babel/polyfill:\n\n\n\nNote the --save option instead of --save-dev as this is a polyfill that needs to\nrun before your source code.\n\nNow luckily for us, we're using the env preset which has a \"useBuiltIns\" option\nthat when set to \"usage\" will practically apply the last optimization mentioned\nabove where you only include the polyfills you need. With this new option the\nconfiguration changes like this:\n\n\n\nBabel will now inspect all your code for features that are missing in your\ntarget environments and include only the required polyfills. For example this\ncode:\n\nPromise.resolve().finally();\n\nwould turn into this (because Edge 17 doesn't have Promise.prototype.finally):\n\nrequire(\"core-js/modules/es.promise.finally\");\n\nPromise.resolve().finally();\n\nIf we weren't using the env preset with the \"useBuiltIns\" option set to \"usage\"\nwe would've had to require the full polyfill only once in our entry point before\nany other code.\n\n\nSummary#\n\nWe used @babel/cli to run Babel from the terminal, @babel/polyfill to polyfill\nall the new JavaScript features, and the env preset to only include the\ntransformations and polyfills for the features that we use and that are missing\nin our target browsers.\n\n我们使用 CLI 在终端运行babel，使用 polyfill 来支持新的JS语法，使用 evn preset 处理转换特征，来适应我们的浏览器。","routePath":"/site/webpack/site/babel/22-Babel Usage Guide","lang":"","toc":[{"text":"Overview 概述","id":"overview-概述","depth":3,"charIndex":505},{"text":"Basic usage with CLI 基本使用","id":"basic-usage-with-cli-基本使用","depth":3,"charIndex":1482},{"text":"Core Library","id":"core-library","depth":3,"charIndex":1755},{"text":"CLI tool","id":"cli-tool","depth":3,"charIndex":2308},{"text":"Plugins & Presets 插件和预设","id":"plugins--presets-插件和预设","depth":3,"charIndex":3089},{"text":"Configuration","id":"configuration","depth":3,"charIndex":4289},{"text":"Polyfill","id":"polyfill","depth":3,"charIndex":4732},{"text":"Summary","id":"summary","depth":3,"charIndex":6767}],"domain":"","frontmatter":{},"version":""},{"id":2,"title":"Configure Babel","content":"#\n\n统计信息：字数 2450 阅读5分钟\n\nBabel can be configured! Many other tools have similar configs: ESLint\n(.eslintrc), Prettier (.prettierrc).\n\nAll Babel API options are allowed. However, if the option requires JavaScript,\nyou may want to use a JavaScript configuration file.\n\nWhat's your use case? You are using a monorepo? You want to compile\nnode_modules? babel.config.json is for you!\n\nYou have a configuration that only applies to a single part of your project?\n.babelrc.json is for you!\n\nWe recommend using the babel.config.json format. Babel itself is using it.\n\n\nbabel.config.json#\n\nCreate a file called babel.config.json with the following content at the root of\nyour project (where the package.json is).\n\n\n\n\n\nCheck out the babel.config.json documentation to see more configuration options.\n\n\n.babelrc.json#\n\nCreate a file called .babelrc.json with the following content in your project.\n\n\n\nCheck out the .babelrc documentation to see more configuration options.\n\n\npackage.json#\n\nAlternatively, you can choose to specify your .babelrc.json config from within\npackage.json using the babel key like so:\n\n\n\n\nJavaScript configuration files#\n\nYou can also write babel.config.json and .babelrc.json files using JavaScript:\n\n\n\nYou can read more about JavaScript configuration files in the dedicated\ndocumentation\n\nUsing the CLI (@babel/cli) babel --plugins\n@babel/plugin-transform-arrow-functions script.js\n\nCheck out the babel-cli documentation to see more configuration options.\n\nUsing the API (@babel/core) require(\"@babel/core\").transform(\"code\", { plugins:\n[\"@babel/plugin-transform-arrow-functions\"] });\n\nCheck out the babel-core documentation to see more configuration options.","routePath":"/site/webpack/site/babel/23-Babel-Configure","lang":"","toc":[{"text":"babel.config.json","id":"babelconfigjson","depth":3,"charIndex":558},{"text":".babelrc.json","id":"babelrcjson","depth":3,"charIndex":789},{"text":"package.json","id":"packagejson","depth":3,"charIndex":961},{"text":"JavaScript configuration files","id":"javascript-configuration-files","depth":3,"charIndex":1101}],"domain":"","frontmatter":{},"version":""},{"id":3,"title":"Learn ES6 语法介绍","content":"#\n\n统计信息：字数 17760 阅读36分钟\n\n\nIntroduction#\n\nECMAScript 2015 is an ECMAScript standard that was ratified in June 2015.\n\nES2015 is a significant update to the language, and the first major update to\nthe language since ES5 was standardized in 2009. Implementation of these\nfeatures in major JavaScript engines is underway now.\n\nSee the ES2015 standard for full specification of the ECMAScript 2015 language.\n\n\nECMAScript 2015 Features#\n\nArrows and Lexical(词法) This#\n\n箭头函数和this指向：箭头函数和周围代码是相同的环境（可以获取类中的属性和方法）。如果不使用箭头函数，需要在构造器中使用bind将函数中的this绑定到当前类\n中。\n\nArrows are a function shorthand using the => syntax. They are syntactically\nsimilar to the related feature in C#, Java 8 and CoffeeScript. They support both\nexpression and statement bodies. Unlike functions, arrows share the same lexical\nthis as their surrounding code. If an arrow is inside another function, it\nshares the \"arguments\" variable of its parent function.\n\n\n\nClasses#\n\nES2015 classes are syntactic sugar over the prototype-based OO pattern. Having a\nsingle convenient declarative form makes class patterns easier to use, and\nencourages interoperability. Classes support prototype-based inheritance, super\ncalls, instance and static methods and constructors.\n\n\n\nEnhanced Object Literals#\n\nObject literals are extended to support setting the prototype at construction,\nshorthand for foo: foo assignments, defining methods and making super calls.\nTogether, these also bring object literals and class declarations closer\ntogether, and let object-based design benefit from some of the same\nconveniences.\n\n\n\nThe proto property requires native support, and was deprecated in previous\nECMAScript versions. Most engines now support the property, but some do not.\nAlso, note that only web browsers are required to implement it, as it's in Annex\nB. It is available in Node.\n\nTemplate Strings#\n\nTemplate strings provide syntactic sugar for constructing strings. This is\nsimilar to string interpolation features in Perl, Python and more. Optionally, a\ntag can be added to allow the string construction to be customized, avoiding\ninjection attacks or constructing higher level data structures from string\ncontents.\n\n\n\nDestructuring#\n\nDestructuring allows binding using pattern matching, with support for matching\narrays and objects. Destructuring is fail-soft, similar to standard object\nlookup foo[\"bar\"], producing undefined values when not found.\n\n\n\nDefault + Rest + Spread#\n\nCallee-evaluated default parameter values. Turn an array into consecutive\narguments in a function call. Bind trailing parameters to an array. Rest\nreplaces the need for arguments and addresses common cases more directly.\n\n\n\nLet + Const#\n\nBlock-scoped binding constructs. let is the new var. const is single-assignment.\nStatic restrictions prevent use before assignment.\n\n\n\nIterators + For..Of#\n\nIterator objects enable custom iteration like CLR IEnumerable or Java Iterable.\nGeneralize for..in to custom iterator-based iteration with for..of. Don’t\nrequire realizing an array, enabling lazy design patterns like LINQ.\n\n\n\nGenerators#\n\nGenerators simplify iterator-authoring using function* and yield. A function\ndeclared as function* returns a Generator instance. Generators are subtypes of\niterators which include additional next and throw. These enable values to flow\nback into the generator, so yield is an expression form which returns a value\n(or throws).\n\nNote: Can also be used to enable ‘await’-like async programming, see also ES7\nawait proposal.\n\n\n\nUnicode#\n\nNon-breaking additions to support full Unicode, including new unicode literal\nform in strings and new RegExp u mode to handle code points, as well as new APIs\nto process strings at the 21bit code points level. These additions support\nbuilding global apps in JavaScript.\n\n\n\nModules#\n\nLanguage-level support for modules for component definition. Codifies patterns\nfrom popular JavaScript module loaders (AMD, CommonJS). Runtime behaviour\ndefined by a host-defined default loader. Implicitly async model – no code\nexecutes until requested modules are available and processed.\n\n\n\nModule Formatters#\n\nBabel can transpile ES2015 Modules to several different formats including\nCommon.js, AMD, System, and UMD. You can even create your own. For more details\nsee the modules docs.\n\nModule Loaders#\n\nNot part of ES2015 This is left as implementation-defined within the ECMAScript\n2015 specification. The eventual standard will be in WHATWG's Loader\nspecification, but that is currently a work in progress. What is below is from a\nprevious ES2015 draft.\n\nModule loaders support:\n\nDynamic loading State isolation Global namespace isolation Compilation hooks\nNested virtualization The default module loader can be configured, and new\nloaders can be constructed to evaluate and load code in isolated or constrained\ncontexts.\n\n\n\nAdditional polyfill needed#\n\nSince Babel defaults to using common.js modules, it does not include the\npolyfill for the module loader API. Get it here.\n\nUsing Module Loader#\n\nIn order to use this, you'll need to tell Babel to use the system module\nformatter. Also be sure to check out System.js\n\nMap + Set + WeakMap + WeakSet#\n\nEfficient data structures for common algorithms. WeakMaps provides leak-free\nobject-key’d side tables.\n\n\n\nProxies#\n\nProxies enable creation of objects with the full range of behaviors available to\nhost objects. Can be used for interception, object virtualization,\nlogging/profiling, etc.\n\n\n\nThere are traps available for all of the runtime-level meta-operations:\n\n\n\nUnsupported feature#\n\nDue to the limitations of ES5, Proxies cannot be transpiled or polyfilled. See\nsupport in various JavaScript engines.\n\nSymbols#\n\nSymbols enable access control for object state. Symbols allow properties to be\nkeyed by either string (as in ES5) or symbol. Symbols are a new primitive type.\nOptional name parameter used in debugging - but is not part of identity. Symbols\nare unique (like gensym), but not private since they are exposed via reflection\nfeatures like Object.getOwnPropertySymbols.\n\n\n\nLimited support via polyfill\n\nLimited support requires the Babel polyfill. Due to language limitations, some\nfeatures can't be transpiled or polyfilled. See core.js's caveats section for\nmore details.\n\nSubclassable Built-ins In ES2015, built-ins like Array, Date and DOM Elements\ncan be subclassed.\n\n\n\nPartial support#\n\nBuilt-in subclassability should be evaluated on a case-by-case basis as classes\nsuch as HTMLElement can be subclassed while many such as Date, Array and Error\ncannot be due to ES5 engine limitations.\n\n\n\nMost of these APIs are supported by the Babel polyfill. However, certain\nfeatures are omitted for various reasons (e.g. String.prototype.normalize needs\na lot of additional code to support). You can find more polyfills here.\n\nBinary and Octal Literals#\n\nTwo new numeric literal forms are added for binary (b) and octal (o).\n\n\n\nOnly supports literal form：Babel is only able to transform 0o767 and not\nNumber(\"0o767\").\n\nPromises#\n\nPromises are a library for asynchronous programming. Promises are a first class\nrepresentation of a value that may be made available in the future. Promises are\nused in many existing JavaScript libraries.\n\n\n\nReflect API#\n\nFull reflection API exposing the runtime-level meta-operations on objects. This\nis effectively the inverse of the Proxy API, and allows making calls\ncorresponding to the same meta-operations as the proxy traps. Especially useful\nfor implementing proxies.\n\n\n\nTail Calls#\n\nCalls in tail-position are guaranteed to not grow the stack unboundedly. Makes\nrecursive algorithms safe in the face of unbounded inputs.\n\n\n\nTemporarily Removed in Babel 6#\n\nOnly explicit self referencing tail recursion was supported due to the\ncomplexity and performance impact of supporting tail calls globally. Removed due\nto other bugs and will be re-implemented.","routePath":"/site/webpack/site/babel/24-Babel-Learn ES2015","lang":"","toc":[{"text":"Introduction","id":"introduction","depth":3,"charIndex":25},{"text":"ECMAScript 2015 Features","id":"ecmascript-2015-features","depth":3,"charIndex":403},{"text":"Arrows and Lexical(词法) This","id":"arrows-and-lexical词法-this","depth":4,"charIndex":430},{"text":"Classes","id":"classes","depth":4,"charIndex":917},{"text":"Enhanced Object Literals","id":"enhanced-object-literals","depth":4,"charIndex":1219},{"text":"Template Strings","id":"template-strings","depth":4,"charIndex":1822},{"text":"Destructuring","id":"destructuring","depth":4,"charIndex":2162},{"text":"Default + Rest + Spread","id":"default--rest--spread","depth":4,"charIndex":2397},{"text":"Let + Const","id":"let--const","depth":4,"charIndex":2647},{"text":"Iterators + For..Of","id":"iterators--forof","depth":4,"charIndex":2796},{"text":"Generators","id":"generators","depth":4,"charIndex":3044},{"text":"Unicode","id":"unicode","depth":4,"charIndex":3481},{"text":"Modules","id":"modules","depth":4,"charIndex":3764},{"text":"Module Formatters","id":"module-formatters","depth":4,"charIndex":4067},{"text":"Module Loaders","id":"module-loaders","depth":4,"charIndex":4264},{"text":"Additional polyfill needed","id":"additional-polyfill-needed","depth":4,"charIndex":4805},{"text":"Using Module Loader","id":"using-module-loader","depth":4,"charIndex":4957},{"text":"Map + Set + WeakMap + WeakSet","id":"map--set--weakmap--weakset","depth":4,"charIndex":5100},{"text":"Proxies","id":"proxies","depth":4,"charIndex":5238},{"text":"Unsupported feature","id":"unsupported-feature","depth":4,"charIndex":5498},{"text":"Symbols","id":"symbols","depth":4,"charIndex":5639},{"text":"Partial support","id":"partial-support","depth":4,"charIndex":6318},{"text":"Binary and Octal Literals","id":"binary-and-octal-literals","depth":4,"charIndex":6765},{"text":"Promises","id":"promises","depth":4,"charIndex":6957},{"text":"Reflect API","id":"reflect-api","depth":4,"charIndex":7176},{"text":"Tail Calls","id":"tail-calls","depth":4,"charIndex":7448},{"text":"Temporarily Removed in Babel 6","id":"temporarily-removed-in-babel-6","depth":4,"charIndex":7602}],"domain":"","frontmatter":{},"version":""},{"id":4,"title":"babel-preset-env使用指南","content":"#\n\n统计信息：字数 6188 阅读13分钟\n\n\n文章概览#\n\nbabel-preset-env是非常重要且常用的一个插件预设，掌握它的用法以及实现原理非常有必要。\n\n本文主要内容包括：babel-preset-env是什么、入门实例、如何配置以支持特定版本的 node/浏览器、实现原理等。\n\n\nbabel-preset-env简介#\n\n历史背景：为了让开发者能够尽早用上新的JS特性，babel团队开发了babel-preset-latest。这个preset比较特殊，它是多个preset的集合\n(es2015+)，并且随着ECMA规范的更新更增加它的内容。\n\n比如，当前(2018.06.02)，它包含的preset包括：es2017、es1016、es2015。\n\n到了明年，可能它包含的preset就包括：es2018、es2017、es2016、es2015。\n\n随着时间的推移，babel-preset-latest 包含的插件越来越多，这带来了如下问题：\n\n 1. 加载的插件越来越多，编译速度会越来越慢；\n 2. 随着用户浏览器的升级，ECMA规范的支持逐步完善，编译至低版本规范的必要性在减少（比如ES6 -> ES5），多余的转换不单降低执行效率，还浪费带宽。\n\n因为上述问题的存在，babel官方推出了babel-preset-env插件。它可以根据开发者的配置，按需加载插件。配置项大致包括：\n\n 1. 需要支持的平台：比如node、浏览器等。\n 2. 需要支持的平台的版本：比如支持node@6.1等。\n\n默认配置的情况下，它跟 babel-preset-latest 是等同的，会加载从es2015开始的所有preset。\n\n\n入门例子#\n\n首先，安装依赖。\n\n\n\n创建 index.js。\n\n\n\n配置文件 .babelrc 如下，当前为默认配置。\n\n\n\n运行转换命令\n\n\n\n转换结果如下：\n\n\n\n\n针对node版本的配置#\n\n前面提到，babel-preset-env 提供了更精细化的配置，以提升编译速度，同时减少代码冗余。\n\n我们看下实际例子。假设当前有如下代码：\n\n\n\n采用 babel-preset-env，默认配置下，输出的转换结果如下（具体内容不用关心，知道很长就行了）。\n\n\n\n如果我们的代码是打算跑在node@8.9.3版本上，那上面的兼容代码就有点多余了，因为node@8.9.3已经支持了async/await。\n\n修改下 .babelrc，加上配置参数\"target\"，它表示我们需要支持哪些平台+哪些版本。这里声明我们要支持的是node版本为8.9.3。\n\n\n\n再次进行转码，结果如下。几乎没有变化，因为node最新版本支持 async/await，因此不需要额外的兼容代码。\n\n\n\n\n针对浏览器版本的配置#\n\nbabel-preset-env 同样提供了对浏览器版本的配置能力。\n\n\n支持特定版本的浏览器#\n\n假设我们的代码如下：\n\n\n\n如果只需要支持 IE11，那么可以这样配置。\n\n\n\n如果只需要支持支持 Edge 16，那么可以这样配置\n\n\n\n因为 IE 11 不支持模板字面量，而 Edge 16支持模板字面量，因此上面配置的转码结果是不同的，读者可以自行尝试。\n\n\n支持特定版本范围的浏览器#\n\n大部分时候，我们要针对的都是特定范围的浏览器，比如 IE8+，那么，逐个指定是不现实的。好在 babel-preset-env 支持要支持的版本范围。\n\n比如，我们需要支持 IE8+、chrome62+，那么可以这样配置：\n\n\n\n看下前面声明的范围涵盖了哪些浏览器。\n\n\n\n对浏览器版本范围的配置，babel-preset-env 借助了 browserslist 这个库，还有更多的配置方式，可以自行探究。\n\n\nbabel-preset-env实现原理#\n\n实现原理很简单。官方文档写的挺简洁的，挑重点大致翻译下。\n\n1、首先，检测浏览器对JS特性的支持程度，比如通过通过 compat-table 这样的外部数据。\n\n2、将 JS特性 跟 特定的babel插件 建立映射，映射关系可以参考 这里。\n\n3、stage-x 的插件不包括在内。\n\n4、根据开发者的配置项，确定至少需要包含哪些插件。比如声明了需要支持 IE8+、chrome62+，那么，所有IE8+需要的插件都会被包含进去。\n\n\n相关链接#\n\nhttps://babeljs.io/docs/plugins/preset-env/#how-it-works","routePath":"/site/webpack/site/babel/25-babel-preset-env使用指南","lang":"","toc":[{"text":"文章概览","id":"文章概览","depth":2,"charIndex":24},{"text":"babel-preset-env简介","id":"babel-preset-env简介","depth":2,"charIndex":148},{"text":"入门例子","id":"入门例子","depth":2,"charIndex":729},{"text":"针对node版本的配置","id":"针对node版本的配置","depth":2,"charIndex":815},{"text":"针对浏览器版本的配置","id":"针对浏览器版本的配置","depth":2,"charIndex":1171},{"text":"支持特定版本的浏览器","id":"支持特定版本的浏览器","depth":3,"charIndex":1221},{"text":"支持特定版本范围的浏览器","id":"支持特定版本范围的浏览器","depth":3,"charIndex":1367},{"text":"babel-preset-env实现原理","id":"babel-preset-env实现原理","depth":2,"charIndex":1589},{"text":"相关链接","id":"相关链接","depth":2,"charIndex":1830}],"domain":"","frontmatter":{},"version":""},{"id":5,"title":"@babel/preset-env 使用","content":"#\n\n统计信息：字数 4544 阅读10分钟\n\n\n使用目的#\n\n根据不同的生产环境，对应不同的 JS 语法规范，然后把这部分语法规范传递给 babel 进行转换。用来处理浏览器兼容性，node\n环境兼容性，不同环境下都可以运行最新的 JS 语法。\n\n> @babel/preset-env is a smart preset that allows you to use the latest\n> JavaScript without needing to micromanage which syntax transforms (and\n> optionally, browser polyfills) are needed by your target environment(s). This\n> both makes your life easier and JavaScript bundles smaller!\n\n@babel/preset-env 是一个智能预设，允许使用最新的 JavaScript 语法，而无需微观管理目标环境所需的语法转换（以及可选的浏览器\npolyfill），让你工作更轻松，也让打包后的 JavaScript bundle 更小（根据不同目标环境，打成不同的包）！\n\n\n转换案例#\n\n转换前代码\n\n\n\n例如在 chrome 60 中，我们发现转换后的代码仍然是箭头函数，因为Chrome60已经实现了箭头函数语法，所以不会转换成ES5的函数定义语法。\n\n\n\n\n\n把Chrome60改成Chrome38，代码是ES5的函数定义语法，因为Chrome38不支持箭头函数语法。\n\n\n\n\n\n@babel/preset-env可以通过browserslist针对目标环境不支持的语法进行语法转换，那么也可以对目标环境不支持的特性API进行部分引用呢？这\n样我们就不用把完整的polyfill全部引入到最终的文件里，可以大大减少体积。\n\n\n基本配置#\n\n\ntargets#\n\n转换后的目标浏览器，该参数项可以取值为字符串、字符串数组或对象，不设置的时候取默认值空对象{}。该参数项的写法与browserslist是一样的，下面是一个例子\n\n\n\n\nuseBuiltIns#\n\npreset-env 如何处理垫片 polyfills。\n\nuseBuiltIns项取值可以是\"usage\" 、 \"entry\" 或 false。如果该项不进行设置，则取默认值false。\n\n在我们没有配置该参数项，或是取值为false的时候，polyfill 会全部引入到最终的代码里。\n\nuseBuiltIns取值为\"entry\"或\"usage\"的时候，会根据配置的目标环境找出需要的polyfill进行部分引入。这意味着核心js将相对于文件本身进\n行解析，并且需要可访问。\n\nbabel.config.json\n\n\n\n.browserslistrc\n\n\n\n\nCorejs#\n\n此选项仅在与useBuiltIns:usage 或 entry一起使用时有效，并确保@babel/preset-env注入您的核心 js\n版本支持的polyfill。建议指定次要版本，否则“3”将被解释为“3.0”，可能不包括最新功能的polyfill。\n\n取默认值或2的时候，Babel转码的时候使用的是core-js@2版本（即core-js2.x.x）。因为某些新API只有core-js@3里才有，例如数组的f\nlat方法，我们需要使用core-js@3的API模块进行补齐，这个时候我们就把该项设置为3。\n\n需要注意的是，corejs取值为2的时候，需要安装并引入core-js@2版本，或者直接安装并引入polyfill也可以。如果corejs取值为3，必须安装并引\n入core-js@3版本才可以，否则Babel会转换失败。\n\n\nmodules#\n\n这个参数项的取值可以是\"amd\"、\"umd\" 、 \"systemjs\" 、 \"commonjs\" 、\"cjs\" 、\"auto\"\n、false。在不设置的时候，取默认值\"auto\"。\n\n该项用来设置是否把ES6的模块化语法改成其它模块化语法。\n\n我们常见的模块化语法有两种：（1）ES6的模块法语法用的是import与export；（2）commonjs模块化语法是require与module.expor\nts。\n\n在该参数项值是'auto'或不设置的时候，会发现我们转码前的代码里import都被转码成require了。\n\n如果我们将参数项改成false，那么就不会对ES6模块化进行更改，还是使用import引入模块。\n\n使用ES6模块化语法有什么好处呢。在使用Webpack一类的打包工具，可以进行静态分析，从而可以做tree shaking等优化措施。\n\n\n参考#\n\nhttps://zhuanlan.zhihu.com/p/394782898\n\nhttps://babeljs.io/docs/babel-preset-env\n\nhttps://www.npmjs.com/package/@babel/preset-env","routePath":"/site/webpack/site/babel/26-babel-preset-env 作用","lang":"","toc":[{"text":"使用目的","id":"使用目的","depth":2,"charIndex":24},{"text":"转换案例","id":"转换案例","depth":2,"charIndex":554},{"text":"基本配置","id":"基本配置","depth":2,"charIndex":833},{"text":"targets","id":"targets","depth":3,"charIndex":841},{"text":"useBuiltIns","id":"usebuiltins","depth":3,"charIndex":936},{"text":"Corejs","id":"corejs","depth":3,"charIndex":1232},{"text":"modules","id":"modules","depth":3,"charIndex":1613},{"text":"参考","id":"参考","depth":2,"charIndex":2006}],"domain":"","frontmatter":{},"version":""},{"id":6,"title":"@babel/plugin-transform-runtime 说明","content":"#\n\n统计信息：字数 4487 阅读9分钟\n\n\n问题来源#\n\nBabel 通过 babel-preset-env 的配置，把 es6 的语法转换成 es5。\n\n具体转换过程就是在每一个模块前面增加转换函数。\n\n但样这做存在一个问题。在我们正常的前端工程开发的时候，少则几十个js文件，多则上千个。如果每个文件里都使用了class类语法，那会导致每个转换后的文件上部都会注\n入这些相同的函数声明。这会导致我们用构建工具打包出来的包非常大。\n\n那么怎么办？一个思路就是，我们把这些函数声明都放在一个npm包里，需要使用的时候直接从这个包里引入到我们的文件里。这样即使上千个文件，也会从相同的包里引用这些函\n数。通过webpack这一类的构建工具打包的时候，我们只会把使用到的npm包里的函数引入一次，这样就做到了复用，减少了体积。\n\n@babel/runtime就是上面说的这个npm包，@babel/runtime把所有语法转换会用到的辅助函数都集成在了一起。这么多辅助函数要一个个记住并手动\n引入，平常人是做不到的，我也做不到。\n\n\n解决问题#\n\n@babel/plugin-transform-runtime有三大作用，其中之一就是自动移除语法转换后内联的辅助函数（inline Babel\nhelpers），使用@babel/runtime/helpers里的辅助函数来替代。这样就减少了我们手动引入的麻烦。\n\n直接更改配置文件 Babel.config.js\n\n\n\n\nplugin-transform-runtime 作用#\n\n@babel/plugin-transform-runtime有三大作用：\n\n1.自动移除语法转换后内联的辅助函数（inline Babel helpers），使用@babel/runtime/helpers里的辅助函数来替代；\n\n2.当代码里使用了core-js的API，自动引入@babel/runtime-corejs3/core-js-stable/，以此来替代全局引入的core-j\ns/stable;\n\n3.当代码里使用了Generator/async函数，自动引入@babel/runtime/regenerator，以此来替代全局引入的regenerator-\nruntime/runtime；\n\n作用2和3其实是在做API转换，对内置对象进行重命名，以防止污染全局环境。\n\n\n配置项#\n\n默认配置\n\n\n\n基本配置\n\n\n\n参数说明：\n\nhelpers#\n\n该项是用来设置是否要自动引入辅助函数包，这个我们当然要引入了，这是@babel/plugin-transform-runtime的核心用途。该项取值是布尔值，我\n们设置为true，其默认值也是true，所以也可以省略不填。\n\ncorejs和regenerator#\n\n这两项是用来设置是否做API转换以避免污染全局环境，regenerator取值是布尔值，corejs取值是false、2和3。这个上一节已经讲过了，在前端业务项\n目里，我们一般对corejs取false，即不对Promise这一类的API进行转换。而在开发JS库的时候设置为2或3。regenerator取默认的true就\n可以。\n\nuseESModules#\n\n该项用来设置是否使用ES6的模块化用法，取值是布尔值。默认是fasle，在用webpack一类的打包工具的时候，我们可以设置为true，以便做静态分析。\n\nabsoluteRuntime#\n\n该项用来自定义@babel/plugin-transform-runtime引入@babel/runtime/模块的路径规则，取值是布尔值或字符串。没有特殊需求\n，我们不需要修改，保持默认false即可。\n\nversion#\n\n该项主要是和@babel/runtime及其进化版@babel/runtime-corejs2、@babel/runtime-corejs3的版本号有关系，这三\n个包我们只需要根据需要安装一个。我们把安装的npm包的版本号设置给version即可。例如，在上节的babel14例子里，安装的@babel/runtime-c\norejs3版本是^7.10.4，那么配置项version也取'^7.10.4'。 其实该项不填取默认值就行，目前填写版本号主要是可以减少打包体积。\n\n另外，在Babel6版本，该插件还有两个配置选项polyfill和useBuiltIns，在v7版本已经移除了，大家不需要再使用。\n\n\n参考#\n\nhttps://zhuanlan.zhihu.com/p/394783228\n\nhttps://zhuanlan.zhihu.com/p/394783727\n\nhttps://zhuanlan.zhihu.com/p/394783900","routePath":"/site/webpack/site/babel/27-babel-plugin-transform-runtime 说明","lang":"","toc":[{"text":"问题来源","id":"问题来源","depth":3,"charIndex":23},{"text":"解决问题","id":"解决问题","depth":3,"charIndex":466},{"text":"plugin-transform-runtime 作用","id":"plugin-transform-runtime-作用","depth":3,"charIndex":636},{"text":"配置项","id":"配置项","depth":3,"charIndex":1013},{"text":"helpers","id":"helpers","depth":4,"charIndex":1042},{"text":"corejs和regenerator","id":"corejs和regenerator","depth":4,"charIndex":1165},{"text":"useESModules","id":"useesmodules","depth":4,"charIndex":1353},{"text":"absoluteRuntime","id":"absoluteruntime","depth":4,"charIndex":1446},{"text":"version","id":"version","depth":4,"charIndex":1568},{"text":"参考","id":"参考","depth":3,"charIndex":1884}],"domain":"","frontmatter":{},"version":""},{"id":7,"title":"","content":"报错 Auto packing the repository in background for optimum performance-ok#\n\n统计信息：字数 479 阅读1分钟\n\ngit 报错 Auto packing the repository in background for optimum performance\n\n本地 “悬空对象”太多(git删除分支或者清空stash的时候，这些其实还没有真正删除，成为悬空对象，使用merge命令可以从中恢复一些文件)\n\n解决：删除悬挂的分支\n\n","routePath":"/site/webpack/site/git/BUG-Auto packing the repository in background for optimum performance","lang":"","toc":[{"text":"报错 Auto packing the repository in background for optimum performance-ok","id":"报错-auto-packing-the-repository-in-background-for-optimum-performance-ok","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":8,"title":"Nightmare","content":"前端页面测试#\n\n统计信息：字数 33858 阅读68分钟\n\n关于函数测试，比如有一些固定的输入输出，可以使用mocha来进行测试，参考 Mocha测试基本使用。\n\n关于页面功能的测试，推荐nightmare。\n\n\n\n可以结合mocha使用。\n\n\n\n\nNightmare#\n\nhttps://github.com/segmentio/nightmare#api\n\nNightmare is a high-level browser automation library from Segment.\n\nThe goal is to expose a few simple methods that mimic user actions (like goto,\ntype and click), with an API that feels synchronous for each block of scripting,\nrather than deeply nested callbacks. It was originally designed for automating\ntasks across sites that don't have APIs, but is most often used for UI testing\nand crawling.\n\nUnder the covers it uses Electron, which is similar to PhantomJS but roughly\ntwice as fast and more modern.\n\n⚠️ Security Warning: We've implemented many of the security recommendations\noutlined by Electron to try and keep you safe, but undiscovered vulnerabilities\nmay exist in Electron that could allow a malicious website to execute code on\nyour computer. Avoid visiting untrusted websites.\n\n🛠 Migrating to 3.x: You'll want to check out this issue before upgrading. We've\nworked hard to make improvements to nightmare while limiting the breaking\nchanges and there's a good chance you won't need to do anything.\n\nNiffy is a perceptual diffing tool built on Nightmare. It helps you detect UI\nchanges and bugs across releases of your web app.\n\nDaydream is a complementary chrome extension built by @stevenmiller888 that\ngenerates Nightmare scripts for you while you browse.\n\nMany thanks to @matthewmueller and @rosshinkley for their help on Nightmare.\n\n * Examples\n   * UI Testing Quick Start\n   * Perceptual Diffing with Niffy & Nightmare\n * API\n   * Set up an instance\n   * Interact with the page\n   * Extract from the page\n   * Cookies\n   * Proxies\n   * Promises\n   * Extending Nightmare\n * Usage\n * Debugging\n * Additional Resources\n\n\nExamples#\n\nLet's search on DuckDuckGo:\n\n\n\nYou can run this with:\n\n\n\nOr, let's run some mocha tests:\n\n\n\nYou can see examples of every function in the tests here.\n\nTo get started with UI Testing, check out this quick start guide.\n\n\nTo run the mocha tests#\n\n\n\n\nAPI#\n\nNightmare(options)#\n\nCreates a new instance that can navigate around the web. The available options\nare documented here, along with the following nightmare-specific options.\n\nwaitTimeout (default: 30s)#\n\nThrows an exception if the .wait() didn't return true within the set timeframe.\n\n\n\ngotoTimeout (default: 30s)#\n\nThrows an exception if the .goto() didn't finish loading within the set\ntimeframe. Note that, even though goto normally waits for all the resources on a\npage to load, a timeout exception is only raised if the DOM itself has not yet\nloaded.\n\n\n\nloadTimeout (default: infinite)#\n\nForces Nightmare to move on if a page transition caused by an action (eg,\n.click()) didn't finish within the set timeframe. If loadTimeout is shorter than\ngotoTimeout, the exceptions thrown by gotoTimeout will be suppressed.\n\n\n\nexecutionTimeout (default: 30s)#\n\nThe maximum amount of time to wait for an .evaluate() statement to complete.\n\n\n\npaths#\n\nThe default system paths that Electron knows about. Here's a list of available\npaths:\nhttps://github.com/atom/electron/blob/master/docs/api/app.md#appgetpathname\n\nYou can overwrite them in Nightmare by doing the following:\n\n\n\nswitches#\n\nThe command line switches used by the Chrome browser that are also supported by\nElectron. Here's a list of supported Chrome command line switches:\nhttps://github.com/atom/electron/blob/master/docs/api/chrome-command-line-switch\nes.md\n\n\n\nelectronPath#\n\nThe path to the prebuilt Electron binary. This is useful for testing on\ndifferent versions of Electron. Note that Nightmare only supports the version on\nwhich this package depends. Use this option at your own risk.\n\n\n\ndock (OS X)#\n\nA boolean to optionally show the Electron icon in the dock (defaults to false).\nThis is useful for testing purposes.\n\n\n\nopenDevTools#\n\nOptionally shows the DevTools in the Electron window using true, or use an\nobject hash containing mode: 'detach' to show in a separate window. The hash\ngets passed to contents.openDevTools() to be handled. This is also useful for\ntesting purposes. Note that this option is honored only if show is set to true.\n\n\n\ntypeInterval (default: 100ms)#\n\nHow long to wait between keystrokes when using .type().\n\n\n\npollInterval (default: 250ms)#\n\nHow long to wait between checks for the .wait() condition to be successful.\n\n\n\nmaxAuthRetries (default: 3)#\n\nDefines the number of times to retry an authentication when set up with\n.authenticate().\n\n\n\ncertificateSubjectName#\n\nA string to determine the client certificate selected by electron. If this\noptions is set, the select-client-certificate event will be set to loop through\nthe certificateList and find the first certificate that matches subjectName on\nthe electron Certificate Object.\n\n\n\n.engineVersions()#\n\nGets the versions for Electron and Chromium.\n\n.useragent(useragent)#\n\nSets the useragent used by electron.\n\n.authentication(user, password)#\n\nSets the user and password for accessing a web page using basic authentication.\nBe sure to set it before calling .goto(url).\n\n.end()#\n\nCompletes any queue operations, disconnect and close the electron process. Note\nthat if you're using promises, .then() must be called after .end() to run the\n.end() task. Also note that if using an .end() callback, the .end() call is\nequivalent to calling .end() followed by .then(fn). Consider:\n\n\n\n.halt(error, done)#\n\nClears all queued operations, kills the electron process, and passes error\nmessage or 'Nightmare Halted' to an unresolved promise. Done will be called\nafter the process has exited.\n\n\nInteract with the Page#\n\n.goto(url[, headers])#\n\nLoads the page at url. Optionally, a headers hash can be supplied to set headers\non the goto request.\n\nWhen a page load is successful, goto returns an object with metadata about the\npage load, including:\n\n * url: The URL that was loaded\n * code: The HTTP status code (e.g. 200, 404, 500)\n * method: The HTTP method used (e.g. \"GET\", \"POST\")\n * referrer: The page that the window was displaying prior to this load or an\n   empty string if this is the first page load.\n * headers: An object representing the response headers for the request as in\n   {header1-name: header1-value, header2-name: header2-value}\n\nIf the page load fails, the error will be an object with the following\nproperties:\n\n * message: A string describing the type of error\n * code: The underlying error code describing what went wrong. Note this is NOT\n   the HTTP status code. For possible values, see\n   https://code.google.com/p/chromium/codesearch#chromium/src/net/base/net_error\n   _list.h\n * details: A string with additional details about the error. This may be null\n   or an empty string.\n * url: The URL that failed to load\n\nNote that any valid response from a server is considered “successful.” That\nmeans things like 404 “not found” errors are successful results for goto. Only\nthings that would cause no page to appear in the browser window, such as no\nserver responding at the given address, the server hanging up in the middle of a\nresponse, or invalid URLs, are errors.\n\nYou can also adjust how long goto will wait before timing out by setting the\ngotoTimeout option on the Nightmare constructor.\n\n.back()#\n\nGoes back to the previous page.\n\n.forward()#\n\nGoes forward to the next page.\n\n.refresh()#\n\nRefreshes the current page.\n\n.click(selector)#\n\nClicks the selector element once.\n\n.mousedown(selector)#\n\nMousedowns the selector element once.\n\n.mouseup(selector)#\n\nMouseups the selector element once.\n\n.mouseover(selector)#\n\nMouseovers the selector element once.\n\n.mouseout(selector)#\n\nMouseout the selector element once.\n\n.type(selector[, text])#\n\nEnters the text provided into the selector element. Empty or falsey values\nprovided for text will clear the selector's value.\n\n.type() mimics a user typing in a textbox and will emit the proper keyboard\nevents.\n\nKey presses can also be fired using Unicode values with .type(). For example, if\nyou wanted to fire an enter key press, you would write .type('body', '\\u000d').\n\n> If you don't need the keyboard events, consider using .insert() instead as it\n> will be faster and more robust.\n\n.insert(selector[, text])#\n\nSimilar to .type(), .insert() enters the text provided into the selector\nelement. Empty or falsey values provided for text will clear the selector's\nvalue.\n\n.insert() is faster than .type() but does not trigger the keyboard events.\n\n.check(selector)#\n\nChecks the selector checkbox element.\n\n.uncheck(selector)#\n\nUnchecks the selector checkbox element.\n\n.select(selector, option)#\n\nChanges the selector dropdown element to the option with attribute\n[value=option]\n\n.scrollTo(top, left)#\n\nScrolls the page to desired position. top and left are always relative to the\ntop left corner of the document.\n\n.viewport(width, height)#\n\nSets the viewport size.\n\n.inject(type, file)#\n\nInjects a local file onto the current page. The file type must be either js or\ncss.\n\n.evaluate(fn[, arg1, arg2,...])#\n\nInvokes fn on the page with arg1, arg2,.... All the args are optional. On\ncompletion it returns the return value of fn. Useful for extracting information\nfrom the page. Here's an example:\n\n\n\nError-first callbacks are supported as a part of evaluate(). If the arguments\npassed are one fewer than the arguments expected for the evaluated function, the\nevaluation will be passed a callback as the last parameter to the function. For\nexample:\n\n\n\nNote that callbacks support only one value argument (eg function(err, value)).\nUltimately, the callback will get wrapped in a native Promise and only be able\nto resolve a single value.\n\nPromises are also supported as a part of evaluate(). If the return value of the\nfunction has a then member, .evaluate() assumes it is waiting for a promise. For\nexample:\n\n\n\n.wait(ms)#\n\nWaits for ms milliseconds e.g. .wait(5000).\n\n.wait(selector)#\n\nWaits until the element selector is present e.g. .wait('#pay-button').\n\n.wait(fn[, arg1, arg2,...])#\n\nWaits until the fn evaluated on the page with arg1, arg2,... returns true. All\nthe args are optional. See .evaluate() for usage.\n\n.header(header, value)#\n\nAdds a header override for all HTTP requests. If header is undefined, the header\noverrides will be reset.\n\n\nExtract from the Page#\n\n.exists(selector)#\n\nReturns whether the selector exists or not on the page.\n\n.visible(selector)#\n\nReturns whether the selector is visible or not.\n\n.on(event, callback)#\n\nCaptures page events with the callback. You have to call .on() before calling\n.goto(). Supported events are documented here.\n\nAdditional \"page\" events#\n\n.on('page', function(type=\"error\", message, stack))#\n\nThis event is triggered if any javascript exception is thrown on the page. But\nthis event is not triggered if the injected javascript code (e.g. via\n.evaluate()) is throwing an exception.\n\n\"page\" events#\n\nListens for window.addEventListener('error'), alert(...), prompt(...) &\nconfirm(...).\n\n.on('page', function(type=\"error\", message, stack))#\n\nListens for top-level page errors. This will get triggered when an error is\nthrown on the page.\n\n.on('page', function(type=\"alert\", message))#\n\nNightmare disables window.alert from popping up by default, but you can still\nlisten for the contents of the alert dialog.\n\n.on('page', function(type=\"prompt\", message, response))#\n\nNightmare disables window.prompt from popping up by default, but you can still\nlisten for the message to come up. If you need to handle the confirmation\ndifferently, you'll need to use your own preload script.\n\n.on('page', function(type=\"confirm\", message, response))#\n\nNightmare disables window.confirm from popping up by default, but you can still\nlisten for the message to come up. If you need to handle the confirmation\ndifferently, you'll need to use your own preload script.\n\n.on('console', function(type [, arguments, ...]))#\n\ntype will be either log, warn or error and arguments are what gets passed from\nthe console. This event is not triggered if the injected javascript code (e.g.\nvia .evaluate()) is using console.log.\n\n.once(event, callback)#\n\nSimilar to .on(), but captures page events with the callback one time.\n\n.removeListener(event, callback)#\n\nRemoves a given listener callback for an event.\n\n.screenshot([path][, clip])#\n\nTakes a screenshot of the current page. Useful for debugging. The output is\nalways a png. Both arguments are optional. If path is provided, it saves the\nimage to the disk. Otherwise it returns a Buffer of the image data. If clip is\nprovided (as documented here), the image will be clipped to the rectangle.\n\n.html(path, saveType)#\n\nSaves the current page as html as files to disk at the given path. Save type\noptions are here.\n\n.pdf(path, options)#\n\nSaves a PDF to the specified path. Options are here.\n\n.title()#\n\nReturns the title of the current page.\n\n.url()#\n\nReturns the url of the current page.\n\n.path()#\n\nReturns the path name of the current page.\n\n\nCookies#\n\n.cookies.get(name)#\n\nGets a cookie by it's name. The url will be the current url.\n\n.cookies.get(query)#\n\nQueries multiple cookies with the query object. If a query.name is set, it will\nreturn the first cookie it finds with that name, otherwise it will query for an\narray of cookies. If no query.url is set, it will use the current url. Here's an\nexample:\n\n\n\nAvailable properties are documented here:\nhttps://github.com/atom/electron/blob/master/docs/api/session.md#sescookiesgetde\ntails-callback\n\n.cookies.get()#\n\nGets all the cookies for the current url. If you'd like get all cookies for all\nurls, use: .get({ url: null }).\n\n.cookies.set(name, value)#\n\nSets a cookie's name and value. This is the most basic form, and the url will be\nthe current url.\n\n.cookies.set(cookie)#\n\nSets a cookie. If cookie.url is not set, it will set the cookie on the current\nurl. Here's an example:\n\n\n\nAvailable properties are documented here:\nhttps://github.com/atom/electron/blob/master/docs/api/session.md#sescookiessetde\ntails-callback\n\n.cookies.set(cookies)#\n\nSets multiple cookies at once. cookies is an array of cookie objects. Take a\nlook at the .cookies.set(cookie) documentation above for a better idea of what\ncookie should look like.\n\n.cookies.clear([name])#\n\nClears a cookie for the current domain. If name is not specified, all cookies\nfor the current domain will be cleared.\n\n\n\n.cookies.clearAll()#\n\nClears all cookies for all domains.\n\n\n\n\nProxies#\n\nProxies are supported in Nightmare through switches.\n\nIf your proxy requires authentication you also need the authentication call.\n\nThe following example not only demonstrates how to use proxies, but you can run\nit to test if your proxy connection is working:\n\n\n\n\nPromises#\n\nBy default, Nightmare uses default native ES6 promises. You can plug in your\nfavorite ES6-style promises library like bluebird or q for convenience!\n\nHere's an example:\n\n\n\nYou can also specify a custom Promise library per-instance with the Promise\nconstructor option like so:\n\n\n\n\nExtending Nightmare#\n\nNightmare.action(name, [electronAction|electronNamespace], action|namespace)#\n\nYou can add your own custom actions to the Nightmare prototype. Here's an\nexample:\n\n\n\n> Remember, this is attached to the static class Nightmare, not the instance.\n\nYou'll notice we used an internal function evaluate_now. This function is\ndifferent than nightmare.evaluate because it runs it immediately, whereas\nnightmare.evaluate is queued.\n\nAn easy way to remember: when in doubt, use evaluate. If you're creating custom\nactions, use evaluate_now. The technical reason is that since our action has\nalready been queued and we're running it now, we shouldn't re-queue the evaluate\nfunction.\n\nWe can also create custom namespaces. We do this internally for\nnightmare.cookies.get and nightmare.cookies.set. These are useful if you have a\nbundle of actions you want to expose, but it will clutter up the main nightmare\nobject. Here's an example of that:\n\n\n\nYou can also add custom Electron actions. The additional Electron action or\nnamespace actions take name, options, parent, win, renderer, and done. Note the\nElectron action comes first, mirroring how .evaluate() works. For example:\n\n\n\n...would clear the browser’s cache before navigating to example.org.\n\nSee this document for more details on creating custom actions.\n\n.use(plugin)#\n\nnightmare.use is useful for reusing a set of tasks on an instance. Check out\nnightmare-swiftly for some examples.\n\nCustom preload script#\n\nIf you need to do something custom when you first load the window environment,\nyou can specify a custom preload script. Here's how you do that:\n\n\n\nThe only requirement for that script is that you'll need the following prelude:\n\n\n\nTo benefit of all of nightmare's feedback from the browser, you can instead copy\nthe contents of nightmare's preload script.\n\nStorage Persistence between nightmare instances#\n\nBy default nightmare will create an in-memory partition for each instance. This\nmeans that any localStorage or cookies or any other form of persistent state\nwill be destroyed when nightmare is ended. If you would like to persist state\nbetween instances you can use the webPreferences.partition api in electron.\n\n\n\nIf you specify a null paritition then it will use the electron default behavior\n(persistent) or any string that starts with 'persist:' will persist under that\npartition name, any other string will result in in-memory only storage.\n\n\nUsage#\n\nInstallation#\n\nNightmare is a Node.js module, so you'll need to have Node.js installed. Then\nyou just need to npm install the module:\n\n\n\nExecution#\n\nNightmare is a node module that can be used in a Node.js script or module.\nHere's a simple script to open a web page:\n\n\n\nIf you save this as cnn.js, you can run it on the command line like this:\n\n\n\nCommon Execution Problems#\n\nNightmare heavily relies on Electron for heavy lifting. And Electron in turn\nrelies on several UI-focused dependencies (eg. libgtk+) which are often missing\nfrom server distros.\n\nFor help running nightmare on your server distro check out How to run nightmare\non Amazon Linux and CentOS guide.\n\nDebugging#\n\nThere are three good ways to get more information about what's happening inside\nthe headless browser:\n\n 1. Use the DEBUG=* flag described below.\n 2. Pass { show: true } to the nightmare constructor to have it create a\n    visible, rendered window where you can watch what is happening.\n 3. Listen for specific events.\n\nTo run the same file with debugging output, run it like this DEBUG=nightmare\nnode cnn.js (on Windows use set DEBUG=nightmare & node cnn.js).\n\nThis will print out some additional information about what's going on:\n\n\n\nDebug Flags#\n\nAll nightmare messages\n\n\n\nOnly actions\n\n\n\nOnly logs\n\n\n\n\nAdditional Resources#\n\n * Ross Hinkley's Nightmare Examples is a great resource for setting up\n   nightmare, learning about custom actions, and avoiding common pitfalls.\n * Nightmare Issues has a bunch of standalone runnable examples. The script\n   numbers correspond to nightmare issue numbers.\n * Nightmarishly good scraping is a great tutorial by Ændrew Rininsland on\n   getting up & running with Nightmare using real-life data.\n\n\nTests#\n\nAutomated tests for nightmare itself are run using Mocha and Chai, both of which\nwill be installed via npm install. To run nightmare's tests, just run make test.\n\nWhen the tests are done, you'll see something like this:\n\n\n\nNote that if you are using xvfb, make test will automatically run the tests\nunder an xvfb-run wrapper. If you are planning to run the tests headlessly\nwithout running xvfb first, set the HEADLESS environment variable to 0.\n\n下面是实际的案例\n\n","routePath":"/site/webpack/site/git/Nightmare","lang":"","toc":[{"text":"Examples","id":"examples","depth":2,"charIndex":1821},{"text":"To run the mocha tests","id":"to-run-the-mocha-tests","depth":3,"charIndex":2051},{"text":"API","id":"api","depth":2,"charIndex":2079},{"text":"Nightmare(options)","id":"nightmareoptions","depth":4,"charIndex":2085},{"text":"certificateSubjectName","id":"certificatesubjectname","depth":4,"charIndex":4521},{"text":".engineVersions()","id":"engineversions","depth":4,"charIndex":4816},{"text":".useragent(useragent)","id":"useragentuseragent","depth":4,"charIndex":4882},{"text":".authentication(user, password)","id":"authenticationuser-password","depth":4,"charIndex":4944},{"text":".end()","id":"end","depth":4,"charIndex":5104},{"text":".halt(error, done)","id":"halterror-done","depth":4,"charIndex":5412},{"text":"Interact with the Page","id":"interact-with-the-page","depth":3,"charIndex":5616},{"text":".goto(url[, headers])","id":"gotourl-headers","depth":4,"charIndex":5641},{"text":".back()","id":"back","depth":4,"charIndex":7247},{"text":".forward()","id":"forward","depth":4,"charIndex":7290},{"text":".refresh()","id":"refresh","depth":4,"charIndex":7335},{"text":".click(selector)","id":"clickselector","depth":4,"charIndex":7377},{"text":".mousedown(selector)","id":"mousedownselector","depth":4,"charIndex":7431},{"text":".mouseup(selector)","id":"mouseupselector","depth":4,"charIndex":7493},{"text":".mouseover(selector)","id":"mouseoverselector","depth":4,"charIndex":7551},{"text":".mouseout(selector)","id":"mouseoutselector","depth":4,"charIndex":7613},{"text":".type(selector[, text])","id":"typeselector-text","depth":4,"charIndex":7672},{"text":".insert(selector[, text])","id":"insertselector-text","depth":4,"charIndex":8187},{"text":".check(selector)","id":"checkselector","depth":4,"charIndex":8448},{"text":".uncheck(selector)","id":"uncheckselector","depth":4,"charIndex":8506},{"text":".select(selector, option)","id":"selectselector-option","depth":4,"charIndex":8568},{"text":".scrollTo(top, left)","id":"scrolltotop-left","depth":4,"charIndex":8679},{"text":".viewport(width, height)","id":"viewportwidth-height","depth":4,"charIndex":8814},{"text":".inject(type, file)","id":"injecttype-file","depth":4,"charIndex":8866},{"text":".evaluate(fn[, arg1, arg2,...])","id":"evaluatefn-arg1-arg2","depth":4,"charIndex":8973},{"text":".wait(ms)","id":"waitms","depth":4,"charIndex":9808},{"text":".wait(selector)","id":"waitselector","depth":4,"charIndex":9865},{"text":".wait(fn[, arg1, arg2,...])","id":"waitfn-arg1-arg2","depth":4,"charIndex":9955},{"text":".header(header, value)","id":"headerheader-value","depth":4,"charIndex":10115},{"text":"Extract from the Page","id":"extract-from-the-page","depth":3,"charIndex":10248},{"text":".exists(selector)","id":"existsselector","depth":4,"charIndex":10272},{"text":".visible(selector)","id":"visibleselector","depth":4,"charIndex":10349},{"text":".on(event, callback)","id":"onevent-callback","depth":4,"charIndex":10419},{"text":".once(event, callback)","id":"onceevent-callback","depth":4,"charIndex":12053},{"text":".removeListener(event, callback)","id":"removelistenerevent-callback","depth":4,"charIndex":12150},{"text":".screenshot([path][, clip])","id":"screenshotpath-clip","depth":4,"charIndex":12234},{"text":".html(path, saveType)","id":"htmlpath-savetype","depth":4,"charIndex":12572},{"text":".pdf(path, options)","id":"pdfpath-options","depth":4,"charIndex":12692},{"text":".title()","id":"title","depth":4,"charIndex":12768},{"text":".url()","id":"url","depth":4,"charIndex":12819},{"text":".path()","id":"path","depth":4,"charIndex":12866},{"text":"Cookies","id":"cookies","depth":3,"charIndex":12921},{"text":".cookies.get(name)","id":"cookiesgetname","depth":4,"charIndex":12931},{"text":".cookies.get(query)","id":"cookiesgetquery","depth":4,"charIndex":13014},{"text":".cookies.get()","id":"cookiesget","depth":4,"charIndex":13428},{"text":".cookies.set(name, value)","id":"cookiessetname-value","depth":4,"charIndex":13558},{"text":".cookies.set(cookie)","id":"cookiessetcookie","depth":4,"charIndex":13685},{"text":".cookies.set(cookies)","id":"cookiessetcookies","depth":4,"charIndex":13953},{"text":".cookies.clear([name])","id":"cookiesclearname","depth":4,"charIndex":14159},{"text":".cookies.clearAll()","id":"cookiesclearall","depth":4,"charIndex":14305},{"text":"Proxies","id":"proxies","depth":3,"charIndex":14367},{"text":"Promises","id":"promises","depth":3,"charIndex":14641},{"text":"Extending Nightmare","id":"extending-nightmare","depth":3,"charIndex":14932},{"text":"Nightmare.action(name, [electronAction|electronNamespace], action|namespace)","id":"nightmareactionname-electronactionelectronnamespace-actionnamespace","depth":4,"charIndex":14954},{"text":".use(plugin)","id":"useplugin","depth":4,"charIndex":16256},{"text":"Custom preload script","id":"custom-preload-script","depth":4,"charIndex":16386},{"text":"Storage Persistence between nightmare instances","id":"storage-persistence-between-nightmare-instances","depth":4,"charIndex":16766},{"text":"Usage","id":"usage","depth":2,"charIndex":17363},{"text":"Installation","id":"installation","depth":4,"charIndex":17371},{"text":"Execution","id":"execution","depth":4,"charIndex":17508},{"text":"Common Execution Problems","id":"common-execution-problems","depth":4,"charIndex":17718},{"text":"Debugging","id":"debugging","depth":4,"charIndex":18040},{"text":"Additional Resources","id":"additional-resources","depth":2,"charIndex":18657},{"text":"Tests","id":"tests","depth":2,"charIndex":19091}],"domain":"","frontmatter":{},"version":""},{"id":9,"title":"JS实现翻译的多种方案","content":"中英文切换\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n你好","routePath":"/site/webpack/site/git/Translation","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":10,"title":"enzyme 简单实践","content":"#\n\n统计信息：字数 2847 阅读6分钟\n\nenzyme 主要用于 React 组件测试\n\n文档链接：https://enzymejs.github.io/enzyme/\n\nhttps://www.npmjs.com/package/enzyme\n\nJest\n断言配置：https://github.com/enzymejs/enzyme-matchers/tree/master/packages/jest-enzym\ne\n\n环境依赖配置：https://github.com/enzymejs/enzyme-matchers/tree/master/packages/jest-env\nironment-enzyme\n\n官网星星只有 800 颗，证明实际使用的人数不是很多（因为判断组件太严格）国内的组件和功能经常更改，这里不合适，代码两年没有更新了\n\n\n简单步骤#\n\n这个只是测试组件，不包括断言库，可以选择自定义的断言库（React 通常匹配 Jest 断言库）\n\n需要在测试入口配置\n\n\n\n然后编写组件测试文件\n\n\n\n渲染组件有三个方式\n\nshallow rendering：浅渲染有助于限制您将组件作为一个单元进行测试，并确保您的测试不会间接断言子组件的行为。\n\nfull DOM rendering：完整 DOM 渲染非常适用于您的组件可能与 DOM API 交互或需要测试封装在高阶组件中的组件的用例。\n\nstatic rendered markup：使用 enzyme 的渲染功能从你的 React 树中生成 HTML，并分析生成的 HTML 结构。\n\n适合不同的组件和交互\n\nhttps://enzymejs.github.io/enzyme/docs/api/shallow.html\n\nhttps://enzymejs.github.io/enzyme/docs/api/mount.html\n\nhttps://enzymejs.github.io/enzyme/docs/api/render.html","routePath":"/site/webpack/site/git/enzyme 简单实践","lang":"","toc":[{"text":"简单步骤","id":"简单步骤","depth":3,"charIndex":380}],"domain":"","frontmatter":{},"version":""},{"id":11,"title":"Git 使用规范流程","content":"#\n\n统计信息：字数 6168 阅读13分钟\n\n团队开发中，遵循一个合理、清晰的Git使用流程，是非常重要的。\n\n否则，每个人都提交一堆杂乱无章的commit，项目很快就会变得难以协调和维护。\n\n下面是ThoughtBot 的Git使用规范流程。我从中学到了很多，推荐你也这样使用Git。\n\n\n\n\n第一步：新建分支#\n\n首先，每次开发新功能，都应该新建一个单独的分支（这方面可以参考《Git分支管理策略》）。\n\n\n\n\n第二步：提交分支commit#\n\n分支修改后，就可以提交commit了。\n\n\n\ngit add 命令的all参数，表示保存所有变化（包括新建、修改和删除）。\n\ngit status 命令，用来查看发生变动的文件。\n\ngit commit 命令的verbose参数，会列出 diff 的结果。\n\n\n第三步：撰写提交信息#\n\n提交commit时，必须给出完整扼要的提交信息，下面是一个范本。\n\n\n\n第一行是不超过50个字的提要，然后空一行，罗列出改动原因、主要变动、以及需要注意的问题。最后，提供对应的网址（比如Bug ticket）。\n\n\n第四步：与主干同步#\n\n分支的开发过程中，要经常与主干保持同步。\n\n\n\n\n第五步：合并commit#\n\n分支开发完成后，很可能有一堆commit，但是合并到主干的时候，往往希望只有一个（或最多两三个）commit，这样不仅清晰，也容易管理。\n\n那么，怎样才能将多个commit合并呢？这就要用到 git rebase 命令。\n\n\n\ngit rebase命令的i参数表示互动（interactive），这时git会打开一个互动界面，进行下一步操作。\n\n下面采用Tute Costa的例子，来解释怎么合并commit。\n\n\n\n上面的互动界面，先列出当前分支最新的4个commit（越下面越新）。每个commit前面有一个操作命令，默认是pick，表示该行commit被选中，要进行reb\nase操作。\n\n4个commit的下面是一大堆注释，列出可以使用的命令。\n\n>  * pick：正常选中\n>  * reword：选中，并且修改提交信息；\n>  * edit：选中，rebase时会暂停，允许你修改这个commit（参考这里）\n>  * squash：选中，会将当前commit与上一个commit合并\n>  * fixup：与squash相同，但不会保存当前commit的提交信息\n>  * exec：执行其他shell命令\n\n上面这6个命令当中，squash和fixup可以用来合并commit。先把需要合并的commit前面的动词，改成squash（或者s）。\n\n\n\n这样一改，执行后，当前分支只会剩下两个commit。第二行和第三行的commit，都会合并到第一行的commit。提交信息会同时包含，这三个commit的提交信\n息。\n\n\n\n如果将第三行的squash命令改成fixup命令。\n\n\n\n运行结果相同，还是会生成两个commit，第二行和第三行的commit，都合并到第一行的commit。但是，新的提交信息里面，第三行commit的提交信息，会被\n注释掉。\n\n\n\nsquash和fixup命令，还可以当作命令行参数使用，自动合并commit。\n\n\n\n\n第六步：推送到远程仓库#\n\n合并commit后，就可以推送当前分支到远程仓库了。\n\n\n\ngit push命令要加上force参数，因为rebase以后，分支历史改变了，跟远程分支不一定兼容，有可能要强行推送。\n\n\n第七步：发出Pull Request#\n\n提交到远程仓库以后，就可以发出 Pull Request 到master分支，然后请求别人进行代码review，确认可以合并到master。","routePath":"/site/webpack/site/git/git-use-process","lang":"","toc":[{"text":"第一步：新建分支","id":"第一步新建分支","depth":2,"charIndex":148},{"text":"第二步：提交分支commit","id":"第二步提交分支commit","depth":2,"charIndex":208},{"text":"第三步：撰写提交信息","id":"第三步撰写提交信息","depth":2,"charIndex":356},{"text":"第四步：与主干同步","id":"第四步与主干同步","depth":2,"charIndex":477},{"text":"第五步：合并commit","id":"第五步合并commit","depth":2,"charIndex":514},{"text":"第六步：推送到远程仓库","id":"第六步推送到远程仓库","depth":2,"charIndex":1363},{"text":"第七步：发出Pull Request","id":"第七步发出pull-request","depth":2,"charIndex":1470}],"domain":"","frontmatter":{},"version":""},{"id":12,"title":"npm link的使用","content":"npm link用法总结#\n\n统计信息：字数 1997 阅读4分钟\n\nnpm link用来在本地项目和本地npm模块之间建立连接，可以在本地进行模块测试\n\n具体用法：\n\n1. 项目和模块在同一个目录下，可以使用相对路径\n\nnpm link ../module\n\n2. 项目和模块不在同一个目录下\n\ncd到模块目录，npm link，进行全局link\n\ncd到项目目录，npm link 模块名(package.json中的name)\n\n3. 解除link\n\n解除项目和模块link，项目目录下，npm unlink 模块名\n\n解除模块全局link，模块目录下，npm unlink 模块名\n\n\nnpm link的使用#\n\n\n功能#\n\n在本地开发npm模块的时候，我们可以使用npm link命令，将npm 模块链接到对应的运行项目中去，方便地对模块进行调试和测试\n\n\n使用方法#\n\n\n创建链接#\n\n在这里，我们有两个项目，一个是npm-link-module，是我们要开发的npm模块,另一个是npm-link-example,是我们要运行npm模块的项目\n\n首先，进入我们的npm-link-module项目，执行npm link\n\n\n\n执行命令后，npm-link-module会根据package.json上的配置，被链接到全局，路径是{prefix}/lib/node_modules/，这是\n官方文档上的描述，我们可以使用npm config get\nprefix命令获取到prefix的值(不过我这里使用的是windows，实际被链接到的路径是{prefix}/node_modules/，不知道是不是npm升\n级的原因)，如果是win系统的话，实际观察，会发现在{prefix}/lib/node_modules/路径下的node-link-module是一个快捷方式\n\n然后，进入npm-link-example项目，执行 npm link npm-link-module\n\n\n\nnpm-link-module会被链接到 npm-link-example/node_modules下面，同样也是快捷方式\n\nOK，链接创建完成\n\n\n代码实践#\n\n好，让我们测试一下创建链接之后会有哪些便利\n\n之前在npm-link-module里，我是这样写的\n\n我们在npm-link-example引用然后运行","routePath":"/site/webpack/site/git/npm link的使用","lang":"","toc":[{"text":"功能","id":"功能","depth":2,"charIndex":311},{"text":"使用方法","id":"使用方法","depth":2,"charIndex":383},{"text":"创建链接","id":"创建链接","depth":3,"charIndex":391},{"text":"代码实践","id":"代码实践","depth":3,"charIndex":922}],"domain":"","frontmatter":{},"version":""},{"id":13,"title":"Npm版本问题","content":"npm package-lock的管理#\n\n统计信息：字数 11886 阅读24分钟\n\npackage-lock.json文件很容易产生冲突，我们先来看看为什么需要 package-lock.json.\n\n\npackage-lock.json 作用#\n\n> package-lock.json is automatically generated for any operations where npm\n> modifies either the node_modules tree, or package.json. It describes the exact\n> tree that was generated, such that subsequent installs are able to generate\n> identical trees, regardless of intermediate dependency updates.\n\n以上摘自官方文档，翻译一下就是\n\npackage-lock.json会在npm更改node_modules目录树或者package.json时自动生成的。它准确的描述了当前项目npm包的依赖树，\n并且在随后的安装中会根据package-lock.json来安装，保证是相同的一个依赖树，不考虑这个过程中是否有某个依赖有小版本的更新。\n\n这里有个很重要的点就是，package-lock.json记录的是一个依赖树，而不是你直接在package.json中的依赖项。和直接在package.json\n中锁死版本不一样的地方在于，package.json中只是锁死了依赖项的版本，而没有锁死依赖项的依赖的版本，这里就是变数的地方。如果不对整个依赖树做锁定，那前后\n编译出来的应用版本可能是不一样的，有可能开发时能正常工作，而到了线上却不能工作。\n\n所以很明显的package-lock.json是很符合我们的诉求的。我们需要让后面每一次install都是相同的版本，打出来的包都有着相同的依赖，这对于我们项目\n的稳定性、前后一致性是非常重要的。\n\n\n解决 package-lock 的冲突#\n\n不要试图删除package-lock.json来解决一些问题，这样会破坏package-lock.json的作用。\n\npackage-lock是工具自动生成的一个文件内容，对于这种自动生成的文件最好的办法还是交由工具去处理，而不是手工一个一个的去处理产生的冲突。\n\n在开发过程中，合并的时候如何如果出现了冲突，在merge\nconflicts的阶段，只需要从主分支中checkout去package-lock.json，再以此为基础，重新安装新分支中需要的依赖。\n\n\n\n这样让npm自动的去维护package-lock.json。当然上面的步骤同样也适用于rebase过程。\n\n我相信这个办法可以很好的解决package-lock.json冲突的问题，并且团队合作中，做merge或者rebase操作的人可以通过查看package.jso\nn的变更知道新安装了哪些依赖包，来重新安装，也可以很好的解决这个问题。\n\n\n校验 package-lock.json 的正确性#\n\n在按照上面的步骤解决完package-lock.json的冲突后，code\nreviewer对package-lock.json的正确性需要做一次校验，按照gerrit中的说法就是verify的过程。将被review的代码拉到本地做一次\nnpm\ninstall，检查package-lock.json是否有modified，如果没有modify说明提交的package-lock.json是一份正确的文件。\n\n有一个问题，package-lock.json中的resolved字段会被不同环境中的npm\nregistry改写，这样会导致很多的冲突。所以在经过正确性校验的过程中，可能会因为本地registry的配置问题会导致package-lock.json处于m\nodified状态。所以为了规避这个问题，需要在团队内统一npm\nregistry，可以在项目根目录中使用.npmrc来配置项目级别的registry来进行统一。\n\n\nresolved 选项#\n\n不同依赖库安装时，会更改 resolved 选项。不同电脑执行同样的 npm install 会产生不同的 package-lock.json\n文件，这样会造成代码冲突。本质的原因如下：\n\n\nNpm版本问题#\n\n\n简介#\n\n如果你已经将节点包管理(npm)更新到版本5.x.x，看起来一切似乎都很顺利。等等，这是什么?用 npm 初始化项目的会自动创建了一个新文件\npackage-lock.json。如果打开它，它看起来有点像 package.json\n的依赖项，但更冗长。我们决定忽略它，继续开发项目。最终，我们有时会遇到依赖项的问题，找不到，或者安装了错误的版本。大多数人最终都会删package-lock.j\nson和运行“npm install”。那么，为什么要有它呢? 它应该做什么? 它实际上是做什么的?\n\n\n总结#\n\n * 如果你使用的 npm 版本 为 ^5.x.x , package-lock.json 会默认自动生成\n * 你应该使用 package-lock 来确保一致的安装和兼容的依赖关系\n * 你应该将 package-lock 提交到源代码控制\n * 从npm ^ 5.1.x开始，package.json能够胜过 package-lock.json，所以你遇到较少让人头痛的问题\n * 不再删除 package-lock 只是为了运行npm install并重新生成它\n\n\n背景#\n\n语义版本控制#\n\n在你了解 package-lock 甚至 package.jso n之前，你必须了解语义版本控制（semver）。 这是npm背后的天才，是什么使它更成功。\n你可以在 此处\n阅读有关npm如何使用它的更多信息。简而言之，如果你正在构建与其他应用程序接口的应用程序，你应该告知你所做的更改将如何影响第三方与你的应用程序交互的能力。这是通\n过语义版本控制完成的，版本由三部分组成：X，Y，Z，分别是主要版本，次要版本和补丁版本。\n\n例如：1.2.3，主要版本1，次要版本2，补丁3。\n\n补丁中的更改表示不会破坏任何内容的错误修复。 次要版本的更改表示不会破坏任何内容的新功能。 主要版本的更改代表了一个破坏兼容性的大变化。\n如果用户不适应主要版本更改，则内容将无法正常工作。\n\n管理包#\n\nnpm 存在使管理包变得容易。你的项目可能有数百个依赖项，每个依赖项都有一百个，为了让你的注意力远离依赖地狱，通过 npm\n管理，使用一些简单的命令，你可以安装和管理这些依赖关系，几乎不必考虑它们。\n\n当您使用npm安装包（并保存它）时，会在 package.json 中添加一个包含包名称和应该使用的 semver的条目。默认情况下，npm\n安装最新版本，并预先插入版本号，例如 “^1.2.12”，这表示至少应该使用版本\n1.2.12，但任何高于此版本的版本都可以，只要它具有相同的主要版本，由于次要版本和补丁编号仅代表错误修正和非破坏性添加，\n你可以安全地使用任何更高版本的同一主要版本。阅读更多关于semver通配符的信息，请看 这里。\n\n共享项目#\n\n在 package.json 中定义这样的依赖项的真正好处是，任何有权访问 package.json\n的人都可以创建一个包含运行应用程序所需模块的依赖项文件夹，但是让我们来看看事情可能出错的具体方式。\n\n假设我们创建了一个将使用 express 的新项目。 运行npm init后，我们安装express：npm install express -\nsave。在编写代码时，最新的版本是4.15.4，所以 “express”：“^\n4.15.4”作为我的package.json中的依赖项添加，并且我的电脑安装了确切的版本。\n\n现在也许明天，express 的维护者会发布 bug 修复，因此最新版本变为4.15.5。 然后，如果有人想要为我的项目做贡献，他们会克隆它，然后运行`npm\ninstall。'因为4.15.5是具有相同主要版本的更高版本，所以为它们安装。 我们都安装 express ，但我们却是不同的版本。\n\n从理论上讲，它们应该仍然是兼容的，但也许bugfix会影响我们正在使用的功能，而且当使用Express版本4.15.4和4.15.5运行时，我们的应用程序会产生\n不同的结果。\n\n\nPackage-lock#\n\n目的#\n\npackage-lock.json 的目的是避免上述情况，其中从同一 package.json 安装模块会导致两种不同的安装。 在 npm 版本 5.x.x\n中添加了 package-lock.json，因此如果你使用的是主要版本 5 或更高版本，除非您禁用它，否则它会自动生成。\n\n内容结构#\n\npackage-lock 是 package.json\n中列出的每个依赖项的大型列表，应安装的特定版本，模块的位置（URI），验证模块完整性的哈希，它需要的包列表 ，以及依赖项列表。 让我们来看看 express\n的列表是什么：\n\n\n\n可以在“requires”部分中列出的每个包中找到等效条目。\n\nnpm(^5.x.x.x)后的做法，npm 使用package-lock.json，而不是使用 package.json 来解析和安装模块。因为\npackage-lock 为每个模块及其每个依赖项指定了版本，位置和完整性哈希，所以它每次创建的安装都是相同的。\n无论你使用什么设备，或者将来安装它都无关紧要，每次都应该给你相同的结果，这非常有用。\n\n\n争议#\n\n因此，如果引用 package-lock 是希望解决一个常见问题，为什么它的顶级搜索结果（除了npm文档）都是关于禁用它或质疑它扮演的角色？\n\n在npm 5.x.x之前，package.json 是项目的真实来源，npm 用户喜欢这个模型，并且非常习惯于维护他们的包文件。 但是，当首次引入\npackage-lock 时，它的行为与有多少人预期的相反。\n给定一个预先存在的包和package-lock，对package.json的更改（许多用户认为是真实的来源）没有同步到package-lock 中。\n\n**示例：**包A，版本 1.0.0 在 package.json 和 package.lock.json 中。\n在package.json中，A被手动编辑为1.1.0版。 如果认为 package.json 是真实来源的用户运行 npm install，他们会期望安装\n1.1.0版。 但是，安装了1.0.0版，即使列出的 v1.1.0 是 package.json， 他们也希望安装是 1.0.0版。\n\n示例： package-lock.json 中不存在模块，但它存在于 package.json 中，作为一个将package.json\n视为真实来源的用户，我希望能够安装我的模块。 但是，由于 package-lock.json 不存在该模块，因此未安装该模块，并且我的代码因无法找到模块而失败。\n\n大部分时间，因为我们无法弄清楚为什么我们的依赖关系没有被正确安装，要么删除了package-lock.json 并重新安装，要么完全禁用\npackage-lock.json 来解决问题。\n\n期望与真实行为之间的这种冲突在 npm repo中引发了一个非常有趣的问题线索。 有些人认为package.json 应该是事实的来源，有些人认为，因为\npackage-lock 是 npm 用来创建安装的东西，所以应该被认为是事实的来源。 这场争议的解决方案在于 PR＃17508。 如果\npackage.json 已更新，Npm 维护者添加了一个更改，导致package.json 覆盖 package-lock。\n现在，在上述两种情况下，都会正确安装用户期望安装的软件包。 此更改是作为npm v5.1.0的一部分发布的，该版本于2017年7月5日上线。","routePath":"/site/webpack/site/git/npm package-lock的管理","lang":"","toc":[{"text":"package-lock.json 作用","id":"package-lockjson-作用","depth":2,"charIndex":103},{"text":"解决 package-lock 的冲突","id":"解决-package-lock-的冲突","depth":2,"charIndex":901},{"text":"校验 package-lock.json 的正确性","id":"校验-package-lockjson-的正确性","depth":2,"charIndex":1331},{"text":"resolved 选项","id":"resolved-选项","depth":2,"charIndex":1776},{"text":"简介","id":"简介","depth":2,"charIndex":1897},{"text":"总结","id":"总结","depth":2,"charIndex":2152},{"text":"背景","id":"背景","depth":2,"charIndex":2395},{"text":"**语义版本控制**","id":"语义版本控制","depth":4,"charIndex":-1},{"text":"**管理包**","id":"管理包","depth":4,"charIndex":-1},{"text":"**共享项目**","id":"共享项目","depth":4,"charIndex":-1},{"text":"**Package-lock**","id":"package-lock","depth":2,"charIndex":-1},{"text":"**目的**","id":"目的","depth":4,"charIndex":-1},{"text":"**内容结构**","id":"内容结构","depth":4,"charIndex":-1},{"text":"争议","id":"争议","depth":2,"charIndex":4080}],"domain":"","frontmatter":{},"version":""},{"id":14,"title":"npm 两步验证","content":"#\n\n统计信息：字数 2060 阅读5分钟\n\n\n问题#\n\n近期发布版本时，在 cli npm login登录后，输入正确的用户名和密码，提示需要一个 Enter one-time password from your\nauthenticator app，无法发包。\n\n在网页上操作，登录时也需要输入临时的验证码（one-time password），无法登录。\n\n\n当前配置#\n\n本地或者 web 端没有开启配置两步验证\n\nhttps://docs.npmjs.com/configuring-two-factor-authentication#removing-2fa-on-the\n-web\n\n本地查看是否支持两步验证\n\n\n\n官方建议开启两步验证，但是本地经常发布版本，不希望使用两步验证（太麻烦）。根据官方文档，cli 登录都需要一个两步验证（为了安全），不能直接跳过两步验证。\n\nFor your security, npm may require additional verification to allow you to log\nin to your account. If you do not have two-factor authentication enabled, you\nmay be asked to verify yourself with a one-time password sent to the email\naddress configured for your account.\n\n\n解决方法#\n\n1、在网页端登录，然后会发一个验证码到邮箱中（可能6位数字），使用验证码可以正常登录。详见文档：\n\nhttps://docs.npmjs.com/receiving-a-one-time-password-over-email\n\n2、登录后，找到设置界面，获取 token （选择读写的权限）\n\n3、在项目根目录中，或者用户根目录中，配置一下 .npmrc 后面的是获取的 token\n\n\n\n具体参考：https://docs.npmjs.com/using-private-packages-in-a-ci-cd-workflow\n\n4、切换到项目中，直接运行 npm publish 即可发布版本（发版本不需要登录）；再次发版本时，直接执行4。\n\n注：也可以在发版本时，在环境变量中增加 token，可以试一下 export xxxxx && npm run build && npm publish\n\n如果安装私有库的代码，执行 npm install 也是正常的","routePath":"/site/webpack/site/git/npm 发布两步验证","lang":"","toc":[{"text":"问题","id":"问题","depth":3,"charIndex":23},{"text":"当前配置","id":"当前配置","depth":3,"charIndex":182},{"text":"解决方法","id":"解决方法","depth":3,"charIndex":664}],"domain":"","frontmatter":{},"version":""},{"id":15,"title":"npm 学习","content":"#\n\n统计信息：字数 7799 阅读16分钟\n\nNPM（node package manager），通常称为node包管理器。顾名思义，它的主要功能就是管理node包。\n\n包括：安装、卸载、更新、查看、搜索、发布等。\n\n\n1、常规使用#\n\n\n安装#\n\nnode包的安装分两种：本地安装、全局安装。两者的区别如下，后面会通过简单例子说明\n\n * 本地安装：package会被下载到当前所在目录，也只能在当前目录下使用。\n * 全局安装：package会被下载到到特定的系统目录下，安装的package能够在所有目录下使用。\n\nnpm install -g grunt-cli 全局安装 grunt-cli\n\n对于单独作用的包，安装在对应的文件夹下，对于全局的指令（cnpm, grunt-cli 等全局工具需要全局安装）\n\n\n\n\n更新#\n\n以 react 为例\n\n\n\n\n查看#\n\n\n\n\n搜索#\n\n\n\n\n\n\n发布#\n\n\n\n\n2、NPM配置#\n\nnpm 在内网中的配置：npm config 主要是增删改查，下面以代理服务器 proxy 进行分析。这部分功能目前使用不多。\n\n\n设置proxy#\n\n内网使用npm很头痛的一个问题就是代理，假设我们的代理是 http://proxy.example.com:8080，那么命令如下：\n\n\n\n由于npm config set命令比较常用，于是可以如下简写\n\n\n\n\n查看proxy#\n\n设置完，我们查看下当前代理设置\n\n\n\n输出如下：\n\n\n\n同样可如下简写：\n\n\n\n\n删除proxy#\n\n代理不需要用到了，那删了吧\n\n\n\n\n查看所有配置#\n\n\n\n\n直接修改配置文件#\n\n有时候觉得一条配置一条配置地修改有些麻烦，就直接进配置文件修改了\n\n\n\n\n3、package.json字段简介#\n\n 1. name: package的名字（由于他会成为url的一部分，所以 non-url-safe\n    的字母不会通过，也不允许出现\".\"、\"_\"），最好先在http://registry.npmjs.org/上搜下你取的名字是否已经存在\n 2. version:\n    package的版本，当package发生变化时，version也应该跟着一起变化，同时，你声明的版本需要通过semver的校验（semver可自行谷歌\n    ）\n 3. dependencies:\n    ==package的应用依赖模块，即别人要使用这个package，至少需要安装哪些东东==。应用依赖模块会安装到当前模块的node_modules目录下\n    。例如运行时需要的 react vue bootstrap.\n 4. devDependencies：==package的开发依赖模块，即别人要在这个package上进行开发==。例如 webpack\n\n\n4、版本号#\n\na、\"~1.2.3\"\n\n\n\n\n\n\n\nb、\"1.x.x\"\n\n\n\n\n\n\n\n\n5、npm 升级#\n\n\n\n通常情况下 npm 会和 nodeJS 同时安装。默认的安装版本是5。有些情况需要手动更新 npm 版本。\n\n> Since npm and node.js products are managed by different entities, updates and\n> maintenance can become complex. Also, the Node.js installation process\n> installs npm in a directory that only has local permissions. This can cause\n> permissions errors when you attempt to run packages globally.\n\n> To solve both these issues, many developers opt to use a node version manager,\n> or nvm, to install npm. The version manager will avoid permissions errors, and\n> will solve the complexities of updating Node.js and npm.\n\n> In addition, developers can use an nvm to test their applications on multiple\n> versions of npm. The nvm enables you to easily switch npm as well as node\n> versions. This makes it easier to ensure that your applications work for most\n> users, even if they are using other versions of npm. If you decide to install\n> a version manager, use the instructions for the version manager you select to\n> learn how to switch versions, and to learn how to keep up-to-date with the\n> latest version of npm.\n\n> 由于npm和node.js产品由不同的实体管理，因此更新和维护可能会变得复杂。此外，Node.js安装过程将npm安装在一个只有本地权限的目录中。当您尝试全\n> 局运行程序包时，这可能会导致权限错误。\n> \n> 为了解决这两个问题，许多开发人员选择使用节点版本管理器或nvm来安装npm。版本管理器将避免权限错误，并将解决更新Node.js和npm的复杂性。\n> \n> 此外，开发人员可以使用nvm在多个版本的npm上测试他们的应用程序。nvm使您能够轻松切换npm以及节点版本。这样可以更容易地确保您的应用程序适用于大多数用\n> 户，即使他们正在使用其他版本的npm。如果您决定安装版本管理器，请使用所选版本管理器的说明来学习如何切换版本，并学习如何保持最新版本的npm。\n\n这个是不同版本下的 node 和 npm，最好使用 nmv 或者 n 等版本管理工具处理不同版本问题","routePath":"/site/webpack/site/git/npm 学习","lang":"","toc":[{"text":"1、常规使用","id":"1常规使用","depth":2,"charIndex":110},{"text":"安装","id":"安装","depth":3,"charIndex":120},{"text":"更新","id":"更新","depth":3,"charIndex":363},{"text":"查看","id":"查看","depth":3,"charIndex":383},{"text":"搜索","id":"搜索","depth":3,"charIndex":391},{"text":"发布","id":"发布","depth":3,"charIndex":401},{"text":"2、NPM配置","id":"2npm配置","depth":2,"charIndex":409},{"text":"设置proxy","id":"设置proxy","depth":3,"charIndex":485},{"text":"查看proxy","id":"查看proxy","depth":3,"charIndex":601},{"text":"删除proxy","id":"删除proxy","depth":3,"charIndex":652},{"text":"查看所有配置","id":"查看所有配置","depth":3,"charIndex":680},{"text":"直接修改配置文件","id":"直接修改配置文件","depth":3,"charIndex":692},{"text":"3、package.json字段简介","id":"3packagejson字段简介","depth":2,"charIndex":740},{"text":"4、版本号","id":"4版本号","depth":2,"charIndex":1190},{"text":"5、npm 升级","id":"5npm-升级","depth":2,"charIndex":1234}],"domain":"","frontmatter":{},"version":""},{"id":16,"title":"npx 教程","content":"#\n\n统计信息：字数 1137 阅读3分钟\n\nnpx 是 npm 的高级版本\n\n\n用途#\n\n * 在项目中直接运行指令，直接运行node_modules中的某个指令，不需要输入文件路径\n\n\n\n * 避免全局安装模块：npx 临时安装一个模块，使用过后删除这个模块(下面的两个模块不需要全局安装)\n\n\n\n * 使用不同版本的命令，使用本地或者下载的命令\n\n\n\n\n参数#\n\n-p 下载某个模块后，运行命令（命令必须在下载后才行，类似于通道符）\n\n\n\n\ngithub#\n\n可以执行仓库中的代码，远程代码必须是一个模块，即必须包含package.json和入口脚本\n\n","routePath":"/site/webpack/site/git/npx","lang":"","toc":[{"text":"用途","id":"用途","depth":3,"charIndex":40},{"text":"参数","id":"参数","depth":3,"charIndex":179},{"text":"github","id":"github","depth":3,"charIndex":223}],"domain":"","frontmatter":{},"version":""},{"id":17,"title":"","content":"更好用的前端 npm link 工具-yalc#\n\n统计信息：字数 2564 阅读6分钟\n\n在组件依赖开发中，我的项目作为依赖库没方法独自间接运行，须要依赖进别的我的项目执行，这时候最罕用的形式就是npm link。但用npm\nlink引入的依赖因为资源文件不在我的项目下，webpack不会对其做预编译，导致理论构建或者运行时会报错，此时如果间接将文件复制进依赖目录则能失常运行。对于这\n样的状况，意外的碰到了一个很适宜的解决方案——yalc。\n\n\nYalc#\n\nyalc 能够在本地将npm包模仿公布，将公布后的资源寄存在一个全局存储中。而后能够通过yalc将包增加进须要援用的我的项目中。\n\n这时候package.json的依赖表中会多出一个file:.yalc/...的依赖包，这就是yalc创立的非凡援用。同时也会在我的项目根目录创立一个yalc.\nlock确保援用资源的一致性。因而，测试完我的项目还须要执行删除yalc包的操作，能力失常应用。\n\n整个过程绝对于npm link会更加繁琐一些，要通过发包、增加依赖，完结后也须要做革除操作，但也正因而才防止了npm link的一些问题。\n\n\n装置#\n\n\n\n\n公布依赖#\n\n在所开发的依赖我的项目下执行公布操作\n\n\n\n此时如果存在npm\n生命周期脚本：prepublish、prepare、prepublishOnly、prepack、preyalcpublish，会按此程序逐个执行。如果存在：p\nostyalcpublish、postpack、publish、postpublish，也会按此程序逐个执行。\n\n想要齐全禁用脚本执行须要应用\n\n\n\n此时就曾经将依赖公布到本地了。\n\n\n增加依赖#\n\n进入到我的项目执行\n\n\n\n能够看到我的项目中增加了yalc.lock文件，package.json对应的包名会有个地址为file:.yalc/结尾的我的项目。 也能够应用\n\n\n\n将版本锁定，防止因为本地新包推送产生影响。\n\n--dev将依赖增加进dependency中。--pure不会影响package.json文件。\n\n除此之外，还能应用link形式援用依赖包。\n\n\n\n\n更新依赖#\n\n当有新批改的包须要公布时，应用推送命令能够疾速的更新所有依赖\n\n\n\n或是简写\n\n\n\n\n移除依赖#\n\n\n\n或是移除所有\n\n","routePath":"/site/webpack/site/git/yalc","lang":"","toc":[{"text":"更好用的前端 npm link 工具-yalc","id":"更好用的前端-npm-link-工具-yalc","depth":2,"charIndex":-1},{"text":"Yalc","id":"yalc","depth":3,"charIndex":225},{"text":"装置","id":"装置","depth":3,"charIndex":501},{"text":"公布依赖","id":"公布依赖","depth":3,"charIndex":509},{"text":"增加依赖","id":"增加依赖","depth":3,"charIndex":722},{"text":"更新依赖","id":"更新依赖","depth":3,"charIndex":917},{"text":"移除依赖","id":"移除依赖","depth":3,"charIndex":967}],"domain":"","frontmatter":{},"version":""},{"id":18,"title":"如何向开源社区提问题","content":"#\n\n统计信息：字数 11206 阅读23分钟\n\n使用软件产品，或多或少都会遇到问题。对于商业产品，我们可以咨询客服寻求帮助。对于公司自己研发的产品，我们可以直接请教专家同事。但对于开源软件，在遇到问题时，如何\n才能及时有效地寻求帮助呢？\n\n\n1、提问前#\n\n遇到问题时，心里都很着急。在决定向开源社区提交问题前，最好先做做以下功课：\n\n\n从官方文档中找答案#\n\n确保自己阅读过至少一次官方文档。这样在遇到问题时，如果能回忆起只言片语，就可以再去读一遍相关文档，问题往往也就解决了。\n\n\nGoogle 是你的朋友#\n\n对于成熟的开源项目，你遇到的问题，很可能别人也遇到过。这时通过 Google、StackOverflow\n等网站的搜索服务，可以帮你快速定位并解决问题。永远记住，地球上的你并不孤单，包括你遇到的问题。\n\n\n挖掘 Bug 宝藏#\n\n开源软件一般都会有自己的 Bug 管理方案，比如 WebKit、V8、jQuery、SeaJS 等等。从它们的官网上找到 Bug\n管理地址，然后通过搜索看看有无你遇到的问题。对于活跃社区来说，这一招经常很管用。比如 jQuery 的 Bug Tracker，通过右上角的 Search\nTickets 可以找到非常多有用的信息。一个运作良好的 Bug 库，经常是一座巨大的宝藏。SeaJS 是直接通过 GitHub Issues 来管理，你可以在\nIssues 中找到很多信息。\n\n\n求助朋友#\n\n如果你使用的开源软件，在朋友圈或同事圈里也有人使用，那么抬起你的脚、或拿起你的电话，真挚诚恳的探讨不会遭遇拒绝，而会增进友谊。不要犹豫，你的内心渴望面对面交流，\n你的朋友也是。\n\n如果以上 4 步都无法解决你遇到的问题，也别犹豫，立马向开源社区提交问题就好。\n\n\n2、提问时#\n\n下面探讨的是如何通过互联网的方式来问问题。\n\n\n平和对等的心态#\n\n很多开源软件都是免费的，作者往往是业余时间出于兴趣在维护，没有义务回答社区问题。提问时，不要把自己摆在顾客的位置，比如\n\n> 项目马上要上线了，请务必帮忙解决 这是我的邮箱，请及时联系我\n\n另外，也不要把自己摆在乞食者的位置，比如\n\n> 冰天雪地跪求解答 救命啊，我的网站挂了\n\n在开源社区，一切皆是朋友。无论对方是 Linux 内核的作者，还是某个 jQuery\n插件的作者，你和作者都是对等的。你的提问是在帮助开源软件完善。平和对等的心态，可以让你的问题赢得更多人的阅读和思考。\n\n\n通过正确的途径提交#\n\n如果遇到问题的开源软件有专门的 Bug 管理系统，请最好到这些指定系统中提交。比如，对于前端开发工程师来说，下面这些 Tracker 系统很重要。\n\n * jQuery Tickets\n * WebKit Bugzilla\n * Mozilla Bugzilla\n\n还有各个开源类库的 Issues 库，比如 SeaJS 的是：seajs/issues\n\n最不好的途径是\n\n * QQ 、阿里旺旺、微信等群组。这些群组主要是用来工作或休闲的。对开源项目来说，在这些地方提问，作者一般不会关注，效率非常低。\n * 微博、Facebook 等社交网络。不少人在微博上通过 at 或私信询问 SeaJS\n   问题，这些我经常看不到。看到了，也不情愿回复。微博是扯淡、交流情感的地方，一般是写代码写累了，才去逛逛，很少会有在社交网络上回答技术问题的心情。\n\n通过正确的途径提交问题，一般可以让你的问题得到及时准确的回复。\n\n\n使用明确、有意义的标题#\n\n抱着平和对等的心态，找到合适的途径后，就得静下心来将遇到的问题写成文字。书写文字不是一件简单的事情，我们可以从遵循一些简单的规则开始。\n\n首先是标题要简洁清晰，要言之有物。比如\n\n> 我遇到了一个 Ajax 问题 SeaJS 在我的浏览器上运行不了\n\n上面的标题很糟糕，光看标题作者无法知道发生了什么事。当开源社区的问题很多时，上面这类标题，经常会让作者直接忽视或将优先级降到很低。更妥当的标题是\n\n> Ajax 请求未返回正确的 responseXML SeaJS 2.0 在 IE6 上运行时抛错\n\n明确、有意义的标题，可以帮助作者确定问题具体是什么类型、预估需要多少时间解决、是否现在马上解决等。一个好的标题，也有利于社区知识的沉淀和后期搜索。标题有如一个人\n的颜面衣着，虽然不是关键，但在嘈杂的信息社区中，这很重要。\n\n\n遵循良好的模板#\n\n如果社区提供了问题模板，一定要仔细看下。比如 Google Code 社区，当你创建一个问题时，会自动提供以下模板：\n\n\n\n遵循这个模板去描述问题，经常能省很多事。作者一般也非常欢迎通过模板提交的问题。如果社区没有提供模板，也可以自己遵循以上模板来提交。\n\n下面针对问题内容，具体说说一些需要注意的点。\n\n\n语法正确、格式清晰#\n\n虽然我们不是作家，但正确的语法、清晰的格式，可以让读者赏心悦目，也就更有心情帮你一起思考解决问题。\n\n对于很多需要代码来描述的问题，要尤其注意格式，比如\n\n\n\n可读性不如\n\n\n\nGitHub 的 Markdown 语法可以很好地支持代码排版、语法高亮等，建议书写代码时，一定要先阅读下说明：GitHub Flavored\nMarkdown。这能让你的内容看起来很专业，社区也就更有意愿会去帮助你，否则糟糕的排版，经常带来的是发帖之后的石沉大海。\n\n\n描述事实、而不是猜测#\n\n事实是指，依次进行了哪些操作、产生了怎样的结果。比如\n\n> 我在 Windows XP 下用 IE6 打开 seajs.org 后，点击“5 分钟上手 SeaJS”，这时浏览器弹出脚本错误提示，例子显示不正确。\n\n上面是一段比较好的事实描述（更好的是把错误提示也截图上来），而不要像下面这样猜测：\n\n> SeaJS 在 IE6 下运行不正常，我怀疑是源码第 213 行有问题。\n\n上面的描述，会让作者一头雾水、甚至很恼火。尽量避免猜测性描述，除非你能先描述事实，在事实描述清楚之后，再给出合理的猜测是欢迎的。\n\n对于前端项目来说，如果能提供可重现错误的在线可访问代码，那是最好不过的。一旦你这么用心去做了，作者往往也会很用心地立马帮你解决。\n\n\n描述目标、而不是过程#\n\n经常会有这种情况，提问者在脑袋里有个更高层次的目标，他们在自以为能达到目标的特定道路上卡住了，然后跑来问该怎么走。比如\n\n> SeaJS 的 parseMap 方法在遇到 map 的多个配置项同时匹配同一个路径时，应该允许用户指定是全部生效还是仅第一个匹配的配置项生效。\n\n上面这个问题的背后，提问者实际上想解决的是如何通过 SeaJS 来做版本管理。提问者选择了通过 map\n的方式来实现，但这过程中遇到了问题，因此跑过来继续怎么走。然而，如果只是描述过程，往往会把作者也绕进去。\n\n实际情况却是，提问者选择的路本身就是一条崎岖之路，对于要解决的问题，实际上有更好的方式。这种情况下，描述清楚目标，讲清楚要干什么非常重要。\n\n在描述自己是怎么做之前，一定要先描述要做什么。提问题时，What 往往比 How 更重要。\n\n\n要有具体场景#\n\n无论在开源社区，还是微博、知乎等平台上，有一种非常常见的问题：\n\n> 如何维护 JavaScript 代码？ 如何使用 SeaJS 进行模块化开发？\n\n这类问题还有很多，每每遇到，只能笑笑，然后悄悄地忽略掉。因此这类问题很难回答，就如下面这些问题一样：\n\n> 如何才能让生命有意义？ 如何打败淘宝？\n\n这类提问者，一般比较浮躁，经常对问题本身也没有经过思考。踏实的提问者，不会让问题浮在空中无法回答，而会在具体场景中让问题落地：\n\n> 我的项目有 20 多个 JS 文件，接下来还会急剧增加。目前遇到以下问题……（省略五百字）…… 请问如何维护？\n\n\n仔细检查、确保准确#\n\n是人都会犯错误，特别是在如此快节奏的互联网环境下。好不容易把问题描述清楚时，不要急着立刻提交。在提交前，至少保证从头到尾再仔细阅读一遍，比如语法错误、错别字、标\n点符号、排版等等。做到这些，不光是尊重别人，也是尊重自己。\n\n\n3、提问后#\n\n提交问题后，建议通过邮件等方式订阅回复。互联网上最有效的沟通方式是异步沟通，不要期待作者马上回复，也不要心烦意乱着急地等待。出去看看天，数数云朵，你会逐步明白什\n么是风轻云淡。\n\n\n尽可能补充信息#\n\n在接收到回复时，仔细阅读。最经常的情况是，社区回复的，经常不是你想要的。比如\n\n> 根据你的描述，问题无法重现。能否提供具体使用环境和重现步骤？\n\n这时要淡定。仔细看看自己提交的问题描述是否足够清晰，如果有可补充的信息，尽量补充，以帮助作者能尽快定位问题。比如\n\n> 很抱歉，我前面有一步描述不正确，实际情况是我是在 IETester 中运行的……\n\n谦和淡定的交流，不光能帮助你解决问题，还有助于你结交更多朋友。\n\n\n适当的总结#\n\n当问题终于解决时，建议对问题进行总结。可以编辑原帖，也可以通过博客等方式总结。你的总结，会让遇到同样问题的朋友们受益，并且对自己的技能也是一种提高。前端业界，无\n论国内还是国外，有很多牛人之所以成为牛人，很大程度上都是因为有总结思考的好习惯。\n\n\n不要忘记感谢#\n\n最后，记得感谢。很多开源软件的作者，都是利用业余时间在创作代码。你的感谢，汇集许许多多大家的感谢，会让开源社区充满爱与力量。\n\n最后的最后，如果你认可这篇文章，欢迎以各种形式转载。你的传播，能让整个开源社区更美好。","routePath":"/site/webpack/site/git/如何向开源社区提问题","lang":"","toc":[{"text":"1、提问前","id":"1提问前","depth":2,"charIndex":121},{"text":"从官方文档中找答案","id":"从官方文档中找答案","depth":3,"charIndex":169},{"text":"Google 是你的朋友","id":"google-是你的朋友","depth":3,"charIndex":243},{"text":"挖掘 Bug 宝藏","id":"挖掘-bug-宝藏","depth":3,"charIndex":361},{"text":"求助朋友","id":"求助朋友","depth":3,"charIndex":615},{"text":"2、提问时","id":"2提问时","depth":2,"charIndex":754},{"text":"平和对等的心态","id":"平和对等的心态","depth":3,"charIndex":786},{"text":"通过正确的途径提交","id":"通过正确的途径提交","depth":3,"charIndex":1040},{"text":"使用明确、有意义的标题","id":"使用明确有意义的标题","depth":3,"charIndex":1462},{"text":"遵循良好的模板","id":"遵循良好的模板","depth":3,"charIndex":1841},{"text":"语法正确、格式清晰","id":"语法正确格式清晰","depth":3,"charIndex":2005},{"text":"描述事实、而不是猜测","id":"描述事实而不是猜测","depth":3,"charIndex":2242},{"text":"描述目标、而不是过程","id":"描述目标而不是过程","depth":3,"charIndex":2578},{"text":"要有具体场景","id":"要有具体场景","depth":3,"charIndex":2953},{"text":"仔细检查、确保准确","id":"仔细检查确保准确","depth":3,"charIndex":3238},{"text":"3、提问后","id":"3提问后","depth":2,"charIndex":3363},{"text":"尽可能补充信息","id":"尽可能补充信息","depth":3,"charIndex":3462},{"text":"适当的总结","id":"适当的总结","depth":3,"charIndex":3682},{"text":"不要忘记感谢","id":"不要忘记感谢","depth":3,"charIndex":3814}],"domain":"","frontmatter":{},"version":""},{"id":19,"title":"如何向开源项目提交无法解答的问题","content":"#\n\n统计信息：字数 10231 阅读21分钟\n\n作为一名互联网开发者，本人使用和参与过许多开源项目。开源社区里，提问和回答是最有趣的组成部分，有些你来我往，有些则石沉大海。人们提问的方式有许多迷人和实用的共通\n之处。我把它们提炼出来，希望能帮助到那些像我一样充满了好奇心、且愿意付诸行动去惹恼开源项目维护者的人们。\n\n==这里提出的问题都是不好的问题，不利于正确解决问题==\n\n以下是『如何提出无法解答的问题』的十三个小技巧：\n\n\n1. 惜字如金#\n\n『言多必失，不如闷声发大财』\n\n压缩问题的字节数，不要让对方觉得你啰嗦。用最简单的字词描述你的问题，提炼关键字，简化掉冗长的过程和繁琐的细节。\n\n * 正确示范：\n\n\n\n * 错误示范：\n\n\n\n\n2. 缓兵之计#\n\n『和他成为长期笔友。』\n\n如果维护者答复你了，通常他们会索要进一步的信息。记住不要着急回复，那样显得你像个工作狂（时时刻刻泡在电脑边，可怜巴巴的等待回复）。你还有其他生活，喝杯咖啡，聊个\n微信，隔上十天半个月再回复。相信我，他们很快会失去耐心而关掉这个问题，或者因为一时关不了而心情郁闷。\n\n * 正确示范：\n\n\n\n * 错误示范：\n\n\n\n\n3. 夹带私货#\n\n『我哪有时间排查，这绝对是你的锅。』\n\n在一个中型或者大型项目中引入开源模块容易遇到奇怪的问题。几十个文件上百个业务模块，项目工期又紧张，一一排查太辛苦了，还是另请高明吧，赶紧打个包发给对方。\n\n * 正确示范：\n\n\n\n * 错误示范：\n\n\n\n\n4. 卖个关子#\n\n『欲知后事如何，且听下回分解』\n\n总是留个后手，不要一次性把话说完，让你的问题充满神秘感，充分调动起读者的好奇心。\n\n * 正确示范：\n\n\n\n * 错误示范：\n\n\n\n\n5. 弄乱格式#\n\n『怕他轻易看懂我的问题，我必须要做点什么』\n\n从来，永远不要格式化问题。你又不是美工，美化格式不是你的特长。你的精力要用在项目开发中，也没有时间去学习什么格式化语法。至于对方能不能看明白，你才不需要关心。\n\n * 正确示范：\n\n\n\n * 错误示范：\n\n\n\n\n6. 遗漏关键信息#\n\n『诶？我忘了说我没插电源了么？』\n\n项目代码一开始总是跑的好好的，你做了某个操作、或改动了某些代码、或者在一个特殊的环境下，问题出现了。\n这个区别往往是问题的关键，把它留在心里就好，不要轻易说出来。\n\n * 正确示范：\n\n\n\n * 错误示范：\n\n\n\n\n7. 提供错误的信息#\n\n『在错误的信息上解决问题才能体现你牛逼嘛！哈哈哈』\n\n有时候需要做一些误导，有意或者无意，总之制造困难是你的强项。\n\n * 正确示范：\n\n\n\n * 错误示范：\n\n\n\n\n8. 尽情宣泄情绪#\n\n『你们把我项目搞挂了，狗屎！』\n\n开源项目导致了你的项目出现 BUG，导致了你周六晚上还要加班，导致了男/女友抱怨你不理他/她，这必须要有人负责。你的工作和生活被他们毁了，也别让他们好过。\n\n * 正确示范：\n\n\n\n * 错误示范：\n\n\n\n\n9. 构思宏伟蓝图#\n\n『我要造一台汽车，该怎么做？』\n\n尝试问一个具有宏大目标的问题，只有那些祖母般慈祥的维护者才会尝试回答你（这简直不可能发生）。而且由于你表现出了在所有技术细节上的毫无准备以及极端无知，对方的回答\n也没办法让你满意。\n\n * 正确示范：\n\n\n\n * 错误示范：\n\n\n\n\n10. 自由发挥#\n\n『八股文的时代早就过去了！』\n\n很多开源项目的维护者都是傲慢、迂腐、喜欢设定各种规矩的怪胎。例如他们常常会提供奇怪的问题模板，让你在一个又臭又长的表单里填空。一旦你不按他们说的来，他们就会视你\n为捣乱分子，把你批判一番。你哪里受得了这些拘束，想怎么写就怎么写，让他们和他们的模板都见鬼去吧！\n\n * 正确示范：\n\n\n\n * 错误示范：\n\n\n\n\n11. 重复提问#\n\n『重要的事要说三遍』\n\n在不同的地方重复你提过的问题，加深对方的印象，颠覆对方的想象！\n\n * 正确示范：\n\n\n\n * 错误示范：\n\n\n\n\n12. 出其不意#\n\n『到全世界提问，到他们想不到的地方提问』\n\n即使你知道有官方渠道，也推荐用其他方式向维护者提问：微博、Twitter、知乎私信、知乎评论区、Email、微信、个人博客、蚂蚁森林、朋友圈、他对 TFboys\n微博的转发，今日头条娱乐版的评论区……到一切你能找到他的地方去提问。\n\n * 正确示范：\n\n\n\n * 错误示范：\n\n\n\n\n13. 上纲上线#\n\n『接连便是难懂的话，什么\"KPI\"，\"绩效\"，\"弃坑\"之类，引得众人都哄笑起来』\n\n把你的问题拔高一个层次，站在道德高地进行指责，一旦讨论涉及到政治，他们便百口莫辩。\n\n * 正确示范：\n\n\n\n * 错误示范：\n\n\n\n\n总结#\n\n总而言之，开源项目的维护者在尝试解答和解决问题时，总是希望能亲眼看到问题发生，不要让他们得逞。另外，他们大多对未关闭的问题有强迫症，尽量多制造一些这样的问题。","routePath":"/site/webpack/site/git/如何向开源项目提交无法解答的问题","lang":"","toc":[{"text":"**1. 惜字如金**","id":"1-惜字如金","depth":2,"charIndex":-1},{"text":"**2. 缓兵之计**","id":"2-缓兵之计","depth":2,"charIndex":-1},{"text":"**3. 夹带私货**","id":"3-夹带私货","depth":2,"charIndex":-1},{"text":"**4. 卖个关子**","id":"4-卖个关子","depth":2,"charIndex":-1},{"text":"**5. 弄乱格式**","id":"5-弄乱格式","depth":2,"charIndex":-1},{"text":"**6. 遗漏关键信息**","id":"6-遗漏关键信息","depth":2,"charIndex":-1},{"text":"**7. 提供错误的信息**","id":"7-提供错误的信息","depth":2,"charIndex":-1},{"text":"**8. 尽情宣泄情绪**","id":"8-尽情宣泄情绪","depth":2,"charIndex":-1},{"text":"**9. 构思宏伟蓝图**","id":"9-构思宏伟蓝图","depth":2,"charIndex":-1},{"text":"**10. 自由发挥**","id":"10-自由发挥","depth":2,"charIndex":-1},{"text":"**11. 重复提问**","id":"11-重复提问","depth":2,"charIndex":-1},{"text":"**12. 出其不意**","id":"12-出其不意","depth":2,"charIndex":-1},{"text":"**13. 上纲上线**","id":"13-上纲上线","depth":2,"charIndex":-1},{"text":"**总结**","id":"总结","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":20,"title":"如何有效地报告 Bug","content":"#\n\n统计信息：字数 17905 阅读36分钟\n\n作者：Simon Tatham 专业的自由软件程序员\n\n翻译：Dasn\n\n\n引言#\n\n为公众写过软件的人，大概都收到过很拙劣的bug（计算机程序代码中的错误或程序运行时的瑕疵——译者注）报告，例如：\n\n在报告中说“不好用”；\n\n所报告内容毫无意义；\n\n在报告中用户没有提供足够的信息；\n\n在报告中提供了错误信息；\n\n所报告的问题是由于用户的过失而产生的；\n\n所报告的问题是由于其他程序的错误而产生的；\n\n所报告的问题是由于网络错误而产生的；\n\n这便是为什么“技术支持”被认为是一件可怕的工作，因为有拙劣的bug报告需要处理。然而并不是所有的bug报告都令人生厌：我在业余时间维护自由软件，有时我会收到非常\n清晰、有帮助并且*“有内容”*的bug报告。\n\n在这里我会尽力阐明如何写一个好的bug报告。我非常希望每一个人在报告bug之前都读一下这篇短文，当然我也希望用户在给我报告bug之前已经读过这篇文章。\n\n简单地说，报告bug的目的是为了让程序员看到程序的错误。您可以亲自示范，也可以给出能导致程序出错的、详尽的操作步骤。如果程序出错了，程序员会收集额外的信息直到找\n到错误的原因；如果程序没有出错，那么他们会请您继续关注这个问题，收集相关的信息。\n\n在bug报告里，要设法搞清什么是事实（例如：“我在电脑旁”和“XX出现了”）什么是推测（例如：“我想问题可能是出在……”）。如果愿意的话，您可以省去推测，但是千\n万别省略事实。\n\n当您报告bug的时候（既然您已经这么做了），一定是希望bug得到及时修正。所以此时针对程序员的任何过激或亵渎的言语（甚至谩骂）都是与事无补的——因为这可能是程序\n员的错误，也有可能是您的错误，也许您有权对他们发火，但是如果您能多提供一些有用的信息（而不是激愤之词）或许bug会被更快的修正。除此以外，请记住：如果是免费软件\n，作者提供给我们已经是出于好心，所以要是太多的人对他们无礼，他们可能就要“收起”这份好心了。\n\n\n“程序不好用”#\n\n程序员不是弱智：如果程序一点都不好用，他们不可能不知道。他们不知道一定是因为程序在他们看来工作得很正常。所以，或者是您作过一些与他们不同的操作，或者是您的环境与\n他们不同。他们需要信息，报告bug也是为了提供信息。信息总是越多越好。\n\n许多程序，特别是自由软件，会公布一个“已知bug列表”。如果您找到的bug在列表里已经有了，那就不必再报告了，但是如果您认为自己掌握的信息比列表中的丰富，那无论\n如何也要与程序员联系。您提供的信息可能会使他们更简单地修复bug。\n\n本文中提到的都是一些指导方针，没有哪一条是必须恪守的准则。不同的程序员会喜欢不同形式的bug报告。如果程序附带了一套报告bug的准则，一定要读。如果它与本文中提\n到的规则相抵触，那么请以它为准。\n\n如果您不是报告bug，而是寻求帮助，您应该说明您曾经到哪里找过答案，（例如：我看了第四章和第五章的第二节，但我找不到解决的办法。）这会使程序员了解用户喜欢到哪里\n去找答案，从而使程序员把帮助文档做得更容易使用。\n\n\n“演示给我看”#\n\n报告bug的最好的方法之一是“演示”给程序员看。让程序员站在电脑前，运行他们的程序，指出程序的错误。让他们看着您启动电脑、运行程序、如何进行操作以及程序对您的输\n入有何反应。\n\n他们对自己写的软件了如指掌，他们知道哪些地方不会出问题，而哪些地方最可能出问题。他们本能地知道应该注意什么。在程序真的出错之前，他们可能已经注意到某些地方不对劲\n，这些都会给他们一些线索。他们会观察程序测试中的每一个细节，并且选出他们认为有用的信息。\n\n这些可能还不够。也许他们觉得还需要更多的信息，会请您重复刚才的操作。他们可能在这期间需要与您交流一下，以便在他们需要的时候让bug重新出现。他们可能会改变一些操\n作，看看这个错误的产生是个别问题还是相关的一类问题。如果您不走运，他们可能需要坐下来，拿出一堆开发工具，花上几个小时来好好地研究一下。但是最重要的是在程序出错的\n时候让程序员在电脑旁。一旦他们看到了问题，他们通常会找到原因并开始试着修改。\n\n\n“告诉我该怎么做”#\n\n如今是网络时代，是信息交流的时代。我可以点一下鼠标把自己的程序送到俄罗斯的某个朋友那里，当然他也可以用同样简单的方法给我一些建议。但是如果我的程序出了什么问题，\n我不可能在他旁边。“演示”是很好的办法，但是常常做不到。\n\n如果您必须报告bug，而此时程序员又不在您身边，那么您就要想办法让bug重现在他们面前。当他们亲眼看到错误时，就能够进行处理了。\n\n确切地告诉程序员您做了些什么。如果是一个图形界面程序，告诉他们您按了哪个按钮，依照什么顺序按的。如果是一个命令行程序，精确的告诉他们您键入了什么命令。您应该尽可\n能详细地提供您所键入的命令和程序的反应。\n\n把您能想到的所有的输入方式都告诉程序员，如果程序要读取一个文件，您可能需要发一个文件的拷贝给他们。如果程序需要通过网络与另一台电脑通讯，您或许不能把那台电脑复制\n过去，但至少可以说一下电脑的类型和安装了哪些软件（如果可以的话）。\n\n\n“哪儿出错了？在我看来一切正常哦！”#\n\n如果您给了程序员一长串输入和指令，他们执行以后没有出现错误，那是因为您没有给他们足够的信息，可能错误不是在每台计算机上都出现，您的系统可能和他们的在某些地方不一\n样。有时候程序的行为可能和您预想的不一样，这也许是误会，但是您会认为程序出错了，程序员却认为这是对的。\n\n同样也要描述发生了什么。精确的描述您看到了什么。告诉他们为什么您觉得自己所看到的是错误的，最好再告诉他们，您认为自己应该看到什么。如果您只是说：“程序出错了”，\n那您很可能漏掉了非常重要的信息。\n\n如果您看到了错误消息，一定要仔细、准确的告诉程序员，这确实很重要。在这种情况下，程序员只要修正错误，而不用去找错误。他们需要知道是什么出问题了，系统所报的错误消\n息正好帮助了他们。如果您没有更好的方法记住这些消息，就把它们写下来。只报告“程序出了一个错”是毫无意义的，除非您把错误消息一块报上来。\n\n特殊情况下，如果有错误消息号，一定要把这些号码告诉程序员。不要以为您看不出任何意义，它就没有意义。错误消息号包含了能被程序员读懂的各种信息，并且很有可能包含重要\n的线索。给错误消息编号是因为用语言描述计算机错误常常令人费解。用这种方式告诉您错误的所在是一个最好的办法。\n\n在这种情形下，程序员的排错工作会十分高效。他们不知道发生了什么，也不可能到现场去观察，所以他们一直在搜寻有价值的线索。错误消息、错误消息号以及一些莫名其妙的延迟\n，都是很重要的线索，就像办案时的指纹一样重要，保存好。\n\n如果您使用UNIX系统，程序可能会产生一个内核输出（coredump）。内核输出是特别有用的线索来源，别扔了它们。另一方面，大多数程序员不喜欢收到含有大量内核输\n出文件的EMAIL，所以在发邮件之前最好先问一下。还有一点要注意：内核输出文件记录了完整的程序状态，也就是说任何秘密（可能当时程序正在处理一些私人信息或秘密数据\n）都可能包含在内核输出文件里。\n\n\n“出了问题之后，我做了……”#\n\n当一个错误或bug发生的时候，您可能会做许多事情。但是大多数人会使事情变的更糟。我的一个朋友在学校里误删了她所有的Word文件，在找人帮忙之前她重装了Word，\n又运行了一遍碎片整理程序，这些操作对于恢复文件是毫无益处的，因为这些操作搞乱了磁盘的文件区块。恐怕在这个世界上没有一种反删除软件能恢复她的文件了。如果她不做任何\n操作，或许还有一线希望。\n\n这种用户仿佛一只被逼到墙角的鼬（黄鼠狼、紫貂一类的动物——译者注）：背靠墙壁，面对死亡的降临奋起反扑，疯狂攻击。他们认为做点什么总比什么都不做强。然而这些在处理\n计算机软件问题时并不适用。\n\n不要做鼬，做一只羚羊。当一只羚羊面对料想不到的情况或受到惊吓时，它会一动不动，是为了不吸引任何注意，与此同时也在思考解决问题的最好办法（如果羚羊有一条技术支持热\n线，此时占线。）。然后，一旦它找到了最安全的行动方案，它便去做。\n\n当程序出毛病的时候，立刻停止正在做的任何操作。不要按任何健。仔细地看一下屏幕，注意那些不正常的地方，记住它或者写下来。然后慎重地点击“确定”\n或“取消”，选择一个最安全的。学着养成一种条件反射——一旦电脑出了问题，先不要动。要想摆脱这个问题，关掉受影响的程序或者重新启动计算机都不好，一个解决问题的好办\n法是让问题再次产生。程序员们喜欢可以被重现的问题，快乐的程序员可以更快而且更有效率的修复bug。\n\n\n“我想粒子的跃迁与错误的极化有关”#\n\n并不只是非专业的用户才会写出拙劣的bug报告，我见过一些非常差的bug报告出自程序员之手，有些还是非常优秀的程序员。\n\n有一次我与另一个程序员一起工作，他一直在找代码中的bug，他常常遇到一个bug，但是不会解决，于是就叫我帮忙。“出什么毛病了？”我问。而他的回答却总是一些关于b\nug的意见。如果他的观点正确，那的确是一件好事。这意味着他已经完成了工作的一半，并且我们可以一起完成另一半工作。这是有效率并有用的。\n\n但事实上他常常是错的。这就会使我们花上半个小时在原本正确的代码里来回寻找错误，而实际上问题出在别的地方。我敢肯定他不会对医生这么做。“大夫，我得了Hydroyo\nyodyne（真是怪病——译者），给我开个方子”，人们知道不该对一位医生说这些。您描述一下症状，哪个地方不舒服，哪里疼、起皮疹、发烧……让医生诊断您得了什么病，\n应该怎样治疗。否则医生会把您当做疑心病或精神病患者打发了，这似乎没什么不对。\n\n做程序员也是一样。即便您自己的“诊断”有时真的有帮助，也要只说“症状”。“诊断”是可说可不说的，但是“症状”一定要说。同样，在bug报告里面附上一份针对bug而\n做出修改的源代码是有用处的，但它并不能替代bug报告本身。\n\n如果程序员向您询问额外的信息，千万别应付。曾经有一个人向我报告bug，我让他试一个命令，我知道这个命令不好用，但我是要看看程序会返回一个什么错误（这是很重要的线\n索）。但是这位老兄根本就没试，他在回复中说“那肯定不好用”，于是我又花了好些时间才说服他试了一下那个命令。\n\n用户多动动脑筋对程序员的工作是有帮助的。即使您的推断是错误的，程序员也应该感谢您，至少您想去帮助他们，使他们的工作变的更简单。不过千万别忘了报告“症状”，否则只\n会使事情变得更糟。\n\n\n“真是奇怪，刚才还不好用，怎么现在又好了？”#\n\n“间歇性错误”着实让程序员发愁。相比之下，进行一系列简单的操作便能导致错误发生的问题是简单的。程序员可以在一个便于观察的条件下重复那些操作，观察每一个细节。太多\n的问题在这种情况下不能解决，例如：程序每星期出一次错，或者偶然出一次错，或者在程序员面前从不出错（程序员一离开就出错。——译者）。当然还有就是程序的截止日期到了\n，那肯定要出错。\n\n大多数“间歇性错误”并不是真正的“间歇”。其中的大多数错误与某些地方是有联系的。有一些错误可能是内存泄漏产生的，有一些可能是别的程序在不恰当的时候修改某个重要文\n件造成的，还有一些可能发生在每一个小时的前半个小时中（我确实遇到过这种事情）。\n\n同样，如果您能使bug重现，而程序员不能，那很有可能是他们的计算机和您的计算机在某些地方是不同的，这种不同引起了问题。我曾写过一个程序，它的窗口可以蜷缩成一个小\n球呆在屏幕的左上角，它在别的计算机上只能在 800x600 的解析度工作，但是在我的机器上却可以在 1024x768 下工作。\n\n程序员想要了解任何与您发现的问题相关的事情。有可能的话您到另一台机器上试试，多试几次，两次，三次，看看问题是不是经常发生。如果问题出现在您进行了一系列操作之后，\n不是您想让它出现它就会出现，这就有可能是长时间的运行或处理大文件所导致的错误。程序崩溃的时候，您要尽可能的记住您都做了些什么，并且如果您看到任何图形,也别忘了提\n一下。您提供的任何事情都是有帮助的。即使只是概括性的描述（例如：当后台有EMACS运行时，程序常常出错），这虽然不能提供导致问题的直接线索，但是可能帮助程序员重\n现问题。\n\n最重要的是：程序员想要确定他们正在处理的是一个真正的“间歇性错误”呢，还是一个在另一类特定的计算机上才出现的错误。他们想知道有关您计算机的许多细节，以便了解您的\n机器与他们的有什么不同。有许多细节都依仗特定的程序，但是有一件东西您一定要提供——版本号。程序的版本、操作系统的版本以及与问题有关的程序的版本。\n\n\n“我把磁盘装进了 Windows……”#\n\n表意清楚在一份bug报告里是最基本的要求。如果程序员不知道您说的是什么意思，那您就跟没说一样。我收到的bug报告来自世界各地，有许多是来自非英语国家，他们通常为\n自己的英文不好而表示歉意。总的来说，这些用户发来的bug报告通常是清晰而且有用的。几乎所有不清晰的bug报告都是来自母语是英语的人，他们总是以为只要自己随便说说\n，程序员就能明白。\n\n * 精确。如果做相同的事情有两种方法，请说明您用的是哪一种。例如：“我选择了‘载入’”，可能意味着“我用鼠标点击‘载入’”或“我按下了‘ALT+L’”，说清楚\n   您用了哪种方法，有时候这也有关系。\n * 详细。信息宁多毋少！如果您说了很多，程序员可以略去一部分，可是如果您说的太少，他们就不得不回过头再去问您一些问题。有一次我收到了一份bug报告只有一句话，\n   每一次我问他更多事情时，他每次的回复都是一句话，于是我花了几个星期的时间才得到了有用的信息。\n * 慎用代词。诸如“它”，“窗体”这些词，当它们指代不清晰的时候不要用。来看看这句话：“我运行了FooApp，它弹出一个警告窗口，我试着关掉它，它就崩溃了。”\n   这种表述并不清晰，用户究竟关掉了哪个窗口？是警告窗口还是整个FooApp程序？您可以这样说，“我运行FooApp程序时弹出一个警告窗口，我试着关闭警告窗口\n   ，FooApp崩溃了。”这样虽然罗嗦点，但是很清晰不容易产生误解。\n * 检查。重新读一遍您写的bug报告，您觉得它是否清晰？如果您列出了一系列能导致程序出错的操作，那么照着做一遍，看看您是不是漏写了一步。\n\n\n小结：#\n\n * bug报告的首要目的是让程序员亲眼看到错误。如果您不能亲自做给他们看，给他们能使程序出错的详细的操作步骤。\n * 如果首要目的不能达成，程序员不能看到程序出错。这就需要bug报告的第二个目的来描述程序的什么地方出毛病了。详细的描述每一件事情：您看到了什么，您想看到什么\n   ，把错误消息记下来，尤其是“错误消息号”。\n * 当您的计算机做了什么您料想不到的事，不要动！在您平静下来之前什么都别做。不要做您认为不安全的事。\n * 尽量试着自己“诊断”程序出错的原因（如果您认为自己可以的话）。即使做出了“诊断”，您仍然应该报告“症状”。\n * 如果程序员需要，请准备好额外的信息。如果他们不需要，就不会问您要。他们不会故意为难自己。您手头上一定要有程序的版本号，它很可能是必需品。\n * 表述清楚，确保您的意思不能被曲解。\n * 总的来说，最重要的是要做到精确。程序员喜欢精确。","routePath":"/site/webpack/site/git/如何有效地报告 Bug","lang":"","toc":[{"text":"引言","id":"引言","depth":3,"charIndex":62},{"text":"“程序不好用”","id":"程序不好用","depth":3,"charIndex":852},{"text":"“演示给我看”","id":"演示给我看","depth":3,"charIndex":1303},{"text":"“告诉我该怎么做”","id":"告诉我该怎么做","depth":3,"charIndex":1732},{"text":"“哪儿出错了？在我看来一切正常哦！”","id":"哪儿出错了在我看来一切正常哦","depth":3,"charIndex":2141},{"text":"“出了问题之后，我做了……”","id":"出了问题之后我做了","depth":3,"charIndex":2971},{"text":"“我想粒子的跃迁与错误的极化有关”","id":"我想粒子的跃迁与错误的极化有关","depth":3,"charIndex":3578},{"text":"“真是奇怪，刚才还不好用，怎么现在又好了？”","id":"真是奇怪刚才还不好用怎么现在又好了","depth":3,"charIndex":4350},{"text":"“我把磁盘装进了 Windows……”","id":"我把磁盘装进了-windows","depth":3,"charIndex":5220},{"text":"小结：","id":"小结","depth":3,"charIndex":5919}],"domain":"","frontmatter":{},"version":""},{"id":21,"title":"前端工程化","content":"#","routePath":"/site/webpack/site/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":22,"title":"使用 Mkdocs 在 Github 上快速部署文章","content":"#\n\n统计信息：字数 2581 阅读6分钟\n\n2021-11-03\n\n以考代练：如何安装；如何初始化；如何增加超链接；（如何部署到github）\n\n博客较短；仅供参考\n\n为项目编写文档，找到了一款叫 MkDocs 的工具。\n\nMkDocs 架构简单，工具可以自动创建一个配置文件 mkdocs.yml，以及 docs 文件夹，通过简单的配置，在 docs 文件夹上添加 markdown\n文件作为页面。完成后工具自带部署到 Github 上的功能，通过简单的设置，就可以轻松使用 GitPage 展示项目文档。 具体细节可以参考 MkDocs\n官网文档：\n\nMkDocs 中文官网\n\nMkDocs 英文官网\n\n\nMkDocs 安装#\n\n使用 pip 安装 mkdocs。\n\n\n\n安装完成后，可以检查以下 MkDocs 是否能正确安装\n\n\n\n能看到版本号正常显示，即表示 MkDocs 工具以被正常安装完成。\n\n\n创建文档项目#\n\nMkDocs 提供了 mkdocs new 命令创建文档项目。然而，在一般情况下，我们都是先在 GitHub\n上创建了一个已有的项目，然后再为其添加相应的文档。这里有两个方法可以参考：\n\n * 使用 mkdocs new 来创建一个新文档项目，然后将其中的 docs 文件夹以及 mkdocs.yml 配置文件复制到项目根目录下。\n * 直接创建一个 mkdocs.yml 和 docs 文件夹与项目根目录下。 接下来，我们可以在 docs 目录下创建一个 index.md\n   文件，然后向其中添加一些内容，尝试运行一下看看文档项目是否能正常运行，具体方法如下：\n\n\n\n等待工具运行，然后默认地址是 http://127.0.0.1:8000 我们通过浏览器打开，查看页面是否能正常显示。\n\n\n超链接#\n\nmkdocs 的链接非常简单，直接使用 MarkDown 语法的连接即可，连接路径使用项目相对路径即可。 如果是图片，可以在 docs 文件夹向创建一个\nimages 的文件夹，引用的使用可以使用方法:\n\n\n\n\n部署到 Github#\n\nMkDocs 部署到 Github 也非常简单，使用命令 mkdocs gh-deploy ，工具就会自动将相应内容推送到项目的 gh-pages\n分支上，然后只需要在 Github 项目设置中选择好对应 GitPage 的分支，然后通过 https://.github.io/ 访问即可。","routePath":"/site/webpack/site/mkdocs/Mkdocs-github-blog","lang":"","toc":[{"text":"MkDocs 安装","id":"mkdocs-安装","depth":2,"charIndex":305},{"text":"创建文档项目","id":"创建文档项目","depth":2,"charIndex":405},{"text":"超链接","id":"超链接","depth":2,"charIndex":763},{"text":"部署到 Github","id":"部署到-github","depth":2,"charIndex":875}],"domain":"","frontmatter":{},"version":""},{"id":23,"title":"快速开始","content":"MkDocs 快速入门#\n\n统计信息：字数 7363 阅读15分钟\n\n2021-11-03\n\n> 本文选自 《了不起的Markdown》，作者：毕小烦\n\nMkDocs 是一个用 Python 开发的静态站点生成器工具，它可以非常简单快速的创建项目文档。MkDocs 的文档源码使用 Markdown\n编写，配置文件使用 YAML 编写，可以一键编译成静态站点。\n\n很多开源的项目文档都使用 MkDocs 编写，因此我们非常有必要学习一下。\n\n环境\n\n * 支持 macOS/Linux/Windows\n * 安装 Python: 2.7.8 +\n\n安装\n\n\n\n查看 mkdocs 版本\n\n\n\n或\n\n\n\n查看 mkdocs 帮助\n\n\n\n升级\n\n\n\n卸载\n\n\n\n\n快速开始#\n\n\n创建项目#\n\n\n\n\n启动服务#\n\n\n\n在浏览器中打开 http://127.0.0.1:8000 ，启动效果如下图所示：\n\n\n\n服务器启动后，当配置文件、文档目录或主题发生改变时，服务器就会自动加载变更并生成新的文档。\n\n小贴示：\n\n服务器默认地址为 127.0.0.1:8000 ，如果端口被占用怎么办呢？\n\n当然也支持自定义地址，使用下面这命令：\n\nmkdocs serve --dev-addr=127.0.0.1:8888\n\n或\n\nmkdocs serve -a 127.0.0.1:9999\n\n\n添加页面#\n\nMkDocs 中一个 Markdown 文档渲染后就是一个页面，因此如果我们想添加一个页面，就需要先在 docs 目录下添加一个 Markdown\n文件，文件的后缀名可以是 md、markdown 、mdown、 mkdn 、mkd。\n\n实例演示：\n\nSTEP 1. 在 docs 目录中添加 test.md\n\n\n\n说明：\n\ndocs 的目录结构对应着生成页面的 URL，本例中对应的 URL 是：\n\n\n\nSTEP 2. 修改配置文件 mkdocs.yml\n\n\n\n说明：\n\n * index.md 是默认的首页\n * test.md 是新增页面\n\n效果如下图所示：\n\n\n\n小贴示：\n\n文件名暂不支持中文，文件路径中也不要有中文。\n\n\n配置主题#\n\nMkDocs 的主题是可以配置的，默认主题是 mkdocs。\n\n前面的例子中 mkdocs.yml 文件也可以配置成这样：\n\n\n\n如果想切换成别的主题，只要更改 theme 的值就可了。\n\n如：\n\n\n\n效果如下图所示：\n\n\n\n主题分为内置主题、第三方主题和自定义主题，内置主题如上所述，直接配置主题名就可以了；如果是第三方主题，就需要先安装主题再进行配置了；自定义主题有点难度本文暂不介\n绍。\n\n\n生成站点#\n\n如果想发布项目，需要先构建项目，生成一个静态资源站点。\n\n\n\n构建完成后的项目结构如下：\n\n\n\n构建完成后的资源全部放到了 site 目录下。\n\n小贴示：\n\n 1. 使用 mkdocs build --clean 可以在构建时清理一些残留资源。\n 2. site 需要部署到 webserver 上才能正常运行。\n\n\n发布项目#\n\nsite 目录就是我们要发布的项目，我们可以把 site 部署到任意的地方，如： GitHub project pages。","routePath":"/site/webpack/site/mkdocs/Mkdocs-guide","lang":"","toc":[{"text":"创建项目","id":"创建项目","depth":2,"charIndex":337},{"text":"启动服务","id":"启动服务","depth":2,"charIndex":347},{"text":"添加页面","id":"添加页面","depth":2,"charIndex":590},{"text":"配置主题","id":"配置主题","depth":2,"charIndex":914},{"text":"生成站点","id":"生成站点","depth":2,"charIndex":1120},{"text":"发布项目","id":"发布项目","depth":2,"charIndex":1286}],"domain":"","frontmatter":{},"version":""},{"id":24,"title":"Mac 安装 mkdocs 的环境搭建","content":"#\n\n统计信息：字数 4743 阅读10分钟\n\n2021-11-03\n\n这是个人安装环境遇到的问题总结\n\n最近做一个静态博客网站，使用 mkdocs 这个框架，后端使用 python\n构建，折腾了好久才安装成功。下面把安装过程的问题简单总结一下，特别注意环境工具版本问题。\n\n\n环境说明#\n\n我本地是 mac 环境，已经安装 node npm python3 wget virtualEnv n nvm 等工具，作用分别如下：\n\n\n\n其他工具\n\n\n\n具体这些工具的安装和注意事项不说了，可以到对应的博客查看。\n\n\nnode 版本#\n\nmkdocs 需要 node 老版本。\n\n我本地默认的 node 版本是 12 ，可以安装 mkdocs ，但是始终无法安装插件。我切换到 8 版本进行安装，具体操作如下：\n\n使用 n 或者 nvm 等 node 版本工具管理版本并进行安装。\n\n\n\n然后把 node 版本切换到早期版本（否则后期可能遇到 mkdocs 版本不对应，无法安装等）\n\n\npython 版本#\n\n一定在 python3 虚拟环境中搭建！！！\n\n需要新建 python3 的虚拟环境（我默认使用 python 2.7.10 的环境，后期各种报错，material 这个材质包无法正常安装）。\n\n使用 virtualEnv 管理虚拟环境，然后新建一个 py3 的环境。\n\n使用 source /bin/activate 启动环境。Mac安装gitbook，卡在Installing GitBook 3.2.3\n\n现在环境基本搭建好，开始安装 mkdocs\n\n\n安装 mkdocs#\n\n需要 Python 和 pip 来安装 MkDocs . 可以通过以下命令查看是否安装了上述依赖\n\n\n\nMkDocs 支持 Python 2.6, 2.7, 3.3 和 3.4。强烈建议使用 python3 环境安装。\n\n使用 pip 安装 mkdocs :\n\n\n\nmkdocs已经安装到你的系统. 运行 mkdocs help 以检查是否正确安装.\n\n\n\n\n创建项目#\n\n创建一个新项目\n\n\n\n下面开启服务\n\n\n\n\n配置信息说明#\n\n博客的各种配置文件在 mkdocs.yml 中进行设置，下面进行简单的说明\n\n\n\n上面这些配置可以使用其他的配置\n\n\n参考链接#\n\nhttps://www.mkdocs.org/user-guide/styling-your-docs/\n\nhttps://squidfunk.github.io/mkdocs-material/customization/\n\nhttps://www.pythonsky.cn/technical-talk/233.html\n\nhttps://github.com/nvm-sh/nvm#installing-and-updating\n\nhttps://www.cnblogs.com/gaozejie/p/10689742.html\n\nhttps://www.jianshu.com/p/622ad36ee020\n\nhttps://www.pythonsky.cn/technical-talk/233.html\n\nhttps://www.jianshu.com/p/c75381320b8a\n\nhttps://www.cnblogs.com/princesong/p/11133310.html\n\nhttps://www.jianshu.com/p/622ad36ee020\n\nhttps://www.jianshu.com/p/c75381320b8a\n\nhttps://www.baidu.com/s?ie=UTF-8&wd=Installing%20GitBook%203.2.3\n\nhttps://markdown-docs-zh.readthedocs.io/zh_CN/latest/","routePath":"/site/webpack/site/mkdocs/Mkdocs-mac-env","lang":"","toc":[{"text":"环境说明","id":"环境说明","depth":3,"charIndex":138},{"text":"node 版本","id":"node-版本","depth":3,"charIndex":256},{"text":"python 版本","id":"python-版本","depth":3,"charIndex":441},{"text":"安装 mkdocs","id":"安装-mkdocs","depth":3,"charIndex":683},{"text":"创建项目","id":"创建项目","depth":3,"charIndex":875},{"text":"配置信息说明","id":"配置信息说明","depth":3,"charIndex":904},{"text":"参考链接","id":"参考链接","depth":3,"charIndex":972}],"domain":"","frontmatter":{},"version":""},{"id":25,"title":"主题插件","content":"gitbook 入门教程之主题插件#\n\n统计信息：字数 7516 阅读16分钟\n\n\n主题插件#\n\n目前 gitbook 提供三类文档: Book 文档,API 文档和 FAQ 文档.\n\n其中,默认的也是最常使用的就是 Book 文档,如果想要了解其他两种文档模式,需要引入相应的主题插件.\n\n> 官方主题插件文档: https://toolchain.gitbook.com/themes/\n\n\nBook 文档##\n\n\ntheme-default 主题##\n\n> 插件地址: https://plugins.gitbook.com/plugin/theme-default\n\ntheme-default 是 3.0.0\n引入的默认主题,大多数插件针对的都是默认主题,如果切换到其他主题或者自定义主题,可能会造成某些情况下不兼容,甚至报错.\n\n默认情况下,左侧菜单不显示层级属性,如果将 showLevel 属性设置为 true 可以显示层级数字.\n\n示例:\n\n\n\n效果:\n\n\n\n> 默认情况下左侧菜单树不显示目录层级\n\n\n\n> 开启层级显示设置后,左侧菜单树显示当前目录层级\n\n\ntheme-comscore 主题##\n\n> 插件地址: https://plugins.gitbook.com/plugin/theme-comscore\n\ndefault 默认主题是黑白的,而 comscore 主题是彩色的,即标题和正文颜色有所区分.\n\n示例:\n\n\n\n效果:\n\n\n\n> 默认情况下各级标题颜色均是黑色,不同级别的标题仅仅是大小区别.\n\n\n\n> 设置 comscore 主题后,各级标题颜色不同,不仅仅是大小不同.\n\n\nAPI 文档##\n\n\ntheme-api 插件##\n\n> 插件地址: https://plugins.gitbook.com/plugin/theme-api\n\n如果文档本身是普普通文档模式,切换成 api 文档模式后并不会有太大变化,除非一开始就是接口文档,那样使用 theme-api 插件才能看出效果.\n\n示例:\n\n\n\n语法:\n\n * 方法区\n\n\n\n * 语法区\n\n\n\n示例:\n\n\n\n效果:\n\n\n\n> 添加 api 相关方法后的文档效果,正常会两列显示并在右上角增加语言切换工具.\n\n\nFAQ 文档##\n\n\ntheme-faq 插件##\n\n> 插件地址: https://plugins.gitbook.com/plugin/theme-faq\n\ntheme-faq 可以帮助我们构建问答中心,预设好常见问题以及相应答案模式,同时为了方便搜索到问题或答案,一般需要搜索插件的配合.\n\n示例:\n\n\n\n> 帮助中心没有工具栏,因此涉及到工具类的插件一律失效或主动移除,同时默认搜索插件也会失效.\n\n语法:\n\n * 增加文章间的关联\n\n\n\n> 在当前页面底部显示延伸阅读,支持 yaml 语法关联到其他页面.\n\n * 增加头部 logo\n\n\n\n> 新建 _layouts/website/page.html 文件,用于扩展当前主题插件来增加自定义 logo.\n\n * 增加导航栏链接\n\n\n\n> 新建 _layouts/website/page.html 文件,用于扩展当前主题插件来增加自定义导航栏链接.\n\n示例:\n\n\n\n> 新建 _layouts/website/page.html 文件,增加自定义 logo 和导航栏链接.\n\n效果:\n\n\n\n\n小结##\n\n本节主要讲解了常用的三种文档模式,其中 default 主题插件,适合一般的博客类网站或静态网站,api 主题插件适合接口文档的编写,faq\n主题插件则适合帮助中心.\n\n三种主题插件分别对应不同的应用场景,默认情况下使用的是 default\n主题插件,平时介绍的大多数功能插件也大多适合这种主题,另外两种主题可能就不能很好兼容第三方插件,需要亲身体验.","routePath":"/site/webpack/site/mkdocs/gitbook 入门教程之主题插件","lang":"","toc":[{"text":"Book 文档#","id":"book-文档","depth":2,"charIndex":197},{"text":"theme-default 主题#","id":"theme-default-主题","depth":3,"charIndex":209},{"text":"theme-comscore 主题#","id":"theme-comscore-主题","depth":3,"charIndex":489},{"text":"API 文档#","id":"api-文档","depth":2,"charIndex":709},{"text":"theme-api 插件#","id":"theme-api-插件","depth":3,"charIndex":720},{"text":"FAQ 文档#","id":"faq-文档","depth":2,"charIndex":955},{"text":"theme-faq 插件#","id":"theme-faq-插件","depth":3,"charIndex":966},{"text":"小结#","id":"小结","depth":2,"charIndex":1433}],"domain":"","frontmatter":{},"version":""},{"id":26,"title":"gitbook 入门教程之使用 gitbook-cli 开发电子书","content":"#\n\n统计信息：字数 19259 阅读39分钟\n\ngitbook 生成电子书主要有三种方式:\n\n * gitbook-cli 命令行操作,简洁高效,适合从事软件开发的相关人员.\n * gitbook-editor 编辑器操作,可视化编辑,适合无编程经验的文学创作者.\n * gitbook.com 官网操作,在线编辑实时发布,适合无本地环境且科学上网的体验者.\n\n本文主要讲解第一种 gitbook-cli 命令行操作流程,其他两种见另外两篇教程.\n\n\ngitbook 的一些常用命令##\n\n\n安装 gitbook-cli 脚手架工具##\n\n本机已安装 node.js 开发环境,安装完成后运行 gitbook -V 能够打印出版本信息,则表示安装成功.\n\n\n\n> 关于安装配置相关问题请参考 环境要求\n\n\n初始化 gitbook 项目##\n\n初始化项目,按照 gitbook 规范会自动创建 README.md 和 SUMMARY.md 两个文件,具体用途见下文.\n\n其实 SUMMARY.md 是电子书的章节目录,gitbook 会初始化相应的文件目录结构,所以主要是用于开发初始阶段.\n\n\n\n\n启动 gitbook 项目##\n\n启动本地服务,程序无报错则可以在浏览器预览电子书效果: http://localhost:4000\n\n由于能够实时预览电子书效果,并且大多数开发环境搭建在本地而不是远程服务器中,所以主要用于开发调试阶段.\n\n\n\n\n构建 gitbook 静态网页##\n\n构建静态网页而不启动本地服务器,默认生成文件存放在 _book/ 目录,当然输出目录是可配置的,暂不涉及,见高级部分.\n\n输出静态网页后可打包上传到服务器,也可以上传到 github 等网站进行托管,因而主要用于发布准备阶段.\n\n\n\n\n章节小结##\n\n * gitbook init 初始化 README.md 和 SUMMARY.md 两个文件.\n * gitbook build 本地构建但不运行服务,默认输出到 _book/ 目录.\n * gitbook serve 本地构建并运行服务,默认访问 http://localhost:4000 实时预览.\n\n\n\n\n\n\ngitbook 的目录结构说明##\n\n既然要书写一本电子书,那么起码的章节介绍和章节详情自然是必不可少的.\n\n当然还有标题,作者和联系方式等个性化信息需要指定,如果不指定的话,一旦采用默认配合,八成不符合我们的预期,说不定都会变成匿名电子书?所以配置文件一般也是需要手动\n设置的!\n\n真正可选的文件要数词汇表了,毕竟不是每一本电子书都有专业词汇需要去解释说明.如果在章节详情顺便解释下涉及到的专业词汇,那么自然也就不需要词汇表文件了.\n\n简单解释下各个文件的作用:\n\n * README.md 是默认首页文件,相当于网站的首页 index.html ,一般是介绍文字或相关导航链接.\n * SUMMARY.md 是默认概括文件,主要是根据该文件内容生成相应的目录结构,同 README.md 一样都是被gitbook init\n   初始化默认创建的重要文件.\n * _book 是默认的输出目录,存放着原始 markdown 渲染完毕后的 html 文件,可以直接打包到服务器充当静态网站使用.一般是执行 gitbook\n   build 或 gitbook serve 自动生成的.\n * book.json 是配置文件,用于个性化调整 gitbook 的相关配置,如定义电子书的标题,封面,作者等信息.虽然是手动创建但一般是必选的.\n * GLOSSARY.md 是默认的词汇表,主要说明专业词汇的详细解释,这样阅读到专业词汇时就会有相应提示信息,也是手动创建但是可选的.\n * LANGS.md 是默认的语言文件,用于国际化版本翻译,和 GLOSSARY.md 一样是手动创建但是可选的.\n\n\nREADME.md 首页文件[必须]##\n\n编辑 README.md 文件,随便写点内容并启动本地服务(gitbook serve)实时预览效果.\n\n\n\n\nSUMMARY.md 概括文件[必须]##\n\n先停止本地服务,编辑章节目录结构,然后重新再初始化(gitbook init)自动创建相应目录.\n\n\n\n\n_book 输出目录[可选]##\n\n执行 gitbook build 或 gitbook serve 命令后会自动生成静态网页.\n\n\n\n\nbook.json 配置文件[可选]##\n\n在根目录下新建 book.json 配置文件,完整的支持项请参考官方文档,下面仅列举常用的一些配置项.\n\n\n\ntitle 标题##\n\n> 书籍的标题\n\n示例:\n\n\n\nauthor 作者##\n\n> 书籍的作者\n\n示例:\n\n\n\ndescription 描述##\n\n> 书籍的简要描述\n\n示例:\n\n\n\nisbn 国际标准书号##\n\n> 书籍的国际标准书号\n\n示例:\n\n\n\n> 选填,请参考 ISBN Search\n\nlanguage 语言##\n\n> 支持语言项: 默认英语(en),设置成简体中文(zh-hans)\n\n\n\n示例:\n\n\n\ndirection 阅读顺序##\n\n> 阅读顺序,支持从右到左(rtl)或从左到右(ltr),默认值取决于语言值.\n\n示例:\n\n\n\ngitbook 版本##\n\n> 指定 gitbook 版本,支持SemVer规范,接受类似于 >=3.2.3 的条件.\n\n示例:\n\n\n\nroot 根目录##\n\n> 指定存放 gitbook 文件(除了book.json文件本身)的根目录\n\n示例:\n\n\n\nlinks 侧边栏链接##\n\n> 左侧导航栏添加链接,支持外链\n\n示例;\n\n\n\nstyles 自定义样式##\n\n> 自定义全局样式\n\n示例:\n\n\n\nplugins 插件##\n\n> 配置额外的插件列表,添加新插件项后需要运行 gitbook install 安装到当前项目.\n\ngitbook 默认自带5个插件,分别是:\n\n * highlight 语法高亮插件\n * search 搜索插件\n * sharing 分享插件\n * font-settings 字体设置插件\n * livereload 热加载插件\n\n> 后续会介绍一些常用插件,如需获取更多插件请访问官网插件市场\n\n示例:\n\n\n\npluginsConfig 插件配置##\n\n> 安装插件的相应配置项,具体有哪些配置项是由插件本身提供的,应访问插件官网进行查询.\n\n\n\nstructure 目录结构配置##\n\n> 指定README.md,SUMMARY.md,GLOSSARY.md 和 LANGS.md 文件名称.\n\n配置项                   描述\nstructure.readme      readme 文件名(默认值是 README.md)\nstructure.summary     summary 文件名(默认值是 SUMMARY.md)\nstructure.glossary    glossary 文件名(默认值是 GLOSSARY.md)\nstructure.languages   languages 文件名(默认值是 LANGS.md)\n\npdf 配置##\n\n> 定制 pdf 输出格式,可能需要安装 ebook-convert 等相关插件\n\n配置项                 描述\npdf.pageNumbers     添加页码(默认值是 true )\npdf.fontSize        字体大小(默认值是 12 )\npdf.fontFamily      字体集(默认值是 Arial )\npdf.paperSize       页面尺寸(默认值是 a4\n                    ),支持a0,a1,a2,a3,a4,a5,a6,b0,b1,b2,b3,b4,b5,b6,legal,letter\npdf.margin.top      上边界(默认值是 56 )\npdf.margin.bottom   下边界(默认值是 56 )\npdf.margin.left     左边界(默认值是 62 )\npdf.margin.right    右边界(默认值是 62 )\n\n> 电子书封面照片 cover.jpg 和 cover_small.jpg,后续会详细说明.\n\n\nGLOSSARY.md 词汇表文件[可选]##\n\n词汇表文件,用于全书的专业词汇解释说明,比如鼠标悬停在专业词汇上会有相应提示.\n\n> 语法格式: ## + `` + 专业词汇\n\n学习 gitbook 前最好先学习下markdown和git,你知道他们的用途吗?\n\n示例:\n\n\n\n\nLANGS.md 语言文件[可选]##\n\n支持国际化编写图书,一种语言一个单独子目录,同样地,将语言文件放到根目录下.\n\n示例:\n\n\n\n\n章节小结##\n\n开发初始阶段运行 gitbook init 命令按照 SUMMARY.md 文件内容自动创建对应目录结构,编写各自文件内容后运行 gitbook serve\n启动本地服务实时预览效果.\n\n开发到一定程度后打算发布服务,再运行 gitbook build 输出到 _book/ 目录,别忘了配置 book.json 文件,然后就可以将 _book/\n文件夹整个扔到 nginx 等静态服务器上,这样就能联网访问你的电子书了.\n\n是不是很简单,后续还会有如何发布与导出等相关教程,今天先到这里,下次见!\n\n作者： 雪之梦技术驿站\n\n出处：https://www.cnblogs.com/snowdreams1006/p/10649210.html\n\n分类: gitbook 入门教程\n\n标签: gitbook, git, markdown, gitbook-cli","routePath":"/site/webpack/site/mkdocs/gitbook 入门教程之使用 gitbook-cli 开发电子书","lang":"","toc":[{"text":"`gitbook` 的一些常用命令#","id":"gitbook-的一些常用命令","depth":2,"charIndex":-1},{"text":"安装 `gitbook-cli` 脚手架工具#","id":"安装-gitbook-cli-脚手架工具","depth":3,"charIndex":-1},{"text":"初始化 `gitbook` 项目#","id":"初始化-gitbook-项目","depth":3,"charIndex":-1},{"text":"启动 `gitbook` 项目#","id":"启动-gitbook-项目","depth":3,"charIndex":-1},{"text":"构建 `gitbook` 静态网页#","id":"构建-gitbook-静态网页","depth":3,"charIndex":-1},{"text":"章节小结#","id":"章节小结","depth":3,"charIndex":760},{"text":"`gitbook` 的目录结构说明#","id":"gitbook-的目录结构说明","depth":2,"charIndex":-1},{"text":"`README.md` 首页文件[必须]#","id":"readmemd-首页文件必须","depth":3,"charIndex":-1},{"text":"`SUMMARY.md` 概括文件[必须]#","id":"summarymd-概括文件必须","depth":3,"charIndex":-1},{"text":"`_book` 输出目录[可选]#","id":"_book-输出目录可选","depth":3,"charIndex":-1},{"text":"`book.json` 配置文件[可选]#","id":"bookjson-配置文件可选","depth":3,"charIndex":-1},{"text":"`title` 标题#","id":"title-标题","depth":4,"charIndex":-1},{"text":"`author` 作者#","id":"author-作者","depth":4,"charIndex":-1},{"text":"`description` 描述#","id":"description-描述","depth":4,"charIndex":-1},{"text":"`isbn` 国际标准书号#","id":"isbn-国际标准书号","depth":4,"charIndex":-1},{"text":"`language` 语言#","id":"language-语言","depth":4,"charIndex":-1},{"text":"`direction` 阅读顺序#","id":"direction-阅读顺序","depth":4,"charIndex":-1},{"text":"`gitbook` 版本#","id":"gitbook-版本","depth":4,"charIndex":-1},{"text":"`root` 根目录#","id":"root-根目录","depth":4,"charIndex":-1},{"text":"`links` 侧边栏链接#","id":"links-侧边栏链接","depth":4,"charIndex":-1},{"text":"`styles` 自定义样式#","id":"styles-自定义样式","depth":4,"charIndex":-1},{"text":"`plugins` 插件#","id":"plugins-插件","depth":4,"charIndex":-1},{"text":"`pluginsConfig` 插件配置#","id":"pluginsconfig-插件配置","depth":4,"charIndex":-1},{"text":"`structure` 目录结构配置#","id":"structure-目录结构配置","depth":4,"charIndex":-1},{"text":"`pdf` 配置#","id":"pdf-配置","depth":4,"charIndex":-1},{"text":"`GLOSSARY.md` 词汇表文件[可选]#","id":"glossarymd-词汇表文件可选","depth":3,"charIndex":-1},{"text":"`LANGS.md` 语言文件[可选]#","id":"langsmd-语言文件可选","depth":3,"charIndex":-1},{"text":"章节小结#","id":"章节小结-1","depth":3,"charIndex":3695}],"domain":"","frontmatter":{},"version":""},{"id":27,"title":"gitbook 入门教程之使用 gitbook-editor 编辑器开发电子书","content":"#\n\n统计信息：字数 1871 阅读4分钟\n\n亲测,目前已不再支持旧版 gitbook-editor 编辑器,而官网也没有相应的新版编辑器,如果哪位找到了新版编辑器,还望告知!\n\n\n\n现在注册 gitbook 账号会默认重定向到 新版官网,而 旧版官网 的账号应该是可以正常使用的,前提是你必须之前注册过.\n\n\n\n遗憾的是,最新注册的账号是无法使用 gitbook-editor 编辑器,不能登录到 gitbook ,也无法同步 github ,充其量只能算本地的\nmarkdown 编辑器,所以这一节不再介绍了.\n\n\n\n如果有兴趣了解 gitbook-editor 编辑器的基本使用,请参考 gitbook editor 编辑器.","routePath":"/site/webpack/site/mkdocs/gitbook 入门教程之使用 gitbook-editor 编辑器开发电子书","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":28,"title":"gitbook-cli","content":"#\n\n统计信息：字数 1570 阅读4分钟\n\nThe GitBook command line interface.\n\nInstall this globally and you'll have access to the gitbook command anywhere on\nyour system.\n\n\n\nNote: The purpose of the gitbook command is to load and run the version of\nGitBook you have specified in your book (or the latest one), irrespective of its\nversion. The GitBook CLI only support versions >=2.0.0 of GitBook.\n\ngitbook-cli store GitBook's versions into ~/.gitbook, you can set the\nGITBOOK_DIR environment variable to use another directory.\n\n\nHow to use it?#\n\n\nRun GitBook#\n\nRun command gitbook build, gitbook serve (read GitBook documentation for\ndetails).\n\nList all available commands using:\n\n\n\nSpecify a specific version#\n\nBy default, GitBook CLI will read the gitbook version to use from the book\nconfiguration, but you can force a specific version using --gitbook option:\n\n\n\nand list available commands in this version using:\n\n\n\nManage versions#\n\nList installed versions:\n\n\n\nList available versions on NPM:\n\n\n\nInstall a specific version:\n\n\n\nUpdate to the latest version\n\n\n\nUninstall a specific version\n\n\n\nUse a local folder as a GitBook version (for developement)\n\n","routePath":"/site/webpack/site/mkdocs/gitbook-cli","lang":"","toc":[{"text":"How to use it?","id":"how-to-use-it","depth":2,"charIndex":510},{"text":"Run GitBook","id":"run-gitbook","depth":3,"charIndex":528},{"text":"Specify a specific version","id":"specify-a-specific-version","depth":4,"charIndex":664},{"text":"Manage versions","id":"manage-versions","depth":4,"charIndex":901}],"domain":"","frontmatter":{},"version":""},{"id":29,"title":"Markdown 新语法","content":"#\n\n统计信息：字数 743 阅读2分钟\n\n这部分语法在部分软件是正常的，在 github 暂时不支持。\n\n\n这是引用语法#\n\n一个具有脚注的文本A。1 一个具有脚注的文本B。2\n\n需要在界面末尾写出注释的内容（注意格式）\n\n\n流程图#\n\n这个可以用来分析算法和数据流（需要本地分析截图）\n\n\n\n这是复杂的流程图 :sunny:\n\n\n\n\nFootnotes\n\n 1. 这里引用的是Anna名言。 ↩\n\n 2. 这里引用的是董明珠的诗句。 ↩","routePath":"/site/webpack/site/mkdocs/markdown-new-style","lang":"","toc":[{"text":"这是引用语法","id":"这是引用语法","depth":3,"charIndex":54},{"text":"流程图","id":"流程图","depth":3,"charIndex":113}],"domain":"","frontmatter":{},"version":""},{"id":30,"title":"JS打包工具rollup——完全入门指南","content":"","routePath":"/site/webpack/site/rollup/28-rollup完全入门指南","lang":"","toc":[{"text":"前言","id":"前言","depth":2,"charIndex":-1},{"text":"rollup.js简介","id":"rollupjs简介","depth":2,"charIndex":-1},{"text":"rollup.js实例","id":"rollupjs实例","depth":2,"charIndex":-1},{"text":"demo0 开始使用rollup","id":"demo0-开始使用rollup","depth":3,"charIndex":-1},{"text":"demo1 使用rollup进行模块化打包","id":"demo1-使用rollup进行模块化打包","depth":2,"charIndex":-1},{"text":"demo2 使用配置文件来进行rollup打包","id":"demo2-使用配置文件来进行rollup打包","depth":2,"charIndex":-1},{"text":"demo3 监听文件变化，随时打包","id":"demo3-监听文件变化随时打包","depth":2,"charIndex":-1},{"text":"demo4 是时候写ES6了","id":"demo4-是时候写es6了","depth":2,"charIndex":-1},{"text":"demo5 解析cjs，打包第三方模块","id":"demo5-解析cjs打包第三方模块","depth":2,"charIndex":-1},{"text":"demo6 不要打包到一个文件，为rollup设置外部模块和全局变量","id":"demo6-不要打包到一个文件为rollup设置外部模块和全局变量","depth":2,"charIndex":-1},{"text":"demo7 打包node内置模块","id":"demo7-打包node内置模块","depth":2,"charIndex":-1},{"text":"demo8 配合CDN来使用rollup","id":"demo8-配合cdn来使用rollup","depth":2,"charIndex":-1},{"text":"demo9 最小化你的代码","id":"demo9-最小化你的代码","depth":2,"charIndex":-1},{"text":"demo10 为你的代码添eslint检查","id":"demo10-为你的代码添eslint检查","depth":2,"charIndex":-1},{"text":"demo11 控制开发环境和生产环境下的配置","id":"demo11-控制开发环境和生产环境下的配置","depth":2,"charIndex":-1},{"text":"demo12 使用rollup的API","id":"demo12-使用rollup的api","depth":2,"charIndex":-1},{"text":"demo13 除了打包JS，我们还能……","id":"demo13-除了打包js我们还能","depth":2,"charIndex":-1},{"text":"extra 编写你自己的rollup插件","id":"extra-编写你自己的rollup插件","depth":2,"charIndex":-1},{"text":"总结 and 一个完整的rollup项目的模板","id":"总结-and-一个完整的rollup项目的模板","depth":2,"charIndex":-1},{"text":"参考资料","id":"参考资料","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":31,"title":"rollup打包工具基础配置使用详解","content":"#\n\n统计信息：字数 16753 阅读34分钟\n\n\n使用详解#\n\n\n前言#\n\nRollup官方解析： Rollup 是一个 JavaScript 模块打包器，可以将小块代码编译成大块复杂的代码，例如 library（库） 或应用程序\n\nwebpack官方解析： webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack\n处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个\nbundle。(webpack存在大量引导代码和模块函数)\n\n> vue框架源码是使用Rollup进行打包的，而且rollup和webpack相比更适用于框架的开发，打包后的代码可读性更高。\n\n使用Rollup的开源项目： - vue - vuex - vue-router\n\n使用webpack的项目： - ElementUI - mint-ui - vue-cli\n\n从上面使用场景可以大概分析出，Rollup 偏向应用于js库，webpack 偏向应用于前端工程，UI 库。\n\n如果你的应用场景中只是 js 代码，希望做 ES 转换，模块解析，可以使用 Rollup。 如果你的场景中涉及到\ncss、html，涉及到复杂的代码拆分合并，建议使用 webpack。\n\n\n介绍#\n\n * esModule打包器\n * 将项目中散落的小模块打包成整块的代码，让划分的小模块可以更好地运行在浏览器环境和nodejs环境\n * 作用： 与webpack非常类似\n * 对比：\n   Rollup相对于webpack更小巧，webpack可以完成项目中各种工程化的需求，而Rollup仅仅是一款ESM（ESmodule）打包器，没有任何其\n   它的功能。 例如，webpack中有HMR（热替换功能），Rollup中没有\n * Rollup的意义： 提供一个充分利用ESM各项特性的高效打包器。利用ESmodule的各种特性构建出结构比较扁平，性能比较出众的类库。\n\n\n注意点#\n\n 1. type字段的产生用于定义package.json文件和该文件所在目录根目录中.js文件和无拓展名文件的处理方式。值为'module'则当作es模块处理\n    ；值为'commonjs'则被当作commonJs模块处理。\n 2. 目前node默认的是如果pacakage.json没有定义type字段，则按照commonJs规范处理。\n 3. node官方建议包的开发者明确指定package.json中type字段的值。\n 4. 无论package.json中的type字段为何值，.mjs的文件都按照es模块来处理，.cjs的文件都按照commonJs模块来处理。\n\n> 执行build的时候，因为rollup.config.js使用的是es模块语法，package.json不声明type值为module，会报错，或者把rol\n> lup.config.js改成rollup.config.mjs再执行。\n\n\n安装#\n\n初始化项目包：npm init\n\n安装 rollup：npm i rollup -D\n\n创建 rollup 配置文件：rollup.config.js\n\n\n\n\n使用#\n\n\ninput#\n\n入口的配置字段为 input\n\n\n单入口配置#\n\n单个入口的配置只需要为 input 指定一个入口文件即可\n\n\n\n\n多入口配置#\n\n多个入口配置需要将导出的配置设置为数组，数组的项为一个对象，每一个对象都可以单独配置。\n\n\n\n\noutput#\n\n出口的配置字段为 output，一个出口时output使用对象形式，多个出口使用数组形式。\n\n * file：出口的地址以及打包的名字\n * format：打包的格式，格式分为五种分别为：amd / es / cjs / iife / umd\n * name：当 format 为 iife 和 umd 时必须提供，将作为全局变量挂在window(浏览器环境)下\n * sourcemap：生成 main.map.js 文件，方便调试\n * banner：为打包好的文件添加注释，注释的位置在整个文件的首行\n * footer：为打包好的文件添加注释，注释的位置在整个文件的尾行\n * intro：为打包好的文件添加注释，注释的位置在打包数据内容的头部\n * outro：为打包好的文件添加注释，注释的位置在打包数据内容的末尾\n\n> banner、footer、intro、outro 可以不用配置在出口中。\n\n\n单出口配置#\n\n\n\n\n多出口配置#\n\n\n\n\nexternal#\n\n需要保持某些库外部引用状态，这时需要使用 external 属告诉 rollup.js 哪些是外部的类库，不需要将这些外部类库进行打包。\n\n确保外部化处理不想打包进库的依赖。\n\n\n\nmain.js 源文件代码\n\n\n\n未保持外部引入打包后代码\n\n\n\n保持外部引入打包后代码\n\n\n\n\nplugins#\n\n\nnode模块的引用#\n\n> 在某些时候，项目可能取决于从NPM安装到node_modules文件夹中的软件包。\n> 与Webpack和Browserify等其他捆绑软件不同，Rollup不知道如何开箱即用、如何处理这些依赖项，因此需要添加一些插件配置。\n> rollup.js编译源码中的模块引用默认只支持\n> ES6+的模块方式import/export。然而大量的npm模块是基于CommonJS模块方式，这就导致了大量 npm\n> 模块不能直接编译使用，导致打包报错。所以辅助rollup.js编译支持 npm模块和CommonJS模块方式的插件就应运而生。\n\n\n\n * @rollup/plugin-node-resolve 插件允许我们加载第三方模块\n * @rollup/plugin-commonjs 插件将它们转换为ES6版本\n * @rollup/plugin-json 支持导入json，没有 json 插件的支持我们在导入 json 文件时会报错\n\n\n\n使用第三方库 lodash\n\n\n\n> 执行npm run build 后会看到打包后的文件多了很多内容，这些代码就是ladash的代码，被打包整合进来了。\n\n补充\n\n如果不想第三方库被打包进来，而可以在外面引入，配合使用的话，可以在rollup.config.js中配置 external: ['lodash']。\n\n\n支持别名#\n\n安装@rollup/plugin-alias插件，插件提供了为模块起别名的功能。\n\n\n\n\n代码压缩#\n\n使用@rollup/plugin-terser进行打包代码压缩。\n\n\n\n\n开启本地服务器 & 热更新#\n\n * rollup-plugin-serve 开启本地服务器\n * rollup-plugin-livereload 开启热更新，实时刷新页面\n\n\n\npackage.json文件配置启动脚本命令\n\n\n\nindex.html文件中引入bundle.js打包文件\n\n\n\n\neslint#\n\n@rollup/plugin-eslint 使用代码检查功能\n\n\n\n需要创建.eslintrc文件配置 eslint 规则\n\n1、使用.eslintrc.js文件格式，如果package.json中配置\"type\": \"module\"，则需要更改文件后缀名为.eslintrc.cjs。\n\n\n\n2、使用.eslintrc.json文件格式\n\n\n\n在rollup.config.js中配置eslint插件\n\n\n\nESLint 支持几种格式的配置文件：\n\n * JavaScript - 使用 .eslintrc.js 然后输出一个配置对象。\n * YAML - 使用 .eslintrc.yaml 或 .eslintrc.yml 去定义配置的结构。\n * JSON - 使用 .eslintrc.json 去定义配置的结构，ESLint 的 JSON 文件允许 JavaScript 风格的注释。\n * (弃用) - 使用 .eslintrc，可以使 JSON 也可以是 YAML。\n * package.json - 在 package.json 里创建一个 eslintConfig属性，在那里定义你的配置。\n\n如果同一个目录下有多个配置文件，ESLint 只会使用一个。优先级顺序如下：\n\n 1. .eslintrc.js\n 2. .eslintrc.yaml\n 3. .eslintrc.yml\n 4. .eslintrc.json\n 5. .eslintrc\n 6. package.json\n\n\ntree-shaking#\n\ntree shaking是rollup提出的，这也是rollup一个非常重要的feature，那什么是tree\nshaking，rollup的解释是在构建代码时，在使用ES6模块化的代码中，会对你的代码进行静态分析，只打包使用到的代码。这样的好处是减少代码的体积。\n\n与 Webpack 不同的是，Rollup 不仅仅针对模块进行依赖分析，它的分析流程如下：\n\n 1. 从入口文件开始，组织依赖关系，并按文件生成 Module\n 2. 生成抽象语法树（Acorn），建立语句间的关联关系\n 3. 为每个节点打标，标记是否被使用\n 4. 生成代码（MagicString+ position）去除无用代码\n\n\n设置环境变量NODE_ENV#\n\n\nwindows#\n\nset NODE_ENV=production\n\n\n\n\nlinux & mac#\n\nexport NODE_ENV=production\n\n\n\n\n跨平台设置#\n\n依赖 cross-env 模块\n\n\n\n根据环境配置插件\n\n\n\n\n参考链接#\n\nhttps://zhuanlan.zhihu.com/p/608457915\n\nhttps://zhuanlan.zhihu.com/p/340255085\n\nhttps://juejin.cn/post/6968839519353176077\n\nhttps://juejin.cn/post/6844903596970999815\n\n模块化规范\n\n模块化系列\n\nseajs-模块化历史讨论","routePath":"/site/webpack/site/rollup/29-rollup打包工具基础配置使用详解","lang":"","toc":[{"text":"使用详解","id":"使用详解","depth":2,"charIndex":25},{"text":"前言","id":"前言","depth":3,"charIndex":33},{"text":"介绍","id":"介绍","depth":3,"charIndex":606},{"text":"注意点","id":"注意点","depth":3,"charIndex":902},{"text":"安装","id":"安装","depth":3,"charIndex":1321},{"text":"使用","id":"使用","depth":3,"charIndex":1406},{"text":"input","id":"input","depth":3,"charIndex":1412},{"text":"单入口配置","id":"单入口配置","depth":3,"charIndex":1437},{"text":"多入口配置","id":"多入口配置","depth":3,"charIndex":1478},{"text":"output","id":"output","depth":3,"charIndex":1534},{"text":"单出口配置","id":"单出口配置","depth":3,"charIndex":1950},{"text":"多出口配置","id":"多出口配置","depth":3,"charIndex":1961},{"text":"external","id":"external","depth":3,"charIndex":1972},{"text":"plugins","id":"plugins","depth":3,"charIndex":2123},{"text":"node模块的引用","id":"node模块的引用","depth":3,"charIndex":2134},{"text":"支持别名","id":"支持别名","depth":3,"charIndex":2732},{"text":"代码压缩","id":"代码压缩","depth":3,"charIndex":2784},{"text":"开启本地服务器 & 热更新","id":"开启本地服务器--热更新","depth":3,"charIndex":2828},{"text":"eslint","id":"eslint","depth":3,"charIndex":2978},{"text":"tree-shaking","id":"tree-shaking","depth":3,"charIndex":3640},{"text":"设置环境变量NODE_ENV","id":"设置环境变量node_env","depth":3,"charIndex":3959},{"text":"windows","id":"windows","depth":3,"charIndex":3977},{"text":"linux & mac","id":"linux--mac","depth":3,"charIndex":4015},{"text":"跨平台设置","id":"跨平台设置","depth":3,"charIndex":4060},{"text":"参考链接","id":"参考链接","depth":3,"charIndex":4100}],"domain":"","frontmatter":{},"version":""},{"id":32,"title":"01 笔记","content":"#\n\n\n单文件编译#\n\n\n\n常用输出格式分为三种：iife cjs umd，表示浏览器环境，node 环境，两者都支持的环境\n\n全部格式：\"amd\", \"cjs\", \"system\", \"es\", \"iife\" or \"umd\".\n\n第一个测试文件中，包括了这三个打包的方式，可以查看具体的打包结果","routePath":"/site/webpack/site/rollup/demo01-note","lang":"","toc":[{"text":"单文件编译","id":"单文件编译","depth":2,"charIndex":3}],"domain":"","frontmatter":{},"version":""},{"id":33,"title":"笔记","content":"#\n\n实际生产环境中，需要使用配置文件\n\n单模块入口","routePath":"/site/webpack/site/rollup/demo02-note","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":34,"title":"笔记","content":"#\n\n多入口多出口文件的配置\n\n","routePath":"/site/webpack/site/rollup/demo03-note","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":35,"title":"04 插件","content":"#\n\n插件的配置：先安装，然后在配置文件中导入和使用\n\n全部插件介绍：\n\nhttps://rollupjs.org/guide/en/#plugins\n\nhttps://rollupjs.org/guide/en/#plugin-development\n\n\n\n\n@rollup/plugin-json#\n\nA Rollup plugin which Converts .json files to ES6 modules.\n\n将 .json 文件转换为 ES6 模块的 Rollup 插件。\n\n允许导入 json 文件\n\n\n@rollup/plugin-node-resolve#\n\nA Rollup plugin which locates modules using the Node resolution algorithm, for\nusing third party modules in node_modules\n\n一个使用 Node 解析算法定位模块的 Rollup 插件，用于在 node_modules 中使用第三方模块\n\n\n@rollup/plugin-commonjs#\n\nA Rollup plugin to convert CommonJS modules to ES6, so they can be included in a\nRollup bundle\n\n将 CommonJS 模块转换为 ES6 的 Rollup 插件，因此它们可以包含在 Rollup 包中\n\n\nrollup-plugin-terser#\n\nRollup plugin to minify generated es bundle. Uses terser under the hood.\n\n用于缩小生成的 es 包的汇总插件。 在hook下使用更简洁。\n\n\n\n\n其他选项#\n\n其他的选项参考：https://www.rollupjs.com/guide/big-list-of-options","routePath":"/site/webpack/site/rollup/demo04-note","lang":"","toc":[{"text":"@rollup/plugin-json","id":"rollupplugin-json","depth":3,"charIndex":130},{"text":"@rollup/plugin-node-resolve","id":"rollupplugin-node-resolve","depth":3,"charIndex":261},{"text":"@rollup/plugin-commonjs","id":"rollupplugin-commonjs","depth":3,"charIndex":471},{"text":"rollup-plugin-terser","id":"rollup-plugin-terser","depth":3,"charIndex":648},{"text":"其他选项","id":"其他选项","depth":2,"charIndex":781}],"domain":"","frontmatter":{},"version":""},{"id":36,"title":"说明","content":"#\n\n统计信息：字数 402 阅读1分钟\n\n本目录为 webpack 等打包构建工具介绍，以及个人笔记总结。\n\nwebpack 官方链接：https://www.webpackjs.com/\n\nRollup 官方链接：https://www.rollupjs.com/\n\nbable 官方链接：https://www.babeljs.cn/\n\n代码案例链接：https://github.com/Michael18811380328/webpack-babel\n\n注意：构建工具不同版本配置不同，需要根据实际项目版本号使用。","routePath":"/site/webpack/site/webpack/00-readme","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":37,"title":"webpack 主要概念","content":"#\n\n统计信息：字数 3558 阅读8分钟\n\ncreate time 2019-01-01\n\nlast modify time 2024-04-12\n\n官网文档链接：https://webpack.docschina.org/concepts/plugins/\n\nwebpack 静态文件打包：首先构建一个依赖图（dependency graph），然后生成一个或者多个包（bundle）。\n\n\n入口（entry）#\n\n这里表示 webpack 构建依赖图的开始的文件（通常是 src/index.js）\n\n\n\nhttps://webpack.docschina.org/concepts/entry-points/\n\n入口配置简单：入口配置分为单页面和多页面：\n\n通常一个 SPA 项目使用一个入口文件；\n\n如果功能复杂，实际是多个页面，后端根据不同路由进入不同的界面，那么可以设置多个入口文件（多个入口可以复用组件）。\n\n\n\n\n出口（output）#\n\n表示打包后的文件的输出位置（默认是./dist/main.js），可以输出多个打包文件\n\n\n\n\nloader#\n\nwebpack 默认可以打包 js json 文件，但是对于 css less sass ts 等文件不能直接打包。loader\n可以对不同文件进行预处理，并转换成有效的模块。需要在 module-rules 添加 loader（注意路径）。\n\nLoader 参数有两个：\n\n * test 是正则表达式，可以匹配不同类型的文件（根据文件名的后缀匹配文件）注：正则表达式不能加入引号。\n * use 是一个数组，表示对于不同类型的文件使用不同的 loader，一步一步进行处理。\n\nloader 针对常见的文件都有对应的loader。\n\n\n\n\n插件（plugin）#\n\nloader 可以解决不同文件的处理方法，plugin\n可以支持更多功能，例如配置环境变量，或者新生成一个文件（目前没有用到）。插件很多很复杂，目的是解决loader无法解决的事情。\n\n\n\n\n模式 mode#\n\n默认是 production、还有 development 或者 none。这个设置后不需要变化（通常不用none）。\n\n\n总结#\n\nwebpack 主要概念：bundle、block、entry、output、loader、plugin、mode","routePath":"/site/webpack/site/webpack/01-webpack基本概念","lang":"","toc":[{"text":"入口（entry）","id":"入口entry","depth":3,"charIndex":197},{"text":"出口（output）","id":"出口output","depth":3,"charIndex":415},{"text":"loader","id":"loader","depth":3,"charIndex":476},{"text":"插件（plugin）","id":"插件plugin","depth":3,"charIndex":757},{"text":"模式 mode","id":"模式-mode","depth":3,"charIndex":866},{"text":"总结","id":"总结","depth":2,"charIndex":938}],"domain":"","frontmatter":{},"version":""},{"id":38,"title":"create-react-app入门教程","content":"#\n\n统计信息：字数 3959 阅读8分钟\n\ncreate time 2019-01-01\n\nlast modify time 2024-04-12\n\nCreate React\nApp是官方出的一个构建React单页面应用的脚手架工具。它本身集成了Webpack，并配置了一系列内置的loader和默认的npm的脚本，可以很轻松的实现零配\n置就可以快速开发React的应用。\n\n官网文档\n\n\nQuick Start#\n\n\n全局安装#\n\n\n\n\n公共目录#\n\n公共目录里面的内容不会被webpack进行处理，仅仅会拷贝到最终生成的项目的根目录下。\n\n\nHTML模板修改#\n\n在public目录中有个index.html是单页面应用的基本模板，所有react生成的代码都会注入到此HTML中。所以此处可以添加一些cdn脚本或者全局的ht\nml。\n\n\n添加全局的资源（图片、字体、svg、视频等）#\n\n在公共目录下，你可以放字体文件、图片、svg等文件，访问这些文件最好添加 %PUBLIC_URL%作为根目录。\n\n\n环境变量#\n\n巧妙的使用环境变量可以帮我们在项目中区分开生产环境还是编译环境，从而执行不同的代码。\n\n\n添加自定义环境变量文件.env#\n\n项目根目录下创建.env文件，文件内部添加 key=value的配置可以直接应用于项目的编译中。\n\n\n\n> Note: 如果创建自定义的环境变量必须以REACT_APP_开头.\n\n\n在项目中使用环境变量#\n\n在项目中可以直接用process.env.XXX访问我们的自定义的环境变量。比如：\n\n * js中使用\n\n\n\n再比如：判断是否是生产环境\n\n\n\n\n配合TypeScript#\n\n第一种方式：创建项目的时候直接配置好TypeScript.\n\n\n\n第二种方式：为现有的React项目添加TypeScript\n\n\n\n\n配置代理#\n\n\npackage.json配置代理#\n\n配置简单代理，直接在package.json文件中添加proxy节点即可：\n\n\n\n\n自定义配置代理#\n\n第一步：安装 http-proxy-middleware\n\n\n\n第二步：创建： src/setupProxy.js 添加如下内容:\n\n\n\n\nHTTPS托管静态站#\n\n有时候需要用HTTPS进行调试相关结构，所以需要把静态站也做成HTTPS的，那么以下配置：\n\n配置HTTPS的环境变量为true然后再用npm start启动dev server就是HTTPS的了。\n\n\n\n浏览器可能有安全警告，不用管，直接测试，enjoy it！\n\n\n分析包结构的大小#\n\nSource map explorer可以帮助我们分析代码最终打包的bundles的代码来自哪里\n\n安装：\n\n\n\n添加分析脚本到package.json的scripts中：\n\n\n\n那么就可以运行以下命令进行分析最终打包的情况了：\n\n\n\n说明：此时 webpack 需要开启 sourcemap 配置才能正常使用。如果没有开启 sourcemap 则无法分析。","routePath":"/site/webpack/site/webpack/02-create-react-app入门教程","lang":"","toc":[{"text":"Quick Start","id":"quick-start","depth":2,"charIndex":195},{"text":"全局安装","id":"全局安装","depth":3,"charIndex":210},{"text":"公共目录","id":"公共目录","depth":2,"charIndex":220},{"text":"HTML模板修改","id":"html模板修改","depth":3,"charIndex":273},{"text":"添加全局的资源（图片、字体、svg、视频等）","id":"添加全局的资源图片字体svg视频等","depth":3,"charIndex":371},{"text":"环境变量","id":"环境变量","depth":2,"charIndex":454},{"text":"添加自定义环境变量文件`.env`","id":"添加自定义环境变量文件env","depth":3,"charIndex":-1},{"text":"在项目中使用环境变量","id":"在项目中使用环境变量","depth":3,"charIndex":615},{"text":"配合TypeScript","id":"配合typescript","depth":2,"charIndex":701},{"text":"配置代理","id":"配置代理","depth":2,"charIndex":783},{"text":"`package.json`配置代理","id":"packagejson配置代理","depth":3,"charIndex":-1},{"text":"自定义配置代理","id":"自定义配置代理","depth":3,"charIndex":852},{"text":"HTTPS托管静态站","id":"https托管静态站","depth":2,"charIndex":932},{"text":"分析包结构的大小","id":"分析包结构的大小","depth":2,"charIndex":1080}],"domain":"","frontmatter":{},"version":""},{"id":39,"title":"网易项目webpack配置解析","content":"#\n\n统计信息：字数 16390 阅读33分钟\n\ncreate time 2020-01-01\n\nlast modify time 2024-04-12\n\n课程 webpack 版本是4\n\n学习目标：自己可以看懂90%的配置文件，并自定义plugin和loader\n\n\n01 环境与目录#\n\n环境分类：开发、测试、生产\n\n开发环境：增加开发服务器操作\n\n测试环境：测试环境和生产环境很接近\n\n生产环境：增加 tree-shaking devtool(source-map)操作(压缩操作)\n\n不同模式下对应不同的文件：\n\n * 开发环境下 npm run dev => dev.config.js；\n * 生产环境下 npm run build => prod.config.js。\n\n实际操作时，有一个 base.config.js 是基础默认配置，不同环境都会执行，运行时会执行多个脚本。\n\nnpm run build 实际执行了什么操作？\n\n\n\npackage.json\n\n\n\nBuild.js （这是网易项目中自定义的build脚本）\n\n\n\n使用第三方插件创建的build.js 也差不多，@vue/cli 创建的build脚本。\n\n在命令行中输入 webpack config.js 和执行 node build.js 并在JS文件中使用的效果是一样的。\n\n代码中，webpack 本质上是一个方法。\n\n\n\n打包过程是异步的，所以先进行DLL打包，然后再引入生产环境配置，进行下一步打包。\n\nbuild 脚本：导入配置文件，调用webpack打包方法进行打包\n\nbuild.js\n\n\n\nprod 脚本中，有一个webpack-merge 方法，可以合并多个脚本\n\n配置的本质就是一个对象，merge就是合并多个对象\n\nwebpack.prod.conf.js\n\n\n\n\n02 常用 loader 和插件#\n\n常用插件 plugins，下面依次介绍\n\n * webpack.DefinePlugin 在打包阶段定义全局变量\n * webpack.HashedModuledsPlugin 保持 module.id 稳定\n * webpack.NoEmitOnErrorsPlugin 屏蔽错误\n * webpack.providePlugin 提供插件库\n * copy-webpack-plugin 可以帮助拷贝内容\n\n全部的插件官方文档：https://v4.webpack.docschina.org/plugins/\n\n\nwebpack.DefinePlugin#\n\n指定当前的环境变量（打包阶段定义全局变量）\n\n可以使用 webpack --env production\n通过命令行的形式传参，或者使用这个对象指定当前的环境变量是开发环境还是生产环境，在业务代码中获取到当前的环境变量。\n\n\n\nprod.env.js 简化版\n\n\n\n\nwebpack.DllReferencePlugin#\n\n\n\n\nMiniCssExtractPlugin#\n\n官方推荐使用mini-css-extract-plugin插件来打包css文件（从css文件中提取css代码到单独的文件中，对css代码进行代码压缩等）。\n\n\n\n\nModuleConcatenationPlugin#\n\n过去 webpack 打包时的一个取舍是将 bundle 中各个模块单独打包成闭包。这些打包函数使你的 JavaScript\n在浏览器中处理的更慢。相比之下，一些工具像 Closure Compiler 和 RollupJS\n可以提升(hoist)或者预编译所有模块到一个闭包中，提升你的代码在浏览器中的执行速度。\n\n\n\n\nwebpack.HashedModuleIdsPlugin#\n\n保持模块的 module.id 稳定\n\n该插件会根据模块的相对路径生成一个四位数的hash作为模块id, 建议用于生产环境。\n\n如何判断一个文件是新的还是旧的（浏览器读取新文件，还是读取缓存文件），就根据文件后面的hash值判断。所以webpack打包输出的文件中就增加了哈希值。\n\n\n\n\nwebpack.NoEmitOnErrorsPlugin#\n\n如果代码出现问题，webpack 默认不会继续编译，显示错误。\n\n这个插件可以继续编译并让浏览器显示（操作更友好）。\n\n\n\n\nwebpack.providePlugin 提供第三方库#\n\n如果我们在全局中使用某些库，例如jquery，可以使用这个插件\n\nbase.conf.js\n\n对于 axios jquery 等通用组件，每个组件都需要 import，可以只用这个插件。直接在这里定义，不需要在不同组件中全局定义，定以后可以打包到环境中。\n\n\n\n\ncopy-webpack-plugin 可以帮助拷贝内容#\n\n这个插件不是自带的，需要安装\n\n\n\n\n03 优化打包的内容#\n\n\nDLL优化#\n\n\n\n什么是DLL优化？我们需要用第三方库，不会修改第三方库的内容，每次webpack打包会处理第三方库代码。既然第三方库代码不变，我们可以先把第三方库代码处理了，放\n在一边，然后下一次打包不需要再次处理这部分代码，直接使用。\n\n\n\nwebpack.dll.js\n\n\n\nbash 打包第三方库\n\n\n\n输出 vender.dll.js\n\n然后在webpack配置文件中增加这个文件\n\n\n\n使用 webpack 继续打包项目代码\n\n\nHappyPack#\n\n\n\n如果项目较小，打包编译的时间反而更多\n\n因为这里使用多进程，调用进程也消耗时间\n\n所以文件组件较少时，使用 Happypack 可能增加打包时间。\n\n如果大型项目，那么使用这个可以节省很多时间。\n\n这是一个第三方库，需要单独安装到dev中\n\n\n04 webpack 自定义插件#\n\n项目中打包简化：可变性配置：通过编写响应的操作函数；\n\nMyloader.js 自定义增加插件（使用正则替换代码中的字符，类似于AST，抽象语法树，类似中间件的语法）开发的时候，我们使用 static\n中的图片，生产环境中需要使用 www.baidu.com 中的图片，所以可以自定义一个插件替换开发环境中的变量。\n\n\n\n使用\n\n\n\nindex.js 插件就是监听 webpack 的生命周期函数，并在合适的时候处理代码\n\n\n\nmake 周期需要处理很多编译的配置，新手不好做，done 周期直接操作编译后的文件，相对简单\n\n\n总结#\n\n如果对模块内容批量进行处理：loader 是首选方案；\n\n如果要加入特殊的功能：可以自定义增加插件 plugin；\n\nloader 是对某一类文件进行处理（css-loader sass-loader）\n\nplugin 是监听到 webpack 的某个过程（make）执行的一个操作（webpack插件系统的生命周期）","routePath":"/site/webpack/site/webpack/03-网易webpack配置解析","lang":"","toc":[{"text":"01 环境与目录","id":"01-环境与目录","depth":2,"charIndex":134},{"text":"02 常用 loader 和插件","id":"02-常用-loader-和插件","depth":2,"charIndex":788},{"text":"webpack.DefinePlugin","id":"webpackdefineplugin","depth":3,"charIndex":1067},{"text":"webpack.DllReferencePlugin","id":"webpackdllreferenceplugin","depth":3,"charIndex":1224},{"text":"MiniCssExtractPlugin","id":"minicssextractplugin","depth":3,"charIndex":1256},{"text":"ModuleConcatenationPlugin","id":"moduleconcatenationplugin","depth":3,"charIndex":1361},{"text":"webpack.HashedModuleIdsPlugin","id":"webpackhashedmoduleidsplugin","depth":3,"charIndex":1551},{"text":"webpack.NoEmitOnErrorsPlugin","id":"webpacknoemitonerrorsplugin","depth":3,"charIndex":1728},{"text":"webpack.providePlugin 提供第三方库","id":"webpackprovideplugin-提供第三方库","depth":3,"charIndex":1822},{"text":"copy-webpack-plugin 可以帮助拷贝内容","id":"copy-webpack-plugin-可以帮助拷贝内容","depth":3,"charIndex":1985},{"text":"03 优化打包的内容","id":"03-优化打包的内容","depth":2,"charIndex":2035},{"text":"DLL优化","id":"dll优化","depth":3,"charIndex":2049},{"text":"HappyPack","id":"happypack","depth":3,"charIndex":2271},{"text":"04 webpack 自定义插件","id":"04-webpack-自定义插件","depth":2,"charIndex":2407},{"text":"总结","id":"总结","depth":2,"charIndex":2690}],"domain":"","frontmatter":{},"version":""},{"id":40,"title":"webpack 构建分析","content":"#\n\n统计信息：字数 8363 阅读17分钟\n\ncreate time 2020-01-01\n\nlast modify time 2024-04-15\n\n【课程主题】从源码探究构建工具之手动实现webpack\n\n1、webpack基本使用：从模块谈起，到底什么是 webpack\n\n2、打包文件分析：分析 bundle.min.js 源码\n\n3、读完源码我们来写简易 webpack\n\n\nwebpack 在哪里使用#\n\ncreate-react-app、vue-cli 等脚手架已经打包了webpack工具，所以高级框架不会直接配置 webpack。\n\n我们如果不依赖 脚手架，需要直接开发一个前端项目，需要安装 webpack webpack-cli 等工具。\n\n为什么使用 webpack?\n\n因为浏览器不能直接读取 JS 的引用关系，不能识别 require 等语法，所以需要打包成一个文件，这样浏览器读取打包后的文件，可以正常运行。打包后是一个\nIIFE 立即执行函数，不同函数（模块）作为立即执行的参数传入。\n\n新建配置文件 webpack.config.js 包括：\n\n * entry 入口模块\n * module 一个模块即为一个文件，从 entry 模块递归找出所有的依赖模块\n * chunk 代码块，一个代码块由多个模块组合而成，用于代码的合并和分割\n * loader 模块转换器\n * plugin 插件\n * output 输出结果\n\n\n\n执行流程\n\n\n\n\nwebpack 的作用#\n\n依赖文件（模块）搜集；分析依赖关系\n\n内部实现 require 函数重写（浏览器不支持require）\n\n入口文件ID是0，按照顺序存入函数的参数，然后webpack依次require，根据不同的依赖关系，执行不同的函数\n\n\n官方解释#\n\nwebpack 是模块打包机：分析项目结构，找到 JS 模块和其他浏览器不能直接运行的扩展语言（Sass TS）并将其打包成合适的合适以供浏览器使用。\n\n构建：把源代码转换成线上可实行的CSS JS HTML代码\n\n\n具体作用#\n\n\n\n\nbundle.main.js 结构分析#\n\n首先把函数内部折叠，分析整理的结构和关系\n\n\n\n下面看传参，传参是一个数组，数组的每一项是一个模块，对应一个ID\n\n\n\n函数体，实现 require 转换\n\n\n\n\n自定义简易webpack#\n\n分析依赖关系前，首先把不同的JS代码读入，然后获取require部分，需要使用AST\n\nAST（抽象语法树）编译原理 babel 也会用到AST（astexplorer.net\n可以在线把字符串转换成AST）高级语言执行，需要编译器，编译成为二进制代码。如果写语言，需要会编译原理。\n\n词法分析（扫描）代码去掉注释，一个一个字母读代码，移除空白，分割成tokens。\n\n语法分析 解析器 把 tokens 一维数组，转换成树，监测语法错误，删除不完整的括号。\n\n如果直接读文件（结果是字符串），然后使用正则表达式处理依赖关系，模块很大就复杂了。所以使用AST构建文件结构。\n\n读取文件后，转换成AST，然后一步一步处理文件内容。\n\n新建项目和脚本 package.json\n\n\n\n\n\n下面是脚本 wypack.js\n\n\n\n这就是实现的简易 mypack","routePath":"/site/webpack/site/webpack/04-网易webpack编译原理分析","lang":"","toc":[{"text":"webpack 在哪里使用","id":"webpack-在哪里使用","depth":2,"charIndex":193},{"text":"webpack 的作用","id":"webpack-的作用","depth":2,"charIndex":642},{"text":"官方解释","id":"官方解释","depth":3,"charIndex":769},{"text":"具体作用","id":"具体作用","depth":3,"charIndex":885},{"text":"bundle.main.js 结构分析","id":"bundlemainjs-结构分析","depth":3,"charIndex":895},{"text":"自定义简易webpack","id":"自定义简易webpack","depth":2,"charIndex":999}],"domain":"","frontmatter":{},"version":""},{"id":41,"title":"为你揭秘webpack的高级技巧","content":"#\n\n统计信息：字数 2938 阅读6分钟\n\ncreate time 2020-01-01\n\nlast modify time 2024-04-15\n\n> 与之前课程重复，所以简单记录不同点。\n\nWebpack 不同等级的使用者：\n\n初级：可以通过CLI搭建基本的webpack并打包项目\n\n中级：可以更改一部分配置文件（loader plugin）\n\n高级：使用webpack解决项目的问题\n\n\n环境和目录#\n\n * 开发环境（dev）webpack.dev.conf.js\n * 测试环境（test）Test.js 打包测试文件，而不是打包业务代码\n * 生产环境（prod）\n\n对应不同的配置文件\n\n基本配置文件：\n\nwebpack.base.conf.js (主要是loaders)\n\nvue-loader\n\nbabel-loader\n\nurl-loader(handle image file jpg)\n\nurl-loader(handle meida file mp4)\n\n在不同环境中，把基本配置和特定环境的配置项目 merge 成一个配置文件。\n\n例如：生产环境下执行下面的操作\n\n\n\nJS内部使用 webpack.base.conf.js and webpack.prod.conf.js 合并文件，从 config 中拿出 index.js\nand pro.env 中的环境变量，然后进行生产环境下面的打包。\n\n\n\n\n常用 loader 和 plugin#\n\n * webpack.DefinePlugin 在打包阶段定义全局变量\n * webpack.HashedMouduleIdsPlugin 保持 module.id 稳定，第三方库避免重复打包\n * webpack.NoEmitOnErrorsPlugin 屏蔽打包时的错误，浏览器可以显示界面\n * webpack.ProvidePlugin 提供库\n * copy-webpack-plugin 帮助手动拷贝内容（未打包的字体图标或者图片）\n\n这些在前面的课程中介绍过，这里简单说一下第一个\n\n\n\n插件都放在 plugins 数组中，创建一个插件的实例","routePath":"/site/webpack/site/webpack/05-网易webpack的高级技巧","lang":"","toc":[{"text":"环境和目录","id":"环境和目录","depth":2,"charIndex":198},{"text":"常用 loader 和 plugin","id":"常用-loader-和-plugin","depth":2,"charIndex":618}],"domain":"","frontmatter":{},"version":""},{"id":42,"title":"Webpack 打包工具简单使用","content":"#\n\n统计信息：字数 5328 阅读11分钟\n\ncreate time 2019-01-01\n\nlast modify time 2024-04-15\n\n网易云课堂，注意：课程 2017年出版，是 webpack 版本 3，出品人水平一般，不是大公司。课程仅作为简单复习，了解概念等即可。\n\n课程链接：https://study.163.com/course/courseMain.htm?courseId=1004724031&_trace_c_p_\nk2_=1104e3d9ab4a4d969e7b387fb5863a48\n\n现在是 2024年，webpack\n具体细节参考官方文档：https://webpack.docschina.org/guides/getting-started/\n\n\n课时1 详细介绍webpack工具的相关基础知识#\n\n为什么使用 webpack? 这需要从网页加载说起。一个界面中，如果 HTML 中有多个 style 和 script\n标签，那么需要进行多次网络请求，性能较差。我们可以把多个 JS 或者 CSS 文件打包成一个 CSS 或者 JS\n文件，这样前端只需要请求1次即可，性能得到优化。\n\n同时，打包过程中，根据不同的 loader，例如 uglyfy 可以把不需要的部分删除，或者丑化代码，减少代码量，减少网络请求时间，同样性能得到优化。\n\nWebpack 定义: 是一个前端资源加载、打包工具，将根据模块的依赖关系，进行静态分析，并依据规则生成对应的静态资源。（可以把一个图状的依赖结构，包括\ndependencies）打包成简单的几个 JS 文件（static assets）\n\n\n课时2 搭建webpack的打包的开发环境#\n\n在 3 版本中，全局安装 webpack\n\n\n\n这样就把 test.js 打包成 bundle.js (如果是配置文件，需要设置一个或者多个入口文件进行打包)\n\n不同 JS 文件内部互相依赖（module.exports = {}, require('path')）\n\nwebpack 进行语法分析后，可以获取不同文件的依赖关系。\n\n\n课时3 打包多个相互依赖的js文件过程#\n\n==可以通过模块的导入导出功能，创建不同模块的依赖关系树，然后进行打包。==\n\n一个模块（文件）可以 export 很多变量，import { } 需要使用大括号\n\n一个模块只能 export default 一个变量（类），import 后面直接加这个类名即可\n\nexport 和 export default 的区别，参考\nhttps://www.cnblogs.com/fanyanzhao/p/10298543.html\n\n\n课时4 利用工具打包 css 文件#\n\ncss 之间没有明显的依赖关系，所以通过 loader 进行加载打包\n\n\n\ncss-loader 可以把 js 中import xxx.css 这样的依赖关系整理出来\n\nstyle-loader 可以把 HTML 中的 style 标签整理出来\n\n还有其他的 sass less loader 对应相关的样式文件\n\n通常在 webpack 配置文件中设置，需要考虑 loader 的顺序（从后向前执行），否则无法生效\n\n\n\n\n课时5 如何打包样式文件#\n\n单文件，可以直接在 css require 中使用 loader 打包，实际不会这样使用\n\n\n\n实际上需要在配置文件中批量处理，使用正则表达式匹配文件，然后加入对应的 loader\n\n\n\n服务端环境\n\nwebpack 是打包工具\n\n本地需要一个服务器，就是 webpack-dev-server 把打包的文件放在本地的服务器上\n\n早期的代码，需要把 webpack 编译和 webpack-dev-server 运行服务器分别写成两个命令\n\n","routePath":"/site/webpack/site/webpack/06-网易 webpack 打包工具使用","lang":"","toc":[{"text":"课时1 详细介绍webpack工具的相关基础知识","id":"课时1-详细介绍webpack工具的相关基础知识","depth":3,"charIndex":349},{"text":"课时2 搭建webpack的打包的开发环境","id":"课时2-搭建webpack的打包的开发环境","depth":3,"charIndex":718},{"text":"课时3 打包多个相互依赖的js文件过程","id":"课时3-打包多个相互依赖的js文件过程","depth":3,"charIndex":910},{"text":"课时4 利用工具打包 css 文件","id":"课时4-利用工具打包-css-文件","depth":3,"charIndex":1149},{"text":"课时5 如何打包样式文件","id":"课时5-如何打包样式文件","depth":3,"charIndex":1382}],"domain":"","frontmatter":{},"version":""},{"id":43,"title":"webpack 起步","content":"- +","routePath":"/site/webpack/site/webpack/07-webpack 官方起步","lang":"","toc":[{"text":"基本安装","id":"基本安装","depth":2,"charIndex":-1},{"text":"创建一个 bundle","id":"创建一个-bundle","depth":2,"charIndex":-1},{"text":"模块","id":"模块","depth":2,"charIndex":-1},{"text":"使用一个配置文件","id":"使用一个配置文件","depth":2,"charIndex":-1},{"text":"npm scripts","id":"npm-scripts","depth":2,"charIndex":-1},{"text":"结论","id":"结论","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":44,"title":"webpack5 和 webpack4 的区别有哪些","content":"#\n\n统计信息：字数 9773 阅读20分钟\n\n原文链接：https://juejin.cn/post/6990869970385109005\n\n1、Tree Shaking#\n\n作用： 如果我们的项目中引入了 lodash 包，但是我只有了其中的一个方法。其他没有用到的方法是不是冗余的？此时 tree-shaking\n就可以把没有用的那些东西剔除掉，来减少最终的bundle体积。\n\n> usedExports : true, 标记没有用的叶子\n\n> minimize: true, 摇掉那些没有用的叶子\n\n\n\n由于 tree shaking 只支持 esmodule ，如果你打包出来的是 commonjs，此时 tree-shaking 就失效了。不过当前大家都用的是\nvue，react 等框架，他们都是用 babel-loader 编译，以下配置就能够保证他一定是 esmodule\n\n\n\nwebpack5的 mode=“production” 自动开启 tree-shaking。\n\n2、压缩代码#\n\n1.webpack4#\n\n> webpack4 上需要下载安装 terser-webpack-plugin 插件，并且需要以下配置：\n\n\n\n2.webpack5#\n\n内部本身就自带 js 压缩功能，他内置了 terser-webpack-plugin 插件，我们不用再下载安装。而且在 mode=“production”\n的时候会自动开启 js 压缩功能。\n\n> 如果你要在开发环境使用，就用下面：\n\n\n\n3.js 压缩失效问题#\n\n当你下载 optimize-css-assets-webpack-plugin ，执行 css 压缩以后，你会发现 webpack5 默认的 js\n压缩功能失效了。先说 optimize-css-assets-webpack-plugin 的配置：\n\n> npm install optimize-css-assets-webpack-plugin -D\n\n\n\n> 此时的压缩插件 optimize-css-assets-webpack-plugin 可以配置到 plugins 里面去，也可以如图配置到到\n> optimization 里面。区别如下：\n\n配置到 plugins 中，那么这个插件在任何情况下都会工作。 而配置在 optimization 表示只有 minimize 为 true 的时候才能工作。\n\n> 当安装 optimize-css-assets-webpack-plugin 以后你去打包会发现原来可以压缩的 js\n> 文件，现在不能压缩了。原因是你指定的压缩器是\n\noptimize-css-assets-webpack-plugin 导致默认的 terser-webpack-plugin 就会失效。解决办法如下：\n\n> npm install terser-webpack-plugin -D\n\n\n\n即便在 webpack5 中，你也要像 webpack4 中一样使用 js 压缩。\n\n4.注意事项#\n\n在webpack5里面使用 optimize-css-assets-webpack-plugin 又是会报错，因为官方已经打算要废除了，请使用替换方案：\n\n> npm i css-assets-webpack-plugin -D\n\n3、合并模块#\n\n> 普通打包只是将一个模块最终放到一个单独的立即执行函数中，如果你有很多模块，那么就有很多立即执行函数。concatenateModules\n> 可以要所有的模块都合并到一个函数里面去。\n\noptimization.concatenateModules = true\n\n配置如下：\n\n\n\n此时配合 tree-shaking 你会发现打包的体积会减小很多。\n\n4、副作用 sideEffects#\n\n> webpack4 新增了一个 sideEffects 的功能，容许我们通过配置来标识我们的代码是否有副作用。\n\n> 这个特性只有在开发 npm 包的时候用到\n\n副作用的解释： 在utils文件夹下面有index.js文件，用于系统导出utils里面其他文件，作用就是写的少， 不管 utils\n里面有多少方法，我都只需要引入 utils 即可。\n\n\n\n此时，如果文件 getBBB 在外界没有用到，而 tree-shaking 又不能把它摇掉咋办？这个 getBBB 就是副作用。你或许要问\ntree-shaking 为什么不能奈何他？原因就是：他在 utils/index.js 里面使用了。只能开启副作用特性。如下：\n\n\n\n副作用开启：\n\n> (1)optimization.sideEffects = true 开启副作用功能\n\n> (2)package.json 中设置 sideEffects : false 标记所有模块无副作用\n\n说明： webpack 打包前都会检查项目所属的 package.json 文件中的 sideEffects\n标识，如果没有副作用，那些没有用到的模块就不需要打包，反之亦然。此时，在webpack.config.js 里面开启 sideEffects。\n\n5、webpack 缓存#\n\n1.webpack4 缓存配置#\n\n支持缓存在内存中\n\n> npm install hard-source-webpack-plugin -D\n\n\n\n2. webpack5 缓存配置#\n\nwebpack5 内部内置了 cache 缓存机制。直接配置即可。\n\n> cache 会在开发模式下被设置成 type： memory 而且会在生产模式把cache 给禁用掉。\n\n\n\n> type 的可选值为： memory 使用内容缓存，filesystem 使用文件缓存。\n\n> 当 type=filesystem的时候设置cacheDirectory才生效。用于设置你需要的东西缓存放在哪里？\n\n6、对loader的优化#\n\n> webpack 4 加载资源需要用不同的 loader\n\n * raw-loader 将文件导入为字符串\n * url-loader 将文件作为 data url 内联到 bundle文件中\n * file-loader 将文件发送到输出目录中\n\n\n\n> webpack5 的资源模块类型替换 loader\n\n * asset/resource 替换 file-loader(发送单独文件)\n * asset/inline 替换 url-loader （导出 url）\n * asset/source 替换 raw-loader（导出源代码）\n * asset\n\n\n\nwebpack5\n\n7、启动服务的差别#\n\n1.webpack4 启动服务#\n\n通过 webpack-dev-server 启动服务\n\n2.webpack5 启动服务#\n\n内置使用 webpack serve 启动，但是他的日志不是很好，所以一般都加都喜欢用 webpack-dev-server 优化。\n\n8. 模块联邦（微前端）#\n\n> webpack 可以实现 应用程序和应用程序之间的引用。\n\n9.devtool的差别#\n\nsourceMap需要在 webpack.config.js里面直接配置 devtool 就可以实现了。而\ndevtool有很多个选项值，不同的选项值，不同的选项产生的 .map 文件不同，打包速度不同。\n\n一般情况下，我们一般在开发环境配置用“cheap-eval-module-source-map”，在生产环境用‘none’。\n\ndevtool在webpack4和webpack5上也是有区别的\n\n> v4: devtool: 'cheap-eval-module-source-map'\n\n> v5: devtool: 'eval-cheap-module-source-map'\n\n10.热更新差别#\n\n> webpack4设置\n\n\n\n> webpack5 设置\n\n如果你使用的是bable6，按照上述设置，你会发现热更新无效，需要添加配置：\n\n\n\n当前最新版的babel里面的 babel-loader已经帮我们处理的热更新失效的问题。所以不必担心，直接使用即可。\n\n如果你引入 mini-css-extract-plugin 以后你会发现 样式的热更新也会失效。\n\n只能在开发环境使用style-loader，而在生产环境用MinicssExtractPlugin.loader。 如下：\n\n\n\n11、使用 webpack-merge 的差别#\n\n> webpack4 导入\n\nconst merge = require('webpack-merge);\n\n> webpack 5 导入\n\nconst {merge} = require('webpack-merge');\n\n12、 使用 copy-webpack-plugin 的差别\n\n\n\nwebpack5 支持的新版本里面需要配置的更加清楚。","routePath":"/site/webpack/site/webpack/08-webpack5 和 webpack4 的区别有哪些","lang":"","toc":[{"text":"1、Tree Shaking","id":"1tree-shaking","depth":4,"charIndex":72},{"text":"2、压缩代码","id":"2压缩代码","depth":4,"charIndex":448},{"text":"3、合并模块","id":"3合并模块","depth":4,"charIndex":1408},{"text":"4、副作用 sideEffects","id":"4副作用-sideeffects","depth":4,"charIndex":1596},{"text":"5、webpack 缓存","id":"5webpack-缓存","depth":4,"charIndex":2168},{"text":"6、对loader的优化","id":"6对loader的优化","depth":4,"charIndex":2478},{"text":"7、启动服务的差别","id":"7启动服务的差别","depth":4,"charIndex":2789},{"text":"8. 模块联邦（微前端）","id":"8-模块联邦微前端","depth":4,"charIndex":2933},{"text":"9.devtool的差别","id":"9devtool的差别","depth":4,"charIndex":2980},{"text":"10.热更新差别","id":"10热更新差别","depth":4,"charIndex":3291},{"text":"11、使用 webpack-merge 的差别","id":"11使用-webpack-merge-的差别","depth":4,"charIndex":3550}],"domain":"","frontmatter":{},"version":""},{"id":45,"title":"package","content":"#\n\n统计信息：字数 3848 阅读8分钟\n\nwebpack babel package.json 配置\n\n\npackage.json#\n\n\n1、创建 package.json#\n\n\n\n\n2、设置包#\n\n\n\n在一个字段中可以运行另一个字段\n\nbin: 用于存放内部命令对应的可执行文件的位置。如果一部分包是全局设置，那么需要找到全局的文件位置。\n\n\n\nmyCommand 对应着可执行文件是./bin/index.js。\n\n安装包时，会在node_modules/.bin 下面建立链接。\n\nbin字段在项目中使用不是很多\n\nMain: 指定入口文件，默认是根目录下的index.js\n\n\n\n入口文件设置成 index.js\n\nconfig 设置环境变量\n\n\n\n\n\ndependencies 项目运行依赖的包（run）\n\ndevDependencies 项目开发依赖的包（build）\n\n\nwebpack#\n\n常见的webpack配置\n\n\n\n入口函数 entry#\n\nwebpack 应该使用什么模块；进入入口起点后，webpack 会找出依赖的模块或者库。通常使用对象写法配置 entry。\n\n\n\n出口函数 output#\n\n告诉 webpack 输出包的位置（bundles）以及输出文件的命名；默认路径是 ./dist 。这里表示在 ./dist 下生成 main.min.js.\n\n\n\n模块 module#\n\nwebpack 通过loader支持各种语言和预处理器的编写模块。配置loader来支持其他文件（例如css/image，支持 jsx或者 vue文件）。\n\n使用 react jsx babel less 等需要配置不同的插件。\n\n例如 ES6 babel\n\nBabel-preset-react 对应react中的ES6\n\nbabel 在不同浏览器支持不同，需要转义， babel-preset-react\n\n\n\n\n\n插件 plugins#\n\n插件是webpack的核心功能，可以设置各种高级配置。\n\nHtml-webpack-plugin 插件：在 webpack构建中，在对应的目录下生成 html 文件，可以正确的引入 webpack 生成的文件。\n\n外部扩展 externals#\n\nReact react-dom 这部分内容不需要包含在项目中。","routePath":"/site/webpack/site/webpack/09-webpack主要概念","lang":"","toc":[{"text":"package.json","id":"packagejson","depth":2,"charIndex":54},{"text":"1、创建 package.json","id":"1创建-packagejson","depth":3,"charIndex":70},{"text":"2、设置包","id":"2设置包","depth":3,"charIndex":93},{"text":"webpack","id":"webpack","depth":2,"charIndex":394},{"text":"入口函数 entry","id":"入口函数-entry","depth":4,"charIndex":420},{"text":"出口函数 output","id":"出口函数-output","depth":4,"charIndex":499},{"text":"模块 module","id":"模块-module","depth":4,"charIndex":596},{"text":"插件 plugins","id":"插件-plugins","depth":4,"charIndex":818},{"text":"外部扩展 externals","id":"外部扩展-externals","depth":4,"charIndex":938}],"domain":"","frontmatter":{},"version":""},{"id":46,"title":"带你深度解锁Webpack系列(基础篇) 01","content":"#\n\n统计信息：字数 33009 阅读67分钟\n\ncreate time 2024-04-12\n\nlast modify time 2024-04-12\n\n掘金\n\n无名之苝\n\n2020-03-0947,221阅读15分钟\n\n三篇长文带你解锁 Webpack ，希望读完这三篇文章，你能够对 webpack 的各项配置有一个更为清晰的认识。\n\n\n1.webpack 是什么？#\n\nwebpack 是一个现代 JavaScript 应用程序的静态模块打包器，当 webpack\n处理应用程序时，会递归构建一个依赖关系图，其中包含应用程序需要的每个模块，然后将这些模块打包成一个或多个 bundle。\n\n\n2.webpack 的核心概念#\n\n * entry: 入口\n * output: 输出\n * loader: 模块转换器，用于把模块原内容按照需求转换成新内容\n * 插件(plugins): 扩展插件，在webpack构建流程中的特定时机注入扩展逻辑来改变构建结果或做你想要做的事情\n\n\n3.初始化项目#\n\n新建一个文件夹，如: webpack-first\n(当然，你可以使用任意一个你喜欢的项目名)。推荐大家参考本文一步一步进行配置，不要总是在网上找什么最佳配置，你掌握了webpack之后，根据自己的需求配置出来的\n，就是最佳配置。\n\n本篇文章对应的项目地址(编写本文时使用): github.com/YvetteLau/w…\n\n使用 npm init -y 进行初始化(也可以使用 yarn)。\n\n要使用 webpack，那么必然需要安装 webpack、webpack-cli:\n\n\n\n鉴于前端技术变更迅速，祭出本篇文章基于 webpack 的版本号:\n\n\n\n从 wepack V4.0.0 开始， webpack 是开箱即用的，在不引入任何配置文件的情况下就可以使用。\n\n新建 src/index.js 文件，我们在文件中随便写点什么:\n\n\n\n使用 npx webpack --mode=development 进行构建，默认是 production 模式，我们为了更清楚得查看打包后的代码，使用\ndevelopment 模式。\n\n可以看到项目下多了个 dist 目录，里面有一个打包出来的文件 main.js。\n\nwebpack 有默认的配置，如默认的入口文件是 ./src，默认打包到dist/main.js。更多的默认配置可以查看:\nnode_modules/webpack/lib/WebpackOptionsDefaulter.js。\n\n查看 dist/main.js 文件，可以看到，src/index.js 并没有被转义为低版本的代码，这显然不是我们想要的。\n\n\n\n\n4.将JS转义为低版本#\n\n前面我们说了 webpack 的四个核心概念，其中之一就是 loader，loader 用于对源代码进行转换，这正是我们现在所需要的。\n\n将JS代码向低版本转换，我们需要使用 babel-loader。\n\nbabel-loader#\n\n首先安装一下 babel-loader\n\n\n\n此外，我们还需要配置 babel，为此我们安装一下以下依赖:\n\n\n\n对babel7配置不熟悉的小伙伴，可以阅读一下这篇文章: 不可错过的 Babel7 知识\n\n新建 webpack.config.js，如下:\n\n\n\n建议给 loader 指定 include 或是 exclude，指定其中一个即可，因为 node_modules\n目录通常不需要我们去编译，排除后，有效提升编译效率。\n\n这里，我们可以在 .babelrc 中编写 babel 的配置，也可以在 webpack.config.js 中进行配置。\n\n创建一个 .babelrc#\n\n配置如下：\n\n\n\n现在，我们重新执行 npx webpack --mode=development，查看 dist/main.js，会发现已经被编译成了低版本的JS代码。\n\n在webpack中配置 babel#\n\n\n\n这里有几点需要说明：\n\n * loader 需要配置在 module.rules 中，rules 是一个数组。\n * loader 的格式为:\n\n\n\n或者也可以像下面这样:\n\n\n\ntest 字段是匹配规则，针对符合规则的文件进行处理。\n\nuse 字段有几种写法\n\n * 可以是一个字符串，例如上面的 use: 'babel-loader'\n * use 字段可以是一个数组，例如处理CSS文件是，use: ['style-loader', 'css-loader']\n * use 数组的每一项既可以是字符串也可以是一个对象，当我们需要在webpack 的配置文件中对 loader\n   进行配置，就需要将其编写为一个对象，并且在此对象的 options 字段中进行配置，如：\n\n\n\n上面我们说了如何将JS的代码编译成向下兼容的代码，当然你可以还需要一些其它的 babel 的插件和预设，例如\n@babel/preset-react，@babel/plugin-proposal-optional-chaining 等，不过，babel\n的配置并非本文的重点，我们继续往下。\n\n不要说细心的小伙伴了，即使是粗心的小伙伴肯定也发现了，我们在使用 webpack 进行打包的时候，一直运行的都是 npx webpack\n--mode=development 是否可以将 mode 配置在 webpack.config.js 中呢？显然是可以的。\n\n\n5.mode#\n\n将 mode 增加到 webpack.config.js 中:\n\n\n\nmode 配置项，告知 webpack 使用相应模式的内置优化。\n\nmode 配置项，支持以下两个配置:\n\n * development：将 process.env.NODE_ENV 的值设置为 development，启用 NamedChunksPlugin 和\n   NamedModulesPlugin\n * production：将 process.env.NODE_ENV 的值设置为 production，启用\n   FlagDependencyUsagePlugin, FlagIncludedChunksPlugin,\n   ModuleConcatenationPlugin, NoEmitOnErrorsPlugin, OccurrenceOrderPlugin,\n   SideEffectsFlagPlugin 和 UglifyJsPlugin\n\n现在，我们直接使用 npx webpack 进行编译即可。\n\n\n6.在浏览器中查看页面#\n\n搞了这么久，还不能在浏览器中查看页面，这显然不能忍！\n\n查看页面，难免就需要 html 文件，有小伙伴可能知道，有时我们会指定打包文件中带有 hash，那么每次生成的 js\n文件名会有所不同，总不能让我们每次都人工去修改 html，这样不是显得我们很蠢嘛~\n\n我们可以使用 html-webpack-plugin 插件来帮助我们完成这些事情。\n\n首先，安装一下插件:\n\n\n\n新建 public 目录，并在其中新建一个 index.html 文件( 文件内容使用 html:5 快捷生成即可)\n\n修改 webpack.config.js 文件。\n\n\n\n此时执行 npx webpack，可以看到 dist 目录下新增了 index.html 文件，并且其中自动插入了 <% } %>\n\nprocess.env 中默认并没有 NODE_ENV，这里配置下我们的 package.json 的 scripts.\n\n为了兼容Windows和Mac，我们先安装一下 cross-env:\n\n\n\n然后我们运行 npm run dev 和 运行 npm run build ，对比下 dist/index.html ，可以看到 npm run\nbuild，生成的 index.html 文件中引入了对应的 css 和 js。并且对应的 title 内容也不一样。\n\n你说这里是不是非得是用 NODE_ENV 去判断？当然不是咯，你写 aaa=1 ，aaa=2 都行（当然啦，webpack.config.js 和\nscripts 都需要进行相应修改），但是可能会被后面接手的人打死。\n\n更多html-webpack-plugin配置项\n\n如何在浏览器中实时展示效果#\n\n说了这么多，到现在还没能在浏览器中实时查看效果，是不是已经有点捉急了，先看一下如何实时查看效果吧，不然都不知道自己配得对不对。\n\n话不多说，先装依赖:\n\n\n\n修改下咱们的 package.json 文件的 scripts：\n\n\n\n在控制台执行 npm run dev，启动正常，页面上啥也没有，修改下我们的JS代码，往页面中增加点内容，正常刷新(也就是说不需要进行任何配置就可以使用了)。\n\nExcuse me。怪我平时不认真咯，每次都乖乖的配个 contentBase，原来根本不需要配，带着疑问，我又去搜寻了一番。\n\n原来在配置了 html-webpack-plugin 的情况下， contentBase 不会起任何作用，也就是说我以前都是白配了，这是一个悲伤的故事。\n\n不过呢，我们还是可以在 webpack.config.js 中进行 webpack-dev-server\n的其它配置，例如指定端口号，设置浏览器控制台消息，是否压缩等等:\n\n\n\n * 启用 quiet 后，除了初始启动信息之外的任何内容都不会被打印到控制台。这也意味着来自 webpack 的错误或警告在控制台不可见 ————\n   我是不会开启这个的，看不到错误日志，还搞个锤子\n\n * stats: \"errors-only\" ， 终端中仅打印出 error，注意当启用了 quiet 或者是 noInfo 时，此属性不起作用。 —————\n   这个属性个人觉得很有用，尤其是我们启用了 eslint 或者使用 TS进行开发的时候，太多的编译信息在终端中，会干扰到我们。\n\n * 启用 overlay 后，当编译出错时，会在浏览器窗口全屏输出错误，默认是关闭的。\n\n\n\n * clientLogLevel:\n   当使用内联模式时，在浏览器的控制台将显示消息，如：在重新加载之前，在一个错误之前，或者模块热替换启用时。如果你不喜欢看这些信息，可以将其设置为\n   silent (none 即将被移除)。\n\n\n\n本篇文章不是为了细说 webpack-dev-server 的配置，所以这里就不多说了。关于 webpack-dev-server 更多的配置可以点击查看。\n\n细心的小伙伴可能发现了一个小问题，我们在src/index.js中增加一句 console.log('aaa')：\n\n\n\n然后通过 npm run dev 查看效果，会发现：\n\n\n\n这显然不是我们源码中对应的行号，点进去的话，会发现代码是被编译后的，我当前的代码非常简单，还能看出来，项目代码复杂后，“亲妈”看编译后都费劲，这不利于我们开发调\n试，不是我们想要的，我们肯定还是希望能够直接对应到源码的。\n\n\n7.devtool#\n\ndevtool 中的一些设置，可以帮助我们将编译后的代码映射回原始源代码。不同的值会明显影响到构建和重新构建的速度。\n\n对我而言，能够定位到源码的行即可，因此，综合构建速度，在开发模式下，我设置的 devtool 的值是 cheap-module-eval-source-map。\n\n\n\n生产环境可以使用 none 或者是 source-map，使用 source-map 最终会单独打包出一个 .map 文件，我们可以根据报错信息和此 map\n文件，进行错误解析，定位到源代码。\n\nsource-map 和 hidden-source-map 都会打包生成单独的 .map 文件，区别在于，source-map\n会在打包出的js文件中增加一个引用注释，以便开发工具知道在哪里可以找到它。hidden-source-map 则不会在打包的js中增加引用注释。\n\n但是我们一般不会直接将 .map 文件部署到CDN，因为会直接映射到源码，更希望将.map\n文件传到错误解析系统，然后根据上报的错误信息，直接解析到出错的源码位置。\n\n还可以设置其他的devtool值，你可以使用不同的值，构建对比差异。\n\n现在我们已经说了 html、js 了，并且也可以在浏览器中实时看到效果了，现在就不得不说页面开发三巨头之一的 css 。\n\n\n8.如何处理样式文件呢#\n\nwebpack 不能直接处理 css，需要借助 loader。如果是 .css，我们需要的 loader 通常有：\nstyle-loader、css-loader，考虑到兼容性问题，还需要 postcss-loader，而如果是 less 或者是 sass 的话，还需要\nless-loader 和 sass-loader，这里配置一下 less 和 css 文件(sass 的话，使用 sass-loader即可):\n\n先安装一下需要使用的依赖:\n\n\n\n测试一下，新建一个 less 文件，src/index.less:\n\n\n\n再在入口文件中引入此 less:\n\n\n\n我们修改了配置文件，重新启动一下服务: npm run dev。可以看到页面的背景色变成了红色。\n\nOK，我们简单说一下上面的配置：\n\n * style-loader 动态创建 style 标签，将 css 插入到 head 中.\n * css-loader 负责处理 @import 等语句。\n * postcss-loader 和 autoprefixer，自动生成浏览器兼容性前缀 —— 2020了，应该没人去自己徒手去写浏览器前缀了吧\n * less-loader 负责处理编译 .less 文件,将其转为 css\n\n这里，我们之间在 webpack.config.js 写了 autoprefixer 需要兼容的浏览器，仅是为了方便展示。推荐大家在根目录下创建\n.browserslistrc，将对应的规则写在此文件中，除了 autoprefixer\n使用外，@babel/preset-env、stylelint、eslint-plugin-conmpat 等都可以共用。\n\n注意：\n\n\n\n当然，loader 其实还有一个参数，可以修改优先级，enforce 参数，其值可以为: pre(优先执行) 或 post (滞后执行)。\n\n现在，我们已经可以处理 .less 文件啦，.css 文件只需要修改匹配规则，删除 less-loader 即可。\n\n现在的一切看起来都很完美，但是假设我们的文件中使用了本地的图片，例如:\n\n\n\n你就会发现，报错啦啦啦，那么我们要怎么处理图片或是本地的一些其它资源文件呢。不用想，肯定又需要 loader 出马了。\n\n\n9.图片/字体文件处理#\n\n我们可以使用 url-loader 或者 file-loader 来处理本地的资源文件。url-loader 和 file-loader 的功能类似，但是\nurl-loader 可以指定在文件大小小于指定的限制时，返回 DataURL，因此，个人会优先选择使用 url-loader。\n\n首先安装依赖:\n\n\n\n\n\n安装 url-loader 的时候，控制台会提示你，还需要安装下 file-loader，听人家的话安装下就行(新版 npm 不会自动安装\npeerDependencies)：\n\n\n\n在 webpack.config.js 中进行配置：\n\n\n\n此处设置 limit 的值大小为 10240，即资源大小小于 10K 时，将资源转换为 base64，超过 10K，将图片拷贝到 dist\n目录。esModule 设置为 false，否则， 会出现\n\n将资源转换为 base64 可以减少网络请求次数，但是 base64 数据较大，如果太多的资源是 base64，会导致加载变慢，因此设置 limit\n值时，需要二者兼顾。\n\n默认情况下，生成的文件的文件名就是文件内容的 MD5 哈希值并会保留所引用资源的原始扩展名，例如我上面的图片(thor.jpeg)对应的文件名如下：\n\n\n\n当然，你也可以通过 options 参数进行修改。\n\n\n\n重新编译，在浏览器中审查元素，可以看到图片名变成了: thor_a5f7c0.jpeg。\n\n当本地资源较多时，我们有时会希望它们能打包在一个文件夹下，这也很简单，我们只需要在 url-loader 的 options 中指定 outpath，如:\noutputPath: 'assets'，构建出的目录如下:\n\n\n\n更多的 url-loader 配置可以查看\n\n到了这里，有点岁月静好的感觉了。\n\n\n\n不过还没完，如果你在 public/index.html 文件中，使用本地的图片，例如，我们修改一下 public/index.html：\n\n\n\n重启本地服务，虽然，控制台不会报错，但是你会发现，浏览器中根本加载不出这张图片，Why？因为构建之后，通过相对路径压根找不着这张图片呀。\n\nHow？怎么解决呢？\n\n\n10.处理 html 中的本地图片#\n\n安装 html-withimg-loader 来解决咯。\n\n\n\n修改 webpack.config.js：\n\n\n\n然后在我们的 html 中引入一张文件测试一下（图片地址自己写咯，这里只是示意）:\n\n\n\n重启本地服务，图片并没能加载，审查元素的话，会发现图片的地址显示的是 {\"default\":\"assets/thor_a5f7c0.jpeg\"}。\n\n\n\n我当前 file-loader 的版本是 5.0.2，5版本之后，需要增加 esModule 属性：\n\n\n\n再重启本地服务，就搞定啦。\n\n话说使用 html-withimg-loader 处理图片之后，html 中就不能使用 vm, ejs 的模板了，如果想继续在 html 中使用 <%\nif(htmlWebpackPlugin.options.config.header) { %>\n这样的语法，但是呢，又希望能使用本地图片，可不可以？鱼和熊掌都想要，虽然很多时候，能吃个鱼就不错了，但是这里是可以的哦，像下面这样编写图片的地址，并且删除htm\nl-withimg-loader的配置即可。\n\n\n\n图片加载OK啦，并且 <% %> 语法也可以正常使用，吼吼吼~~~\n\n虽然，webpack 的默认配置很好用，但是有的时候，我们会有一些其它需要啦，例如，我们不止一个入口文件，这时候，该怎么办呢？\n\n\n11.入口配置#\n\n入口的字段为: entry\n\n\n\nentry 的值可以是一个字符串，一个数组或是一个对象。\n\n字符串的情况无需多说，就是以对应的文件为入口。\n\n为数组时，表示有“多个主入口”，想要多个依赖文件一起注入时，会这样配置。例如:\n\n\n\npolyfills.js 文件中可能只是简单的引入了一些 polyfill，例如 babel-polyfill，whatwg-fetch\n等，需要在最前面被引入（我在 webpack2 时这样配置过）。\n\n那什么时候是对象呢？不要捉急，后面将多页配置的时候，会说到。\n\n\n12.出口配置#\n\n配置 output 选项可以控制 webpack 如何输出编译文件。\n\n\n\n例如，你最终编译出来的代码部署在 CDN 上，资源的地址为: 'https://AAA/BBB/YourProject/XXX'，那么可以将生产的\npublicPath 配置为: //AAA/BBB/。\n\n编译时，可以不配置，或者配置为 /。可以在我们之前提及的 config.js 中指定 publicPath（config.js 中区分了 dev 和\npublic）， 当然还可以区分不同的环境指定配置文件来设置，或者是根据 isDev 字段来设置。\n\n除此之外呢，考虑到CDN缓存的问题，我们一般会给文件名加上 hash.\n\n\n\n如果你觉得 hash 串太长的话，还可以指定长度，例如 bundle.[hash:6].js。使用 npm run build 打包看看吧。\n\n问题出现啦，每次文件修改后，重新打包，导致 dist 目录下的文件越来越多。要是每次打包前，都先清空一下目录就好啦。可不可以做到呢？必须可以！\n\n\n13.每次打包前清空dist目录#\n\n反正我是懒得手动去清理的，只要你足够懒，你总是会找到好办法的，懒人推动科技进步。这里，我们需要插件: clean-webpack-plugin\n\n安装依赖:\n\n\n\n以前，clean-webpack-plugin 是默认导出的，现在不是，所以引用的时候，需要注意一下。另外，现在构造函数接受的参数是一个对象，可缺省。\n\n\n\n现在你再修改文件，重现构建，生成的hash值和之前dist中的不一样，但是因为每次 clean-webpack-plugin 都会帮我们先清空一波 dist\n目录，所以不会出现太多文件，傻傻分不清楚究竟哪个是新生成文件的情况。\n\n希望dist目录下某个文件夹不被清空#\n\n不过呢，有些时候，我们并不希望整个 dist 目录都被清空，比如，我们不希望，每次打包的时候，都删除 dll 目录，以及 dll\n目录下的文件或子目录，该怎么办呢？\n\nclean-webpack-plugin 为我们提供了参数 cleanOnceBeforeBuildPatterns。\n\n\n\n此外，clean-webpack-plugin 还有一些其它的配置，不过我使用的不多，大家可以查看clean-webpack-plugin\n\n至此，我们算是完成了一个基础配置。但是这不够完美，或者说有些时候，我们还会有一些其它的需求。下一篇关于webpack配置的文章会介绍一些其它的情况。\n\n> 参考资料\n\n * Peer Dependencies\n * html-webpack-plugin\n * webpack中文文档\n\n\n最后#\n\n如果本文对你有帮助的话，给本文点个赞吧r\n\n看得不过瘾？\n\n带你深度解锁Webpack系列(进阶篇) 带你深度解锁Webpack系列(优化篇)\n\n作者：无名之苝 链接：https://juejin.cn/post/6844904079219490830 来源：稀土掘金\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","routePath":"/site/webpack/site/webpack/10-深度解锁Webpack系列(基础篇) 01","lang":"","toc":[{"text":"1.webpack 是什么？","id":"1webpack-是什么","depth":3,"charIndex":171},{"text":"2.webpack 的核心概念","id":"2webpack-的核心概念","depth":3,"charIndex":299},{"text":"3.初始化项目","id":"3初始化项目","depth":3,"charIndex":444},{"text":"4.将JS转义为低版本","id":"4将js转义为低版本","depth":3,"charIndex":1146},{"text":"babel-loader","id":"babel-loader","depth":4,"charIndex":1263},{"text":"创建一个 .babelrc","id":"创建一个-babelrc","depth":4,"charIndex":1558},{"text":"在webpack中配置 babel","id":"在webpack中配置-babel","depth":4,"charIndex":1661},{"text":"5.mode","id":"5mode","depth":3,"charIndex":2307},{"text":"6.在浏览器中查看页面","id":"6在浏览器中查看页面","depth":3,"charIndex":2769},{"text":"html-webpack-plugin 的 config 的妙用","id":"html-webpack-plugin-的-config-的妙用","depth":4,"charIndex":-1},{"text":"如何在浏览器中实时展示效果","id":"如何在浏览器中实时展示效果","depth":4,"charIndex":3495},{"text":"7.devtool","id":"7devtool","depth":3,"charIndex":4643},{"text":"8.如何处理样式文件呢","id":"8如何处理样式文件呢","depth":3,"charIndex":5219},{"text":"9.图片/字体文件处理","id":"9图片字体文件处理","depth":3,"charIndex":6200},{"text":"10.处理 html 中的本地图片","id":"10处理-html-中的本地图片","depth":3,"charIndex":7145},{"text":"11.入口配置","id":"11入口配置","depth":3,"charIndex":7746},{"text":"12.出口配置","id":"12出口配置","depth":3,"charIndex":8007},{"text":"13.每次打包前清空dist目录","id":"13每次打包前清空dist目录","depth":3,"charIndex":8469},{"text":"希望dist目录下某个文件夹不被清空","id":"希望dist目录下某个文件夹不被清空","depth":4,"charIndex":8764},{"text":"最后","id":"最后","depth":3,"charIndex":9148}],"domain":"","frontmatter":{},"version":""},{"id":47,"title":"带你深度解锁Webpack系列(进阶篇)","content":"#\n\n统计信息：字数 29666 阅读60分钟\n\n掘金\n\n无名之苝\n\n2020-03-0947,221阅读15分钟\n\n三篇长文，带你解锁 Webpack ，希望读完这三篇文章，你能够对 webpack 的各项配置有一个更为清晰的认识。\n\n本文是第二篇，如果你还没有阅读《带你深度解锁Webpack系列(基础篇)》，建议阅读之后，再继续阅读本文。\n\n本文会引入更多的 webpack 配置，如果文中有任何错误，欢迎在评论区指正，我会尽快修正。 webpack 优化部分放在了下一篇。\n\n推荐大家参考本文一步一步进行配置，不要总是想着找什么最佳配置，掌握之后，根据自己的需求配置出来的，就是最佳配置。\n\n本文对应的项目地址(编写本文时使用) 供参考：github.com/YvetteLau/w…\n\n\n\n\n1. 静态资源拷贝#\n\n有些时候，我们需要使用已有的JS文件、CSS文件（本地文件），但是不需要 webpack 编译。例如，我们在 public/index.html 中引入了\npublic 目录下的 js 或 css 文件。这个时候，如果直接打包，那么在构建出来之后，肯定是找不到对应的 js / css 了。\n\n> public 目录结构\n\n\n\n现在，我们在 index.html 中引入了 ./js/base.js。\n\n\n\n这时候，我们 npm run dev，会发现有找不到该资源文件的报错信息。\n\n对于这个问题，我们可以手动将其拷贝至构建目录，然后在配置 CleanWebpackPlugin\n时，注意不要清空对应的文件或文件夹即可，但是如若这个静态文件时不时的还会修改下，那么依赖于手动拷贝，是很容易出问题的。\n\n不要过于相信自己的记性，依赖于手动拷贝的方式，大多数人应该都有过忘记拷贝的经历，你要是说你从来没忘过。\n\n\n\n幸运的是，webpack 为我们这些记性不好又爱偷懒的人提供了好用的插件 CopyWebpackPlugin，它的作用就是将单个文件或整个目录复制到构建目录。\n\n首先安装一下依赖：\n\n\n\n修改配置(当前，需要做的是将 public/js 目录拷贝至 dist/js 目录)：\n\n\n\n此时，重新执行 npm run dev，报错信息已经消失。\n\n这里说一下 flatten 这个参数，设置为 true，那么它只会拷贝文件，而不会把文件夹路径都拷贝上，大家可以不设置 flatten 时，看下构建结果。\n\n另外，如果我们要拷贝一个目录下的很多文件，但是想过滤掉某个或某些文件，那么 CopyWebpackPlugin 还为我们提供了 ignore 参数。\n\n\n\n例如，这里我们忽略掉 js 目录下的 other.js 文件，使用 npm run build 构建，可以看到 dist/js 下不会出现 other.js\n文件。 CopyWebpackPlugin 还提供了很多其它的参数，如果当前的配置不能满足你，可以查阅文档进一步修改配置。\n\n\n2.ProvidePlugin#\n\nProvidePlugin 在我看来，是为懒人准备的，不过也别过度使用，毕竟全局变量不是什么“好东西”。ProvidePlugin 的作用就是不需要\nimport 或 require 就可以在项目中到处使用。\n\nProvidePlugin 是 webpack 的内置插件，使用方式如下：\n\n\n\n默认寻找路径是当前文件夹 ./** 和 node_modules，当然啦，你可以指定全路径。\n\nReact 大家都知道的，使用的时候，要在每个文件中引入 React，不然立刻抛错给你看。还有就是 jquery, lodash\n这样的库，可能在多个文件中使用，但是懒得每次都引入，好嘛，一起来偷个懒，修改下 webpack 的配置:\n\n\n\n这样配置之后，你就可以在项目中随心所欲的使用 $、_map了，并且写 React 组件时，也不需要 import React 和 Component\n了，如果你想的话，你还可以把 React 的 Hooks 都配置在这里。\n\n另外呢，Vue 的配置后面多了一个 default，这是因为 vue.esm.js 中使用的是 export default 导出的，对于这种，必须要指定\ndefault。React 使用的是 module.exports 导出的，因此不要写 default。\n\n另外，就是如果你项目启动了 eslint 的话，记得修改下 eslint 的配置文件，增加以下配置：\n\n\n\n当然啦，偷懒要有个度，你要是配一大堆全局变量，最终可能会给自己带来麻烦，对自己配置的全局变量一定要负责到底。\n\n\n\n\n3.抽离CSS#\n\nCSS打包我们前面已经说过了，不过呢，有些时候，我们可能会有抽离CSS的需求，即将CSS文件单独打包，这可能是因为打包成一个JS文件太大，影响加载速度，也有可能\n是为了缓存(例如，只有JS部分有改动)，还有可能就是“我高兴”：我想抽离就抽离，谁也管不着。\n\n不管你是因为什么原因要抽离CSS，只要你有需求，我们就可以去实现。\n\n首先，安装 loader:\n\n\n\n> mini-css-extract-plugin 和 extract-text-webpack-plugin 相比:\n\n 1. 异步加载\n 2. 不会重复编译(性能更好)\n 3. 更容易使用\n 4. 只适用CSS\n\n修改我们的配置文件：\n\n\n\n现在，我们重新编译：npm run build，目录结构如下所示:\n\n\n\n前面说了最好新建一个 .browserslistrc 文件，这样可以多个 loader 共享配置，所以，动手在根目录下新建文件\n(.browserslistrc)，内容如下（你可以根据自己项目需求，修改为其它的配置）:\n\n\n\n修改 webpack.config.js：\n\n\n\n要测试自己的 .browserlistrc 有没有生效也很简单，直接将文件内容修改为 last 1 Chrome versions\n，然后对比修改前后的构建出的结果，就能看出来啦。\n\n可以查看更多[browserslistrc]配置项(github.com/browserslis…)\n\n更多配置项，可以查看mini-css-extract-plugin\n\n将抽离出来的css文件进行压缩#\n\n使用 mini-css-extract-plugin，CSS 文件默认不会被压缩，如果想要压缩，需要配置 optimization，首先安装\noptimize-css-assets-webpack-plugin.\n\n\n\n修改webpack配置：\n\n\n\n注意，这里将 OptimizeCssPlugin 直接配置在 plugins 里面，那么 js 和 css 都能够正常压缩，如果你将这个配置在\noptimization，那么需要再配置一下 js 的压缩(开发环境下不需要去做CSS的压缩，因此后面记得将其放到 webpack.config.prod.js\n中哈)。\n\n配置完之后，测试的时候发现，抽离之后，修改 css 文件时，第一次页面会刷新，但是第二次页面不会刷新 —— 好嘛，我平时的业务中用不着抽离\ncss，这个问题搁置了好多天(准确来说是忘记了)。\n\n3月8号再次修改这篇文章的时候，正好看到了 MiniCssExtractPlugin.loader 对应的 option 设置，我们再次修改下对应的 rule。\n\n\n\n\n\n\n4.按需加载#\n\n很多时候我们不需要一次性加载所有的JS文件，而应该在不同阶段去加载所需要的代码。webpack内置了强大的分割代码的功能可以实现按需加载。\n\n比如，我们在点击了某个按钮之后，才需要使用使用对应的JS文件中的代码，需要使用 import() 语法：\n\n\n\nimport() 语法，需要 @babel/plugin-syntax-dynamic-import 的插件支持，但是因为当前\n@babel/preset-env 预设中已经包含了 @babel/plugin-syntax-dynamic-import，因此我们不需要再单独安装和配置。\n\n直接 npm run build 进行构建，构建结果如下：\n\n\n\nwebpack 遇到 import(****) 这样的语法的时候，会这样处理：\n\n * 以**** 为入口新生成一个 Chunk\n * 当代码执行到 import 所在的语句时，才会加载该 Chunk 所对应的文件（如这里的1.bundle.8bf4dc.js）\n\n大家可以在浏览器中的控制台中，在 Network 的 Tab页 查看文件加载的情况，只有点击之后，才会加载对应的 JS 。\n\n\n5.热更新#\n\n 1. 首先配置 devServer 的 hot 为 true\n 2. 并且在 plugins 中增加 new webpack.HotModuleReplacementPlugin()\n\n\n\n我们配置了 HotModuleReplacementPlugin\n之后，会发现，此时我们修改代码，仍然是整个页面都会刷新。不希望整个页面都刷新，还需要修改入口文件：\n\n 1. 在入口文件中新增:\n\n\n\n此时，再修改代码，不会造成整个页面的刷新。\n\n\n\n\n6.多页应用打包#\n\n有时，我们的应用不一定是一个单页应用，而是一个多页应用，那么如何使用 webpack 进行打包呢。为了生成目录看起来清晰，不生成单独的 map 文件。\n\n\n\n如果需要配置多个 HtmlWebpackPlugin，那么 filename 字段不可缺省，否则默认生成的都是 index.html，如果你希望 html\n的文件名中也带有 hash，那么直接修改 fliename 字段即可，例如: filename: 'login.[hash:6].html'。\n\n生成目录如下:\n\n\n\n看起来，似乎是OK了，不过呢，查看 index.html 和 login.html 会发现，都同时引入了 index.f7d21a.js 和\nlogin.f7d21a.js，通常这不是我们想要的，我们希望，index.html 中只引入 index.f7d21a.js，login.html 只引入\nlogin.f7d21a.js。\n\nHtmlWebpackPlugin 提供了一个 chunks\n的参数，可以接受一个数组，配置此参数仅会将数组中指定的js引入到html文件中，此外，如果你需要引入多个JS文件，仅有少数不想引入，还可以指定\nexcludeChunks 参数，它接受一个数组。\n\n\n\n执行 npm run build，可以看到 index.html 中仅引入了 index 的 JS 文件，而 login.html 中也仅引入了 login 的\nJS 文件，符合我们的预期。\n\n\n\n\n7.resolve 配置#\n\nresolve 配置 webpack 如何寻找模块所对应的文件。webpack 内置 JavaScript\n模块化语法解析功能，默认会采用模块化标准里约定好的规则去寻找，但你可以根据自己的需要修改默认的规则。\n\n 1. modules\n\nresolve.modules 配置 webpack 去哪些目录下寻找第三方模块，默认情况下，只会去 node_modules\n下寻找，如果你我们项目中某个文件夹下的模块经常被导入，不希望写很长的路径，那么就可以通过配置 resolve.modules 来简化。\n\n\n\n这样配置之后，我们 ``，会去寻找 ./src/components/dialog，不再需要使用相对路径导入。如果在 ./src/components\n下找不到的话，就会到 node_modules 下寻找。\n\n 1. alias\n\nresolve.alias 配置项通过别名把原导入路径映射成一个新的导入路径，例如：\n\n\n\n例如，我们有一个依赖 @my/react-native-web 可以实现 react-native 转 web。我们代码一般下面这样:\n\n\n\n配置了别名之后，在转 web 时，会从 @my/react-native-web 寻找对应的依赖。\n\n当然啦，如果某个依赖的名字太长了，你也可以给它配置一个短一点的别名，这样用起来比较爽，尤其是带有 scope 的包。\n\n 1. extensions\n\n适配多端的项目中，可能会出现 .web.js, .wx.js，例如在转web的项目中，我们希望首先找 .web.js，如果没有，再找 .js。我们可以这样配置:\n\n\n\n首先寻找 ../dialog.web.js ，如果不存在的话，再寻找\n../dialog.js。这在适配多端的代码中非常有用，否则，你就需要根据不同的平台去引入文件(以牺牲了速度为代价)。\n\n\n\n当然，配置 extensions，我们就可以缺省文件后缀，在导入语句没带文件后缀时，会自动带上extensions\n中配置的后缀后，去尝试访问文件是否存在，因此要将高频的后缀放在前面，并且数组不要太长，减少尝试次数。如果没有配置\nextensions，默认只会找对对应的js文件。\n\n 1. enforceExtension\n\n如果配置了 resolve.enforceExtension 为 true，那么导入语句不能缺省文件后缀。\n\n 1. mainFields\n\n有一些第三方模块会提供多份代码，例如 bootstrap，可以查看 bootstrap 的 package.json 文件：\n\n\n\nresolve.mainFields 默认配置是 ['browser', 'main']，即首先找对应依赖 package.json 中的 brower\n字段，如果没有，找 main 字段。\n\n如：import 'bootstrap' 默认情况下，找得是对应的依赖的 package.json 的 main 字段指定的文件，即\ndist/js/bootstrap。\n\n假设我们希望，import 'bootsrap' 默认去找 css 文件的话，可以配置 resolve.mainFields 为:\n\n\n\n\n8.区分不同的环境#\n\n目前为止我们 webpack 的配置，都定义在了 webpack.config.js 中，对于需要区分是开发环境还是生产环境的情况，我们根据\nprocess.env.NODE_ENV 去进行了区分配置，但是配置文件中如果有多处需要区分环境的配置，这种显然不是一个好办法。\n\n更好的做法是创建多个配置文件，如: webpack.base.js、webpack.dev.js、webpack.prod.js。\n\n * webpack.base.js 定义公共的配置\n * webpack.dev.js：定义开发环境的配置\n * webpack.prod.js：定义生产环境的配置\n\nwebpack-merge 专为 webpack 设计，提供了一个 merge 函数，用于连接数组，合并对象。\n\n\n\nwebpack.config.base.js 中是通用的 webpack 配置，以 webpack.config.dev.js 为例，如下：\n\n\n\n然后修改我们的 package.json，指定对应的 config 文件：\n\n\n\n你可以使用 merge 合并，也可以使用 merge.smart 合并，merge.smart\n在合并loader时，会将同一匹配规则的进行合并，webpack-merge 的说明文档中给出了详细的示例。\n\n\n9.定义环境变量#\n\n很多时候，我们在开发环境中会使用预发环境或者是本地的域名，生产环境中使用线上域名，我们可以在 webpack 定义环境变量，然后在代码中使用。\n\n使用 webpack 内置插件 DefinePlugin 来定义环境变量。\n\nDefinePlugin 中的每个键，是一个标识符.\n\n * 如果 value 是一个字符串，会被当做 code 片段\n * 如果 value 不是一个字符串，会被stringify\n * 如果 value 是一个对象，正常对象定义即可\n * 如果 key 中有 typeof，它只针对 typeof 调用定义\n\n\n\n\n\n\n10.利用webpack解决跨域问题#\n\n假设前端在3000端口，服务端在4000端口，我们通过 webpack 配置的方式去实现跨域。\n\n首先，我们在本地创建一个 server.js：\n\n\n\n执行代码(run code)，现在我们可以在浏览器中访问到此接口: http://localhost:4000/api/user。\n\n在 index.js 中请求 /api/user，修改 index.js 如下:\n\n\n\n我们希望通过配置代理的方式，去访问 4000 的接口。\n\n配置代理#\n\n修改 webpack 配置:\n\n\n\n重新执行 npm run dev，可以看到控制台打印出来了 {name: \"刘小夕\"}，实现了跨域。\n\n大多情况，后端提供的接口并不包含 /api，即：/user，/info、/list 等，配置代理时，我们不可能罗列出每一个api。\n\n修改我们的服务端代码，并重新执行。\n\n\n\n尽管后端的接口并不包含 /api，我们在请求后端接口时，仍然以 /api 开头，在配置代理时，去掉 /api，修改配置:\n\n\n\n重新执行 npm run dev，在浏览器中访问： http://localhost:3000/，控制台中也打印出了{name: \"刘小夕\"}，跨域成功，\n\n\n11.前端模拟数据#\n\n> 简单数据模拟\n\n\n\n在 src/index.js 中直接请求 /user 接口。\n\n\n\n> 使用 mocker-api mock数据接口\n\nmocker-api 为 REST API 创建模拟 API。在没有实际 REST API 服务器的情况下测试应用程序时，它会很有用。\n\n 1. 安装 mocker-api:\n\n\n\n 1. 在项目中新建mock文件夹，新建 mocker.js.文件，文件如下:\n\n\n\n 1. 修改 webpack.config.base.js:\n\n\n\n这样，我们就可以直接在代码中像请求后端接口一样对mock数据进行请求。\n\n 1. 重启 npm run dev，可以看到，控制台成功打印出来 {name: '刘小夕'}\n 2. 我们再修改下 src/index.js，检查下POST接口是否成功\n\n\n\n可以在控制台中看到接口返回的成功的数据。\n\n进阶篇就到这里结束啦，最后一篇是优化篇，下周一带上小板凳和瓜子来约。\n\n\n\n\n最后#\n\n如果本文对你有帮助的话，给本文点个赞吧。\n\n带你深度解锁Webpack系列(优化篇)","routePath":"/site/webpack/site/webpack/11-深度解锁Webpack系列(进阶篇)02","lang":"","toc":[{"text":"1. 静态资源拷贝","id":"1-静态资源拷贝","depth":3,"charIndex":350},{"text":"2.ProvidePlugin","id":"2provideplugin","depth":3,"charIndex":1241},{"text":"3.抽离CSS","id":"3抽离css","depth":3,"charIndex":1933},{"text":"将抽离出来的css文件进行压缩","id":"将抽离出来的css文件进行压缩","depth":4,"charIndex":2601},{"text":"4.按需加载","id":"4按需加载","depth":3,"charIndex":3088},{"text":"5.热更新","id":"5热更新","depth":3,"charIndex":3599},{"text":"6.多页应用打包","id":"6多页应用打包","depth":3,"charIndex":3830},{"text":"7.resolve 配置","id":"7resolve-配置","depth":3,"charIndex":4482},{"text":"8.区分不同的环境","id":"8区分不同的环境","depth":3,"charIndex":5849},{"text":"9.定义环境变量","id":"9定义环境变量","depth":3,"charIndex":6429},{"text":"10.利用webpack解决跨域问题","id":"10利用webpack解决跨域问题","depth":3,"charIndex":6714},{"text":"配置代理","id":"配置代理","depth":4,"charIndex":6951},{"text":"11.前端模拟数据","id":"11前端模拟数据","depth":3,"charIndex":7260},{"text":"最后","id":"最后","depth":3,"charIndex":7699}],"domain":"","frontmatter":{},"version":""},{"id":48,"title":"带你深度解锁Webpack系列(优化篇)","content":"#\n\n统计信息：字数 24100 阅读49分钟\n\n无名之苝\n\n2020-03-1672,326阅读9分钟\n\n带你深度解锁Webpack系列(基础篇) 和 带你深度解锁Webpack系列(进阶篇)，主要是讲解了 Webpack\n的配置，但是随着项目越来越大，构建速度可能会越来越慢，构建出来的js的体积也越来越大，此时就需要对 Webpack 的配置进行优化。\n\n本文罗列出了十多种优化方式，大家可以结合自己的项目，选择适当的方式进行优化。这些 Webpack 插件的源码我大多也没有看过，主要是结合 Webpack\n官方文档以及项目实践，并且花了大量的时间验证后输出了本文，如果文中有错误的地方，欢迎在评论区指正。\n\n鉴于前端技术变更迅速，祭出本篇文章基于 Webpack 的版本号:\n\n\n\n本文对应的项目地址(编写本文时使用)供参考：github.com/YvetteLau/w…\n\n\n\n\n量化#\n\n有时，我们以为的优化是负优化，这时，如果有一个量化的指标可以看出前后对比，那将会是再好不过的一件事。\n\nspeed-measure-webpack-plugin 插件可以测量各个插件和loader所花费的时间，使用之后，构建时，会得到类似下面这样的信息：\n\n\n\n对比前后的信息，来确定优化的效果。\n\nspeed-measure-webpack-plugin 的使用很简单，可以直接用其来包裹 Webpack 的配置:\n\n\n\n\n1.exclude/include#\n\n我们可以通过 exclude、include 配置来确保转译尽可能少的文件。顾名思义，exclude 指定要排除的文件，include 指定要包含的文件。\n\nexclude 的优先级高于 include，在 include 和 exclude 中使用绝对路径数组，尽量避免 exclude，更倾向于使用\ninclude。\n\n\n\n下图是我未配置 include 和配置了 include 的构建结果对比：\n\n\n\n\n2. cache-loader#\n\n在一些性能开销较大的 loader 之前添加 cache-loader，将结果缓存中磁盘中。默认保存在\nnode_modueles/.cache/cache-loader 目录下。\n\n首先安装依赖：\n\n\n\ncache-loader 的配置很简单，放在其他 loader 之前即可。修改Webpack 的配置如下:\n\n\n\n如果你跟我一样，只打算给 babel-loader 配置 cache 的话，也可以不使用 cache-loader，给 babel-loader 增加选项\ncacheDirectory。\n\n\n\ncacheDirectory：默认值为 false。当有设置时，指定的目录将用来缓存 loader 的执行结果。之后的 Webpack\n构建，将会尝试读取缓存，来避免在每次执行时，可能产生的、高性能消耗的 Babel 重新编译过程。设置空值或者 true\n的话，使用默认缓存目录：node_modules/.cache/babel-loader。开启 babel-loader的缓存和配置\ncache-loader，我比对了下，构建时间很接近。\n\n\n3.happypack#\n\n由于有大量文件需要解析和处理，构建是文件读写和计算密集型的操作，特别是当文件数量变多后，Webpack\n构建慢的问题会显得严重。文件读写和计算操作是无法避免的，那能不能让 Webpack 同一时刻处理多个任务，发挥多核 CPU 电脑的威力，以提升构建速度呢？\n\nHappyPack 就能让 Webpack 做到这点，它把任务分解给多个子进程去并发的执行，子进程处理完后再把结果发送给主进程。\n\n首先需要安装 happypack:\n\n\n\n修改配置文件:\n\n\n\nhappypack 默认开启 CPU核数 - 1 个进程，当然，我们也可以传递 threads 给 Happypack。\n\n\n\n说明：当 postcss-loader 配置在 Happypack 中，必须要在项目中创建 postcss.config.js。\n\n\n\n否则，会抛出错误: Error: No PostCSS Config found\n\n另外，当你的项目不是很复杂时，不需要配置 happypack，因为进程的分配和管理也需要时间，并不能有效提升构建速度，甚至会变慢。\n\n\n4.thread-loader#\n\n除了使用 Happypack 外，我们也可以使用 thread-loader ，把 thread-loader 放置在其它 loader 之前，那么放置在这个\nloader 之后的 loader 就会在一个单独的 worker 池中运行。\n\n在 worker 池(worker pool)中运行的 loader 是受到限制的。例如：\n\n * 这些 loader 不能产生新的文件。\n * 这些 loader 不能使用定制的 loader API（也就是说，通过插件）。\n * 这些 loader 无法获取 webpack 的选项设置。\n\n首先安装依赖：\n\n\n\n修改配置:\n\n\n\nthread-loader 和 Happypack 我对比了一下，构建时间基本没什么差别。不过 thread-loader 配置起来为简单。\n\n\n5.开启 JS 多进程压缩#\n\n虽然很多 webpack 优化的文章上会提及多进程压缩的优化，不管是 webpack-parallel-uglify-plugin 或者是\nuglifyjs-webpack-plugin 配置 parallel。不过这里我要说一句，没必要单独安装这些插件，它们并不会让你的 Webpack\n构建速度提升。\n\n当前 Webpack 默认使用的是 TerserWebpackPlugin，默认就开启了多进程和缓存，构建时，你的项目中可以看到 terser 的缓存文件\nnode_modules/.cache/terser-webpack-plugin。\n\n\n6.HardSourceWebpackPlugin#\n\nHardSourceWebpackPlugin 为模块提供中间缓存，缓存默认的存放路径是: node_modules/.cache/hard-source。\n\n配置 hard-source-webpack-plugin，首次构建时间没有太大变化，但是第二次开始，构建时间大约可以节约 80%。\n\n首先安装依赖:\n\n\n\n修改 webpack 的配置：\n\n\n\n\n\n用另外一个比较大的项目测试了下，配置了 HardSourceWebpackPlugin，构建时间从 8S 左右降到了 2S 左右。\n\nHardSourceWebpackPlugin文档中 列出了一些你可能会遇到的问题以及如何解决，例如热更新失效，或者某些配置不生效等。\n\n\n7.noParse#\n\n如果一些第三方模块没有AMD/CommonJS规范版本，可以使用 noParse 来标识这个模块，这样 Webpack\n会引入这些模块，但是不进行转化和解析，从而提升 Webpack 的构建性能 ，例如：jquery 、lodash。\n\nnoParse 属性的值是一个正则表达式或者是一个 function。\n\n\n\n我当前的 webpack-optimize 项目中，没有使用 jquery 或者是 lodash。\n\n因此新建一个项目测试，只引入 jquery 和 loadsh，然后配置 noParse 和不配置 noParse，分别构建比对时间。\n\n配置noParse 前，构建需要 2392ms。配置了 noParse 之后，构建需要 1613ms。 如果你使用到了不需要解析的第三方依赖，那么配置\nnoParse 很显然是一定会起到优化作用的。\n\n\n8.resolve#\n\nresolve 配置 webpack 如何寻找模块所对应的文件。假设我们确定模块都从根目录下的 node_modules 中查找，我们可以配置:\n\n\n\n需要记住的是，如果你配置了上述的 resolve.moudles ，可能会出现问题，例如，你的依赖中还存在 node_modules\n目录，那么就会出现，对应的文件明明在，但是却提示找不到。因此呢，个人不推荐配置这个。如果其他同事不熟悉这个配置，遇到这个问题时，会摸不着头脑。\n\n另外，resolve 的 extensions 配置，默认是 ['.js',\n'.json']，如果你要对它进行配置，记住将频率最高的后缀放在第一位，并且控制列表的长度，以减少尝试次数。\n\n本项目较小，因此测试时，此处优化效果不明显。\n\n\n9.IgnorePlugin#\n\nwebpack 的内置插件，作用是忽略第三方包指定目录。\n\n例如: moment (2.24.0版本) 会将所有本地化内容和核心功能一起打包，我们就可以使用 IgnorePlugin 在打包时忽略本地化内容。\n\n\n\n在使用的时候，如果我们需要指定语言，那么需要我们手动的去引入语言包，例如，引入中文语言包:\n\n\n\nindex.js 中只引入 moment，打包出来的 bundle.js 大小为 263KB，如果配置了 IgnorePlugin，单独引入\nmoment/locale/zh-cn，构建出来的包大小为 55KB。\n\n\n10.externals#\n\n我们可以将一些JS文件存储在 CDN 上(减少 Webpack打包出来的 js 体积)，在 index.html 中通过\n\n我们希望在使用时，仍然可以通过 import 的方式去引用(如 ``)，并且希望 webpack 不会对其进行打包，此时就可以配置 externals。\n\n\n\n\n11.DllPlugin#\n\n有些时候，如果所有的JS文件都打成一个JS文件，会导致最终生成的JS文件很大，这个时候，我们就要考虑拆分 bundles。\n\nDllPlugin 和 DLLReferencePlugin 可以实现拆分 bundles，并且可以大大提升构建速度，DllPlugin 和\nDLLReferencePlugin 都是 webpack 的内置模块。\n\n我们使用 DllPlugin 将不会频繁更新的库进行编译，当这些依赖的版本没有变化时，就不需要重新编译。我们新建一个 webpack\n的配置文件，来专门用于编译动态链接库，例如名为: webpack.config.dll.js，这里我们将 react 和 react-dom\n单独打包成一个动态链接库。\n\n\n\n在 package.json 的 scripts 中增加:\n\n\n\n执行 npm run build:all，可以看到 dist 目录如下，之所以将动态链接库单独放在 dll 目录下，主要是为了使用\nCleanWebpackPlugin 更为方便的过滤掉动态链接库。\n\n\n\nmanifest.json 用于让 DLLReferencePlugin 映射到相关依赖上。\n\n修改 webpack 的主配置文件: webpack.config.js 的配置：\n\n\n\n使用 npm run build 构建，可以看到 bundle.js 的体积大大减少。\n\n修改 public/index.html 文件，在其中引入 react.dll.js\n\n\n\n> 构建速度\n\n\n\n> 包体积\n\n\n\n\n12.抽离公共代码#\n\n抽离公共代码是对于多页应用来说的，如果多个页面引入了一些公共模块，那么可以把这些公共的模块抽离出来，单独打包。公共代码只需要下载一次就缓存起来了，避免了重复下载\n。\n\n抽离公共代码对于单页应用和多页应该在配置上没有什么区别，都是配置在 optimization.splitChunks 中。\n\n\n\n即使是单页应用，同样可以使用这个配置，例如，打包出来的 bundle.js\n体积过大，我们可以将一些依赖打包成动态链接库，然后将剩下的第三方依赖拆出来。这样可以有效减小 bundle.js\n的体积大小。当然，你还可以继续提取业务代码的公共模块，此处，因为我项目中源码较少，所以没有配置。\n\n\n\n> runtimeChunk\n\nruntimeChunk 的作用是将包含 chunk 映射关系的列表从 main.js 中抽离出来，在配置了 splitChunk 时，记得配置\nruntimeChunk.\n\n\n\n最终构建出来的文件中会生成一个 manifest.js。\n\n借助 webpack-bundle-analyzer 进一步优化#\n\n在做 webpack 构建优化的时候，vendor 打出来超过了1M，react 和 react-dom 已经打包成了DLL。\n\n因此需要借助 webpack-bundle-analyzer 查看一下是哪些包的体积较大。\n\n首先安装依赖：\n\n\n\n使用也很简单，修改下我们的配置：\n\n\n\nnpm run build 构建，会默认打开： http://127.0.0.1:8888/，可以看到各个包的体积：\n\n\n\n进一步对 vendor 进行拆分，将 vendor 拆分成了4个(使用 splitChunks 进行拆分即可)。\n\n\n\n重新构建，结果如下所示：\n\n\n\n\n13.webpack自身的优化#\n\ntree-shaking#\n\n如果使用ES6的import 语法，那么在生产环境下，会自动移除没有使用到的代码。\n\n\n\n构建的最终代码里，minus 函数不会被打包进去。\n\nscope hosting 作用域提升#\n\n变量提升，可以减少一些变量声明。在生产环境下，默认开启。\n\n另外，大家测试的时候注意一下，speed-measure-webpack-plugin 和 HotModuleReplacementPlugin\n不能同时使用，否则会报错:\n\n\n\nbabel 配置的优化#\n\n如果你对 babel 还不太熟悉的话，那么可以阅读这篇文章：不容错过的 Babel7 知识。\n\n在不配置 @babel/plugin-transform-runtime 时，babel 会使用很小的辅助函数来实现类似 _createClass\n等公共方法。默认情况下，它将被注入(inject)到需要它的每个文件中。但是这样的结果就是导致构建出来的JS体积变大。\n\n我们也并不需要在每个 js 中注入辅助函数，因此我们可以使用\n@babel/plugin-transform-runtime，@babel/plugin-transform-runtime 是一个可以重复使用 Babel\n注入的帮助程序，以节省代码大小的插件。\n\n因此我们可以在 .babelrc 中增加 @babel/plugin-transform-runtime 的配置。\n\n\n\n以上就是我目前为止使用到的一些优化，如果你有更好的优化方式，欢迎在评论区留言，感谢阅读。\n\n看完这篇文之后，是时候去撸个脚手架了：【中高级前端必备】手摸手教你撸一个脚手架\n\n\n最后#\n\n\n\n> 参考文档：\n\n * webpack优化的一些基本方法\n * 模块(Module)\n * IgnorePlugin\n * DllPlugin\n * 使用 Webpack 的 DllPlugin 提升项目构建速度\n * 使用 HappyPack\n * webapck4抽取公共模块“SplitChunksPlugin”\n * webpack之优化篇（四）：hard-source-webpack-plugin,webpack DllPlugin配置的代替方案","routePath":"/site/webpack/site/webpack/12-深度解锁Webpack系列(优化篇)03","lang":"","toc":[{"text":"量化","id":"量化","depth":3,"charIndex":395},{"text":"1.exclude/include","id":"1excludeinclude","depth":3,"charIndex":613},{"text":"2. cache-loader","id":"2-cache-loader","depth":3,"charIndex":839},{"text":"3.happypack","id":"3happypack","depth":3,"charIndex":1339},{"text":"4.thread-loader","id":"4thread-loader","depth":3,"charIndex":1824},{"text":"5.开启 JS 多进程压缩","id":"5开启-js-多进程压缩","depth":3,"charIndex":2204},{"text":"6.HardSourceWebpackPlugin","id":"6hardsourcewebpackplugin","depth":3,"charIndex":2497},{"text":"7.noParse","id":"7noparse","depth":3,"charIndex":2842},{"text":"8.resolve","id":"8resolve","depth":3,"charIndex":3233},{"text":"9.IgnorePlugin","id":"9ignoreplugin","depth":3,"charIndex":3581},{"text":"10.externals","id":"10externals","depth":3,"charIndex":3864},{"text":"11.DllPlugin","id":"11dllplugin","depth":3,"charIndex":4022},{"text":"12.抽离公共代码","id":"12抽离公共代码","depth":3,"charIndex":4704},{"text":"借助 webpack-bundle-analyzer 进一步优化","id":"借助-webpack-bundle-analyzer-进一步优化","depth":4,"charIndex":5148},{"text":"13.webpack自身的优化","id":"13webpack自身的优化","depth":3,"charIndex":5465},{"text":"tree-shaking","id":"tree-shaking","depth":4,"charIndex":5483},{"text":"scope hosting 作用域提升","id":"scope-hosting-作用域提升","depth":4,"charIndex":5570},{"text":"babel 配置的优化","id":"babel-配置的优化","depth":4,"charIndex":5712},{"text":"最后","id":"最后","depth":3,"charIndex":6190}],"domain":"","frontmatter":{},"version":""},{"id":49,"title":"webpack5 SplitChunksPlugin 实用指南","content":"#\n\n统计信息：字数 17146 阅读35分钟\n\n晓得迷路了\n\n2018-09-16\n\n25,734阅读8分钟\n\n提到前端打包工具，毫无疑问想先到的是 webpack。但是前端发展地很快，时不时会有新东西出现，打包工具这边之前也出现 parcel 和\nrollup。各种工具的碰撞，相互汲取优点，促进技术的发展。\n\nwebpack 从 4.x\n开始支持了零配置的特性，同时对块打包也做了优化，CommonsChunkPlugin已经被移除了，现在是使用optimization.splitChunks代替\n。（webpack5 splitChunks 配置和 webpack4 大体上一样）\n\n本文基于 webpack@5.74.0 实践。下面就开始介绍 splitChunks 的内容。\n\n\n默认情况#\n\nSplitChunksPlugin 默认配置适用大部分场景。\n\n打包默认情况下只会影响按需加载模块，因为对初始块也进行优化打包会影响 HTML 中的 script 标签数，增加请求数。\n\n默认情况（webpack 的默认配置）下 webpack 会根据下述条件自动进行代码块分割：\n\n * 共享模块（至少被引用 2次）或者 node_modules 模块\n * 新代码块大于 20kb（min+gziped之前的体积）\n * 按需加载块时的最大并行请求数将低于或等于 30\n * 初始页面加载时的最大并行请求数将低于或等于 30\n\n记住，默认情况下只有按需加载模块会根据上方条件进行打包优化。\n\n接下来看些例子来理解默认情况的打包。\n\n\n模块全部是同步引入#\n\n\n\n\n\n默认情况只会影响按需加载模块，所以所有内容全部被打包到一起了。\n\n\n有模块动态导入#\n\n这里首先使用符合 ECMAScript 提案 的 import() 语法\n\n\n\n\n\n这里 lodash 使用动态导入，打包结果中可以看到 lodash 被单独打包了，因为默认情况下异步模块会被单独打包。\n\n\nreact 按需加载#\n\n同样的我们试要 react 按需加载，使用 React.lazy 来实现按需加载\n\n\n\n\n\n打包结果分析：生成了三个 JS 文件，main.js 显然对应 App.jsx，Page1 是异步引入的，单独打包，这边为啥生成了两个包。因为默认情况下\nwebpack 会对异步模块进行打包优化，lodash 又符合上述提到默认的 4 个条件，所以 lodash 也被单独打包了。\n\n\nlodash 按需加载#\n\n我们调整下 lodash 的引入，只引入 sum 模块。\n\n\n\n\n\n可以看到此时就两个文件，因为 lodash/sum 的文件大小小于 20kb，不会被单独打包。\n\n\n共享模块打包#\n\n除了 node_modules 满足条件会被单独打包，共享模块也会，我们看下面例子：\n\n\n\n\n\n打包分析：main、Page1、Page2 各一个 JS 文件，共享模块 Button2 一个包，第三方库一个包。至于为啥共享模块和第三方库是分开打包的，是和\nwebpack 的默认配置有关，后面我们就可以看到默认配置。\n\n\n初始和异步模块的公共库#\n\n最后在看一个场景，如果 App.jsx 中也使用到 lodash，此时会是什么情况。\n\n\n\n\n\n可以看到 lodash 被打包到 main.js 中去了，异步模块和初始块都有的第三方库，会被打包在初始模块中。原因也很简单，Page1 加载前肯定会加载\nApp 模块，App 模块中有了 lodash，Page1 就直接可以使用 App 模块中的 lodash 了。\n\n讲完了 webpack 默认情况下对打包块的优化，接下来看 splitChunks 配置项。\n\n\n配置项#\n\n\n默认配置#\n\nwebpack 5 splitChunks 默认配置如下，上面提到的默认情况下打包的条件（按需加载 + 满足 4 个默认打包条件）在下方配置中就可以体现。\n\n\n\n * chunks: 表示哪些代码需要优化，有三个可选值：initial(初始块)、async(按需加载块)、all(全部块)，默认为 async\n * minSize: 表示在压缩前的最小模块大小，默认为 20000\n * minChunks: 表示被引用次数，默认为 1\n * maxAsyncRequests: 按需加载时候最大的并行请求数，默认为 30\n * maxInitialRequests: 一个入口最大的并行请求数，默认为 30\n * enforceSizeThreshold：强制执行拆分的体积阈值\n * cacheGroups: 缓存组。缓存组的属性除上面所有属性外，还有 test, priority, reuseExistingChunk\n   * test: 用于控制哪些模块被这个缓存组匹配到\n   * priority: 缓存组打包的先后优先级\n   * reuseExistingChunk: 如果当前代码块包含的模块已经有了，就不在产生一个新的代码块\n\n默认配置项基本就上面这些，其他还有如块名称 name，块名称连接符 automaticNameDelimiter 等配置，更多可查看官网\n\n我们重点来看下 chunks 和 cacheGroups。\n\n\nchunks#\n\nchunks 的取值是有 initial, async, all。默认情况下是 async，在本文第一部分已经介绍了它的表现，所以现在来看下其它两个的表现。\n\n * initial 模块下只优化初始模块，也就是说 webpack 只会对初始模块做打包优化。\n * all 模块下同时对初始模块和异步模块做打包优化。\n\ninitial#\n\n我们先来看下 initial 的打包表现，可对比上方示例 1.3 做对比\n\n\n\n\n\n打包分析：可以看到异步模块单独打成了一个包，初始模块打成了两个包：main 和 vendor，initial 模式下打包优化只在初始模块中作用。\n\n在这边我们也可以试下 initial 共享模块的打包，单页面应用的初始模块只有一个，我们需要配置多入口才行。\n\n\n\n\n\n可以看到共享模块 Button2 被单独打包了。\n\n我们也可以通过配置 optimization.splitChunks.cacheGroups.default: false 禁用 default 缓存组。\n\n\n\n\n\n我们可以看到默认配置中共享模块打包优化被禁用后，就有没有了 Button2 的单独打包。\n\n讲完了 initial 模式下打包，最后讲下 all 模式下打包。\n\nall#\n\nall 模式下初始块和异步模块都会按照配置做优化。举个例子，可对比上方示例 1.3、2.1 做对比\n\n\n\n\n\n可以看到打包成了 4 个文件，初始模块的第三方库被单独打包了，异步模块的 lodash 也单独打包了。打包优化作用到了初始和异步模块。\n\n\ncacheGroups#\n\n使用 cacheGroups 可以自定义配置打包块。\n\n\n\n\n\n对比示例 2.4，可以看到 react-dom 被单独打成包了，其他第三方在一个包。自定义打包块的默认优先级是 0，所有优先处理自定义打包。\n\n\n提取第三方库#\n\n最后看下之前 CommonsChunkPlugin 常用的分离部分第三方库功能。这边你可以想一下怎么操作。\n\n上面已经提到了设置 chunks: initial || all 都可以提取出第三方库。但是它是把所有第三库提取出来，所以我们在只提取 react 和\nreact-dom 的情况下，需要自定义一个 cacheGroup。\n\n\n\n\n\n可以看到我们新增了一个缓存组，只匹配 react 和 react-dom，所以达到了之前 CommonsChunkPlugin 的功能。\n\n\noptimization.runtimeChunk#\n\n最后提一下 runtimeChunk，通过optimization.runtimeChunk: true选项，webpack 会添加一个只包含运行时\n(runtime) 额外代码块到每一个入口。（译注：这个需要看场景使用，会导致每个入口都加载多一份运行时代码）\n\n\n总结#\n\nwebpack5 默认情况下只对异步模块做打包优化，额外的打包必须满足 4 个条件（webpack\n的默认配置，可修改）。根据需求可调整为只对初始模块做打包优化，或者初始和异步模块一起优化。同时可配置自己的打包规则。\n\n简而言之：chunks 控制打包作用范围，其他控制打包规则。\n\nwebpack5 的 splitChunks 功能是比较强大的，不过推荐还是使用默认模式，或者提取一下第三方库。\n\n\n参考材料#\n\n * SplitChunksPlugin","routePath":"/site/webpack/site/webpack/13-webpack5 SplitChunksPlugin 实用指南","lang":"","toc":[{"text":"默认情况","id":"默认情况","depth":2,"charIndex":346},{"text":"模块全部是同步引入","id":"模块全部是同步引入","depth":3,"charIndex":672},{"text":"有模块动态导入","id":"有模块动态导入","depth":3,"charIndex":722},{"text":"react 按需加载","id":"react-按需加载","depth":3,"charIndex":836},{"text":"lodash 按需加载","id":"lodash-按需加载","depth":3,"charIndex":1038},{"text":"共享模块打包","id":"共享模块打包","depth":3,"charIndex":1136},{"text":"初始和异步模块的公共库","id":"初始和异步模块的公共库","depth":3,"charIndex":1306},{"text":"配置项","id":"配置项","depth":2,"charIndex":1553},{"text":"默认配置","id":"默认配置","depth":3,"charIndex":1560},{"text":"chunks","id":"chunks","depth":3,"charIndex":2195},{"text":"initial","id":"initial","depth":4,"charIndex":2363},{"text":"all","id":"all","depth":4,"charIndex":2739},{"text":"cacheGroups","id":"cachegroups","depth":3,"charIndex":2870},{"text":"提取第三方库","id":"提取第三方库","depth":2,"charIndex":2989},{"text":"optimization.runtimeChunk","id":"optimizationruntimechunk","depth":2,"charIndex":3240},{"text":"总结","id":"总结","depth":2,"charIndex":3401},{"text":"参考材料","id":"参考材料","depth":2,"charIndex":3607}],"domain":"","frontmatter":{},"version":""},{"id":50,"title":"Starting the development server 报错和解决","content":"#\n\n统计信息：字数 4573 阅读10分钟\n\ncreate time 2024-04-12\n\nlast modify time 2024-04-12\n\n\n问题描述#\n\n最近某个项目开发环境升级后，运行 npm start 后无法启动项目，终端始终显示 Starting the development server...，浏览器\nlocalhost: 3000 界面显示空白。\n\n\n\n错误截图\n\n\n问题分析#\n\n因为近期升级了环境，那么大概率是 webpack 或者 webpack-dev-server 的问题，具体升级的开发环境是 webpack4 升级到\nwebpack5，版本号为：\n\n\n\n查阅各种资料，有下面几个问题需要注意：\n\n\n问题1 3000 端口占用#\n\nWebpack-dev-server 默认在 3000 端口开启服务，如果其他服务已经在 3000 端口启动，那么会出现端口冲突，造成这个项目的\ndev-server 无法启动。\n\n此时需要先查看 3000 端口是否占用，可以使用 lsof 命令查看：\n\n\n\n如果有其他服务占用端口，会显示具体的服务和信息，如下。调试时可以关闭这个服务。\n\n\n\n我本地没有其他服务占用 3000 端口，应该是其他问题。\n\n\n问题2 环境变量 sourcemap 配置#\n\n项目升级后，没有设置 GENERATE_SOURCEMAP 属性\n\n可以添加一个 .env 文件，配置环境变量，或者在 npm 脚本中设置环境变量\n\n\n\n\n问题3 项目的入口函数#\n\n更改后，我的终端 webpack-dev-server 可以正常启动了，但是浏览器中还是空白的。\n\n查看控制台，HTML 渲染正常，但是 JS 没有挂载到 root 根节点，问题定位到入口函数。\n\n这个项目是一个 UI\n组件库。生产环境下是一个入口（index.js），开发环境是另一个入口（index2.js），所以需要配置两个入口文件，然后根据环境不同，使用不同的入口函数。\n\n路径文件中增加配置项 path.js\n\n\n\nwebpack 根据环境设置入口\n\n\n\n此时 entry 就正常了\n\n\n问题4 模块循环引用#\n\n早期代码存在存在循环引用，其中两个模块对外暴露很多函数，不同函数互相引用，造成循环引用。\n\n从代码层面，我先解决了循环引用的问题，这样也便于后面单元测试和模块的维护。\n\n从 webpack 打包构建层面，可以使用 CircularDependencyPlugin 避免循环引用的问题，配置如下。\n\n\n\n\n问题5 模块 splitChunk 问题#\n\n早期项目是一个 UI 项目，为了使用方便，使用了按需加载的语法实现，避免将全部 UI 项目引入到项目中。所以早期的代码如下：\n\n\n\n根据实际情况，在开发环境下不需要按需加载，在生产环境下需要按需加载，那么加入判断\n\n\n\n修改后，再次运行 npm start，终端显示正常，浏览器中打开 localhost: 3000 项目可以正常启动。\n\n\n反思#\n\n1、webpack 注意版本号，网上很多博客可能是 3.x 或者 4.x 的版本，这样造成配置文件不合适。\n\n2、webpack 插件很多很多，后续还是要多学习。\n\n3、几年前刚开始学习计算机，自己看到 webpack 配置一头雾水，现在大概知道主要配置，能解决一些常见问题了，确实需要不断积累和应用。\n\n\n参考链接#\n\nwebpack 官方的插件文档\n\nhttps://webpack.docschina.org/plugins/\n\nhttps://webpack.docschina.org/awesome-webpack/#Webpack-Plugins\n\nsplitTrunk 配置和功能\n\nhttps://juejin.cn/post/6844903680307625997\n\nhttps://juejin.cn/post/6844904195737255943","routePath":"/site/webpack/site/webpack/41-webpack更新版本后报错Starting the development server","lang":"","toc":[{"text":"问题描述","id":"问题描述","depth":2,"charIndex":77},{"text":"问题分析","id":"问题分析","depth":2,"charIndex":199},{"text":"问题1 3000 端口占用","id":"问题1-3000-端口占用","depth":3,"charIndex":321},{"text":"问题2 环境变量 sourcemap 配置","id":"问题2-环境变量-sourcemap-配置","depth":3,"charIndex":541},{"text":"问题3 项目的入口函数","id":"问题3-项目的入口函数","depth":3,"charIndex":643},{"text":"问题4 模块循环引用","id":"问题4-模块循环引用","depth":3,"charIndex":906},{"text":"问题5 模块 splitChunk 问题","id":"问题5-模块-splitchunk-问题","depth":3,"charIndex":1071},{"text":"反思","id":"反思","depth":2,"charIndex":1265},{"text":"参考链接","id":"参考链接","depth":2,"charIndex":1424}],"domain":"","frontmatter":{},"version":""},{"id":51,"title":"webpack 设置 devServer 为 https 协议","content":"#\n\n统计信息：字数 1470 阅读3分钟\n\n最近使用另一个第三方库 @zxing/library 需要 https 开发环境才能使用，默认 webpack-dev-server 开启的是 http\n协议，所以需要改一下配置，才能调试这个功能。\n\n\n1、改动 webpack 配置#\n\n很简单，我们只需要改webpack的devServer的其中一项配置，即可实现启动项目的时候，默认是https协议\n\n\n\n如果上面的更改后无效，那么继续调整环境变量\n\n\n2、更改环境变量#\n\n\n\n更改启动脚本\n\n\n\n\n3、解决浏览器安全链接报错#\n\n如果我们重新启动 webpack-dev-server 后，打开谷歌浏览器，默认会提示如下报错\n\n\n\n我们可以参考这里的方案，让谷歌浏览器不报错\nhttps://blog.csdn.net/m15345704381/article/details/130760324\n或者我本地开另一个浏览器，不会提示安全问题，也可以解决这个问题。\n\n\n参考资料#\n\nhttps://blog.csdn.net/dclnet/article/details/96316401\n\nhttps://blog.csdn.net/Boale_H/article/details/109264808","routePath":"/site/webpack/site/webpack/42-webpack设置devServer启动项目为https协议","lang":"","toc":[{"text":"1、改动 webpack 配置","id":"1改动-webpack-配置","depth":2,"charIndex":124},{"text":"2、更改环境变量","id":"2更改环境变量","depth":2,"charIndex":227},{"text":"3、解决浏览器安全链接报错","id":"3解决浏览器安全链接报错","depth":2,"charIndex":251},{"text":"参考资料","id":"参考资料","depth":2,"charIndex":436}],"domain":"","frontmatter":{},"version":""},{"id":52,"title":"Ant-design 打包后样式错误分析","content":"#\n\n统计信息：字数 7222 阅读15分钟\n\n\n错误现象#\n\n某项目本地开发样式正常（npm run dev），上线后样式不正常（npm run build）\n\n\n错误分析#\n\n本地开发中，antd-mobile 对应的CSS在前，自定义的 CSS 在后，界面可以正常显示；\n\n打包集成到线上，自定义的CSS 编译后为 commons.buldle.css 在前，antd-mobile 直接由 less 编译成 css 未打包，在后面。\n\n所以自定义的样式被已有的 antd-mobile 的样式覆盖，样式错误。\n\n下面是错误的代码 webpack-config-dev.js\n\n\n\n\n问题解决#\n\n\n\n现在生产环境中部署后，样式正常\n\n\n参考文件#\n\n官网文档 https://webpack.docschina.org/concepts/entry-points/\n\nReact+less https://blog.csdn.net/qwe502763576/article/details/83242823\n\nhttps://www.jianshu.com/p/6b0b80eb3e2e\n\nhttps://github.com/ant-design/ant-design/issues/3442#issuecomment-374877201\n\nhttps://www.cnblogs.com/mydxy/articles/10157215.html\n\nhttps://www.cnblogs.com/ldld/p/6488830.html\n\n\n进一步思考#\n\n打包到 bundle 中，那么其他的界面也会引用这个 bundle.css，就会影响其他界面的样式（body 的背景色）。\n\n现在还是原始的问题：按需加载，加载的部分中，不能影响其他自定义的样式。\n\nantd-mobile 中引用任何一个组件时，都会引用 style/index.css 文件。所以，不管使用 less 还是使用\ncss，都会把这部分公共组件引入。目前没有特别好的办法（除非把每一个组件单独应用，然后把公共样式中不影响默认样式的部分拿过来）。\n\nless\n部分有一个对应的按需加载的配置。这个插件根据需要的部分把CSS引入。但是这样打包后的CSS的顺序可能存在问题。所以现在不使用这个方法。如果自己日常使用时，可以使\n用部分引入的方法。","routePath":"/site/webpack/site/webpack/43-webpack 打包 antd-mobile 按需加载样式问题","lang":"","toc":[{"text":"错误现象","id":"错误现象","depth":3,"charIndex":24},{"text":"错误分析","id":"错误分析","depth":3,"charIndex":82},{"text":"问题解决","id":"问题解决","depth":3,"charIndex":294},{"text":"参考文件","id":"参考文件","depth":3,"charIndex":321},{"text":"进一步思考","id":"进一步思考","depth":3,"charIndex":676}],"domain":"","frontmatter":{},"version":""},{"id":53,"title":"---","content":"","routePath":"/site/webpack/site/webpack/44-TS-React-Webpack","lang":"","toc":[{"text":"layout:       post\ntitle:        \"TypeScript React Webpack Combination\"\nsubtitle:     \"Use TS React Webpack together\"\ndate:         2018-10-09 22:00:00\nauthor:       \"ZeFeng\"\nheader-img:   \"img/TS.jpg\"\nheader-mask:  0.3\ncatalog:      true\ntags:\n- TypeScript\n- React\n- Webpack","id":"layout-------posttitle--------typescript-react-webpack-combinationsubtitle-----use-ts-react-webpack-togetherdate---------2018-10-09-220000author-------zefengheader-img---imgtsjpgheader-mask--03catalog------truetags--typescript--react--webpack","depth":2,"charIndex":-1},{"text":"前言","id":"前言","depth":2,"charIndex":-1},{"text":"正文","id":"正文","depth":2,"charIndex":-1},{"text":"初始化项目结构","id":"初始化项目结构","depth":2,"charIndex":-1},{"text":"初始化工程","id":"初始化工程","depth":2,"charIndex":-1},{"text":"安装依赖","id":"安装依赖","depth":2,"charIndex":-1},{"text":"添加TypeScript配置文件","id":"添加typescript配置文件","depth":2,"charIndex":-1},{"text":"编写代码","id":"编写代码","depth":2,"charIndex":-1},{"text":"创建webpack配置文件","id":"创建webpack配置文件","depth":2,"charIndex":-1},{"text":"运行","id":"运行","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":54,"title":"Webpack 打包 TS 文件","content":"","routePath":"/site/webpack/site/webpack/45-TS项目使用Webpack","lang":"","toc":[{"text":"前言","id":"前言","depth":2,"charIndex":-1},{"text":"正文","id":"正文","depth":2,"charIndex":-1},{"text":"初始化项目结构","id":"初始化项目结构","depth":2,"charIndex":-1},{"text":"初始化工程","id":"初始化工程","depth":2,"charIndex":-1},{"text":"安装依赖","id":"安装依赖","depth":2,"charIndex":-1},{"text":"添加TypeScript配置文件","id":"添加typescript配置文件","depth":2,"charIndex":-1},{"text":"编写代码","id":"编写代码","depth":2,"charIndex":-1},{"text":"创建webpack配置文件","id":"创建webpack配置文件","depth":2,"charIndex":-1},{"text":"运行","id":"运行","depth":2,"charIndex":-1},{"text":"Michael 笔记","id":"michael-笔记","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":55,"title":"webpack 脚本说明","content":"#\n\n统计信息：字数 20612 阅读42分钟\n\n按照 craete-react-app 的说明，运行 npm run eject 后，会弹出 webpack 等配置，主要的文件如下。\n\n注意：需要判断不同的 cra 版本，对应的 webpack 345 版本也不同。下面代码比较早，以最新为准。\n\n\n环境说明 env.js#\n\n\n\n\n路径说明 path.js#\n\n","routePath":"/site/webpack/site/webpack/46-webpack 项目配置学习","lang":"","toc":[{"text":"环境说明 env.js","id":"环境说明-envjs","depth":2,"charIndex":150},{"text":"路径说明 path.js","id":"路径说明-pathjs","depth":2,"charIndex":167},{"text":"测试脚本","id":"测试脚本","depth":2,"charIndex":-1},{"text":"开发脚本 start.js","id":"开发脚本-startjs","depth":2,"charIndex":-1},{"text":"部署脚本 build.js","id":"部署脚本-buildjs","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":56,"title":"","content":"","routePath":"/site/webpack/site/webpack/47-webpack 项目配置学习2","lang":"","toc":[{"text":"webpack.config.js配置文件","id":"webpackconfigjs配置文件","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":57,"title":"配置说明","content":"#\n\n统计信息：字数 7690 阅读16分钟\n\n\n第三方依赖版本#\n\n\n\n需要注意高版本和低版本的兼容，还有 webpack-babel 不同版本的配置文件不同\n\n\nScript 脚本说明#\n\n\n\n发布前，依次执行上面的四个脚本\n\n * pub:lib 在 node 环境下 babel 编译代码到 lib 目录下\n * pub:esm 在生产环境下 bebel 编译代码到 es 目录下\n * pub:umd 在生产环境下 webpack 使用配置文件进行编译（入口出口在配置文件中）\n * pub:optimized 删除本地配置文件和翻译文件\n\n前两步应该兼容开发环境（node环境，web开发环境，web生产环境）\n\n\nMakefile 脚本说明#\n\n\n\n\nbabelrc 配置说明#\n\neditor\n\n\n\nTable\n\n\n\nTODO：未来专门弄一个文件学习 babel 及配置作用（基本会使用）\n\n\nwebpack.config.pub.js 配置说明#\n\n\n\n这是 webpack 配置文件，未来要学会\n\n\n附录#\n\nbabel-preset-env\n说明：https://www.cnblogs.com/chyingp/p/understanding-babel-preset-env.html","routePath":"/site/webpack/site/webpack/48-webpack 项目配置学习3","lang":"","toc":[{"text":"第三方依赖版本","id":"第三方依赖版本","depth":3,"charIndex":24},{"text":"Script 脚本说明","id":"script-脚本说明","depth":3,"charIndex":82},{"text":"Makefile 脚本说明","id":"makefile-脚本说明","depth":3,"charIndex":313},{"text":"babelrc 配置说明","id":"babelrc-配置说明","depth":3,"charIndex":332},{"text":"webpack.config.pub.js 配置说明","id":"webpackconfigpubjs-配置说明","depth":3,"charIndex":404},{"text":"附录","id":"附录","depth":3,"charIndex":459}],"domain":"","frontmatter":{},"version":""},{"id":58,"title":"","content":"报错 Preset files are not allowed to export objects#\n\n在使用 webpack 和 babel 编译 react项目时，会报 Preset files are not allowed to export\nobjects 错误。查阅资料，主要是不同版本的 babel 不能兼容使用(版本6和版本7不兼容)。\n\n在高级版本中(>7)这样配置\n\npackage.json\n\n\n\n.bablerc\n\n\n\n在低级版本中存在漏洞，npm audit 不推荐使用低级版本，所以这里使用高级版本搭建。\n\n参考链接\n\nhttps://blog.csdn.net/cyyy1223/article/details/78867941\n\nhttps://segmentfault.com/a/1190000016783625\n\nhttps://www.html.cn/archives/9427\n\n上面说明react+webpack+babel 搭建基础流程\n\nhttps://blog.csdn.net/weixin_36185028/article/details/81117730\n\n说明打包成一个文件、全部文件、部分文件的配置\n\nhttps://www.cnblogs.com/tugenhua0707/p/9452471.html\n\n说明不同的依赖包的作用和配置\n\nhttps://www.e-learn.cn/index.php/content/wangluowenzhang/1121968\n\n说明高级版本的配置","routePath":"/site/webpack/site/webpack/Preset files are not allowed to export objects","lang":"","toc":[{"text":"报错 Preset files are not allowed to export objects","id":"报错-preset-files-are-not-allowed-to-export-objects","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":59,"title":"webpack 基本使用","content":"#\n\n统计信息：字数 30272 阅读61分钟\n\n　　webpack是一款前端模块打包工具,\n它的出现是由于现代web开发越来越复杂，如果还是像原来那样把所有的js代码都写到一个文件中，维护非常困难。而解决复杂化的方法通常是分而治之，就是把复杂化的东西进\n行拆分，形成一个个小的模块，这也是现代web 开发提出的模块化的概念，代码进行拆分，写成一个个小的模块，模块化方案又先后出现了commanjs ,amd,\nES6 module方案， 但浏览器并不能直接支持这些方案，所以要把模块化的代码进行转换，转换成浏览器能识别的内容。webpack\n就是做这个工作的，把多个小的模块化的文件打包成一个浏览器支持的文件，这应该是打包的由来吧。\n\n　　使用webpack之前，先做一下准备工作，就是新建文件夹，以及用到的文件，这里要注意，使用webpack\n时，我们的项目就是node项目了，对于任何一个node项目，都建议创建一个package.json文件，它主要是记录我们项目的信赖，以及用到的命令，\n这里不明白也没关系，我们只要按照步骤做就可以了，用到的时候自然就会明白了。\n\n　　 新建一个文件夹，就命名为webpack-learning吧，然后双击进入这个文件夹，在windows操作系统下，在文件夹中的任意位置，按住shift\n键单击鼠标右键，打开cmd 命令窗口。按照规定，我们要创建package.json文件。在命令窗口中，输入npm init\n–y，就可以快速创建一个package.json 文件。再新建src和dist文件夹，index.html，src目录存放源代码，dist\n目录存放打包后的代码. 在src 下新建index.js, mes.js. 简单项目结构如下：\n\n\n\n　　index.js, mes.js 就是两个不同的模块，简单来说，一个js 文件就是一个模块。wepback最先支持的commanjs 和amd 规范，\n现在ES6 对模块化进了标准化，webpack2.0也直接支持它了。webpack 使用ES6 模块化方案的好处就是它的 Tree Shaking\n功能，这个以后再说，我们先使用commonjs规范\n\n\n\n　　前面已经说了，index.js 不能直接使用，因为浏览器并不支持模块化方案。如果我们在index.html 中直接用script\n标签引入index.js，浏览器就会报错。 这时就用到了webpack对这两个js 文件进行打包，打包成一个浏览器可以识别的文件，供我们在浏览器中使用。\n\n　　使用webpack进行打包， 就要先安装webpack。webpack 的安装方式有两种：全局安装 和 本地安装。\n\n　　1， 全局安装：在刚才打开的命令窗口中，输入 npm install webpack –g, 等待安装完成，\n\n\n\n　　安装完成后，就可以命令行中使用webpack 命令，命令行中输入 webpack src/index.js dist/build.js\n，它表示，对src中的index.js文件进行打包，输出到dist目录下的build.js 中。\n\n\n\n　　打包完成后,可以看到dist目录下多了一个build.js文件，把这个文件引入到index.html文件中，\n\n　　在本地打开index.html 可以看到Hello world 字样，表示打包成功。\n\n　　2， 本地安装：本地安装使用的命令是npm install webpack --save-dev。 首先卸载全局安装的webpack,\n卸载全局安装的webpack命令是npm uninstall webpack -g\n\n　　卸载完成后, 再输入npm install webpack --save-dev 进行本地安装， 安装完成后，\n如果在命令窗口中输入webpack，报错了，没有这个指令，如下图片显示\n\n　　但这时webpack-learning文件夹中多了一个node_modules文件夹，表示安装到了本地。因为在node\n中，把任何东西安装到本地，它们都会安装到项目文件夹中的node_modules中，安装到本地的命令怎么用，npm script\n命令。打开package.json 文件，找到scripts 字段，写入 \"build\": \"webpack src/index.js\ndist/build.js\" ，它原有的text 命令已经删掉\n\n\n\n　　这样在命令行中输入npm run build也可以启用webpack 进行打包。\n\n\n\n　　dist目录下还是会有build.js 文件，用浏览器打开index.html, 还是可以看到Hello world, 证明打包成功。\n\n　　两种安装方式，到底该用哪一种，**推荐本地安装。**全局安装有一个版本管理问题， 如果我们的项目中，有的用webpack 1.0，有的用webpack2.0\n，而全局webpack 却只有一个命令，那就不好办了。本地安装却没有这个问题。If you are using npm scripts in your\nproject, npm will try to look for webpack installation in your local modules for\nwhich this installation technique is useful. 当我们使用npm scripts 时，npm\n会寻找本地安装的webpack ,这就解决版本问题， 每一个项目下都使用本地安装webpack , 互不影响。\n\n　　webpack 配置文件（webpack.config.js）\n\n　　webpack也提供了另外一种方式来完成打包工作，就是使用webpack的配置文件 webpack.config.js，\n先了解一下配置文件中的两个概念：entry, output\n\n * 　　entry 入口文件：webpack以哪个文件作为项目的入口， 就是webpack 打包的时候的从哪个文件开始。 相当于webpack 命令中\n   src/index.js\n * 　　output: webpack 打包完成后的文件放到什么地方。相当于webpack 命令中 dist/build.js\n\n　　现在用配置文件来完成上面的打包工作. 在webpack-learning文件夹下，新建一个js文件，命名为webpack.config.js，\n这是wepback配置文件默认命名规则，也就是webpack进行打包的时候，它会自动寻找项目根目录中的webpack.config.js\n文件，利用里面的规则进行打包。\n\n\n\n　　\n\n　　webpack2 建议我们使用 绝对路径，所以引入nodeJs 的path模块，主要用到了path.join方法,\n它接受路径参数，然后合并成一个完整的路径。\n\n　　这时npm scripts 中的 \"build\": \"webpack src/index.js dist/build.js\" 就要改成 \"build\":\n\"webpack\".\n\n\n\n　　这时在命令行中执行npm run build，同样可以完成打包。\n\n　　三种打包方式，我们生成了三次build.js\n文件，我们也不知道是哪一次生成哪一个文件，所以最好把以前生成的文件删除，保证每次打包完，都是最新的文件。当然，我们也不用每次都手动删除，我们可以使用rimraf\n模块。rimraf 就是用来删除文件或文件夹. 首先要安装它, cnpm i rimraf --save-dev, rimraf 安装到本地后,需要npm\nscript 命令, “rimraf dist” 就可以删除 dist 目录. 修改“build”: “rimraf dist && webpack” &&\n把两个命令连接起来，执行完前面的再执行后面的，依次从左向右执行, 这样我们每次执行build 命令都会先删除，再重新生成。\n\n　　webpack配置文件默认命名为webpack.config.js， 我们能不能命名成其它的名称，如wepback.config.client.js，\n这是可以的，但要使用一个命令行参数\n--config指定我们使用的配置文件，否则webpack找不到配置文件。我们来试一试，先把webpack.config.js文件命名为webpack.conf\nig.client.js, 执行npm run build, 这时你会发现报错了。\n\n\n\n　　它说No configuration file found and no output filename configured via CLI\noption. A configuration file could be named 'webpack.config.js' in the current\ndirectory 没有找到配置文件，配置文件应该命名为webpack.config.js，\n这也验证了webpack的配置文件默认命名为webpack.config.js. 这时我们用config 参数指定使用的配置文件。npm scripts\nbuild 进行如下修改\n\n\n\n　　执行npm run build 命令，打包成功了。有了\n--config参数以后，我们就可以随意命名配置文件，也可以把配置文件放到任意位置。使用vue-cli\n创建项目时，我们就看到它把所有配置文件都放到了build文件夹下，并且命名也有webpack.config.dev.js，\nwebpack.config.pro.js 来区分生产和开发配置文件。当执行npm run dev 命令时，它就是使用--config\n参数来指定它的配置文件，打开package.json看一下scripts字段就可以了。\n\n　　4，webpack-dev-server 热更新和热替换。\n\n　　 上面的打包方式，在项目开发中会遇到一个问题，就是每次修改代码后，如修改index.js文件的内容后，我们都要在命令行中输入npm run build,\n然后等待打包完成，打包完成后，还要重新刷新浏览器才能看到效果。这非常麻烦，怎么解决这个问题，这要用到了webpack-dev-server.\n\n　　webpack-dev-server 是\nwebpack自带的一个小型服务器，我们可以用服务器的方式访问html页面，每当有文件改动时，浏览器会自动刷新页面来反映我们做出的更改，这也就是所谓的livel\noad 或hotload. 首先 npm install webpack-dev-server --save-dev 安装它，\n\n\n\n　　然后在npm script 命令新建一个命令，\"dev\": \"webpack-dev-server\" ，\n在这里，我把wepback的配置文件名称重新改回了webpack.config.js， 所以不用--config指定配置文件\n\n\n\n　　这时，在命令行中输入npm run dev 启动服务器，在浏览器地址栏器输入localhost:8080, 页面中显示hello World,\n但是当我们改变mes.js中的Hello World 为Hello时，浏览器的内容并没有发生变化，和我们预想的不一样。这是 怎么回事? 原来是因为执行过npm\nrun build 命令，dist文件夹中有build.js 文件，我们的html 文件是引用这个文件，把dist\n目录删除，然后浏览器刷新，什么都没有，打开控制台，可以看到报错了，找不到build.js文件。\n\n\n\n　　这是因为启动webpack-dev-server 时，它也会进行打包，只不过它是把打包成功后的文件放到内存中，而不是放到硬盘中，那它放到内存的什么地方呢?\n我们必须知道打包后的build.js 放到什么地方，因为我们的html 文件中要进行引入，script 标签中src就是指向build.js文件地址。\n我们再看一个启动webpack-dev-server 时发生了什么? 当输入npm run dev 时，我们看到\n\n\n\n　　Project is running at http://localhost:8080/\n整个项目运行在localhost:8080下。这也就是我们在浏览器中输入localhost:8080的原因。\n\n　　webpack output is served from /： 通过这一句我们才知道，webpack-dev-server\n默认把打包后的文件放到了根目录下，在服务器中，/ 表示的就是根目录。那我们在 src 引入路径的时候，src= ‘bulid.js’\n就可以了。修改index.html 中 script 的src 为 src=\"build.js\", 修改之后，浏览器刷新，可以看到hello World,\n这时再更改mes.js中的 hello World 为 hello ,浏览器自动刷新，显示hello，成功了。\n\n　　但这里有一个问题，当执行npm run build 时，dist 目录下会生成一个build.js, 本地打开index.html\n又要引入这个文件，需要对html 中的js 路径进行修改为src=\"dist /build.js\", 这样两种状况下要来回切换,\n不利于开发，这两种不同的状态,可以理解为, 一个是开发环境,一个是生产环境. dev 状态下是开发环境, build 是生产环境. 有没有办法让它们统一起来?\n有，那就是output 中另外一个重要的配置 publicPath, 在服务器开发时，所有的静态资源如css,\njs，image都叫公共资源，都会放到一个叫public的文件夹下，publicPath，我想就是指定静态资源的存放位置。既然我们的生产环境是用\ndist/build.js, 它请求的是服务器端dist目录下的资源，所以publicPath 配置成 '/dist/'\n就可以了。这里只要记住：保证output 中的publicPath 和path 路径一致，就可以了。\n\n\n\n　　比热更新更为高级的就是热替换HRM, 当文件内容发生变化时，不用刷新整个页面，只是把变化的部分替换掉。当然它的配置有点小麻烦，不过就是按步骤就可以了。\n\n　　首先，它利用webpack-dev-server和 webpack.config.js 配置文件生成一个服务器，在webpack-learning文件夹下，\n就是项目根目录下新建一个dev-server.js 文件，代码如下：\n\n\n\n　　其次， 修改webpack.config.js 配置文件，\n\n　　一个是对入口文件进行配置，它变成了一个数组，加上了webpack-dev-server 入口\n\n\n\n　　　一个是要添加一个webpack自带的插件 HotModuleReplacementPlugin， 所以整个配置文件修改如下：\n\n\n\n　　最后修改index.js ，就是我们整个项目的入口文件，它接受热替换\n\n\n\n　　这时还要把npm scripts 的build 命令修改成node dev-server.js\n\n\n\n　　在命令窗口输入npm run dev 重新启动服务器, 修改mes.js文件的内容，页面内容实时变化，但没有刷新页面，可以看到配置成功了。\n\n　　设置环境变量\n\n　　配置完成后，又引发另外一个问题，当你使用npm run build 打包时，打包到的build.js 有300K\n之多，而我们只写了两个js文件，都不到1k, 这是怎么回事?\n因为打包的时候，把热替换的代码也打包到里面去了，显然，这是我们不想要的，因为热替换只有在开发环境下使用。\n解决方法就是配置环境变量，根据不同的环境变量，使用不同的配置文件。\n\n　　配置环境变量最简单的方法，就是直接在命令行中设置参数，你可能见到过 直接让NODE_ENV 等于一个值，如 \"build\": \"NODE_ENV=pro\nrimraf dist && webpack\", 这时执行npm run build 发现报错了, NODE_ENV 不是一个内部或外部命令。\n我刚开始学习的时候，也碰到了这个问题，明明是和别人的代码一样，为什么就是报错呢? 原来这样的设置在mac\n系统下是有效的，而在windows下无效，而在windows 系统下，应该使用set 命令 \"build\": \"set NODE_ENV=pro rimraf\ndist && webpack\", 这时执行npm run build\n可以看到打包成功。为了屏蔽掉操作系统的差别，我们要可以使用一个cross-env的包，npm install cross-env --save-dev 安装它,\npackage.json中scripts字段修改如下：\n\n\n\n　　我们给build 命令设置环境变量NODE_ENV 是production, 而dev 设置的是development.\n在代码中怎么获取这些环境变量，这要用到node 的process 模块，process.env.NODE_ENV 就可以获取到了。\n\n　　这里还要注意一点，NODE_ENV=development 中间不能有空格，如果写成NODE_ENV = development, 就成了三个命令了:\nNODE_ENV 是一个命令，= 是一个命令，development也是一个命令，执行npm run build 同样会报错: NODE_ENV\n不是一个内部命令\n\n　　这时我们获取到环境变量，就可以对wepack.config.js 进行修改，不同的环境下，用不同的配置内容。\n\n\n\n　　现在再执行npm run build， 打包后的js代码只有2kb. 执行npm run dev, 热替换依然在起作用，完美了。\n\n　　使用webpack 的强大的loaders 来处理不同的资源。\n\n　　webpack\n把所有的资源都当做模块，对模块的解析都要用到loader(模块加载器)。指定哪个loader对哪些文件解析是在配置文件中完成，它有一个module\n字段，里面就是定义规则的。我们写一个loader 就明白了。现在开发中我们都会用到ES6+ 的语法，然而浏览器不支持，那就用loader 给它编译成ES5,\nES6+ 的语法转化成ES5的语法要用到babel loader。\n\n　　使用任何loader之前，都要先安装它。npm install babel-loader babel-core babel-preset-es2015\n--save-dev 安装babel-loader, 更新 webpack.config.js 文件\n\n\n\n　　module: 定义打包规则，webpack2 用的是rules 来指定规则，它是一个数组，里面是每一个对象，对不同的文件指定不同的规则。\n\n　　　　test:它是一个正则表达式，表示对哪种类型文件应用这个loader。这里一定不要用引号把它包括起来，写成'/.js$/'，\n如果写成这样，永远不会匹配，代码也就不会做任何转化。\n\n　　　　loader: 指定具体的loaders, 注意，webpack2 中 babel-loader 后面的 -loader 字符最好不要省略。\n\n　　　　include: 它是一个文件夹，或一个数组（包含多个文件夹）， 就是对哪个或哪些文件夹中的js文件执行该loader。\n\n　　　　exclude: 它也是一个文件夹或一个数组(包含多个文件夹)，它是对哪个或哪些文件夹中的js文件不执行该loader。\n\n　　 使用babel 进行转换之前，还要新建一个.babelrc的文件，告诉babel 用什么规则进行编译。在项目根目录中，新建.babelrc\n\n\n\n　　好了，配置完成后，我们在index.js 中写一点ES6的代码(箭头函数)，体验一下\n\n\n\n　　npm run build, 打包完成后，我们可以看到 生成的build.js文件中箭头函数转化为普通函数\n\n\n\n　　\n在开发过程还有一个问题要解决，代码的错误查找。如果代码有错误，我们要知道代码在什么地方出错的。现在webpack-dev-server启动服务器，我们把所有的j\ns代码都打包到一个build.js文件中，我们根本不知道，报错在源代码中的什么位置。这就要用到source-map了，压缩后的代码对应到源代码中。这个只要在配置\n文件中添加devtools 配置项就可以了。\n\n\n\n　　这时npm run dev 重新启动服务器，打开浏览器控制台的source面板，你会发现，它多了一个wepback//\n\n\n\n　　在上面双击，或点击左边的小箭头进行展开，可以看到3个文件夹，点击中间的.\n文件夹，可以发现src目录，里面就是我们的源代码。这时，我们在index.js中加入debugger; 或console.log()\n语句，你就会发现，它指向是源代码中文件，而不是打包后的build.js。测试一下\n\n　　我们在mes.js中写入console.log(1)\n\n\n\n　　然后在webpack.config.js中把 devtools: source-map 注释掉\n\n\n\n　　npm run dev 启动服务器，打开控制台, 你可以所有内容指向的是打包后的build.js\n\n\n\n　　现在把wepback.config.js 中的devtool： 'source-map' 解注,\n再重新启动服务器。配置文件只要有变动，就要重新启动服务器。在控制台中可以看到 1 指向了mes.js\n\n\n\n　　点击mes.js ，就会跳转到mes.js 源文件。\n\n　　利用loader 处理样式\n\n　　在web开发中，肯定少不了写css, css 作为一种资源，也要有相对loader进行解析，有的还会用sass 来写样式, 那还需要把sass\n转换成css. 这时需要安装sass-loader, css-loader, style-loader， sass-loader 还要依赖node-sass,\nnpm install sass-loader node-sass css-loader style-loader --save-dev css-loader\n处理的是css文件中的url import 等等， style-loader 是把样式插入html 文件中style 标签中，内嵌样式。配置文件为如下，\n这里只是更改module 下的内容，增加css loader\n\n　　对于多个loader 去处理 一个文件时，它用的是use 来指定规则，处理顺序就从右向左。 先使用sass-loader, 把sass 文件转换成 css\n文件，所以sass 放在最右边，然后把转换好的css 文件中的url 进行处理，css 放到sass 的左边， 最后把css 样式放入到html\n元素中，那就是style-loader, 它放到最左边。\n\n　　利用loader 处理图片\n\n　　当然 还有一个常用的 loader 叫url-loader, 处理图片，文字等等， 比如把图片变成转成base64编码的,\n这样就可以减少http请求数量。当然也不是所有图片都要转化成base 64 一般都是小于10kb 的图片进行转换，否则，会增大css\n文件的大小。这需要options 对这个loader 进行配置。\n\n\n\n　　webpack的基本配置差不多了，我们再使用几个有用的插件。\n\n　　1，UglifyJsPlugin 插件，webpack 中的Tree Shaking\n用到它。webpack2中最大的变化就是它原生支持ES6模块化方案，并且由此带来了Tree Shaking 功能。 我们重写一下mes.js\n\n\n\n　　再重新写一下index.js文件\n\n\n\n　　可以看到程序正常运行，但是在index.js中，我们只用到了multiply函数，所以打包后的文件中， 我们只想包含multiply\n函数，而不用包含其它两个add, substract 函数，这就是tree shaking. Tree shaking 的前提是ES6\n的模块化方案。而在webpack1 时， 由于它不支持ES6, 所以webpack 会利用babel 把ES6\n转换成commonJs，但现在webpack2中原生支持ES6 的import 和export， 也正是由于ES6 module, 它支持Tree\nShaking, 所以我们不想让babel 把ES6 的import 和export 转换成commonJs， 这时需要配置 .babelrc\n文件，给es2015 设置为modules: false.\n\n\n\n　　只要设定modules: false, babel 遇见import 和 export 就不会转化成commonjs.\n\n　　现在执行npm run build进行打包, 打开build.js, 你会发现下面的内容,它把 add和 substract 标住了unused,\n没有用到这两个函数.\n\n\n\n　　既然没有用到这两个函数，那就要把它们从打包后文件中去掉，这用到了webpack 另外一个插件，UglifyJsPlugin，\n我们在webpack.config.js 配置一下，由于是插件，并且只在生产环境中使用，我们只要修改一下plugins 就可以了。\n\n\n\n　　npm run build 重新打包，可以看到build.js中只有multiply() 函数。\n\n　　2. DefinePlugin插件， 当我们执行npm run\n命令的时候，它会暴露一些全局变量供我们自己的代码使用，这些全局变量是我们自己定义的，而且我们想定义多少就定义多少。\n\n　　定义的方式非常简单，就是给DefinePlugin\n传递一个对象参数，使用也是简单，直接使用对象的属性，获取的是对象属性的值，最有用的是设置环境变量参数，因为我们自己写的代码也是有的在生产环境使用，有的在测试环境\n使用，比如在生产环境中，每次都会调用登陆弹窗，在开发的时候却不需要。直接在上面的代码下面加上\n\n\n\n　　当执行npm run 命令时，它就会暴露一个全局变量 ’env‘, 供我们的代码使用，而它的值就是\n我们定义的JSON.stringify(process.env.NODE_ENV)。 在index.js中直接使用env\n\n\n\n　　当执行npm run dev，重新启动服务器的时候，你可看到页面上显示是developement, 和我们预想的一样，那么我们就可以利用env\n进行判断，如果它是生产环境，如果它是测试。\n\n你可能使用过axios库发送ajax请求，当在不同的环境时请求的地址不一致，这时就可以使用环境变量进行基本url配置\n\n","routePath":"/site/webpack/site/webpack/stalled-webpack3基本使用","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":60,"title":"","content":"深入浅出的webpack构建工具---babel之配置文件.babelrc(三)#\n\n统计信息：字数 16537 阅读34分钟\n\n阅读目录\n\n一：理解 babel之配置文件.babelrc 基本配置项\n\n二：在webpack中配置babel\n\n回到顶部\n\n一：理解 babel之配置文件.babelrc 基本配置项\n\n1. 什么是babel? 它是干什么用的？\n\nES6是2015年发布的下一代javascript语言标准，它引入了新的语法和API，使我们编写js代码更加得心应手，比如class，let,for...of\npromise等等这样的，但是可惜的是这些js新特性只被最新版本的浏览器支持，但是低版本浏览器并不支持，那么低版本浏览器下就需要一个转换工具，把es6代码转换成\n浏览器能识别的代码，babel就是这样的一个工具。可以理解为 babel是javascript语法的编译器。\n\n2. Babel编译器 在Babel执行编译的过程中，会从项目的根目录下的 .babelrc文件中读取配置。.babelrc是一个json格式的文件。\n在.babelrc配置文件中，主要是对预设(presets) 和 插件(plugins) 进行配置。.babelrc配置文件一般为如下：\n\n\n\n2.1 plugins 该属性是告诉babel要使用那些插件，这些插件可以控制如何转换代码。\n\n1. 理解 babel-polyfill 和 babel-runtime 及 babel-plugin-transform-runtime\n\nBabel默认只转换新的javascript语法，而不转换新的API，比如 Iterator, Generator, Set, Maps, Proxy,\nReflect,Symbol,Promise 等全局对象。以及一些在全局对象上的方法(比如 Object.assign)都不会转码。\n比如说，ES6在Array对象上新增了Array.form方法，Babel就不会转码这个方法，如果想让这个方法运行，必须使用\nbabel-polyfill来转换等。\n\n因此：babel-polyfill和babel-runtime就是为了解决新的API与这种全局对象或全局对象方法不足的问题，因此可以使用这两个插件可以转换的。\n\n那么他们两者的区别是什么？ babel-polyfill 的原理是当运行环境中并没有实现的一些方法，babel-polyfill会做兼容。\nbabel-runtime\n它是将es6编译成es5去执行。我们使用es6的语法来编写，最终会通过babel-runtime编译成es5.也就是说，不管浏览器是否支持ES6，只要是ES6的\n语法，它都会进行转码成ES5.所以就有很多冗余的代码。\n\nbabel-polyfill 它是通过向全局对象和内置对象的prototype上添加方法来实现的。比如运行环境中不支持Array.prototype.find\n方法，引入polyfill, 我们就可以使用es6方法来编写了，但是缺点就是会造成全局空间污染。\n\nbabel-runtime:\n它不会污染全局对象和内置对象的原型，比如说我们需要Promise，我们只需要即可，这样不仅避免污染全局对象，而且可以减少不必要的代码。\n\n虽然 babel-runtime 可以解决\nbabel-polyfill中的避免污染全局对象，但是它自己也有缺点的，比如上，如果我现在有100个文件甚至更多的话，难道我们需要一个个文件加\n吗？那这样肯定是不行的，因此这个时候出来一个 叫 babel-plugin-transform-runtime， 它就可以帮助我们去避免手动引入\nimport的痛苦，并且它还做了公用方法的抽离。比如说我们有100个模块都使用promise，但是promise的polyfill仅仅存在1份。 这就是\nbabel-plugin-transform-runtime 插件的作用。\n\n2. 理解 babel-plugin-transform-runtime 的配置一些选项\n\n因此通过上面的理解，我们可以对 transform-runtime 通过如下配置 plugins; 如下代码：\n\n\n\n配置项可以看官网，查看官网\n\n**helpers: 默认值为true，**表示是否开启内联的babel\nhelpers(即babel或者环境本来存在的某些对象方法函数)如：extends，etc这样的 在调用模块名字时将被替换名字。\n\npolyfill：默认值为true，表示是否把内置的东西(Promise, Set, Map)等转换成非全局污染的。\n\n**regenerator：默认值为true，**是否开启generator函数转换成使用regenerator runtime来避免污染全局域。\n\n**moduleName：默认值为 babel-runtime，**当调用辅助 设置模块（module）名字/路径. 比如如下这样设置：\n\n\n\nimport引入文件如下这个样子：\n\n\n\n3 presets presets属性告诉Babel要转换的源码使用了哪些新的语法特性，presets是一组Plugins的集合。\n\n3.1 理解 babel-preset-env\n\n比如：\n\nbabel-preset-es2015: 可以将es6的代码编译成es5. babel-preset-es2016: 可以将es7的代码编译为es6.\nbabel-preset-es2017: 可以将es8的代码编译为es7. babel-preset-latest:\n支持现有所有ECMAScript版本的新特性。\n\n举个列子，比如我们需要转换es6语法，我们可以在 .babelrc的plugins中按需引入一下插件，比如：\ncheck-es2015-constants、es2015-arrow-functions、es2015-block-scoped-functions等等几十个\n不同作用的plugin： 那么配置项可能是如下方式：\n\n\n\n但是Babel团队为了方便，将同属ES2015的几十个Transform\nPlugins集合到babel-preset-es2015一个Preset中，这样我们只需要在.babelrc的presets加入es2015一个配置就可以完成\n全部ES2015语法的支持了： 如下配置：\n\n\n\n但是我们随着时间的推移，将来可能会有跟多的版本插件,比如 bebel-preset-es2018,.... 等等。 因此 babel-preset-env\n出现了，它的功能类似于 babel-preset-latest，它会根据目标环境选择不支持的新特性来转译。\n\n首先需要在项目中安装，如下命令：\n\n\n\n在.babelrc配置文件中 可以如下简单的配置：\n\n\n\n我们还可以仅仅配置项目所支持的浏览器的配置\n\n\\1. 支持每个浏览器最后两个版本和safari大于等于7版本所需的polyfill代码转换，我们可以如下配置：\n\n\n\n\\2. 支持市场份额超过5%的浏览器，可以如下配置：\n\n\n\n\\3. 指定浏览器版本，可以如下配置：\n\n\n\nNode.js 如果通过Babel编译Node.js代码的话，可以设置 \"target.node\" 是 'current', 含义是\n支持的是当前运行版本的nodejs。 如下配置代码：\n\n\n\n理解 babel-preset-env 中的选项配置： 1. targets: {[string]: number | string }, 默认为{};\n含义是支持一个运行环境的对象，比如支持node版本；可以如下配置： node: '6.0'; 运行环境: chrome, opera, edge,\nfirefox, safari, ie, ios, android, node, electron\n\n**2. targets.browsers ** 支持浏览器的配置项，该配置项使用方式可以到\nbrowserslist来查询（https://github.com/browserslist/browserslist） 比如上面的\n支持每个浏览器最后两个版本和safari大于等于7版本。如上配置。\n\n3. modules 该参数的含义是：启用将ES6模块语法转换为另一种模块类型。将该设置为false就不会转换模块。默认为 'commonjs'.\n该值可以有如下： 'amd' | 'umd' | 'systemjs' | 'commonjs' | false\n\n我们在项目中一般会看到如下配置，设置modules: false, 如下代码配置：\n\n\n\n这样做的目的是：以前我们需要使用babel来将ES6的模块语法转换为AMD,\nCommonJS，UMD之类的模块化标准语法，但是现在webpack都帮我做了这件事了，所以我们不需要babel来做，因此需要在babel配置项中设置modul\nes为false，因为它默认值是commonjs, 否则的话，会产生冲突。\n\n4. loose, 该参数值默认为false。 含义是：允许它们为这个 preset 的任何插件启用”loose” 转换。\n\n5. include: 包含一些插件，默认为 []; 比如包含箭头函数，可以如下配置：\n\n\n\n6. exclude； 排除哪些插件，默认为 []; 比如 排除生成器，可以如下配置：\n\n\n\n3.2 理解 babel-presets-stage-x 官方预设(preset),\n有两种，一个是按年份(babel-preset-es2017)，一个是按阶段(babel-preset-stage-0)。 这主要是根据TC39\n委员会ECMASCRPIT 发布流程来制定的。因此到目前为止 有4个不同的阶段预设：\n\n\n\n以上每种预设都依赖于紧随的后期阶段预设，数字越小，阶段越靠后，存在依赖关系。也就是说stage-0是包括stage-1的，以此类推。因此\nstage-0包含stage-1/2/3的内容。所以如果我们不知道需要哪个stage-x的话，直接引入stage-0就好了。\n\nstage0 (https://babeljs.io/docs/en/babel-preset-stage-0) 只是一个美好激进的想法，一些 Babel\n插件实现了对这些特性的支持 ，但是不确定是否会被定为标准.\n\nstage1 (https://babeljs.io/docs/en/babel-preset-stage-1) 值得被纳入标准的特性.\n\nstage2 (https://babeljs.io/docs/en/babel-preset-stage-2) 该特性规范己经被起草，将会被纳入标准里.\n\nstage3 (https://babeljs.io/docs/en/babel-preset-stage-3) 该特性规范已经定稿，大浏览器厂商和\nNode.js 社区己开始着手实现.\n\n但是在我们使用的时候只需要安装你想要的阶段就可以了：比如 babel-preset-stage-2， 安装命令如下：\n\n\n\n回到顶部\n\n二：在webpack中配置babel\n\n在上面了解了babel后，现在我们需要知道如何在webpack中使用它了。由于babel所做的事情是转换代码，所有需要使用loader去转换，因此我们需要配置b\nabel-loader。\n\n在安装babel-loader之前，我们需要安装babel-core，\n因为babel-core是Babel编译器的核心，因此也就意味着如果我们需要使用babel-loader进行es6转码的话，我们首先需要安装\nbabel-core, 安装命令如下即可：\n\n\n\n然后我们再安装 babel-loader, 命令如下：\n\n\n\n接着我们需要安装 babel-preset-env, babel-plugin-transform-runtime, babel-preset-stage-2,\n如下命令安装\n\n\n\n因此 .babelrc 配置如下即可：\n\n\n\n在做demo之前，我们还是先看下目录结构变成如下：\n\n\n\n因此webpack配置中需要添加 babel-loader 配置，如下配置：\n\n\n\nwebpack 所有配置如下代码\n\n\n\npackage.json 安装依赖包如下：\n\n\n\n现在我们继续在 main.js 代码内 编写 Generator 函数，代码如下：\n\n\n\n然后重新运行打包命令 npm run dev 后，打开浏览器运行 可以看到控制台输出 {value: \"a\", done:\nfalse}，说明babel已经转译了。","routePath":"/site/webpack/site/webpack/stalled-webpack4 babel配置文件","lang":"","toc":[{"text":"深入浅出的webpack构建工具---babel之配置文件.babelrc(三)","id":"深入浅出的webpack构建工具---babel之配置文件babelrc三","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":61,"title":"深入浅出的webpack构建工具---DevServer配置项(二)","content":"欢迎你们来访问我","routePath":"/site/webpack/site/webpack/stalled-webpack4DevServer配置项","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":62,"title":"入门 Webpack","content":"","routePath":"/site/webpack/site/webpack/stalled-webpack4入门介绍","lang":"","toc":[{"text":"写在前面的话","id":"写在前面的话","depth":3,"charIndex":-1},{"text":"什么是WebPack，为什么要使用它？","id":"什么是webpack为什么要使用它","depth":3,"charIndex":-1},{"text":"为什要使用WebPack","id":"为什要使用webpack","depth":4,"charIndex":-1},{"text":"什么是Webpack","id":"什么是webpack","depth":4,"charIndex":-1},{"text":"WebPack和Grunt以及Gulp相比有什么特性","id":"webpack和grunt以及gulp相比有什么特性","depth":4,"charIndex":-1},{"text":"开始使用Webpack","id":"开始使用webpack","depth":3,"charIndex":-1},{"text":"安装","id":"安装","depth":4,"charIndex":-1},{"text":"正式使用Webpack前的准备","id":"正式使用webpack前的准备","depth":4,"charIndex":-1},{"text":"正式使用Webpack","id":"正式使用webpack","depth":4,"charIndex":-1},{"text":"通过配置文件来使用`Webpack`","id":"通过配置文件来使用webpack","depth":4,"charIndex":-1},{"text":"更快捷的执行打包任务","id":"更快捷的执行打包任务","depth":4,"charIndex":-1},{"text":"Webpack的强大功能","id":"webpack的强大功能","depth":3,"charIndex":-1},{"text":"生成Source Maps（使调试更容易）","id":"生成source-maps使调试更容易","depth":4,"charIndex":-1},{"text":"使用webpack构建本地服务器","id":"使用webpack构建本地服务器","depth":4,"charIndex":-1},{"text":"Loaders","id":"loaders","depth":4,"charIndex":-1},{"text":"Babel","id":"babel","depth":3,"charIndex":-1},{"text":"Babel的安装与配置","id":"babel的安装与配置","depth":4,"charIndex":-1},{"text":"Babel的配置","id":"babel的配置","depth":4,"charIndex":-1},{"text":"一切皆模块","id":"一切皆模块","depth":3,"charIndex":-1},{"text":"CSS","id":"css","depth":4,"charIndex":-1},{"text":"CSS module","id":"css-module","depth":4,"charIndex":-1},{"text":"CSS预处理器","id":"css预处理器","depth":4,"charIndex":-1},{"text":"插件（Plugins）","id":"插件plugins","depth":3,"charIndex":-1},{"text":"使用插件的方法","id":"使用插件的方法","depth":4,"charIndex":-1},{"text":"HtmlWebpackPlugin","id":"htmlwebpackplugin","depth":4,"charIndex":-1},{"text":"Hot Module Replacement","id":"hot-module-replacement","depth":4,"charIndex":-1},{"text":"产品阶段的构建","id":"产品阶段的构建","depth":3,"charIndex":-1},{"text":"优化插件","id":"优化插件","depth":4,"charIndex":-1},{"text":"缓存","id":"缓存","depth":4,"charIndex":-1},{"text":"去除`build`文件中的残余文件","id":"去除build文件中的残余文件","depth":4,"charIndex":-1},{"text":"总结","id":"总结","depth":3,"charIndex":-1},{"text":"更新说明","id":"更新说明","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":63,"title":"","content":"","routePath":"/site/webpack/site/webpack/stalled-webpack4基本配置","lang":"","toc":[{"text":"深入浅出的webpack构建工具---webpack基本配置(一)","id":"深入浅出的webpack构建工具---webpack基本配置一","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":64,"title":"UglifyJS Webpack Plugin","content":"第一部分#\n\n统计信息：字数 66849 阅读134分钟\n\n参考文档：\n\n原文的图片无法加载，可以自己写出来\n\nhttps://juejin.im/post/5b5d6d6f6fb9a04fea58aabc\n\nhttps://juejin.im/post/5b56909a518825195f499806\n\nhttps://github.com/webpack-contrib/uglifyjs-webpack-plugin\n\n正好我也在使用一个文档生成工具 docz(安利一波) 也最低需要webpack 4+，新版webpack性能提高了不少，而且webpack 4\n都已经发布五个多月了，想必应该已经没什么坑了，应该可以安心的按照别人写的升级攻略升级了。之前一直迟迟不升级完全是被去年被 webpack 3 坑怕了。它在\ncode splitting 的情况下 CommonsChunkPlugin会完全失效。过了好一段时间才修复，欲哭无泪。\n\n所以这次我等了快大半年才准备升级到webpack 4 但万万没想到还是遇到了不少的问题！\n有很多之前遗留的问题还是没有很好地解决。但最主要的问题还是它的文档有所欠缺，已经废除了的东西如commonsChunkPlugin还在官方文档中到处出现，很多重\n要的东西却一笔带过，甚至没写，需要用户自己去看源码才能解决。\n\n还比如在v4.16.0版本中废除了optimization.occurrenceOrder、optimization.namedChunks、optimizat\nion.hashedModuleIds、optimization.namedModules 这几个配置项，替换成了optimization.moduleIds\n和 optimization.chunkIds，但文档完中全没有任何体现，所以你在新版本中还按照文档那样配置其实是没有任何效果的。\n\n最新最完整的文档还是看他项目的配置WebpackOptions.json，强烈建议遇到不清楚的配置项可以看这个，因为它一定保证是和最新代码同步的。\n\n吐槽了这么多，我们言归正传。由于本次手摸手篇幅有些长，所以拆解成了上下两篇文章：\n\n * 上篇 -- 就是普通的在webpack 3的基础上升级，要做哪些操作和遇到了哪些坑\n * 下篇 -- 是在webpack 4下怎么合理的打包和拆包，并且如何最大化利用 long term caching\n\n本文章不是手摸手从零教你 webpack 配置，所以并不会讲太多很基础的配置问题。比如如何处理 css 文件，如何配置\nwebpack-dev-server，讲述 file-loader 和 url-loader 之间的区别等等，有需求的推荐看 官方文档 或者 survivejs\n出的一个系列教程。或者推荐看我司的另一篇 wbepack 入门文章，已同步到 webpack4 传送门。\n\n\n升级篇#\n\n\n前言#\n\n我一直认为模仿和借鉴是学习一个新东西最高效的方法。所以我建议还是通过借鉴一些成熟的 webpack 配置比较好。比如你项目是基于 react 生态圈的话可以借鉴\ncreate-react-app ，下载之后npm run eject 就可以看到它详细的 webpack 配置了。vue 的话由于新版vue cli不支持\neject了，而且改用 webpack-chain来配置，所以借鉴起来可能会不太方便，主要配置 地址。觉得麻烦的话你可以直接借鉴\nvue-element-admin 的 配置。或者你想自己发挥，你可以借鉴 webpack 官方的各种 examples，来组合你的配置。\n\n\n升级 webpack#\n\n首先将 webpack 升级到 4 之后，直接运行webpack\n--xxx是不行的，因为新版本将命令行相关的东西单独拆了出去封装成了webpack-cli。会报如下错误：\n\n> The CLI moved into a separate package: webpack-cli. Please install webpack-cli\n> in addition to webpack itself to use the CLI.\n\n所有你需要安装npm install webpack-cli -D -S。你也可将它安装在全局。\n\n同时新版 webpack 需要Node.js 的最低支持版本为 6.11.5不要忘了升级。如果还需要维护老项目可以使用 nvm 来做一下 node 版本管理。\n\n升级所有依赖\n\n因为webpack4改了 它的hook api ，所以所有的loaders、plugins都需要升级才能够适配。\n\n可以使用命令行 npm outdated，列出所以可以更新的包。免得再一个个去npm找相对于的可用版本了。\n\n\n\n反正把devDependencies的依赖都升级一下，总归不会有错。\n\n\n带来的变化#\n\n其实这次升级带来了不少改变，但大部分其实对于普通用户来说是不需要关注的，比如这次升级带来的功能SideEffects、Module Type’s\nIntroduced、WebAssembly\nSupport，基本平时是用不到的。我们主要关注那些对我们影响比较大的改动如：optimization.splitChunks代替原有的CommonsChunk\nPlugin(下篇文章会着重介绍)，和Better Defaults-mode更好的默认配置，这是大家稍微需要关注一下的。\n\n\n\n> 如果想进一步了解 Tree Shaking和SideEffects的可见文末拓展阅读。 上图参考 Webpack 4 进阶\n\n\n默认配置#\n\nwebpack 4 引入了零配置的概念，被 parcel 刺激到了。 不管效果怎样，这改变还是值得称赞的。\n\n> 最近又新出了 Fastpack 可以关注一下。\n\n言归正题，我们来看看 webpack 默认帮我们做了些什么?\n\ndevelopment 模式下，默认开启了NamedChunksPlugin\n和NamedModulesPlugin方便调试，提供了更完整的错误信息，更快的重新编译的速度。\n\n\n\nproduction 模式下，由于提供了splitChunks和minimize，所以基本零配置，代码就会自动分割、压缩、优化，同时 webpack\n也会自动帮你 Scope hoisting 和 Tree-shaking。\n\n\n\nwebpack 一直以来最饱受诟病的就是其配置门槛极高，配置内容极其复杂和繁琐，容易让人从入门到放弃，而它的后起之秀如 rollup、parcel\n等均在配置流程上做了极大的优化，做到开箱即用，所以webpack 4 也从中借鉴了不少经验来提升自身的配置效率。愿世间再也不需要 webpack 配置工程师。\n\n\nhtml-webpack-plugin#\n\n用最新版本的的 html-webpack-plugin你可能还会遇到如下的错误：\n\n\n\n产生这个 bug 的原因是循环引用依赖，如果你没有这个问题可以忽略。\n\n目前解决方案可以使用 Alpha 版本，npm i --save-dev html-webpack-plugin@next\n\n或者加入chunksSortMode: 'none'就可以了。\n\n但仔细查看文档发现设置成chunksSortMode: 'none'这样是会有问题的。\n\n> Allows to control how chunks should be sorted before they are included to the\n> HTML.\n\n这属性会决定你 chunks 的加载顺序，如果设置为none，你的 chunk\n加载在页面中加载的顺序就不能够保证了，可能会出现样式被覆盖的情况。比如我在app.css里面修改了一个第三方库element-ui的样式，通过加载顺序的先后来覆\n盖它，但由于设置为了none，打包出来的结果变成了这样：\n\n\n\napp.css被先加载了，之前写的样式覆盖就失效了，除非你使用important或者其它 css 权重的方式覆盖它，但这明显是不太合理的。\nvue-cli正好也有这个相关 issue，尤雨溪也在不使用@next版本的基础上 hack\n了它，有兴趣的可以自己研究一下，本人在项目中直接使用了@next版本，也没遇到其它什么问题（除了不兼容 webpack 的 prefetch/preload\n相关 issue）。两种方案都可以，自行选择。\n\n其它 html-webpack-plugin 的配置和之前使用没有什么区别。\n\n\nmini-css-extract-plugin#\n\n\n与 extract-text-webpack-plugin 区别#\n\n由于webpack4对 css 模块支持的完善以及在处理 css\n文件提取的方式上也做了些调整，所以之前我们一直使用的extract-text-webpack-plugin也完成了它的历史使命，将让位于mini-css-ext\nract-plugin。\n\n使用方式也很简单，大家看着 文档 抄就可以了。\n\n它与extract-text-webpack-plugin最大的区别是：它在code spliting的时候会将原先内联写在每一个 js chunk\nbundle的 css，单独拆成了一个个 css 文件。\n\n原先 css 是这样内联在 js 文件里的：\n\n\n\n将 css 独立拆包最大的好处就是 js 和 css 的改动，不会影响对方。比如我改了 js 文件并不会导致 css\n文件的缓存失效。而且现在它自动会配合optimization.splitChunks的配置，可以自定义拆分 css\n文件，比如我单独配置了element-ui作为单独一个bundle,它会自动也将它的样式单独打包成一个 css 文件，不会像以前默认将第三方的 css\n全部打包成一个几十甚至上百 KB 的app.xxx.css文件了。\n\n\n\n\n压缩与优化#\n\n打包 css 之后查看源码，我们发现它并没有帮我们做代码压缩，这时候需要使用 optimize-css-assets-webpack-plugin\n这个插件，它不仅能帮你压缩 css 还能优化你的代码。\n\n\n\n\n\n如上图测试用例所示，由于optimize-css-assets-webpack-plugin这个插件默认使用了 cssnano 来作 css 优化，\n所以它不仅压缩了代码、删掉了代码中无用的注释、还去除了冗余的 css、优化了 css 的书写顺序，优化了你的代码 margin: 10px 20px 10px\n20px; =>margin:10px 20px;。同时大大减小了你 css 的文件大小。更多优化的细节见文档。\n\n\ncontenthash#\n\n但使用 MiniCssExtractPlugin 有一个需求特别注意的地方，在默认文档中它是这样配置的：\n\n\n\n> 简单说明一下： filename\n> 是指在你入口文件entry中引入生成出来的文件名，而chunkname是指那些未被在入口文件entry引入，但又通过按需加载（异步）模块的时候引入的文件。\n\n在 copy 如上代码使用之后发现情况不对！每次改动一个xx.js文件，它对应的 css 虽然没做任何改动，但它的 文件 hash\n还是会发生变化。仔细对比发现原来是 hash 惹的祸。 6.f3bfa3af.css => 6.40bc56f6.css\n\n\n\n但我这是根据官方文档来写的！为什么还有问题！后来在文档的最最最下面发下了这么一段话！\n\n> For long term caching use filename: [contenthash].css. Optionally add [name].\n\n非常的不理解，这么关键的一句话会放在 Maintainers 还后面的地方，默认写在配置里面提示大家不是更好？有热心群众已经开了一个pr，将文档默认配置为\ncontenthash。chunkhash => contenthash相关 issue。\n\n这个真的蛮过分的，稍不注意就会让自己的 css 文件缓存无效。而且很多用户平时修改代码的时候都不会在意自己最终打包出来的\ndist文件夹中到底有哪些变化。所以这个问题可能就一直存在了。浪费了多少资源！人艰不拆！大家觉得 webpack 难用不是没道理的。\n\n补充一点：目前MiniCssExtractPlugin也不是非常完美的，它现在默认会将每个 bundle 的 css 独立于 js文件， 单独拆成一个 css\n文件。但这样会产生一个新的问题。比如我有一个页面它只有一行css，但也会被拆成了一个独立的css文件，还需要额外的一次 http\n请求，非常的不合理。所以我就给官方提了一个 issue，呼吁增加一个minSize，当 css 的内容小于这个size的时候还是内联到 js\n文件中，期待官方增加这个功能。\n\n\n这里再简单说明一下几种 hash 的区别：#\n\n * hash\n\nhash 和每次 build有关，没有任何改变的情况下，每次编译出来的 hash都是一样的，但当你改变了任何一点东西，它的hash就会发生改变。\n\n简单理解，你改了任何东西，hash 就会和上次不一样了。\n\n * chunkhash\n\nchunkhash是根据具体每一个模块文件自己的的内容包括它的依赖计算所得的hash，所以某个文件的改动只会影响它本身的hash，不会影响其它文件。\n\n * contenthash\n\n它的出现主要是为了解决，让css文件不受js文件的影响。比如foo.css被foo.js引用了，所以它们共用相同的chunkhash值。但这样子是有问题的，如果\nfoo.js修改了代码，css文件就算内容没有任何改变，由于是该模块的 hash 发生了改变，其css文件的hash也会随之改变。\n\n这个时候我们就可以使用contenthash了，保证即使css文件所处的模块里有任何内容的改变，只要 css 文件内容不变，那么它的hash就不会发生变化。\n\ncontenthash 你可以简单理解为是 moduleId + content 所生成的 hash。\n\n\n热更新速度#\n\n其实相对 webpack\n线上打包速度，我更关心的本地开发热更新速度，毕竟这才是和我们每一个程序员每天真正打交道的东西，打包一般都会扔给CI自动执行，而且一般项目每天也不会打包很多次。\n\nwebpack\n4一直说自己更好的利用了cache提高了编译速度，但实测发现是有一定的提升，但当你一个项目，路由懒加载的页面多了之后，50+之后，热更新慢的问题会很明显，之前的\n文章中也提到过这个问题，原以为新版本会解决这个问题，但并没有。\n\n不过你首先要排斥你的热更新慢不是，如：\n\n * 没有使用合理的 Devtool souce map 导致\n * 没有正确使用 exclude/include 处理了不需要处理的如node_modules\n * 在开发环境不要压缩代码UglifyJs、提取 css、babel polyfill、计算文件 hash 等不需要的操作\n\n旧方案\n\n最早的方案是开发环境中不是用路由懒加载了，只在线上环境中使用。封装一个_import函数，通过环境变区分是否需要懒加载。\n\n开发环境：\n\n\n\n生成环境：\n\n\n\n但由于 webpack import实现机制问题，会产生一定的副作用。如上面的写法就会导致@/views/下的 所有.vue\n文件都会被打包。不管你是否被依赖引用了，会多打包一些可能永远都用不到 js 代码。 相关 issue\n\n目前新的解决方案思路还是一样的，只在生成模式中使用路由懒加载，本地开发不使用懒加载。但换了一种没副作用的实现方式。\n\n新方案\n\n使用babel 的 plugins\nbabel-plugin-dynamic-import-node。它只做一件事就是：将所有的import()转化为require()，这样就可以用这个插件将所有\n异步组件都用同步的方式引入了，并结合 BABEL_ENV\n这个bebel环境变量，让它只作用于开发环境下。将开发环境中所有import()转化为require()，这种方案解决了之前重复打包的问题，同时对代码的侵入性也\n很小，你平时写路由的时候只需要按照官方文档路由懒加载的方式就可以了，其它的都交给babel来处理，当你不想用这个方案的时候，也只需要将它从babel 的\nplugins中移除就可以了。\n\n具体代码：\n\n首先在package.json中增加BABEL_ENV\n\n\n\n接着在.babelrc只能加入babel-plugin-dynamic-import-node这个plugins，并让它只有在development模式中才生效\n。\n\n\n\n之后就大功告成了，路由只要像平时一样写就可以了。文档\n\n\n\n这样能大大提升你热更新的速度。基本两百加页面也能在2000ms的热跟新完成，基本做到无感刷新。当然你的项目本身就不大页面也不多，完全没必要搞这些。当你的页面变化\n跟不是你写代码速度的时候再考虑也不迟。\n\n\n打包速度#\n\nwebpack 4 在项目中实际测了下，普遍能提高 20%~30%的打包速度。\n\n本文不准备太深入的讲解这部分内容，详细的打包优化速度可以参考 slack 团队的这篇文章，掘金还有译文.\n\n这里有几个建议来帮你加速 webpack 的打包速度。\n\n首先你需要知道你目前打包慢，是慢在哪里。\n\n我们可以用 speed-measure-webpack-plugin 这个插件，它能监控 webpack 每一步操作的耗时。如下图：\n\n\n\n可以看出其实大部分打包花费的时间是在Uglifyjs压缩代码。和前面的提升热更新的切入点差不多，查看source\nmap的正确与否，exclude/include的正确使用等等。\n\n使用新版的UglifyJsPlugin的时候记住可以加上cache: true、parall: true，可以提搞代码打包压缩速度。更多配置可以参考 文档 或者\nvue-cli 的 配置。\n\n编译的时候还有还有一个很慢的原因是那些第三方库。比如echarts、element-ui其实都非常的大，比如echarts打包完也还有\n775kb。所以你想大大提高编译速度，可以将这些第三方库 externals 出去，使用script的方式引入，或者使用\ndll的方式打包。经测试一般如echarts这样大的包可以节省十几秒到几十秒不等。\n\n还有可以使用一些并行执行 webpack 的库：如parallel-webpack、happypack。\n\n顺便说一下，升级一下node可能有惊喜。前不久将CI里面的 node 版本依赖从 6.9.2 => 8.11.3，打包速度直接提升了一分多钟。\n\n总之我觉得打包时间控制在差不多的范围内就可以了，没必要过分的优化。可能你研究了半天，改了一堆参数发现其实也就提升了几秒，但维护成本上去了，得不偿失。还不如升级\nnode、升级 webpack、升级你的编译环境的硬件水平来的实在和简单。\n\n比如我司CI使用的是腾讯云普通的的 8 核 16g 的机器，这个项目也是一个很大的后台管理项目\n200+页面，引用了很多第三方的库，但没有使用什么happypack、dll，只是用了最新版的webpack4，node@8.11.3。\n编译速度稳定在两分多钟，完全不觉得有什么要优化的必要。\n\n\n\n\nTree-Shaking#\n\n这其实并不是 webpack 4 才提出来的概念，最早是 rollup 提出来并实现的，后来在 webpack 2 中就实现了，本次在 webpack 4\n只是增加了 JSON Tree Shaking和sideEffects能让你能更好的摇。\n\n不过这里还是要提一下，默认 webpack 是支持Tree-Shaking的，但在你的项目中可能会因为babel的原因导致它失效。\n\n因为Tree Shaking这个功能是基于ES6 modules 的静态特性检测，来找出未使用的代码，所以如果你使用了 babel\n插件的时候，如：babel-preset-env，它默认会将模块打包成commonjs，这样就会让Tree Shaking失效了。\n\n其实在 webpack 2 之后它自己就支持模块化处理。所以只要让 babel 不transform modules就可以了。配置如下：\n\n\n\n顺便说一下都 8102 年了，请不要在使用babel-preset-esxxxx系列了，请用babel-preset-env，相关文章\n再见，babel-preset-2015。\n\n\n第二部分#\n\n本文为手摸手使用 webpack4（下），主要分为两部分：\n\n * 怎么合理的运用浏览器缓存\n * 怎么构建可靠的持久化缓存\n\n\n默认分包策略#\n\nwebpack 4 最大的改动就是废除了 CommonsChunkPlugin 引入了 optimization.splitChunks。\n\nwebpack 4 的Code Splitting 它最大的特点就是配置简单，如果你的 mode 是 production，那么 webpack 4\n就会自动开启 Code Splitting。\n\n\n\n> 以下内容都会以 vue-element-admin 为例子。 在线 bundle-report\n\n如上图所示，在没配置任何东西的情况下，webpack 4 就智能的帮你做了代码分包。入口文件依赖的文件都被打包进了app.js，那些大于 30kb\n的第三方包，如：echarts、xlsx、dropzone等都被单独打包成了一个个独立 bundle。\n\n它内置的代码分割策略是这样的：\n\n * 新的 chunk 是否被共享或者是来自 node_modules 的模块\n\n * 新的 chunk 体积在压缩之前是否大于 30kb\n\n * 按需加载 chunk 的并发请求数量小于等于 5 个\n\n * 页面初始加载时的并发请求数量小于等于 3 个\n\n\n\n但有一些小的组件，如上图：vue-count-to 在未压缩的情况下只有 5kb，虽然它被两个页面共用了，但 webpack 4\n默认的情况下还是会将它和那些懒加载的页面代码打包到一起，并不会单独将它拆成一个独立的 bundle。（虽然被共用了，但因为体积没有大于 30kb）\n\n你可能会觉得 webpack\n默认策略是不是有问题，我一个组件被多个页面，你每个页面都将这个组件打包进去了，岂不是会重复打包很多次这个组件？就拿vue-count-to来举例，你可以把共用两\n次以上的组件或者代码单独抽出来打包成一个 bundle，但你不要忘了vue-count-to未压缩的情况下就只有 5kb，gizp 压缩完可能只有 1.5kb\n左右，你为了共用这 1.5kb 的代码，却要额外花费一次 http 请求的时间损耗，得不偿失。我个人认为 webpack\n目前默认的打包规则是一个比较合理的策略了。\n\n但有些场景下这些规则可能就显得不怎么合理了。比如我有一个管理后台，它大部分的页面都是表单和 Table，我使用了一个第三方 table\n组件，几乎后台每个页面都需要它，但它的体积也就 15kb，不具备单独拆包的标准，它就这样被打包到每个页面的 bundle\n中了，这就很浪费资源了。这种情况下建议把大部分页面能共用的组件单独抽出来，合并成一个component-vendor.js的包（后面会介绍）。\n\n优化没有银弹，不同的业务，优化的侧重点是不同的。个人认为 webpack 4\n默认拆包已经做得不错了，对于大部分简单的应用来说已经够用了。但作为一个通用打包工具，它是不可能满足所有的业务形态和场景的，所以接下来就需要我们自己稍微做一些优化\n了。\n\n\n优化分包策略#\n\n就拿 vue-element-admin 来说，它是一个基于 Element-UI 的管理后台，所以它会用到如\necharts、xlsx、dropzone等各种第三方插件，同时又由于是管理后台，所以本身自己也会写很多共用组件，比如各种封装好的搜索查询组件，共用的业务模块等\n等，如果按照默认的拆包规则，结果就不怎么完美了。\n\n如第一张图所示，由于element-ui在entry入口文件中被引入并且被大量页面共用，所以它默认会被打包到 app.js\n之中。这样做是不合理的，因为app.js里还含有你的router 路由声明、store 全局状态、utils 公共函数，icons 图标等等这些全局共用的东西。\n\n但除了element-ui，其它这些又是平时开发中经常会修改的东西，比如我新增了一个全局功能函数，utils文件就会发生改变，或者我修改一个路由的\npath，router文件就变了，这些都会导致app.js的 hash 发生改变：app.1.js => app.2.js。但由于 element-ui和\nvue/react等也被打包在其中，虽然你没改变它们，但它们的缓存也会随着app.xxx.js变化而失效了，这就非常不合理的。所以我们需要自己来优化一下缓存策略\n。\n\n我们现在的策略是按照体积大小、共用率、更新频率重新划分我们的包，使其尽可能的利用浏览器缓存。\n\n\n\n我们根据上表来重新划分我们的代码就变成了这样。\n\n * 基础类库 chunk-libs\n\n它是构成我们项目必不可少的一些基础类库，比如 vue+vue-router+vuex+axios\n这种标准的全家桶，它们的升级频率都不高，但每个页面都需要它们。（一些全局被共用的，体积不大的第三方库也可以放在其中：比如\nnprogress、js-cookie、clipboard 等）\n\n * UI 组件库\n\n理论上 UI 组件库也可以放入 libs 中，但这里单独拿出来的原因是： 它实在是比较大，不管是 Element-UI还是Ant Design gizp\n压缩完都可能要 200kb 左右，它可能比 libs 里面所有的库加起来还要大不少，而且 UI 组件库的更新频率也相对的比 libs\n要更高一点。我们不时的会升级 UI 组件库来解决一些现有的 bugs 或使用它的一些新功能。所以建议将 UI 组件库也单独拆成一个包。\n\n * 自定义组件/函数 chunk-commons\n\n这里的 commons 主要分为 必要和非必要。\n\n必要组件是指那些项目里必须加载它们才能正常运行的组件或者函数。比如你的路由表、全局 state、全局侧边栏/Header/Footer 等组件、自定义 Svg\n图标等等。这些其实就是你在入口文件中依赖的东西，它们都会默认打包到app.js中。\n\n非必要组件是指被大部分页面使用，但在入口文件 entry 中未被引入的模块。比如：一个管理后台，你封装了很多 select 或者 table\n组件，由于它们的体积不会很大，它们都会被默认打包到到每一个懒加载页面的 chunk\n中，这样会造成不少的浪费。你有十个页面引用了它，就会包重复打包十次。所以应该将那些被大量共用的组件单独打包成chunk-commons。\n\n不过还是要结合具体情况来看。一般情况下，你也可以将那些非必要组件\\函数也在入口文件 entry\n中引入，和必要组件\\函数一同打包到app.js之中也是没什么问题的。\n\n * 低频组件\n\n低频组件和上面的共用组件 chunk-commons 最大的区别是，它们只会在一些特定业务场景下使用，比如富文本编辑器、js-xlsx前端 excel\n处理库等。一般这些库都是第三方的且大于 30kb，所以 webpack 4 会默认打包成一个独立的 bundle。也无需特别处理。小于 30kb\n的情况下会被打包到具体使用它的页面 bundle 中。\n\n * 业务代码\n\n这部分就是我们平时经常写的业务代码。一般都是按照页面的划分来打包，比如在 vue 中，使用路由懒加载的方式加载页面 component: () =>\nimport('./Foo.vue') webpack 默认会将它打包成一个独立的 bundle。\n\n完整配置代码：\n\n\n\n\n\n上图就是最终拆包结果概要，你可以 点我点我点我，在线查看拆包结果。\n\n这样就能尽可能的利用了浏览器缓存。当然这种优化还是需要因项目而异的。比如上图中的共用组件\nchunk-commons，可能打包出来发现特别大，包含了很多组件，但又不是每一个页面或者大部分页面需要它。很可能出现这种状况：A 页面只需要\nchunk-commons里面的 A 组件，\n但却要下载整个chunk-commons.js，这时候就需要考虑一下，目前的拆包策略是否合理，是否还需要chunk-commons？还是将这些组件打包到各自的\nbundle 中？还是调整一下 minChunks: 2（ 最小共用次数）？或者修改一下它的拆包规则？\n\n\n\n\n博弈#\n\n其实优化就是一个博弈的过程，是让 a bundle 大一点还是 b? 是让首次加载快一点还是让 cache 的利用率高一点？\n但有一点要切记，拆包的时候不要过分的追求颗粒化，什么都单独的打成一个\nbundle，不然你一个页面可能需要加载十几个.js文件，如果你还不是HTTP/2的情况下，请求的阻塞还是很明显的(受限于浏览器并发请求数)。所以还是那句话资源\n的加载策略并没什么完全的方案，都需要结合自己的项目找到最合适的拆包策略。\n\n> 比如支持HTTP/2的情况下，你可以使用 webpack4.15.0 新增的\n> maxSize，它能将你的chunk在minSize的范围内更加合理的拆分，这样可以更好地利用HTTP/2来进行长缓存(在HTTP/2的情况下，缓存策略就和\n> 之前又不太一样了)。\n\n--------------------------------------------------------------------------------\n\n\nLong term caching#\n\n持久化缓存其实是一个老生常谈的问题，前端发展到现在，缓存方案已经很成熟了。简单原理：\n\n * 针对 html 文件：不开启缓存，把 html 放到自己的服务器上，关闭服务器的缓存\n * 针对静态的 js，css，图片等文件：开启 cdn 和缓存，将静态资源上传到 cdn\n   服务商，我们可以对资源开启长期缓存，因为每个资源的路径都是独一无二的，所以不会导致资源被覆盖，保证线上用户访问的稳定性。\n * 每次发布更新的时候，先将静态资源(js, css, img) 传到 cdn 服务上，然后再上传 html\n   文件，这样既保证了老用户能否正常访问，又能让新用户看到新的页面。\n\n相关文章 大公司里怎样开发和部署前端代码？\n\n所以我们现在要做的就是要让 webpack 给静态资源生产一个可靠的 hash，让它能自动在合适的时候更新资源的 hash， 并且保证 hash\n值的唯一性，即为每个打包后的资源生成一个独一无二的 hash 值，只要打包内容不一样，那么 hash 值就不一样。\n\n其实 webpack 4 在持久化缓存这一块已经做得非常的不错了，但还是有一些欠缺，下面我们将要从这几个方面讨论这个问题。\n\n * RuntimeChunk(manifest)\n * Module vs Chunk\n * HashedModuleIdsPlugin\n * NamedChunksPlugin\n\n\nRuntimeChunk(manifest)#\n\nwebpack 4 提供了 runtimeChunk 能让我们方便的提取 manifest，以前我们需要这样配置\n\n\n\n现在只要一行配置就可以了\n\n\n\n它的作用是将包含chunks 映射关系的 list单独从 app.js里提取出来，因为每一个 chunk 的 id 基本都是基于内容 hash\n出来的，所以你每次改动都会影响它，如果不将它提取出来的话，等于app.js每次都会改变。缓存就失效了。\n\n单独抽离 runtimeChunk 之后，每次打包都会生成一个runtimeChunk.xxx.js。（默认叫这名字，可自行修改）\n\n![img](data:image/svg+xml;utf8,)\n\n优化\n\n其实我们发现打包生成的 runtime.js非常的小，gzip 之后一般只有几 kb，但这个文件又经常会改变，我们每次都需要重新请求它，它的 http\n耗时远大于它的执行时间了，所以建议不要将它单独拆包，而是将它内联到我们的 index.html 之中(index.html 本来每次打包都会变)。\n\n这里我选用了 script-ext-html-webpack-plugin，主要是因为它还支持preload和\nprefetch，正好需要就不想再多引用一个插件了，你完全可以使用 inline-manifest-webpack-plugin或者\nassets-webpack-plugin等来实现相同的效果。\n\n\n\n\nModule vs Chunk#\n\n我们经常看到xxxModuleIdsPlugin、xxxChunksPlugin，所以在 webpack 中 module和\nchunk到底是一个怎么样的关系呢？\n\n * chunk: 是指代码中引用的文件（如：js、css、图片等）会根据配置合并为一个或多个包，我们称一个包为 chunk。\n * module: 是指将代码按照功能拆分，分解成离散功能块。拆分后的代码块就叫做 module。可以简单的理解为一个 export/import 就是一个\n   module。\n\n每个 chunk 包可含多个 module。 比如：\n\n\n\n一个module还能跨chunk引用另一个module，比如我想在app.js里面需要引用 chunkId为13的模块2700可以这样引用：\n\n\n\n\nHashedModuleIdsPlugin#\n\n了解了 module和chunk之后，我们来研究一下 moduleId。\n\n首先要确定你的 filename 配置的是chunkhash(它与 hash 的区别可以看上篇文章)。\n\n\n\n我们在入口文件中随便引入一个新文件test.js\n\n\n\n我们运行npm run build，发现了一件奇怪的事情，我只是多引入了一个文件，但发现有十几个文件发生了变化。这是为什么呢？\n\n我们随便挑一个文件 diff 一下，发现两个文件只有 module id 的不同。\n\n![img](data:image/svg+xml;utf8,)\n\n这是因为： webpack 内部维护了一个自增的 id，每个 module 都有一个 id。所以当增加或者删除 module 的时候，id\n就会变化，导致其它文件虽然没有变化，但由于 id 被强占，只能自增或者自减，导致整个 id 的顺序都错乱了。\n\n虽然我们使用 [chunkhash] 作为输出名，但仍然是不够的。 因为 chunk 内部的每个 module 都有一个 id，webpack\n默认使用递增的数字作为 moduleId。 如果引入了一个新文件或删掉一个文件，都可能会导致其它文件的 moduleId 发生改变， 那这样缓存失效了。如：\n\n![img](data:image/svg+xml;utf8,)\n\n本来是一个按序的 moduleId list，这时候我插入一个orange模块，插在第三个位置，这样就会导致它之后的所以 module id 都依次加了 1。\n\n这到了原因，解决方案就很简单了。我们就不要使用一个自增的 id 就好了，这里我们使用HashedModuleIdsPlugin。\n\n> 或者使用optimization.moduleIds v4.16.0 新发布，文档还没有。查看\n> 源码发现它有natural、named、hashed、size、total-size。这里我们设置为optimization.moduleIds='hash\n> '等于HashedModuleIdsPlugin。源码了也写了webpack5会优化这部分代码。\n\n它的原理是使用文件路径的作为 id，并将它 hash 之后作为 moduleId。\n\n![img](data:image/svg+xml;utf8,)\n\n使用了 HashedModuleIdsPlugin`，我们再对比一下发现 module id 不再是简单的 id 了，而是一个四位 hash\n过得字符串(不一定都是四位的，如果重复的情况下会增加位数，保证唯一性 源码)。 这样就固定住了 module id 了。\n\n> NamedModulesPlugin 和 HashedModuleIdsPlugin 原理是相同的，将文件路径作为 id，只不过没有把路径 hash\n> 而已，适用于开发环境方便调试。不建议在生产环境配置，因为这样不仅会增加文件的大小（路径一般偶读比较长），更重要的是为暴露你的文件路径。\n\n\nNamedChunkPlugin#\n\n我们在固定了 module id 之后同理也需要固定一下 chunk id，不然我们增加 chunk 或者减少 chunk 的时候会和 module id\n一样，都可能会导致 chunk 的顺序发生错乱，从而让 chunk 的缓存都失效。\n\n作者也意识到了这个问题，提供了一个叫NamedChunkPlugin的插件，但在使用路由懒加载的情况下，你会发现NamedChunkPlugin并没什么用。\n供了一个线上demo，可以自行测一下。这里提就直接贴一下结果：\n\n![img](data:image/svg+xml;utf8,)\n\n产生的原因前面也讲了，使用自增 id 的情况下是不能保证你新添加或删除 chunk 的位置的，一旦它改变了，这个顺序就错乱了，就需要重排，就会导致它之后的所有\nid 都发生改变了。\n\n接着我们 查看源码 还发现它只对有 name 的 chunk\n才奏效！所以我们那些异步懒加载的页面都是无效的。这启不是坑爹！我们迭代业务肯定会不断的添加删除页面，这岂不是每新增一个页面都会让之前的缓存都失效？那我们之前还费\n这么大力优化什么拆包呢？\n\n其实这是一个古老的问题了 相关 issue: Vendor chunkhash changes when app code changes 早在 2015\n年就有人提了这个问题，这个问题也一直讨论至今，'网友们'也提供了各种奇淫巧技，不过大部分随着 webpack 的迭代已经不适用或者是修复了。\n\n这里我就结合一下 timse(webpack 第二多贡献)写的持久缓存的文章(在 medium 上需要翻墙) 总结一下目前能解决这个问题的三种方案。\n\n目前解决方案有三种\n\n * records\n * webpackChunkName\n * 自定义 nameResolver\n\n\nwebpack records#\n\n很多人可能连这个配置项都没有注意过，不过早在 2015 年就已经被设计出来让你更好的利用 cache。官方文档\n\n要使用它配置也很简单：\n\n\n\n对，只要这一行代码就能开启这个选项，并打包的时候会自动生成一个 JSON 文件。它含有 webpack 的 records 记录 -\n即「用于存储跨多次构建(across multiple builds)的模块标识符」的数据片段。可以使用此文件来跟踪在每次构建之间的模块变化。\n\n大白话就是：等于每次构建都是基于上次构建的基础上进行的。它会先读取你上次的 chunk 和 module id 的信息之后再进行打包。所以这时候你再添加或者删除\nchunk，并不会导致之前所说的乱序了。\n\n简单看一下构建出来的 JSON 长啥样。\n\n\n\n我们和之前一样，在路由里面添加一个懒加载的页面，打包对比后发现 id 并不会像之前那样按照遍历到的顺序插入了，而是基于之前的 id\n依次累加了。一般新增页面都会在末尾填写一个新 id，删除 chunk 的话，会将原来代表 chunk 的 id，保留，但不会再使用。\n\n\n\n但这个方案不被大家知晓主要原因就是维护这个records.json比较麻烦。如果你是在本地打包运行webpack的话，你只要将records.json当做普通文\n件上传到github、gitlab或其它版本控制仓库。\n\n但现在一般公司都会将打包放在 CI里面，用docker打包，这时候这份records.json存在哪里就是一个问题了。它不仅需要每次打包之前先读取你这份\njson，打包完之后它还需要再更新这份 json，并且还要找地方存贮，为了下次构建再使用。你可以存在 git\n中或者找一个服务器存，但存在什么地其它方都感觉怪怪的。\n\n如果你使用 Circle CI可以使用它的store_artifacts，相关教程。\n\n本人在使用了之后还是放弃了这个方案，使用成本略高。前端打包应该更加的纯粹，不需要依赖太多其它的东西。\n\n\nwebpackChunkName#\n\n在 webpack2.4.0 版本之后可以自定义异步 chunk 的名字了，例如：\n\n\n\n我们在结合 vue 的懒加载可以这样写。\n\n\n\n打包之后就生成了名为 test的 chunk 文件。\n\n\n\nchunk 有了 name 之后就可以解决NamedChunksPlugin没有 name 的情况下的 bug 了。查看打包后的代码我们发现 chunkId\n就不再是一个简单的自增 id 了。\n\n不过这种写法还是有弊端的，首先你需要手动编写每一个 chunk 的\nname，同时还需要保证它的唯一性，当页面一多，维护起来还是很麻烦的。这就违背了程序员的原则：能偷懒就偷懒。\n\n所以有什么办法可以自动生成一个 name 给 chunk 么 ？查看 webpack 源码我们发现了NamedChunksPlugin其实可以自定义\nnameResolver 的。\n\n\n自定义 nameResolver#\n\nNamedChunksPlugin支持自己写 nameResolver 的规则的。但目前大部分相关的文章里的自定义函数是不适合 webpack4 ，而且在结合\nvue 的情况下还会报错。\n\n社区旧方案：\n\n\n\n适配 webpack4 和 vue 的新实现方案：\n\n\n\n当然这个方案还是有一些弊端的因为 id 会可能很长，如果一个 chunk 依赖了很多个 module 的话，id\n可能有几十位，所以我们还需要缩短一下它的长度。我们首先将拼接起来的 id hash 以下，而且要保证 hash\n的结果位数也能太长，浪费字节，但太短又容易发生碰撞，所以最后我们我们选择 4 位长度，并且手动用 Set 做一下碰撞校验，发生碰撞的情况下位数加\n1，直到碰撞为止。详细代码如下：\n\n\n\n我给 vue-cli 官方也提了一个相关 issue尤雨溪最后也采纳了这个方案。 所以如果你现在下载最新\nvue-cli@3上面啰嗦了半天的东西，其实都已经默认配置好了(但作者本人为了找到这个 hack 方法整整花了两天时间 o(╥﹏╥)o)。\n\n目前测试了一段时间没发现有什么问题。不过有一点不是很理解，不知道 webpack 出于什么样的原因，官方一直没有修复这个问题？可能是在等 webpack5\n的时候放大招吧。\n\n\n总结#\n\n拆包策略：\n\n * 基础类库 chunk-libs\n * UI 组件库 chunk-elementUI\n * 自定义共用组件/函数 chunk-commons\n * 低频组件 chunk-eachrts/chunk-xlsx等\n * 业务代码 lazy-loading xxxx.js\n\n持久化缓存：\n\n * 使用 runtimeChunk 提取 manifest，使用\n   script-ext-html-webpack-plugin等插件内联到index.html减少请求\n * 使用 HashedModuleIdsPlugin 固定 moduleId\n * 使用 NamedChunkPlugin结合自定义 nameResolver 来固定 chunkId\n\n上述说的问题大部分在 webpack 官方文档都没明确指出，唯一可以参考的就是这份 cache 文档，在刚更新 webpack4 的时候，我以为官方已经将 id\n不能固定的问题解决了，但现实是残酷的，结果并不理想。不过作者也在很多的 issue 中说他正在着手优化 long term caching。\n\n> We plan to add another way to assign module/chunk ids for long term caching,\n> but this is not ready to be told yet.\n\n在 webpack 的 issue 和源码中也经常见到 Long term caching will be improved in webpack@5和TODO\nwebpack 5 xxxx这样的代码注释。这让我对webpack 5很期待。真心希望webpack\n5能真正的解决前面几个问题，并且让它更加的out-of-the-box，更加的简单和智能，就像webpack\n4的optimization.splitChunks，你基本不用做什么，它就能很好的帮你拆分好bundle包，同时又给你非常的自由发挥空间。\n\n\n展望#\n\nWhats next? 官方在这篇文章中展望了一下 webpack5\n和讲述了一下未来的计划--持续改进用户体验、提升构建速度和性能，降低使用门槛，完善Persistent Caching等等。同时 webpack 也已经支持\nPrefetching/Preloading modules，我相信之后也会有更多的网站会使用这一属性。\n\n同时 webpack 的团队已经承诺会通过投票的方式来决定一些功能。比如不久前发起的投票。\n\n\n\n大家可以关注 Tobias Koppers 的 twitter 进行投票。\n\n最后还是期待一下 webpack5 和它之后的发展吧。如果没有 webpack，也就不会有今天的前端。\n\n其实如一开始就讲的，vue 有vue-cli、react 有creat-react-app，现在新建项目基本都是基于脚手架的，很少有人从零开始写 webpack\n配置文件的，而且一般开发中，一般程序员也不需要经常去修改 webpack 的配置。webpack 官方本身也在不断完善默认配置项，相信 webpack\n的配置门槛也会越来低多。\n\n愿世间再无 webpack 配置工程师。\n\n\n\n\n拓展阅读#\n\n * Webpack 4 和单页应用入门\n\n * Long term caching using Webpack records\n\n * Predictable long term caching with Webpack\n\n * 从 Bundle 文件看 Webpack 模块机制\n\n * minipack\n\n * 各种可视化分析 webpack bundle 库\n\n官方文档\n\n\nUglifyJS Webpack Plugin#\n\nThis plugin uses uglify-js to minify your JavaScript.\n\n\nRequirements#\n\nThis module requires a minimum of Node v6.9.0 and Webpack v4.0.0.\n\n\nGetting Started#\n\nTo begin, you'll need to install uglifyjs-webpack-plugin:\n\n\n\nThen add the plugin to your webpack config. For example:\n\nwebpack.config.js\n\n\n\nAnd run webpack via your preferred method.\n\n\nOptions#\n\n\ntest#\n\nType: String|RegExp|Array Default: /\\.js(\\?.*)?$/i\n\nTest to match files against.\n\nwebpack.config.js\n\n\n\n\ninclude#\n\nType: String|RegExp|Array Default: undefined\n\nFiles to include.\n\nwebpack.config.js\n\n\n\n\nexclude#\n\nType: String|RegExp|Array Default: undefined\n\nFiles to exclude.\n\nwebpack.config.js\n\n\n\n\nchunkFilter#\n\nType: Function<(chunk) -> boolean> Default: () => true\n\nAllowing to filter which chunks should be uglified (by default all chunks are\nuglified). Return true to uglify the chunk, false otherwise.\n\nwebpack.config.js\n\n\n\n\ncache#\n\nType: Boolean|String Default: false\n\nEnable file caching. Default path to cache directory:\nnode_modules/.cache/uglifyjs-webpack-plugin.\n\n> ℹ️ If you use your own minify function please read the minify section for\n> cache invalidation correctly.\n\nBoolean#\n\nEnable/disable file caching.\n\nwebpack.config.js\n\n\n\nString#\n\nEnable file caching and set path to cache directory.\n\nwebpack.config.js\n\nwebpack.config.js\n\n\n\n\ncacheKeys#\n\nType: Function<(defaultCacheKeys, file) -> Object> Default: defaultCacheKeys =>\ndefaultCacheKeys\n\nAllows you to override default cache keys.\n\nDefault cache keys:\n\n\n\nwebpack.config.js\n\n\n\n\nparallel#\n\nType: Boolean|Number Default: false\n\nUse multi-process parallel running to improve the build speed. Default number of\nconcurrent runs: os.cpus().length - 1.\n\n> ℹ️ Parallelization can speedup your build significantly and is therefore\n> highly recommended.\n\nBoolean#\n\nEnable/disable multi-process parallel running.\n\nwebpack.config.js\n\n\n\nNumber#\n\nEnable multi-process parallel running and set number of concurrent runs.\n\nwebpack.config.js\n\n\n\n\nsourceMap#\n\nType: Boolean Default: false\n\nUse source maps to map error message locations to modules (this slows down the\ncompilation). If you use your own minify function please read the minify section\nfor handling source maps correctly.\n\n> ⚠️ cheap-source-map options don't work with this plugin.\n\nwebpack.config.js\n\n\n\n\nminify#\n\nType: Function Default: undefined\n\nAllows you to override default minify function. By default plugin uses uglify-js\npackage. Useful for using and testing unpublished versions or forks.\n\n> ⚠️ Always use require inside minify function when parallel option enabled.\n\nwebpack.config.js\n\n\n\n\nuglifyOptions#\n\nType: Object Default: default\n\nUglifyJS minify options.\n\nwebpack.config.js\n\n\n\n\nextractComments#\n\nType: Boolean|String|RegExp|Function<(node, comment) -> Boolean|Object> Default:\nfalse\n\nWhether comments shall be extracted to a separate file, (see details). By\ndefault extract only comments using /^\\**!|@preserve|@license|@cc_on/i regexp\ncondition and remove remaining comments. If the original file is named foo.js,\nthen the comments will be stored to foo.js.LICENSE. The\nuglifyOptions.output.comments option specifies whether the comment will be\npreserved, i.e. it is possible to preserve some comments (e.g. annotations)\nwhile extracting others or even preserving comments that have been extracted.\n\nBoolean#\n\nEnable/disable extracting comments.\n\nwebpack.config.js\n\n\n\nString#\n\nExtract all or some (use /^\\**!|@preserve|@license|@cc_on/i RegExp) comments.\n\nwebpack.config.js\n\n\n\nRegExp#\n\nAll comments that match the given expression will be extracted to the separate\nfile.\n\nwebpack.config.js\n\n\n\nFunction<(node, comment) -> Boolean>#\n\nAll comments that match the given expression will be extracted to the separate\nfile.\n\nwebpack.config.js\n\n\n\nObject#\n\nAllow to customize condition for extract comments, specify extracted file name\nand banner.\n\nwebpack.config.js\n\n\n\ncondition#\n\nType: Boolean|String|RegExp|Function<(node, comment) -> Boolean|Object>\n\nCondition what comments you need extract.\n\nwebpack.config.js\n\n\n\nfilename#\n\nType: Regex|Function<(string) -> String> Default: ${file}.LICENSE\n\nThe file where the extracted comments will be stored. Default is to append the\nsuffix .LICENSE to the original filename.\n\nwebpack.config.js\n\n\n\nbanner#\n\nType: Boolean|String|Function<(string) -> String> Default: /*! For license\ninformation please see ${commentsFile} */\n\nThe banner text that points to the extracted file and will be added on top of\nthe original file. Can be false (no banner), a String, or a Function<(string) ->\nString> that will be called with the filename where extracted comments have been\nstored. Will be wrapped into comment.\n\nwebpack.config.js\n\n\n\n\nwarningsFilter#\n\nType: Function<(warning, source) -> Boolean> Default: () => true\n\nAllow to filter uglify-js warnings. Return true to keep the warning, false\notherwise.\n\nwebpack.config.js\n\n\n\n\nExamples#\n\n\nCache And Parallel#\n\nEnable cache and multi-process parallel running.\n\nwebpack.config.js\n\n\n\n\nPreserve Comments#\n\nExtract all legal comments (i.e. /^\\**!|@preserve|@license|@cc_on/i) and\npreserve /@license/i comments.\n\nwebpack.config.js\n\n\n\n\nRemove Comments#\n\nIf you avoid building with comments, set uglifyOptions.output.comments to false\nas in this config:\n\nwebpack.config.js\n\n\n\n\nCustom Minify Function#\n\nOverride default minify function - use terser for minification.\n\nwebpack.config.js\n\n","routePath":"/site/webpack/site/webpack/stalled-webpack4打包很慢处理","lang":"","toc":[{"text":"升级篇","id":"升级篇","depth":2,"charIndex":1230},{"text":"前言","id":"前言","depth":3,"charIndex":1237},{"text":"升级 webpack","id":"升级-webpack","depth":3,"charIndex":1539},{"text":"带来的变化","id":"带来的变化","depth":3,"charIndex":2061},{"text":"默认配置","id":"默认配置","depth":3,"charIndex":2377},{"text":"html-webpack-plugin","id":"html-webpack-plugin","depth":2,"charIndex":2860},{"text":"mini-css-extract-plugin","id":"mini-css-extract-plugin","depth":2,"charIndex":3607},{"text":"与 extract-text-webpack-plugin 区别","id":"与-extract-text-webpack-plugin-区别","depth":3,"charIndex":3634},{"text":"压缩与优化","id":"压缩与优化","depth":3,"charIndex":4184},{"text":"contenthash","id":"contenthash","depth":3,"charIndex":4513},{"text":"这里再简单说明一下几种 hash 的区别：","id":"这里再简单说明一下几种-hash-的区别","depth":3,"charIndex":5426},{"text":"热更新速度","id":"热更新速度","depth":2,"charIndex":5951},{"text":"打包速度","id":"打包速度","depth":2,"charIndex":7165},{"text":"Tree-Shaking","id":"tree-shaking","depth":2,"charIndex":8142},{"text":"默认分包策略","id":"默认分包策略","depth":2,"charIndex":8717},{"text":"优化分包策略","id":"优化分包策略","depth":2,"charIndex":9951},{"text":"博弈","id":"博弈","depth":3,"charIndex":12055},{"text":"Long term caching","id":"long-term-caching","depth":2,"charIndex":12496},{"text":"RuntimeChunk(manifest)","id":"runtimechunkmanifest","depth":3,"charIndex":13120},{"text":"Module vs Chunk","id":"module-vs-chunk","depth":3,"charIndex":13761},{"text":"HashedModuleIdsPlugin","id":"hashedmoduleidsplugin","depth":3,"charIndex":14123},{"text":"NamedChunkPlugin","id":"namedchunkplugin","depth":3,"charIndex":15411},{"text":"webpack records","id":"webpack-records","depth":2,"charIndex":16205},{"text":"webpackChunkName","id":"webpackchunkname","depth":2,"charIndex":17066},{"text":"自定义 nameResolver","id":"自定义-nameresolver","depth":2,"charIndex":17465},{"text":"总结","id":"总结","depth":2,"charIndex":18037},{"text":"展望","id":"展望","depth":2,"charIndex":18909},{"text":"拓展阅读","id":"拓展阅读","depth":2,"charIndex":19419},{"text":"Requirements","id":"requirements","depth":2,"charIndex":19700},{"text":"Getting Started","id":"getting-started","depth":2,"charIndex":19783},{"text":"Options","id":"options","depth":2,"charIndex":19986},{"text":"`test`","id":"test","depth":3,"charIndex":-1},{"text":"`include`","id":"include","depth":3,"charIndex":-1},{"text":"`exclude`","id":"exclude","depth":3,"charIndex":-1},{"text":"`chunkFilter`","id":"chunkfilter","depth":3,"charIndex":-1},{"text":"`cache`","id":"cache","depth":3,"charIndex":-1},{"text":"`Boolean`","id":"boolean","depth":4,"charIndex":-1},{"text":"`String`","id":"string","depth":4,"charIndex":-1},{"text":"`cacheKeys`","id":"cachekeys","depth":3,"charIndex":-1},{"text":"`parallel`","id":"parallel","depth":3,"charIndex":-1},{"text":"`Boolean`","id":"boolean-1","depth":4,"charIndex":-1},{"text":"`Number`","id":"number","depth":4,"charIndex":-1},{"text":"`sourceMap`","id":"sourcemap","depth":3,"charIndex":-1},{"text":"`minify`","id":"minify","depth":3,"charIndex":-1},{"text":"`uglifyOptions`","id":"uglifyoptions","depth":3,"charIndex":-1},{"text":"`extractComments`","id":"extractcomments","depth":3,"charIndex":-1},{"text":"`Boolean`","id":"boolean-2","depth":4,"charIndex":-1},{"text":"`String`","id":"string-1","depth":4,"charIndex":-1},{"text":"`RegExp`","id":"regexp","depth":4,"charIndex":-1},{"text":"`Function<(node, comment) -> Boolean>`","id":"functionnode-comment---boolean","depth":4,"charIndex":-1},{"text":"`Object`","id":"object","depth":4,"charIndex":-1},{"text":"`warningsFilter`","id":"warningsfilter","depth":3,"charIndex":-1},{"text":"Examples","id":"examples","depth":2,"charIndex":24488},{"text":"Cache And Parallel","id":"cache-and-parallel","depth":3,"charIndex":24500},{"text":"Preserve Comments","id":"preserve-comments","depth":3,"charIndex":24593},{"text":"Remove Comments","id":"remove-comments","depth":3,"charIndex":24740},{"text":"Custom Minify Function","id":"custom-minify-function","depth":3,"charIndex":24880}],"domain":"","frontmatter":{},"version":""},{"id":65,"title":"配置说明","content":"#\n\n\n第三方依赖版本#\n\n\n\n需要注意高版本和低版本的兼容，还有 webpack-babel 不同版本的配置文件不同\n\n\nScript 脚本说明#\n\n\n\n发布前，依次执行上面的四个脚本\n\n * pub:lib 在 node 环境下 babel 编译代码到 lib 目录下\n * pub:esm 在生产环境下 bebel 编译代码到 es 目录下\n * pub:umd 在生产环境下 webpack 使用配置文件进行编译（入口出口在配置文件中）\n * pub:optimized 删除本地配置文件和翻译文件\n\n前两步应该兼容开发环境（node环境，web开发环境，web生产环境）\n\n\nMakefile 脚本说明#\n\n\n\n\nbabelrc 配置说明#\n\neditor\n\n\n\nTable\n\n\n\nTODO：未来专门弄一个文件学习 babel 及配置作用（基本会使用）\n\n\nwebpack.config.pub.js 配置说明#\n\n\n\n这是 webpack 配置文件，未来要学会\n\n\n附录#\n\nbabel-preset-env\n说明：https://www.cnblogs.com/chyingp/p/understanding-babel-preset-env.html","routePath":"/site/webpack/site/webpack/webpack-setting","lang":"","toc":[{"text":"第三方依赖版本","id":"第三方依赖版本","depth":3,"charIndex":3},{"text":"Script 脚本说明","id":"script-脚本说明","depth":3,"charIndex":61},{"text":"Makefile 脚本说明","id":"makefile-脚本说明","depth":3,"charIndex":292},{"text":"babelrc 配置说明","id":"babelrc-配置说明","depth":3,"charIndex":311},{"text":"webpack.config.pub.js 配置说明","id":"webpackconfigpubjs-配置说明","depth":3,"charIndex":383},{"text":"附录","id":"附录","depth":3,"charIndex":438}],"domain":"","frontmatter":{},"version":""},{"id":66,"title":"说明","content":"#\n\n这是一个测试目录，主要练习 react webpack babel(es6) 的编译和配置。\n\n\n1. webpack 环境搭建（版本6）#\n\n\n\n\n2. 相关的依赖库#\n\n\n\n\n3. webpack 配置#\n\n\n\nbabel 配置\n\n\n\n\n4. 运行 webpack#\n\n此时出现问题：配置 loaders 改成 rules, react-hot 一直报错所以删了，babel 改成 babel-loader.\n\n最后界面中可以显示当前的应用\n\n\n5. 高级配置#\n\nmake dist\n\n直接运行 make dist 即可进行编译和迁移css文件\n\n\n\n注意：如果是nodeJS项目，webpack 可能出现下面的问题\n\n\n\n需要在 webpack-config.js 中加入 target:'node', 这个配置，否则node部分本地打包报错。\n\nhttps://stackoverflow.com/questions/51946848/webpack-nodejs-module-not-found-err\nor-cant-resolve-fs\n\nhttps://jlongster.com/Backend-Apps-with-Webpack--Part-I","routePath":"/site/webpack/site/webpack/webpack04-01README","lang":"","toc":[{"text":"1. webpack 环境搭建（版本6）","id":"1-webpack-环境搭建版本6","depth":3,"charIndex":51},{"text":"2. 相关的依赖库","id":"2-相关的依赖库","depth":3,"charIndex":77},{"text":"3. webpack 配置","id":"3-webpack-配置","depth":3,"charIndex":92},{"text":"4. 运行 webpack","id":"4-运行-webpack","depth":3,"charIndex":123},{"text":"5. 高级配置","id":"5-高级配置","depth":3,"charIndex":227}],"domain":"","frontmatter":{},"version":""},{"id":67,"title":"demo02","content":"#\n\n这里尝试使用 npm run eject 自定义工程脚本\n\n提示：Create React App 2+支持TypeScript，Sass，CSS模块等，而无需弹出：\n\n","routePath":"/site/webpack/site/webpack/webpack04-02-README","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":68,"title":"","content":"使用 create-react-app 搭建编译打包项目\n\n官方文档 https://www.html.cn/create-react-app/docs/getting-started/\n\n其他教程 https://www.jianshu.com/p/77bf3944b0f4\n\n直接执行\n\n\n\n执行上面的脚本，可能出现 A template was not provided. This is likely because you're using an\noutdated 这个错误，网上的意见是，卸载全局安装的 create-react-app 然后 which create-react-app\n测试，确保卸载后（文件已经删除），然后执行 npx create-react-app my-app. 然后出现下面的正确安装的结果。\n\n\n\n\n\n打开文件夹后，执行 npm start 或者 yarn start 均可开启服务\n\n现在使用的是默认的开发工程脚本，下面是默认的readme\n\nThis project was bootstrapped with Create React App.\n\n\nAvailable Scripts#\n\nIn the project directory, you can run:\n\n\nyarn start#\n\nRuns the app in the development mode. Open http://localhost:3000 to view it in\nthe browser.\n\nThe page will reload if you make edits. You will also see any lint errors in the\nconsole.\n\n\nyarn test#\n\nLaunches the test runner in the interactive watch mode. See the section about\nrunning tests for more information.\n\n\nyarn build#\n\nBuilds the app for production to the build folder. It correctly bundles React in\nproduction mode and optimizes the build for the best performance.\n\nThe build is minified and the filenames include the hashes. Your app is ready to\nbe deployed!\n\nSee the section about deployment for more information.\n\n\nyarn eject#\n\nNote: this is a one-way operation. Once you eject, you can’t go back!\n\nIf you aren’t satisfied with the build tool and configuration choices, you can\neject at any time. This command will remove the single build dependency from\nyour project.\n\nInstead, it will copy all the configuration files and the transitive\ndependencies (webpack, Babel, ESLint, etc) right into your project so you have\nfull control over them. All of the commands except eject will still work, but\nthey will point to the copied scripts so you can tweak them. At this point\nyou’re on your own.\n\nYou don’t have to ever use eject. The curated feature set is suitable for small\nand middle deployments, and you shouldn’t feel obligated to use this feature.\nHowever we understand that this tool wouldn’t be useful if you couldn’t\ncustomize it when you are ready for it.\n\n\nLearn More#\n\nYou can learn more in the Create React App documentation.\n\nTo learn React, check out the React documentation.\n\n\nCode Splitting#\n\nThis section has moved here:\nhttps://facebook.github.io/create-react-app/docs/code-splitting\n\n\nAnalyzing the Bundle Size#\n\nThis section has moved here:\nhttps://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size\n\n\nMaking a Progressive Web App#\n\nThis section has moved here:\nhttps://facebook.github.io/create-react-app/docs/making-a-progressive-web-app\n\n\nAdvanced Configuration#\n\nThis section has moved here:\nhttps://facebook.github.io/create-react-app/docs/advanced-configuration\n\n\nDeployment#\n\nThis section has moved here:\nhttps://facebook.github.io/create-react-app/docs/deployment\n\n\nyarn build fails to minify#\n\nThis section has moved here:\nhttps://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-f\nails-to-minify","routePath":"/site/webpack/site/webpack/webpack04-03-README","lang":"","toc":[{"text":"Available Scripts","id":"available-scripts","depth":2,"charIndex":499},{"text":"`yarn start`","id":"yarn-start","depth":3,"charIndex":-1},{"text":"`yarn test`","id":"yarn-test","depth":3,"charIndex":-1},{"text":"`yarn build`","id":"yarn-build","depth":3,"charIndex":-1},{"text":"`yarn eject`","id":"yarn-eject","depth":3,"charIndex":-1},{"text":"Learn More","id":"learn-more","depth":2,"charIndex":2048},{"text":"Code Splitting","id":"code-splitting","depth":3,"charIndex":2173},{"text":"Analyzing the Bundle Size","id":"analyzing-the-bundle-size","depth":3,"charIndex":2285},{"text":"Making a Progressive Web App","id":"making-a-progressive-web-app","depth":3,"charIndex":2419},{"text":"Advanced Configuration","id":"advanced-configuration","depth":3,"charIndex":2559},{"text":"Deployment","id":"deployment","depth":3,"charIndex":2687},{"text":"`yarn build` fails to minify","id":"yarn-build-fails-to-minify","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":69,"title":"","content":"webpack#\n\n\n1、菜鸟教程#\n\n入门#\n\nhttp://www.runoob.com/w3cnote/webpack-tutorial.html\n\nwebpack 作用：将多个静态资源转化成一个静态文件。将多个less/css转化成一个css文件，减少页面的请求。\n\n安装(可以全局安装)可以单文件安装\n\n\n\n注意：在webpack3 版本(3.8.1)中 webpack-cli 在 webpack 内部。在 webpack 4版本中，这两个包分开存放。\n\n目前，在全局下安装4.29.0 版本的webpack and webpack-cli\n\n测试一 简单JS#\n\n\n\n在 package.json 中配置输入输出文件\n\n\n\n现在改成全局只安装 webpack 3.8.1\n\n\n\n入口文件是 index.js 输出文件是 ./dist/index.min.js 即可编译\n\n下面是成功的信息\n\n\n\n测试二 复杂JS#\n\n\n\n\n\nwebpack 根据每一个模块的关系进行静态分析，给每一个模块一个唯一的ID，并通过这个id索引和访问模块。首先启动index.js 然后其他模块会在运行\nrequire 的时候运行。\n\n测试三 loader#\n\nloader 目的：webpack只能处理JS代码，loader进行转换，可以处理 css and jsx 文件。\n\ncss文件需要 css-loader 和 style-loader。css-loader 会遍历css文件，然后找到URL()\n表达式然后处理。style-loader 会把原来的CSS代码插入到页面中的 style 标签中。\n\n\n\n\n\n\n\n\n\n\n\n信息\n\n\n\n测试4 配置文件#\n\n我们可以将编译的选项放在设置文件中，直接运行 webpack 即可编译。\n\n\n\n测试5 插件#\n\n配置 plugins 用于完成其他功能（文件头部输出一些注释信息）\n\n使用内置插件需要\n\n\n\n\n\n测试6 开发环境#\n\n\n\n编译输出内容具有进度和颜色（大项目）\n\nwatch表示监听模式。没有变化的模块会缓存到内存中，不需要每次重新编译。\n\nWebpack-dev-server 开发服务，可以通过 localhost:8080 启动一个静态资源 express web 服务器，会以监听模式自动运行\nwebpack。可以打开浏览器中的 8080查看。并且通过一个 socker.io 服务实时监听项目变化，并自动刷新界面。\n\n\n\n现在提示 webpack-cli 没有安装\n\n\n2、官方教程#\n\nhttps://www.webpackjs.com/concepts/\n\n4.0.0 版本后可能不需要配置文件","routePath":"/site/webpack/site/webpack/webpack3-readme","lang":"","toc":[{"text":"webpack","id":"webpack","depth":2,"charIndex":-1},{"text":"1、菜鸟教程","id":"1菜鸟教程","depth":3,"charIndex":10},{"text":"入门","id":"入门","depth":4,"charIndex":19},{"text":"测试一 简单JS","id":"测试一-简单js","depth":4,"charIndex":277},{"text":"测试二 复杂JS","id":"测试二-复杂js","depth":4,"charIndex":404},{"text":"测试三 loader","id":"测试三-loader","depth":4,"charIndex":513},{"text":"测试4 配置文件","id":"测试4-配置文件","depth":4,"charIndex":716},{"text":"测试5 插件","id":"测试5-插件","depth":4,"charIndex":767},{"text":"测试6 开发环境","id":"测试6-开发环境","depth":4,"charIndex":825},{"text":"2、官方教程","id":"2官方教程","depth":3,"charIndex":1066}],"domain":"","frontmatter":{},"version":""},{"id":70,"title":"mini-css-extract-plugin","content":"#\n\n统计信息：字数 13786 阅读28分钟\n\nThis plugin extracts CSS into separate files. It creates a CSS file per JS file\nwhich contains CSS. It supports On-Demand-Loading of CSS and SourceMaps.\n\nIt builds on top of a new webpack v4 feature (module types) and requires webpack\n4 to work.\n\nCompared to the extract-text-webpack-plugin:\n\n * Async loading\n * No duplicate compilation (performance)\n * Easier to use\n * Specific to CSS\n\n\nGetting Started#\n\nTo begin, you'll need to install mini-css-extract-plugin:\n\n\n\nIt's recommended to combine mini-css-extract-plugin with the css-loader\n\nThen add the loader and the plugin to your webpack config. For example:\n\nstyle.css\n\n\n\ncomponent.js\n\n\n\nwebpack.config.js\n\n\n\n\nOptions#\n\n\npublicPath#\n\nType: String|Function Default: the publicPath in webpackOptions.output\n\nSpecifies a custom public path for the target file(s).\n\nString#\n\nwebpack.config.js\n\n\n\nFunction#\n\nwebpack.config.js\n\n\n\n\nesModule#\n\nType: Boolean Default: false\n\nBy default, mini-css-extract-plugin generates JS modules that use the CommonJS\nmodules syntax. There are some cases in which using ES modules is beneficial,\nlike in the case of module concatenation and tree shaking.\n\nYou can enable a ES module syntax using:\n\nwebpack.config.js\n\n\n\n\nExamples#\n\n\nMinimal example#\n\nwebpack.config.js\n\n\n\n\nThe publicPath option as function#\n\nwebpack.config.js\n\n\n\n\nAdvanced configuration example#\n\nThis plugin should be used only on production builds without style-loader in the\nloaders chain, especially if you want to have HMR in development.\n\nHere is an example to have both HMR in development and your styles extracted in\na file for production builds.\n\n(Loaders options left out for clarity, adapt accordingly to your needs.)\n\nwebpack.config.js\n\n\n\n\nHot Module Reloading (HMR)#\n\nThe mini-css-extract-plugin supports hot reloading of actual css files in\ndevelopment. Some options are provided to enable HMR of both standard\nstylesheets and locally scoped CSS or CSS modules. Below is an example\nconfiguration of mini-css for HMR use with CSS modules.\n\nWhile we attempt to hmr css-modules. It is not easy to perform when\ncode-splitting with custom chunk names. reloadAll is an option that should only\nbe enabled if HMR isn't working correctly. The core challenge with css-modules\nis that when code-split, the chunk ids can and do end up different compared to\nthe filename.\n\nwebpack.config.js\n\n\n\n\nMinimizing For Production#\n\nTo minify the output, use a plugin like optimize-css-assets-webpack-plugin.\nSetting optimization.minimizer overrides the defaults provided by webpack, so\nmake sure to also specify a JS minimizer:\n\nwebpack.config.js\n\n\n\n\nUsing preloaded or inlined CSS#\n\nThe runtime code detects already added CSS via or","routePath":"/site/webpack/site/webpack/插件 mini-css-extract-plugin","lang":"","toc":[{"text":"Getting Started","id":"getting-started","depth":2,"charIndex":414},{"text":"Options","id":"options","depth":2,"charIndex":690},{"text":"`publicPath`","id":"publicpath","depth":3,"charIndex":-1},{"text":"`String`","id":"string","depth":4,"charIndex":-1},{"text":"`Function`","id":"function","depth":4,"charIndex":-1},{"text":"`esModule`","id":"esmodule","depth":3,"charIndex":-1},{"text":"Examples","id":"examples","depth":2,"charIndex":1227},{"text":"Minimal example","id":"minimal-example","depth":3,"charIndex":1239},{"text":"The `publicPath` option as function","id":"the-publicpath-option-as-function","depth":3,"charIndex":-1},{"text":"Advanced configuration example","id":"advanced-configuration-example","depth":3,"charIndex":1337},{"text":"Hot Module Reloading (HMR)","id":"hot-module-reloading-hmr","depth":3,"charIndex":1725},{"text":"Minimizing For Production","id":"minimizing-for-production","depth":3,"charIndex":2369},{"text":"Using preloaded or inlined CSS","id":"using-preloaded-or-inlined-css","depth":3,"charIndex":2616},{"text":"Extracting all CSS in a single file","id":"extracting-all-css-in-a-single-file","depth":3,"charIndex":-1},{"text":"Extracting CSS based on entry","id":"extracting-css-based-on-entry","depth":3,"charIndex":-1},{"text":"Module Filename Option","id":"module-filename-option","depth":3,"charIndex":-1},{"text":"Long Term Caching","id":"long-term-caching","depth":3,"charIndex":-1},{"text":"Remove Order Warnings","id":"remove-order-warnings","depth":3,"charIndex":-1},{"text":"Media Query Plugin","id":"media-query-plugin","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":71,"title":"react-webpack-template","content":"#\n\n统计信息：字数 485 阅读1分钟\n\nThis is a simple template for building React apps. Use this to get started, and\nif you find yourself needing additional features, see my webpack-howto.\n\n\nHow to use this#\n\n * Clone the repo: git clone https://github.com/petehunt/react-webpack-template\n   my-new-project\n * Install the dependencies: cd my-new-project && npm install\n * Start webpack: npm start\n * Add your code to index.js and open index.html","routePath":"/site/webpack/site/webpack/插件 react-webpack-template","lang":"","toc":[{"text":"How to use this","id":"how-to-use-this","depth":2,"charIndex":175}],"domain":"","frontmatter":{},"version":""},{"id":72,"title":"Code Splitting","content":"#\n\n统计信息：字数 14615 阅读30分钟\n\n> This guide extends the examples provided in Getting Started and Output\n> Management. Please make sure you are at least familiar with the examples\n> provided in them.\n\nCode splitting is one of the most compelling features of webpack. This feature\nallows you to split your code into various bundles which can then be loaded on\ndemand or in parallel. It can be used to achieve smaller bundles and control\nresource load prioritization which, if used correctly, can have a major impact\non load time.\n\nThere are three general approaches to code splitting available:\n\n * Entry Points: Manually split code using entry configuration.\n * Prevent Duplication: Use the SplitChunksPlugin to dedupe and split chunks.\n * Dynamic Imports: Split code via inline function calls within modules.\n\n代码分割注意点\n\n * 入口：使用entry配置项手动设置分割代码的入口\n * 阻止重复代码：使用 splitchunkPlugin 插件可以减少重复代码（locash）其他的插件可以压缩CSS部分；bundle-loader\n   支持拆分的代码懒加载\n * 动态导入：使用import语法（不使用commonJS语法）可以动态导入需要的组件（注意可能老浏览器不兼容这样的写法）\n\n\nEntry Points#\n\nThis is by far the easiest and most intuitive way to split code. However, it is\nmore manual and has some pitfalls we will go over. Let's take a look at how we\nmight split another module from the main bundle:\n\nproject\n\n\n\nanother-module.js\n\n\n\nwebpack.config.js\n\n\n\nThis will yield the following build result:\n\n\n\nAs mentioned there are some pitfalls to this approach:\n\n * If there are any duplicated modules between entry chunks they will be\n   included in both bundles.\n * It isn't as flexible and can't be used to dynamically split code with the\n   core application logic.\n\nThe first of these two points is definitely an issue for our example, as lodash\nis also imported within ./src/index.js and will thus be duplicated in both\nbundles. Let's remove this duplication by using the SplitChunksPlugin.\n\n\nPrevent Duplication#\n\n\nEntry dependencies#\n\nThe dependOn option allows to share the modules between the chunks\n\n\n\n\nSplitChunksPlugin#\n\nThe SplitChunksPlugin allows us to extract common dependencies into an existing\nentry chunk or an entirely new chunk. Let's use this to de-duplicate the lodash\ndependency from the previous example:\n\n> The CommonsChunkPlugin has been removed in webpack v4 legato. To learn how\n> chunks are treated in the latest version, check out the SplitChunksPlugin.\n\nwebpack.config.js\n\n\n\nWith the optimization.splitChunks configuration option in place, we should now\nsee the duplicate dependency removed from our index.bundle.js and\nanother.bundle.js. The plugin should notice that we've separated lodash out to a\nseparate chunk and remove the dead weight from our main bundle. Let's do an npm\nrun build to see if it worked:\n\n\n\nHere are some other useful plugins and loaders provided by the community for\nsplitting code:\n\n * mini-css-extract-plugin: Useful for splitting CSS out from the main\n   application.\n * bundle-loader: Used to split code and lazy load the resulting bundles.\n * promise-loader: Similar to the bundle-loader but uses promises.\n\n\nDynamic Imports#\n\nTwo similar techniques are supported by webpack when it comes to dynamic code\nsplitting. The first and recommended approach is to use the import() syntax that\nconforms to the ECMAScript proposal for dynamic imports. The legacy,\nwebpack-specific approach is to use require.ensure. Let's try using the first of\nthese two approaches...\n\n> import() calls use promises internally. If you use import() with older\n> browsers, remember to shim Promise using a polyfill such as es6-promise or\n> promise-polyfill.\n\nBefore we start, let's remove the extra entry and optimization.splitChunks from\nour configuration as they won't be needed for this next demonstration:\n\nwebpack.config.js\n\n\n\nNote the use of chunkFilename, which determines the name of non-entry chunk\nfiles. For more information on chunkFilename, see output documentation. We'll\nalso update our project to remove the now unused files:\n\nproject\n\n\n\nNow, instead of statically importing lodash, we'll use dynamic importing to\nseparate a chunk:\n\nsrc/index.js\n\n\n\nThe reason we need default is that since webpack 4, when importing a CommonJS\nmodule, the import will no longer resolve to the value of module.exports, it\nwill instead create an artificial namespace object for the CommonJS module. For\nmore information on the reason behind this, read webpack 4: import() and\nCommonJs\n\nNote the use of webpackChunkName in the comment. This will cause our separate\nbundle to be named lodash.bundle.js instead of just [id].bundle.js. For more\ninformation on webpackChunkName and the other available options, see the\nimport() documentation. Let's run webpack to see lodash separated out to a\nseparate bundle:\n\n\n\nAs import() returns a promise, it can be used with async functions. However,\nthis requires using a pre-processor like Babel and the Syntax Dynamic Import\nBabel Plugin. Here's how it would simplify the code:\n\nsrc/index.js\n\n\n\n> It is possible to provide a dynamic expression to import() when you might need\n> to import specific module based on a computed variable later.\n\n\nPrefetching/Preloading modules#\n\nwebpack 4.6.0+ adds support for prefetching and preloading.\n\nUsing these inline directives while declaring your imports allows webpack to\noutput “Resource Hint” which tells the browser that for:\n\n * prefetch: resource is probably needed for some navigation in the future\n * preload: resource might be needed during the current navigation\n\nSimple prefetch example can be having a HomePage component, which renders a\nLoginButton component which then on demand loads a LoginModal component after\nbeing clicked.\n\nLoginButton.js\n\n\n\nThis will result in `` being appended in the head of the page, which will\ninstruct the browser to prefetch in idle time the login-modal-chunk.js file.\n\n> webpack will add the prefetch hint once the parent chunk has been loaded.\n\nPreload directive has a bunch of differences compared to prefetch:\n\n * A preloaded chunk starts loading in parallel to the parent chunk. A\n   prefetched chunk starts after the parent chunk finishes loading.\n * A preloaded chunk has medium priority and is instantly downloaded. A\n   prefetched chunk is downloaded while the browser is idle.\n * A preloaded chunk should be instantly requested by the parent chunk. A\n   prefetched chunk can be used anytime in the future.\n * Browser support is different.\n\nSimple preload example can be having a Component which always depends on a big\nlibrary that should be in a separate chunk.\n\nLet's imagine a component ChartComponent which needs huge ChartingLibrary. It\ndisplays a LoadingIndicator when rendered and instantly does an on demand import\nof ChartingLibrary:\n\nChartComponent.js\n\n\n\nWhen a page which uses the ChartComponent is requested, the\ncharting-library-chunk is also requested via ``. Assuming the page-chunk is\nsmaller and finishes faster, the page will be displayed with a LoadingIndicator,\nuntil the already requested charting-library-chunk finishes. This will give a\nlittle load time boost since it only needs one round-trip instead of two.\nEspecially in high-latency environments.\n\n> Using webpackPreload incorrectly can actually hurt performance, so be careful\n> when using it.\n\n\nBundle Analysis#\n\nOnce you start splitting your code, it can be useful to analyze the output to\ncheck where modules have ended up. The official analyze tool is a good place to\nstart. There are some other community-supported options out there as well:\n\n * webpack-chart: Interactive pie chart for webpack stats.\n * webpack-visualizer: Visualize and analyze your bundles to see which modules\n   are taking up space and which might be duplicates.\n * webpack-bundle-analyzer: A plugin and CLI utility that represents bundle\n   content as a convenient interactive zoomable treemap.\n * webpack bundle optimize helper: This tool will analyze your bundle and give\n   you actionable suggestions on what to improve to reduce your bundle size.\n * bundle-stats: Generate a bundle report(bundle size, assets, modules) and\n   compare the results between different builds.","routePath":"/site/webpack/site/webpack/插件 webpack Code Splitting","lang":"","toc":[{"text":"Entry Points","id":"entry-points","depth":2,"charIndex":996},{"text":"Prevent Duplication","id":"prevent-duplication","depth":2,"charIndex":1811},{"text":"Entry dependencies","id":"entry-dependencies","depth":3,"charIndex":1834},{"text":"`SplitChunksPlugin`","id":"splitchunksplugin","depth":3,"charIndex":-1},{"text":"Dynamic Imports","id":"dynamic-imports","depth":2,"charIndex":2985},{"text":"Prefetching/Preloading modules","id":"prefetchingpreloading-modules","depth":2,"charIndex":5026},{"text":"Bundle Analysis","id":"bundle-analysis","depth":2,"charIndex":7153}],"domain":"","frontmatter":{},"version":""},{"id":73,"title":"HappyPack多个进程处理loader-HappyPack优化构建(九)","content":"#\n\n统计信息：字数 7182 阅读15分钟\n\n什么是HappyPack? 作用是什么？#\n\nWebpack是允许在NodeJS中的，它是单线程模型的，因此webpack在构建文件时，比如js，css，图片及字体时，它需要一个一个去解析和编译，不能同时处\n理多个任务。\n\n特别当文件数量变多后，webpack构建慢的问题会显得更为严重。\n\n因此HappyPack出现了，它能让webpack同时处理多个任务，它将任务分解给多个子进程去并发执行，子进程处理完成后再将结果发送给主进程中。\n\nHappyPack的基本原理?#\n\n在webpack构建过程中，我们需要使用Loader对js，css，图片，字体等文件做转换操作，并且转换的文件数据量也是非常大的，且这些转换操作不能并发处理文件\n，而是需要一个个文件进行处理，HappyPack的基本原理是将这部分任务分解到多个子进程中去并行处理，子进程处理完成后把结果发送到主进程中，从而减少总的构建时间\n。\n\n使用案例 安装依赖库\n\n\n\nwebpack.config.js 配置如何使用 happypack 在plugin中配置happypack实例 在loader中使用 happypack\n创建的进程\n\n","routePath":"/site/webpack/site/webpack/插件 webpack HappyPack多个进程处理loader","lang":"","toc":[{"text":"什么是HappyPack? 作用是什么？","id":"什么是happypack-作用是什么","depth":4,"charIndex":23},{"text":"HappyPack的基本原理?","id":"happypack的基本原理","depth":4,"charIndex":243},{"text":"配置说明","id":"配置说明","depth":4,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":74,"title":"webpack 常用插件","content":"#\n\n统计信息：字数 20818 阅读42分钟\n\nhttps://webpack.docschina.org/plugins/\n\n\n官方插件#\n\nWebpack 拥有丰富的插件接口。webpack 自身的大部分功能都使用这些插件接口。这使得 webpack 很灵活。\n\n插件                              描述\nBannerPlugin                    为每个 chunk 文件头部添加 banner\nCommonsChunkPlugin              提取 chunk 之间的公共模块用以共享\nCompressionWebpackPlugin        准备好用 Content-Encoding 格式传送的压缩版资源包\nContextReplacementPlugin        重写 require 表达式的推断上下文\nCopyWebpackPlugin               复制某个文件或整个文件夹到生成目录中\nDefinePlugin                    允许创建一个在编译时可配置的全局常量\nDllPlugin                       拆分 bundles，从而大幅减少构建时间\nEnvironmentPlugin               在 process.env 键上使用 DefinePlugin 的简写方式\nEslintWebpackPlugin             webpack 的 ESLint 插件\nHotModuleReplacementPlugin      启用热更新 (HMR)\nHtmlWebpackPlugin               快速创建 HTML 文件来服务 bundles\nIgnorePlugin                    从 bundles 包中移除某些模块\nLimitChunkCountPlugin           设置 chunk 的最小/最大限制，以便更好的控制 chunk\nMinChunkSizePlugin              确保 chunk 大小在指定限制之上\nMiniCssExtractPlugin            为每一个包含了 CSS 的 JS 文件创建一个 CSS 文件\nNoEmitOnErrorsPlugin            出现编译错误时，跳过输出阶段\nNormalModuleReplacementPlugin   替换与正则表达式匹配的资源\nNpmInstallWebpackPlugin         开发时自动安装缺少的依赖\nProgressPlugin                  报告编译进度\nProvidePlugin                   使用模块但无需使用 import/require\nSourceMapDevToolPlugin          对 source map 进行更细颗粒度的控制\nEvalSourceMapDevToolPlugin      对 eval source map 进行更细颗粒度的控制\nTerserPlugin                    在你的项目中使用 Terser 插件来压缩 JS\n\n\n第三方插件#\n\n查找更多第三方插件，请参阅 awesome-webpack。\n\n\nWebpack Plugins#\n\n * DefinePlugin: Create global constants which can be configured at compile\n   time. -- Maintainer: Webpack Team\n * Compression Plugin: Prepare assets to serve with Content-Encoding. --\n   Maintainer: Webpack Team\n * Offline Plugin: Offline plugin (ServiceWorker, AppCache) for Webpack. --\n   Maintainer: Arthur Stolyar\n * Rewire Plugin: Dependency injection for Webpack bundles. -- Maintainer:\n   Johannes Ewald\n * HTML Webpack Plugin: Simplifies creation of HTML files. -- Maintainer: Jan\n   Nicklas\n * Copy Webpack Plugin: Copy files and directories in webpack. -- Maintainer:\n   Len Boyette\n * Split By Path: Split By Path Webpack Plugin. -- Maintainer: Bohdan Tkachenko\n * SW Precache - Generates a service worker to precache bundle. -- Maintainer:\n   Will Farley\n * CoreJS Plugin - Core-JS as a webpack plugin. -- Maintainer: PatrickJS\n * Bundle Analyzer - Utility that represents bundles as an interactive treemap.\n   -- Maintainer: Yuriy Grunin\n * Module Mapping - Maps modules onto different files. -- Maintainer: Spartez\n   Team\n * Serverless Webpack - Serverless plugin to bundle your lambdas. -- Maintainer:\n   Elastic Coders\n * Prerender SPA - Framework-agnostic static site generation for SPAs. --\n   Maintainer: Chris Fritz\n * Static Site Generator Plugin - Minimal, unopinionated static site generator.\n   -- Maintainer: Mark Dalgleish\n * SVG Sprite Plugin - Plugin for SVG sprites and icons. -- Maintainer: Jeremy\n   Tice (TodayTix)\n * Imagemin Webpack Plugin - Minify images with Imagemin. -- Maintainer: Gregory\n   Benner\n * Prepack Webpack Plugin - A webpack plugin for prepack. -- Maintainer: Gajus\n   Kuizinas\n * Modules CDN Webpack Plugin - Dynamically load your modules from a CDN. --\n   Maintainer: Thomas Sileghem\n * Generate package.json Plugin - Limit dependencies in a deployment\n   package.json to only those that are actually being used by your bundle. --\n   Maintainer: Paul Myburgh\n * Progressive Web App Manifest - PWA manifest manager and generator. --\n   Maintainer: Arthur A. Bergamaschi\n * FileManager Webpack Plugin - Copy, move, delete files and directories before\n   and after Webpack builds -- Maintainer: Gregory Nowakowski\n * Fork TS Checker Webpack Plugin - Webpack plugin that runs typescript type\n   checker on a separate process. -- Maintainer: TypeStrong Team\n * Duplicate Package Checker Webpack Plugin - Warns you when multiple versions\n   of the same package exist in your bundle -- Maintainer: Darren Scerri\n * Circular Dependency Plugin - Detect modules with circular dependencies when\n   bundling -- Maintainer: Aaron Ackerman\n * webpack-inject-plugin - A webpack plugin to dynamically inject code into the\n   bundle. -- Maintainer: Adam Dierkens\n * Public Path Manipulation Plugin - control publicPath of dynamically loaded\n   resources at runtime -- Maintainer: Andrew Goldis\n * Build Notifier Plugin - Display OS-level notifications for build errors and\n   warnings. -- Maintainer: Rocco Cataldo\n * CSS Cleanup Webpack Plugin - A plugin to remove duplicated and unused css\n   rules -- Maintainer: Dominik Weber\n * Extension Reloader - Hot reloading while developing browser extensions --\n   Maintainer: Rubens P. G. Cavalcante\n * Htmls Webpack Plugin: Simple and fast multiple-htmls-generating plugin for\n   webpack. -- Maintainer: Zack Young\n * Mini css extract plugin: Lightweight CSS extraction plugin -- Maintainer:\n   Webpack Contrib\n * build-hash-webpack-plugin For each build, Webpack generates an in-memory hash\n   allowing to know if two build outputs are the same or not. This plugin writes\n   the described build hash in a separate json file. -- Maintainer: Réda Housni\n   Alaoui\n * webpack-hook-plugin - run any shell commands before or after webpack builds\n   -- Maintainer: David Kwon\n * Dynamic Vendor Webpack Plugin - Gives you a way to import vendors with\n   dynamic variable and specific code splitting. -- Maintainer Lilian\n   Saget-Lethias\n * Define Variable Webpack Plugin - Enhancement of DefinePlugin to store defined\n   things in actual variables. -- Maintainer Lilian Saget-Lethias\n * Shell Script Webpack Plugin - A plugin for running arbitrary shell scripts\n   when compiler hooks are triggered. -- Maintainer Drew Loomer\n * Stylelint Webpack Plugin: A Stylelint plugin for webpack. -- Maintainer:\n   Ricardo Gobbo de Souza\n * ESLint Webpack Plugin: A ESLint plugin for webpack . -- Maintainer: Ricardo\n   Gobbo de Souza\n * Exclude Assets Webpack Plugin: A plugin to exclude assets from webpack output\n   based on a path RegExp pattern. -- Maintainer: Klayton Faria\n * Webpack Shell Plugin Next: A plugin allows you to run any shell commands\n   before or after webpack builds. -- Maintainer: Kuzmin Pavel\n * Gettext Webpack Plugin: Embed localization into your bundle using gettext. --\n   Maintainer: Juan Luis Paz\n * Node Polyfill Plugin: Polyfill Node.js core modules. -- Maintainer: Richie\n   Bendall\n * Bytenode Plugin: Compile JavaScript into bytecode using bytenode. --\n   Maintainer: Herbert Treis Neto\n * Chrome Extension Archive Webpack Plugin Create archive file to publish Chrome\n   Exentions to Chrome Web Store -- Maintainer: KeisukeYamashita\n * Layer-pack Webpack Plugin Allow to glob imports file & directories, build\n   mono repo apps via inheritable source code / npm packages & share webpack\n   configs -- Maintainer: Braun Nathanaël\n * webpack-typescript-directory-compile-plugin Configure an source directory of\n   typescript files and an output directory for JavaScript files. Each\n   typescript file in the source directory and any newly added files will be\n   compiled to individual JavaScript files. -- Maintainer: Stephen Sigwart\n * CycloneDX Webpack Plugin: Create CycloneDX Software Bill of Materials (SBOM)\n   from webpack bundles at compile time. -- Maintainer: OWASP CycloneDX Team","routePath":"/site/webpack/site/webpack/插件 webpack 常用插件","lang":"","toc":[{"text":"官方插件","id":"官方插件","depth":2,"charIndex":65},{"text":"第三方插件","id":"第三方插件","depth":2,"charIndex":1414},{"text":"Webpack Plugins","id":"webpack-plugins","depth":3,"charIndex":1455}],"domain":"","frontmatter":{},"version":""},{"id":75,"title":"webpack-howto","content":"#\n\n统计信息：字数 9298 阅读19分钟\n\n\n教程目标#\n\nThis is a cookbook of how to get things done with webpack. This includes most\nthings we use at Instagram and nothing we don't use.My advice: start with this\nas your webpack docs, then look at the official docs for clarification.\n\n这是Instagram公司的使用的webpack配置，可以从这个文档看起，然后以官方网站为准。\n\n\n准备#\n\n * You know browserify, RequireJS or something similar\n * You see the value in:\n   * Bundle splitting\n   * Async loading\n   * Packaging static assets like images and CSS\n\n\n1. 为什么选择 webpack?#\n\n * It's like browserify but can split your app into multiple files. If you have\n   multiple pages in a single-page app, the user only downloads code for just\n   that page. If they go to another page, they don't redownload common code. 类似于\n   browserify，同时可以分割你的APP成为多个文件，如果一个SPA中有多个页面，用户可以下载当前页面需要的JS；如果跳转到另一个界面，不需要下载相同\n   的代码。\n * It often replaces grunt or gulp because it can build and bundle CSS,\n   preprocessed CSS, compile-to-JS languages and images, among other things.\n   可以实现 grunt gulp 类似的功能。\n\nIt supports AMD and CommonJS, among other module systems (Angular, ES6). If you\ndon't know what to use, use CommonJS.\n\n\n2. Webpack for Browserify people#\n\nThese are equivalent:\n\n\n\nHowever, webpack is more powerful than Browserify, so you generally want to make\na webpack.config.js to keep things organized:\n\n\n\nThis is just JS, so feel free to put Real Code in there.\n\n相对于 browserify , webpack 可以设置配置文件\n\n\n3. How to invoke webpack#\n\n怎样使用 webpack? 在目录中增加配置文件，打包时可以增加参数配置不同的打包环境\n\nSwitch to the directory containing webpack.config.js and run:\n\n * webpack for building once for development\n * webpack -p for building once for production (minification)\n * webpack --watch for continuous incremental build in development (fast!)\n * webpack -d to include source maps\n\n\n4. Compile-to-JS languages#\n\n怎样编译成JS文件（typescript coffeescript ES6 编译成 Js）各种 loader 预处理\n\nwebpack's equivalent of browserify transforms and RequireJS plugins is a loader.\nHere's how you can teach webpack to load CoffeeScript and Facebook JSX+ES6\nsupport (you must npm install babel-loader coffee-loader):\n\nSee also the babel-loader installation instructions for additional dependencies\n(tl;dr run npm install babel-core babel-preset-es2015 babel-preset-react).\n\n\n\nTo enable requiring files without specifying the extension, you must add a\nresolve.extensions parameter specifying which files webpack searches for:\n\n\n\n\n5. Stylesheets and images#\n\nFirst update your code to require() your static assets (named as they would with\nnode's require()):\n\n\n\nWhen you require CSS (or less, etc), webpack inlines the CSS as a string inside\nthe JS bundle and require() will insert a","routePath":"/site/webpack/site/webpack/插件 webpack-howto","lang":"","toc":[{"text":"教程目标","id":"教程目标","depth":2,"charIndex":24},{"text":"准备","id":"准备","depth":2,"charIndex":311},{"text":"1. 为什么选择 webpack?","id":"1-为什么选择-webpack","depth":2,"charIndex":488},{"text":"2. Webpack for Browserify people","id":"2-webpack-for-browserify-people","depth":2,"charIndex":1132},{"text":"3. How to invoke webpack","id":"3-how-to-invoke-webpack","depth":2,"charIndex":1416},{"text":"4. Compile-to-JS languages","id":"4-compile-to-js-languages","depth":2,"charIndex":1772},{"text":"5. Stylesheets and images","id":"5-stylesheets-and-images","depth":2,"charIndex":2388},{"text":"6. Feature flags","id":"6-feature-flags","depth":2,"charIndex":-1},{"text":"7. Multiple entrypoints","id":"7-multiple-entrypoints","depth":2,"charIndex":-1},{"text":"8. Optimizing common code","id":"8-optimizing-common-code","depth":2,"charIndex":-1},{"text":"9. Async loading","id":"9-async-loading","depth":2,"charIndex":-1},{"text":"Additional resources","id":"additional-resources","depth":2,"charIndex":-1},{"text":"FAQ","id":"faq","depth":2,"charIndex":-1},{"text":"webpack doesn't seem modular","id":"webpack-doesnt-seem-modular","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":76,"title":"webpack配置问题：HappyPack: plugin for the loader '1' could not be found!","content":"#\n\n统计信息：字数 1488 阅读3分钟\n\n原配置\n\n\n\n版本\n\n\n\n将loader下query换到HappyPack中\n\n修改为\n\n","routePath":"/site/webpack/site/webpack/插件-HappyPack plugin for the loader could not be found","lang":"","toc":[],"domain":"","frontmatter":{},"version":""}]