# React Design Principles

写这篇文档的目睹是介绍React做了什么。我们建议使用React时不要违背这样的原则。这个文档在于对React的理解，并不是React的应用或者组件。

> **Note:**
>
> 本文档假定您对React有深刻的了解。 它描述了React本身的设计原理，而不是React组件或应用程序。
>
> 有关React的介绍，请查看React中的思考。

### Composition

React的核心特点是由组件组成。不同人编写的组件应该共同工作（没有冲突）。对于一个组件函数化的设计，你不需要考虑内部的变化。

举个例子，如果你使用一个组件，不需要改变任何使用的组件，而只需要传入一些本地的state参数。（React组件对外暴露的接口需要完整，只需要给出接口，其他人即可正确使用）。同理，如果必须的情况下，可以给组件增加一些初始化的数据和卸载的代码。

在一个组件中，使用state或者生命周期函数并不是坏事。就像任何一个强大的特点，他们需要适度使用，但是我们无意删除这部分。相反，我们认为，这部分代码是的React更有用。将来我们会使用函数式编程，但是，在这个模型中仍然会保留本地的state和生命周期函数。

组件经常被描述为“只是简单的函数”，但是我们认为他的用处更大。在React中，组价描述任何任何可组合的行为，这包括render，lifestyle，state。

### Common Abstraction

通常，我们拒绝添加可以在用户环境中实现的功能。我们不想使用无用的库代码来夸大您的应用程序。但是，也有例外。

例如，如果React不提供对本地状态或生命周期挂钩的支持，人们将为其创建自定义抽象。当有多个抽象竞争时，React无法强制或利用其中任何一个的属性。它必须使用最低公分母来工作。

这就是为什么有时我们向React本身添加功能的原因。如果我们注意到许多组件以不兼容或低效的方式实现了某个功能，那么我们可能更喜欢将其烘焙到React中。我们不能轻易做到。当我们这样做时，这是因为我们有信心提高抽象级别会使整个生态系统受益。状态，生命周期挂钩，跨浏览器事件规范化就是很好的例子。

### Escape Hatches

React是程序化的。 它由在Facebook上编写的产品的需求驱动。 尽管它受到尚未完全成为主流的一些范例（例如函数式编程）的影响，但使具有不同技能和经验水平的众多开发人员可以使用它是该项目的明确目标。

如果我们要弃用我们不喜欢的模式，则我们有责任考虑它的所有现有用例，并在弃用之前对社区进行替代教育。 如果很难以声明的方式表达一些对构建应用有用的模式，那么我们将为其提供命令性的API。 如果我们无法为许多应用程序中需要的东西找到理想的API，我们将提供一个临时的，低于标准的API，只要有可能稍后将其淘汰，并为将来的改进打开方便之门。

### Stability

我们重视API的稳定性。在Facebook，我们有超过2万个使用React的组件。其他许多公司，包括Twitter和Airbnb，也是React的重度用户。这就是为什么我们通常不愿更改公共API或行为的原因。

但是，我们认为“没有任何变化”意义上的稳定性被高估了。它很快变成停滞状态。取而代之的是，我们更喜欢“在生产中大量使用它，并且当某些事情发生变化时，会有一条清晰的（最好是自动化的）迁移路径。”

弃用模式时，我们会在Facebook上研究其内部用法并添加弃用警告。他们让我们评估了变化的影响。有时，如果我们发现为时过早，我们会退后一步，我们需要更策略性地考虑使代码库达到可以进行此更改的程度。

如果我们确信更改不会带来太大破坏，并且迁移策略对所有用例都可行，那么我们将向开源社区发布弃用警告。我们与Facebook以外的React的许多用户保持着密切联系，并且我们监视流行的开源项目并指导他们解决这些过时的问题。

考虑到Facebook React代码库的庞大规模，成功进行内部迁移通常可以很好地表明其他公司也不会遇到问题。不过，有时人们会指出我们没有想到的其他用例，因此我们为它们添加了逃生舱口，或者重新考虑了我们的方法。

没有充分的理由，我们不会弃用任何东西。我们认识到有时弃用警告会造成挫败感，但我们添加它们是因为弃用警告为我们和社区中许多人认为有价值的改进和新功能扫清了道路。

例如，我们在React 15.2.0中添加了有关未知DOM道具的警告。许多项目受此影响。但是修复此警告很重要，这样我们才能将对自定义属性的支持引入到React中。在我们添加的每个不赞成使用行为背后都有这样的原因。

添加弃用警告时，我们会将其保留在当前主要版本的其余部分中，并在下一个主要版本中更改其行为。如果涉及大量重复的手动工作，我们将发布一个使大多数更改自动化的codemod脚本。 Codemods使我们能够在庞大的代码库中前进而不会停滞不前，并且我们鼓励您也使用它们。

您可以在react-codemod存储库中找到我们发布的codemod。



### 互通性

我们高度重视与现有系统的互操作性并逐步采用。 Facebook拥有大量的非反应代码库。它的网站使用了称为XHP的服务器端组件系统，React之前的内部UI库和React本身的混合体。对我们而言重要的是，任何产品团队都可以开始将React用于一项小功能，而不必重写他们的代码以押注于此。

这就是为什么React提供转义阴影以与可变模型一起使用，并尝试与其他UI库一起很好地工作的原因。您可以将现有的命令式UI包装到声明式组件中，反之亦然。这对于逐步采用至关重要。

### 排程

即使将组件描述为功能，使用React时也不会直接调用它们。每个组件都返回需要呈现的内容的描述，并且该描述可能包括用户编写的组件（例如<LikeButton>）和特定于平台的组件（例如<div>）。在将来的某个时候，React可以“展开” <LikeButton>，然后根据组件的呈现结果以递归方式将更改实际应用于UI树。

这是一个微妙的区别，但却是一个有力的区别。因为您不调用该组件函数，而是让React调用它，所以这意味着React可以在需要时延迟调用它。在当前的实现中，React递归地遍历树，并在一个滴答中调用整个更新后的树的render函数。但是，将来可能会开始延迟一些更新，以避免丢帧。

这是React设计中的常见主题。一些流行的库实现了“推”式方法，该方法在有新数据可用时执行计算。但是，React坚持采用“拉动”方法，在这种方法中，可以将计算延迟到必要时进行。

React不是通用的数据处理库。它是用于构建用户界面的库。我们认为，它唯一地位于应用程序中，以了解哪些计算现在相关，哪些不相关。

如果屏幕外有东西，我们可以延迟与此有关的任何逻辑。如果数据到达速度快于帧速率，我们可以合并和批量更新。我们可以将用户交互（例如，由按钮单击引起的动画）的工作优先于次要的后台工作（例如，渲染刚从网络加载的新内容），以避免丢帧。

需要明确的是，我们现在没有利用这一优势。但是，这样做的自由是为什么我们更希望控制调度，以及为什么setState（）是异步的。从概念上讲，我们认为它是“计划更新”。

如果让用户直接使用“功能性反应式编程”的某些变体中常见的基于“推”式的范式来构成视图，那么对调度的控制将使我们更难获得。我们要拥有“胶水”代码。

对于React来说，一个主要目标是使返回到React之前执行的用户代码量最少。这确保了React保留了根据其对UI的了解来计划和拆分工作的功能。

团队内部有个玩笑，称React应该被称为“时间表”，因为React不想完全“反应”。

### 开发人员经验

提供良好的开发人员经验对我们很重要。

例如，我们维护了React DevTools，使您可以在Chrome和Firefox中检查React组件树。我们听说，它为Facebook工程师和社区带来了巨大的生产力提升。

我们还尝试加倍努力，以提供有用的开发人员警告。例如，如果您以浏览器无法理解的方式嵌套标签，或者您在API中输入了常见的错字，React就会在开发中警告您。开发人员警告和相关检查是React开发版本比生产版本慢的主要原因。

我们在Facebook内部看到的使用模式可帮助我们了解常见错误以及如何及早预防错误。当我们添加新功能时，我们会尝试预见常见错误并发出警告。

我们一直在寻找改善开发人员体验的方法。我们很乐意听到您的建议并接受您的贡献，以使它变得更好。

### 调试

当出现问题时，重要的是您必须有面包屑来将错误追溯到代码库中的错误源。在React中，props和state是那些面包屑。

如果在屏幕上看到错误，可以打开React DevTools，找到负责渲染的组件，然后查看道具和状态是否正确。如果是这样，您就知道问题出在组件的render（）函数或render（）调用的某个函数中。问题是孤立的。

如果状态错误，则说明问题是由此文件中的setState（）调用之一引起的。同样，这也相对容易定位和修复，因为通常在一个目录中只有几个setState（）调用。