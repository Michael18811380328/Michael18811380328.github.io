
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <meta name="author" content="Michael An">
      
      
        <link rel="canonical" href="https://michael18811380328.github.io/interview/16%20%E9%9D%A2%E8%AF%95/">
      
      <link rel="shortcut icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.1.2, mkdocs-material-6.2.8">
    
    
      
        <title>16 面试 - Michale An Blog</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.cb6bc1d0.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.39b8e14a.min.css">
        
          
          
          <meta name="theme-color" content="#ef5552">
        
      
    
    
    
      
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>body,input{font-family:"Roboto",-apple-system,BlinkMacSystemFont,Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono",SFMono-Regular,Consolas,Menlo,monospace}</style>
      
    
    
    
    
      
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="red" data-md-color-accent="">
      
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#-" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid" aria-label="Header">
    <a href="https://michael18811380328.github.io/" title="Michale An Blog" class="md-header-nav__button md-logo" aria-label="Michale An Blog">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    <label class="md-header-nav__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header-nav__title" data-md-component="header-title">
      <div class="md-header-nav__ellipsis">
        <div class="md-header-nav__topic">
          <span class="md-ellipsis">
            Michale An Blog
          </span>
        </div>
        <div class="md-header-nav__topic">
          <span class="md-ellipsis">
            
              16 面试
            
          </span>
        </div>
      </div>
    </div>
    
      <label class="md-header-nav__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" data-md-state="active" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <button type="reset" class="md-search__icon md-icon" aria-label="Clear" data-md-component="search-reset" tabindex="-1">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header-nav__source">
        
<a href="https://github.com/Michael18811380328/Michael18811380328.github.io/" title="Go to repository" class="md-source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 00-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 01-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 000 40.81l195.61 195.6a28.86 28.86 0 0040.8 0l194.69-194.69a28.86 28.86 0 000-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    Michael18811380328/Michael18811380328.github.io
  </div>
</a>
      </div>
    
  </nav>
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    




<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="https://michael18811380328.github.io/" title="Michale An Blog" class="md-nav__button md-logo" aria-label="Michale An Blog">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    Michale An Blog
  </label>
  
    <div class="md-nav__source">
      
<a href="https://github.com/Michael18811380328/Michael18811380328.github.io/" title="Go to repository" class="md-source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 00-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 01-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 000 40.81l195.61 195.6a28.86 28.86 0 0040.8 0l194.69-194.69a28.86 28.86 0 000-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    Michael18811380328/Michael18811380328.github.io
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="nav-1" type="checkbox" id="nav-1" >
      
      <label class="md-nav__link" for="nav-1">
        About
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="About" data-md-level="1">
        <label class="md-nav__title" for="nav-1">
          <span class="md-nav__icon md-icon"></span>
          About
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../about/" class="md-nav__link">
        关于我
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../about/log/" class="md-nav__link">
        学习日志
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2" >
      
      <label class="md-nav__link" for="nav-2">
        算法
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="算法" data-md-level="1">
        <label class="md-nav__title" for="nav-2">
          <span class="md-nav__icon md-icon"></span>
          算法
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
          
            
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="nav-2-1" type="checkbox" id="nav-2-1" >
      
      <label class="md-nav__link" for="nav-2-1">
        基础
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="基础" data-md-level="2">
        <label class="md-nav__title" for="nav-2-1">
          <span class="md-nav__icon md-icon"></span>
          基础
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../algre/in-place/" class="md-nav__link">
        原地算法
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../algre/part-two/" class="md-nav__link">
        二分算法
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../algre/double-pointer/" class="md-nav__link">
        双指针
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../algre/diverce/" class="md-nav__link">
        分治算法
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../algre/%E6%95%B0%E7%BB%84%E7%AE%97%E6%B3%95/" class="md-nav__link">
        数组算法
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../algre/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" class="md-nav__link">
        排序算法
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../algre/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95/" class="md-nav__link">
        字符串算法
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../algre/%E6%A0%88%E9%98%9F%E5%88%97%E7%AE%97%E6%B3%95/" class="md-nav__link">
        栈队列算法
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../algre/%E9%93%BE%E8%A1%A8%E7%AE%97%E6%B3%95/" class="md-nav__link">
        链表算法
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../algre/%E6%A0%91%E7%AE%97%E6%B3%95/" class="md-nav__link">
        树算法
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../algre/%E5%AD%97%E5%85%B8%E6%A0%91/" class="md-nav__link">
        字典树
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../algre/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" class="md-nav__link">
        贪心算法
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

          
            
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="nav-2-2" type="checkbox" id="nav-2-2" >
      
      <label class="md-nav__link" for="nav-2-2">
        前端算法指南
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="前端算法指南" data-md-level="2">
        <label class="md-nav__title" for="nav-2-2">
          <span class="md-nav__icon md-icon"></span>
          前端算法指南
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../algre/01-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/" class="md-nav__link">
        01-反转链表
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../algre/02-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/" class="md-nav__link">
        02-环形链表
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../algre/03-%E9%93%BE%E8%A1%A8%E5%90%88%E5%B9%B6/" class="md-nav__link">
        03-链表合并
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../algre/04-%E6%B1%82%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9/" class="md-nav__link">
        04-求链表中间节点
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../algre/05-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/" class="md-nav__link">
        05-二叉树层序遍历
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../algre/06-%E6%97%A0%E6%9D%83%E5%9B%BE%20BFS%20%E9%81%8D%E5%8E%86/" class="md-nav__link">
        06-无权图 BFS 遍历
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../algre/07-%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/" class="md-nav__link">
        07-实现优先队列
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../algre/08-%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97%E5%8F%8A%E5%BA%94%E7%94%A8/" class="md-nav__link">
        08-双端队列及应用
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../algre/09-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%9A%84%E7%9B%B8%E4%BA%92%E5%AE%9E%E7%8E%B0/" class="md-nav__link">
        09-栈和队列的相互实现
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../algre/10-n%20%E6%95%B0%E4%B9%8B%E5%92%8C/" class="md-nav__link">
        10-n 数之和
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../algre/11-%E4%BA%8C%E5%8F%89%E6%A0%91/" class="md-nav__link">
        11-二叉树
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

          
            
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="nav-2-3" type="checkbox" id="nav-2-3" >
      
      <label class="md-nav__link" for="nav-2-3">
        高级
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="高级" data-md-level="2">
        <label class="md-nav__title" for="nav-2-3">
          <span class="md-nav__icon md-icon"></span>
          高级
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../algre/K-means/" class="md-nav__link">
        K-means 聚类算法
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../algre/LeetCode%E5%88%B7%E9%A2%98%E6%96%B9%E6%B3%95/" class="md-nav__link">
        LeetCode刷题方法
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../algre/%E5%88%B7%E9%A2%98%E7%AA%8D%E9%97%A8/" class="md-nav__link">
        刷题窍门
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../algre/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/" class="md-nav__link">
        常见算法思想
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../algre/%E5%9B%BE%E7%AE%97%E6%B3%95/" class="md-nav__link">
        图算法
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3" >
      
      <label class="md-nav__link" for="nav-3">
        Javascript
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="Javascript" data-md-level="1">
        <label class="md-nav__title" for="nav-3">
          <span class="md-nav__icon md-icon"></span>
          Javascript
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../javascript/ES6-%E9%98%AE%E4%B8%80%E5%B3%B0/" class="md-nav__link">
        ES6-阮一峰
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../javascript/ES6%20%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/" class="md-nav__link">
        ES6 迭代器与生成器
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../javascript/ES6newFeature/" class="md-nav__link">
        ES6newFeature
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../javascript/JS%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" class="md-nav__link">
        JS 性能优化
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../javascript/es6/" class="md-nav__link">
        es6
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../javascript/%E5%B8%B8%E7%94%A8%E5%88%B0%E7%9A%84ES6%E8%AF%AD%E6%B3%95/" class="md-nav__link">
        常用到的ES6语法
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4" >
      
      <label class="md-nav__link" for="nav-4">
        typescript
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="typescript" data-md-level="1">
        <label class="md-nav__title" for="nav-4">
          <span class="md-nav__icon md-icon"></span>
          typescript
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../typescript/01-%E7%AE%80%E4%BB%8B/" class="md-nav__link">
        01-简介
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../typescript/02-%E5%9F%BA%E7%A1%80/" class="md-nav__link">
        02-基础
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../typescript/03-%E8%BF%9B%E9%98%B6/" class="md-nav__link">
        03-进阶
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../typescript/04-%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%BC%80%E5%8F%91-%E6%B5%8B%E8%AF%95%E7%BC%96%E8%AF%91/" class="md-nav__link">
        04-工程化开发-测试编译
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../typescript/%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%BE%E5%A0%82TS%E5%85%A5%E9%97%A8/" class="md-nav__link">
        网易云课堂TS入门
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../typescript/01-%E4%B8%8A%E6%89%8BTypeScript/" class="md-nav__link">
        01-上手TypeScript
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../typescript/02-TS-Gulp/" class="md-nav__link">
        02-TS-Gulp
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../typescript/03-JavaScript%E8%BF%81%E7%A7%BB/" class="md-nav__link">
        03-JavaScript迁移
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../typescript/04-React%20%26%20Webpack/" class="md-nav__link">
        04-React & Webpack
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../typescript/TS%20%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/" class="md-nav__link">
        TS 常见问题整理
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../typescript/TypeScript%E7%BC%96%E8%AF%91%E5%99%A8%20%E2%80%93%20%E4%B8%BA%E4%BB%80%E4%B9%88%E9%BB%98%E8%AE%A4%E6%83%85%E5%86%B5%E4%B8%8B%E4%B8%8D%E5%90%AF%E7%94%A8downlevelIteration%EF%BC%9F/" class="md-nav__link">
        TypeScript编译器-downlevelIteration
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../typescript/typescript%20%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9%E5%92%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/" class="md-nav__link">
        typescript 编译选项和配置文件
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="nav-5" type="checkbox" id="nav-5" >
      
      <label class="md-nav__link" for="nav-5">
        react
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="react" data-md-level="1">
        <label class="md-nav__title" for="nav-5">
          <span class="md-nav__icon md-icon"></span>
          react
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
          
            
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="nav-5-1" type="checkbox" id="nav-5-1" >
      
      <label class="md-nav__link" for="nav-5-1">
        基础
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="基础" data-md-level="2">
        <label class="md-nav__title" for="nav-5-1">
          <span class="md-nav__icon md-icon"></span>
          基础
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../react/React%20FAQ/" class="md-nav__link">
        React FAQ
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../react/React%20PureComponent%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/" class="md-nav__link">
        React PureComponent 使用指南
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../react/React%20%E7%9A%84%20PureComponent%20%E4%B8%8E%20Component/" class="md-nav__link">
        React 的 PureComponent 与 Component
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../react/React%20%E5%90%84%E7%A7%8Dbug%20%E4%BC%9A%E5%AE%9E%E6%97%B6%E6%9B%B4%E6%96%B0/" class="md-nav__link">
        React 各种bug 会实时更新
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../react/React%20%E6%93%8D%E4%BD%9C%E5%85%83%E7%B4%A0%E7%9A%84API/" class="md-nav__link">
        React 操作元素的API
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../react/React%E6%96%B0%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F--getDerivedStateFromProps/" class="md-nav__link">
        React 新生命周期--getDerivedStateFromProps
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../react/React%E4%B8%AD%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93/" class="md-nav__link">
        React 中数据传输
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../react/React%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%B5%81%E7%A8%8B%E5%9B%BE/" class="md-nav__link">
        React 生命周期流程图
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../react/Refs%20%26%20DOM/" class="md-nav__link">
        Refs & DOM
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../react/getDerivedStateFromProps%E7%9A%84%E4%BD%BF%E7%94%A8/" class="md-nav__link">
        getDerivedStateFromProps的使用
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../react/react%20%E4%B8%AD%E9%80%9A%E8%BF%87ref%E8%8E%B7%E5%8F%96%E9%AB%98%E9%98%B6%EF%BC%88HOC%EF%BC%89%E5%AD%90%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" class="md-nav__link">
        react 中通过ref获取高阶（HOC）子组件实例的解决方案
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../react/reactjs%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%B8%8A%E7%AF%87%EF%BC%88%E9%A6%96%E6%AC%A1%E6%B8%B2%E6%9F%93%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%89/" class="md-nav__link">
        reactjs源码分析-上篇（首次渲染实现原理）
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../react/reactjs%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%B8%8B%E7%AF%87%EF%BC%88%E6%9B%B4%E6%96%B0%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%89/" class="md-nav__link">
        reactjs源码分析-下篇（更新机制实现原理）
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../react/%E5%AF%B9React%20children%E7%90%86%E8%A7%A3/" class="md-nav__link">
        对 React children理解
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

          
            
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="nav-5-2" type="checkbox" id="nav-5-2" >
      
      <label class="md-nav__link" for="nav-5-2">
        高级
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="高级" data-md-level="2">
        <label class="md-nav__title" for="nav-5-2">
          <span class="md-nav__icon md-icon"></span>
          高级
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../react/React%20%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/" class="md-nav__link">
        React 高阶组件
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../react/React%20%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/" class="md-nav__link">
        React 中的事件处理
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../react/React-advanced-guides/" class="md-nav__link">
        React-advanced-guides
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../react/react%20%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/" class="md-nav__link">
        react 项目结构及编码规范
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../react/React-%E9%AB%98%E9%98%B6API/" class="md-nav__link">
        React-高阶API
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

          
            
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="nav-5-3" type="checkbox" id="nav-5-3" >
      
      <label class="md-nav__link" for="nav-5-3">
        性能优化
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="性能优化" data-md-level="2">
        <label class="md-nav__title" for="nav-5-3">
          <span class="md-nav__icon md-icon"></span>
          性能优化
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../react/React%20%E5%BC%BA%E5%88%B6%E6%9B%B4%E6%96%B0%E7%BB%84%E4%BB%B6/" class="md-nav__link">
        React 强制更新组件
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../react/React-Design%20Principles/" class="md-nav__link">
        React-Design Principles
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../react/React-Hooks/" class="md-nav__link">
        React-Hooks
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../react/React-Suspense%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E6%8E%A2%E8%AE%A8-%E6%B2%A1%E7%9C%8B%E6%98%8E%E7%99%BD/" class="md-nav__link">
        React-Suspense的实现与探讨
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../react/React-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" class="md-nav__link">
        React-性能优化
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../react/React.Children%E7%9A%84API/" class="md-nav__link">
        React.Children的API
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../react/React.Component/" class="md-nav__link">
        React.Component
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../react/React.children%E4%BB%8B%E7%BB%8D/" class="md-nav__link">
        React.children介绍
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../react/React%E4%BA%8B%E4%BB%B6/" class="md-nav__link">
        React事件
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../react/React%E6%95%B0%E6%8D%AE%E6%B5%81/" class="md-nav__link">
        React数据流
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../react/React%E8%8E%B7%E5%8F%96%E5%B0%BA%E5%AF%B8/" class="md-nav__link">
        React获取尺寸
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="nav-6" type="checkbox" id="nav-6" >
      
      <label class="md-nav__link" for="nav-6">
        工程化
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="工程化" data-md-level="1">
        <label class="md-nav__title" for="nav-6">
          <span class="md-nav__icon md-icon"></span>
          工程化
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../project/%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7%E7%90%86%E8%AE%BA/" class="md-nav__link">
        前端监控理论
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../project/React%20%26%20Webpack/" class="md-nav__link">
        React & Webpack
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../project/TS-React-Webpack/" class="md-nav__link">
        TS-React-Webpack
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="nav-7" type="checkbox" id="nav-7" >
      
      <label class="md-nav__link" for="nav-7">
        课程笔记
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="课程笔记" data-md-level="1">
        <label class="md-nav__title" for="nav-7">
          <span class="md-nav__icon md-icon"></span>
          课程笔记
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../netease/00-%E7%9B%AE%E5%BD%95/" class="md-nav__link">
        00-目录
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../netease/02-v8%E5%BC%95%E6%93%8E%E5%9B%9E%E6%94%B6%E5%86%85%E5%AD%98%E7%AE%80%E4%BB%8B/" class="md-nav__link">
        02-v8引擎回收内存简介
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../netease/03-node%E4%B8%8B%E9%9D%A2%E7%9A%84Restful%E5%AE%9E%E7%8E%B0/" class="md-nav__link">
        03-node下面的Restful实现
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../netease/04-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%9A%84%E6%8F%90%E5%8D%87%E2%80%94%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E6%88%91%E4%BB%AC%E4%BB%A3%E7%A0%81%E7%9A%84%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7/" class="md-nav__link">
        04-编程思想的提升—如何提高我们代码的可扩展性
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../netease/06-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%E5%92%8Cssr/" class="md-nav__link">
        06-浏览器渲染原理和ssr
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../netease/07-%E7%BD%91%E6%98%93%E7%9C%9F%E5%AE%9E%E9%A1%B9%E7%9B%AEwebpack%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90/" class="md-nav__link">
        07-网易真实项目webpack配置解析
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../netease/08-%E4%BB%8E%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90API%E5%B1%82/" class="md-nav__link">
        08-从架构分析API层
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../netease/09-%E5%89%8D%E7%AB%AF%E8%B4%9F%E8%B4%A3%E4%BA%BA%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AE%B9/" class="md-nav__link">
        09-前端负责人的工作内容
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../netease/10-%E5%88%86%E6%9E%90%E6%BA%90%E7%A0%81%E5%AD%A6%E6%9E%B6%E6%9E%84/" class="md-nav__link">
        10-分析源码学架构
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../netease/11-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81/" class="md-nav__link">
        11-设计模式高质量代码
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../netease/12-nodeJS%2BMongoDB%E7%99%BB%E5%BD%95%E7%B3%BB%E7%BB%9F/" class="md-nav__link">
        12-nodeJS+MongoDB登录系统
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../netease/12-nodejs-mongodb-mongoose/" class="md-nav__link">
        12-nodejs-mongodb-mongoose
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../netease/13-%E4%BD%BF%E7%94%A8VUE%E5%88%9B%E5%BB%BA%E7%BB%84%E4%BB%B6%EF%BC%88%E6%B2%A1%E5%AD%A6%E5%AE%8C%EF%BC%89/" class="md-nav__link">
        13-使用VUE创建组件（没学完）
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../netease/16-%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6%E5%B7%A5%E5%85%B7/" class="md-nav__link">
        16-构建自己的脚手架工具
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../netease/17-webpack%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/" class="md-nav__link">
        17-webpack编译原理分析
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../netease/20-%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%8A%80%E8%83%BD-VUE%EF%BC%88%E6%B2%A1%E5%AD%A6%E5%AE%8C%EF%BC%89/" class="md-nav__link">
        20-组件封装的基本技能-VUE（没学完）
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../netease/21-ssr/" class="md-nav__link">
        21-ssr
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../netease/24-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%A6%82%E4%BD%95%E5%81%9A/" class="md-nav__link">
        24-单元测试如何做
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../netease/25-%E5%9F%BA%E4%BA%8ENodeJS%E6%89%93%E9%80%A0Web%E6%9E%B6%E6%9E%84%E4%B8%AD%E9%97%B4%E5%B1%82/" class="md-nav__link">
        25-基于NodeJS打造Web架构中间层
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../netease/26-webpack%E7%9A%84%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7/" class="md-nav__link">
        26-webpack的高级技巧
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="nav-8" type="checkbox" id="nav-8" checked>
      
      <label class="md-nav__link" for="nav-8">
        重点背诵
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="重点背诵" data-md-level="1">
        <label class="md-nav__title" for="nav-8">
          <span class="md-nav__icon md-icon"></span>
          重点背诵
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../01%20%E9%9D%A2%E8%AF%95%E9%A2%981-%281-30%29/" class="md-nav__link">
        01 面试题1-(1-30)
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../02%20%E9%9D%A2%E8%AF%95%E9%A2%981-%2830-60%29/" class="md-nav__link">
        02 面试题1-(30-60)
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../03%20%E9%9D%A2%E8%AF%95%E9%A2%981-%2860-100%29/" class="md-nav__link">
        03 面试题1-(60-100)
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../04%20%E9%9D%A2%E8%AF%95%E9%A2%982-%E6%AF%94%E8%BE%83%E8%80%81/" class="md-nav__link">
        04 面试题2-比较老
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../05%20%E9%9D%A2%E8%AF%95%E9%A2%985-%E6%9C%89%E7%AD%94%E6%A1%88/" class="md-nav__link">
        05 面试题5-有答案
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../06%20%E5%A4%A7%E5%8E%82%E8%A6%81%E6%B1%82/" class="md-nav__link">
        06 大厂要求
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../07%20%E9%9D%A2%E8%AF%95%E9%A2%981-%28101-136%29/" class="md-nav__link">
        07 面试题1-(101-136)
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../08%20%E9%9D%A2%E8%AF%95%E9%A2%983-%E6%B2%A1%E7%AD%94%E6%A1%88/" class="md-nav__link">
        08 面试题3-没答案
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../09%20%E9%9D%A2%E8%AF%95%E9%A2%984%28%E5%85%A8%E6%A0%88%29/" class="md-nav__link">
        09 面试题4(全栈)
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../10%20HR%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE-%E6%AD%A3%E5%9C%A8%E5%81%9A/" class="md-nav__link">
        10 HR面试题目-正在做
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../11%20%E8%B1%AA%E6%83%85%E5%A4%A7%E4%BD%AC%E6%97%A5%E5%B8%B8%E5%B7%A5%E4%BD%9C%E6%84%9F%E6%82%9F/" class="md-nav__link">
        11 豪情大佬日常工作感悟
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../12%20%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/" class="md-nav__link">
        12 知识体系
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../13%20facebook%20%E5%9B%BD%E5%A4%96%E9%9D%A2%E8%AF%95/" class="md-nav__link">
        13 facebook 国外面试
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../14%20%E9%98%BF%E9%87%8C1-4%E9%9D%A2%E9%9D%A2%E7%BB%8F/" class="md-nav__link">
        14 阿里1-4面面经
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../15%20JavaScript%20%E5%9F%BA%E7%A1%80/" class="md-nav__link">
        15 JavaScript 基础
      </a>
    </li>
  

          
            
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
      
        
      
      
      <a href="./" class="md-nav__link md-nav__link--active">
        16 面试
      </a>
      
    </li>
  

          
        </ul>
      </nav>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="https://github.com/Michael18811380328/Michael18811380328.github.io/edit/master/docs/interview/16 面试.md" title="Edit this page" class="md-content__button md-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75L3 17.25z"/></svg>
                  </a>
                
                
                <p>由于公司年前的一些战略调整，和自己预感公司路线的担忧，自己也不得不提前准备一些后路，这期间陆续面试了头条，西瓜视频这边，支付宝公益这边和猿辅导这块。这次和三年前的职业变更，leetcode 刷了一些，但是其实也没刷多少，至少面头条的时候，也只是刷了少数 easy / medium 和那些后端相比少了很多。</p>
<p>然后就是特别推荐这个技术图，去准备复习的知识点:</p>
<p><a href="https://github.com/ouvens/frontend-system-map">现代前端技术知识体系</a></p>
<p>这期间，还有就是对自己特别模糊记忆不清楚的一定记笔记，这期间自己 Evernote 也不断誊抄“答案” 也有 32篇左右，主要还是需要不断加强记忆，尤其面试前。</p>
<p>简单说下三家的各自经历吧。</p>
<h3 id="-">字节跳动-视频架构<a class="headerlink" href="#-" title="Permanent link">&para;</a></h3>
<p>这个大概是十一月面的，这个时候离职意愿还没有那么强烈，而是帮助前同事去完成一个内推名额。打心底，我觉得头条加班多，以及江湖一些小恩怨，我不太偏向去。不过面试还是认认真真的准备，听闻面试很难，加上自己本身是偏 Engineering (Production &gt; Science)多点那种， 所以感觉跪的概率还是比较大。</p>
<p>大概一面是交叉面，是在头条的海淀总部那边，是安全的前端小哥，感觉年龄很年轻（我前同事说她去头条最大感觉就是小鲜肉太多了）。一面纯粹是基础面试题，涉及 JS 的非常多，大概题目我后面记录了下：</p>
<ul>
<li>JS 的基本数据类型?</li>
<li>引用类型是什么？</li>
<li>ES6 Symbol 是什么，用在什么地方？</li>
<li>最满意的项目，学到了什么？</li>
<li>题目1</li>
</ul>
<p><img alt="img" src="https://img1.wxzxzj.com/5E8CC094-2380-4A85-AAD3-97D4E76833A1.png" /></p>
<ul>
<li>题目2</li>
</ul>
<p><img alt="img" src="https://img1.wxzxzj.com/B9EFF5DB-B6BB-4F08-9FE4-31869AE36305.png" /></p>
<ul>
<li>实现函数防抖或者截流的任意一个？</li>
<li>使用 ES5 实现原型链继承？</li>
<li>算法题目</li>
</ul>
<p><img alt="img" src="https://img1.wxzxzj.com/E0EE444C-0E8C-47D0-A1AF-FF5D9F1701C2.png" /></p>
<ul>
<li>统计一个字符串出现次数最大的字符，并且获取出现频率 比如 "accdddccaaaaa" 答案 "a” 6</li>
</ul>
<p>总的来说，一面还是比较快，40-50分钟就完成了，全部都是偏 JS 的题目，大概面完后八点半去了另外一个地方，开车去的，是另外一个办公地点。</p>
<p>二面是未来同部门同事（也很年轻，给我们这些老人一些生路把）面试的，问了也是巨多的问题，涉及到了项目和视频这块，大概聊了一个多快一个半小时了。也要求手写代码，和思路总结这些。</p>
<ul>
<li>var vs const ？ 什么是变量提升？</li>
<li>平时学习的途径有哪些？会看什么样的书籍？</li>
<li>Object.defineProperty() 里面，可以设置哪些属性，分别代表什么意思？ 实际场景有哪些用到了</li>
<li>手写 实现 JS 单例模式和订阅模式(EventMitter)</li>
<li>手写，使用 Promise 实现任务队列发送请求，实现最大请求数目限制任务?</li>
<li>如何实现无缝切换分辨率？</li>
<li>HLS 播放，dts 出错，有什么解决方案没有？</li>
<li>如何解决画面音频不同步的问题？</li>
<li>H.264 里面 I 帧，B 帧 P 帧，代表什么？ IDR 帧代表什么？</li>
<li>H.265 的解决方案有哪些</li>
<li>算法 找到连续某个字符串中不重复的最大子字符， 类似 “acdeadea” =&gt; “acde” leetCode 上的题目</li>
<li>如何克服跨域问题，常见的跨域手段有哪些？</li>
<li>HTTPS 的工作原理，证书机制有什么好处？</li>
<li>如何推进前端和后端需要配合的项目？</li>
<li>WebVR 底层原理是，播放器架构是怎样的？</li>
</ul>
<p>二面问的问题也非常多，涉及到前端基础和项目设计的问题，然后感觉那天精神状态特别好，很多问题思路都比较不错，然后感觉对面的小哥也非常好奇我得项目经历，彼此项目交集还是比较多，他也觉得有些思路之前项目没有用到过。差不多从8点40多面到10点二十左右，然后就叫前同事下班走了。</p>
<p>三面在隔了两天通知了，面试的是这边前端总负责人，问了一些关于简历和意愿的一些问题：</p>
<ul>
<li>个人职业发展的经历？说出感觉印象最深的项目？</li>
</ul>
<p>自己答的是一个 Canvas 粒子动画和现在整体播放的优化这块。</p>
<p>然后面试官又根据这些项目问了一些实现细节，关于代码设计和一些特性原理这块。</p>
<p>总之三面就是一些项目经历的总结，类似 PPT 展示这样子，要说服下面的观众，觉得你做的事情还是很有意义的。</p>
<p>差不多三十分钟左右，又叫坐车去头条总部那边，应该就是 HR 面试了。当然 HR 就是一些常规的问题，然后和个人一些发展预期。其中我个人认为失败感最强的时间段，个人恰好说到了现在，感觉身边都是牛人，为什么项目最后推进一直那么顺利，和创业的不可预知因素的无奈等等。</p>
<p>头条的总体流程还是很快的，隔了周末， offer 开始沟通，整体 Package 感觉头条确实给力，但是自己还是觉得自己创业这块还有希望，加上不太想加班哈哈哈，只能婉拒了。</p>
<h3 id="-_1">支付宝 - 公益<a class="headerlink" href="#-_1" title="Permanent link">&para;</a></h3>
<p>后面前部门关系比较好的 TL 把简历推给了支付宝这边，北京三环总部那边，支付宝公益也就是种树，春节红包这边，这块项目吸引力确实足够。</p>
<p>一面是周六上午，人很 Nice 说周六上午过来面试也行，他也刚好过来加班。一面主要是问了下近况，和项目这些，然后就是一轮笔试题目，一面应该是未来一起共事的同事。</p>
<ul>
<li>Sticky Footer 布局，内容增加，但是 Footer 始终在页面底部</li>
</ul>
<p><img alt="img" src="https://img1.wxzxzj.com/176A655E-5A8E-4EB5-BD00-9FF02597702B.png" /></p>
<ul>
<li>给页面所有 Class 名称为 <code>item</code> 的元素绑定 <code>click</code> 事件;</li>
<li>代码阅读</li>
</ul>
<p><img alt="img" src="https://img1.wxzxzj.com/3895C69C-2E4D-4964-9F41-15E5F3BA3CA1.png" /></p>
<ul>
<li>实现一个简单的事件订阅模式，实现 <code>on()</code> 和 <code>emit()</code> 方法；</li>
<li>实现一个正则表达式，匹配 https://gwalipay.alicdn.com/style-main.css?( 匹配所有包含 .css 的文件，可能带查询参数)</li>
</ul>
<p>差不多，写完之后，又闲聊了这边支付宝的整体情况，后面就走了。</p>
<p>过了差不多几天，周三下午收到面试通过，准备二面，面试是远程电话，上海团队的交叉面试。二面技术基础的问的比较少，还是主要问项目，和项目的产品参与度？</p>
<ul>
<li>说说过去一年做的比较重要的项目？</li>
<li>性能优化的具体实践，如何解决页面卡和慢的问题?</li>
<li>优化的数据对比是怎样的？上线后数据是怎样的？（这里面试官察觉出自己产品嗅觉不是很敏感）</li>
<li>VR 图片是怎么优化的？线上转码系统是怎样工作的？</li>
<li>播放稳定性的埋点是怎样的？</li>
<li>线下产品的重要指标有哪些，技术会关系到哪些？</li>
</ul>
<p>当然差不多二面聊了45分钟，由于在地铁站面试的，感觉交流不是那么顺利，不过好在后面还是通知了三面四面的安排。也加了二面的微信，觉得未来如果来上海可以交流哈哈哈。</p>
<p>过了差不多一周左右时间，因为当时人去云南了，一直等回帝都，才能面试。三面四面是一起面试的，也是电话面试，三面结束没多久，就面试了四面。</p>
<p>他们也是问了一些项目上的问题，其中四面面试官比较牛？开篇就是像我这种经验的人，先给20分钟吹牛，然后他再问20分钟问题？</p>
<p>然后就 balabala 说了20多分钟，然后提了关于 PWA 缓存利用，和 Prefetch 包括 Local DNS 和阿里云 CDN 热源的问题，有一些是关于架构层面的内容，涉及到整个集群的服务利用等，总之问的非常多关于链路的内容，然后又问了 H.265 解决思路和优化怎么做的，以及同步音画等问题。感觉四面最后一面还是暴露了一些架构上的确实，和所谓知识广度问题。</p>
<p>过了三天，通知 HR 面试，见到了 HR 和 前端组负责人，沟通了职业经历，和不稳定性。HR 也大致聊了个人意愿和发展预期，差不多很快两个人也就聊了40多分钟就结束了，然后在国贸那边吃了汉堡王，感觉阿里这面试流程真的算是比较长（虽然很早就知道），由于那个时候双十二和红包活动，过了十天左右，HR 才通知 Offer 申请下来，进行双向沟通，这里就是涉及特别重要的个人发展问题。我个人如果偏 Web 多媒体的话，可能那边短期是不会有个方向的，但是后期肯定会有，还有就是薪资上，不会去和头条 Match ，看个人抉择。我觉得这边 HR 还是很 Nice 说足了自己的一些不足，包括所谓“宽度“ 和 业务思维这些问题，强调这个时间点是不是最好的时候回归阿里这样的。当然最后，自己还是断了这个 Offer。一个是自己觉得业务兴趣问题，也包括整个薪资打底的问题。</p>
<h3 id="_1">猿辅导<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h3>
<p>其实猿辅导也是年后自己公司进行团队调整和疫情薪资调整，包括更严重的 Streaming 流量控制的原因，自己接触了这边。面试流程很快，由于在家办公，猿辅导是在牛客网上面试，一二轮都是交叉面试（是因为面试人员紧张），问的问题也都还是非常基础:</p>
<ul>
<li>函数防抖/截流</li>
<li>Event Loop 代码题目</li>
<li>算法，二分查找</li>
<li>Promise All</li>
<li>Object.Proxy</li>
<li>ES6 的一些新特性</li>
<li>箭头函数</li>
<li>继承</li>
</ul>
<p>其中算法问了关于树的，左视树，输出左边看到的节点。</p>
<p>总的来说每一轮都控制在 45 分钟左右，随后就是部门 TL 的三面，聊了项目上的一些，也涉及了团队方面的一些问题，包括规范，执行等。由于项目问题已经被问了太多次，自己是真的回答的滚瓜乱熟了。大概隔了两天，HR 面试确认个人发展预期，然后和前端负责人双向沟通，大概也就是现任 TL ，给的建议，建议我从技术广度去发展，不要局限某个领域的深度扩展，这边也给予人员管理的期望，希望可以共建专业的前端团队等。</p>
<p>总的来说这三家公司各有特点，从个人角度看，也是暴露了自己整个前几年过于专注的问题，整个思维的广度有所欠缺，和前TL聊的时候，他给的建议，就是要学会讲故事的能力，说白了技术基础，是个人稍微多努力点，多记忆点，都好通过，到更高纬度去思考和项目分析，这种是实战和总结的。感觉的确离那个目标还是有一定距离，总之大家在平时学习积累中，总结和思考一定要有，还有就是在职业发展后期，一定要强调个人的业务联动能力，学会去把项目的整体流程把控起来，说白了技术基础决定你拥有现在的饭碗，个人综合能力（技术能力哦，产品能力，逻辑思维能力，沟通能力）决定你在市场的整体定位。</p>
<h1 id="daily-interview-question">Daily-Interview-Question<a class="headerlink" href="#daily-interview-question" title="Permanent link">&para;</a></h1>
<p>第 160 题：输出以下代码运行结果，为什么？如果希望每隔 1s 输出一个结果，应该如何改造？注意不可改动 square 方法</p>
<div class="codehilite"><pre><span></span><code>const list = [1, 2, 3]
const square = num =&gt; {
  return new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
      resolve(num * num)
    }, 1000)
  })
}

function test() {
  list.forEach(async x=&gt; {
    const res = await square(x)
    console.log(res)
  })
}
test()
</code></pre></div>

<p>解析：<a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/389">第 160 题</a></p>
<h2 id="_2">最近汇总<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h2>
<p>第 159 题：实现 <code>Promise.retry</code>，成功后 <code>resolve</code> 结果，失败后重试，尝试超过一定次数才真正的 <code>reject</code></p>
<p>解析：<a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/387">第 159 题</a></p>
<p>第 158 题：如何模拟实现 Array.prototype.splice</p>
<p>解析：<a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/384">第 158 题</a></p>
<p>第 157 题：浏览器缓存 ETag 里的值是怎么生成的</p>
<p>解析：<a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/383">第 157 题</a></p>
<p>第 156 题：求最终 left、right 的宽度</p>
<div class="codehilite"><pre><span></span><code>&lt;div class=&quot;container&quot;&gt;
    &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;style&gt;
  * {
    padding: 0;
    margin: 0;
  }
  .container {
    width: 600px;
    height: 300px;
    display: flex;
  }
  .left {
    flex: 1 2 300px;
    background: red;
  }
  .right {
    flex: 2 1 200px;
    background: blue;
  }
&lt;/style&gt;
</code></pre></div>

<p>注：此题和 155 题 left、right 样式有些不同</p>
<p>解析：<a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/382">第 156 题</a></p>
<p>第 155 题：求最终 left、right 的宽度</p>
<div class="codehilite"><pre><span></span><code>&lt;div class=&quot;container&quot;&gt;
    &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;style&gt;
  * {
    padding: 0;
    margin: 0;
  }
  .container {
    width: 600px;
    height: 300px;
    display: flex;
  }
  .left {
    flex: 1 2 500px;
    background: red;
  }
  .right {
    flex: 2 1 400px;
    background: blue;
  }
&lt;/style&gt;
</code></pre></div>

<p>解析：<a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/381">第 155 题</a></p>
<p>第 154 题：弹性盒子中 flex: 0 1 auto 表示什么意思</p>
<p>解析：<a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/380">第 154 题</a></p>
<p>第 153 题：实现一个批量请求函数 multiRequest(urls, maxNum)</p>
<p>要求如下：</p>
<ol>
<li>要求最大并发数 maxNum</li>
<li>每当有一个请求返回，就留下一个空位，可以增加新的请求</li>
<li>所有请求完成后，结果按照 urls 里面的顺序依次打出</li>
</ol>
<p>解析：<a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/378">第 153 题</a></p>
<p>2019-12-31</p>
<blockquote>
<p>第 152 题：实现一个 normalize 函数，能将输入的特定的字符串转化为特定的结构化数据</p>
</blockquote>
<p>解析：<a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/331">第 152 题</a></p>
<p>2019-11-25</p>
<blockquote>
<p>第 151 题：用最简洁代码实现 indexOf 方法</p>
</blockquote>
<p>解析：<a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/321">第 151 题</a></p>
<p>2019-11-21</p>
<blockquote>
<p>第 150 题：二分查找如何定位左边界和右边界</p>
<p>不使用JS数组API，查找有序数列最先出现的位置和最后出现的位置</p>
</blockquote>
<p>解析：<a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/320">第 150 题</a></p>
<p>2019-11-12</p>
<blockquote>
<p>第 149 题：babel 怎么把字符串解析成 AST，是怎么进行词法/语法分析的？</p>
</blockquote>
<p>解析：<a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/315">第 149 题</a></p>
<p>2019-11-01</p>
<blockquote>
<p>第 148 题： webpack 中 loader 和 plugin 的区别是什么（平安）</p>
</blockquote>
<p>解析：<a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/308">第 148 题</a></p>
<p>2019-10-31</p>
<blockquote>
<p>第 147 题：v-if、v-show、v-html 的原理是什么，它是如何封装的？</p>
</blockquote>
<p>解析：<a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/307">第 147 题</a></p>
<p>2019-10-29</p>
<blockquote>
<p>第 146 题：Vue 中的 computed 和 watch 的区别在哪里（虾皮）</p>
</blockquote>
<p>解析：<a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/304">第 146 题</a></p>
<p>2019-10-24</p>
<blockquote>
<p>第 145 题：前端项目如何找出性能瓶颈（阿里）</p>
</blockquote>
<p>解析：<a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/300">第 145 题</a></p>
<p>2019-10-22</p>
<blockquote>
<p>第 144 题：手写二进制转 Base64（阿里）</p>
</blockquote>
<p>解析：<a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/299">第 144 题</a></p>
<p>2019-10-21</p>
<blockquote>
<p>第 143 题：将 '10000000000' 形式的字符串，以每 3 位进行分隔展示 '10.000.000.000'</p>
</blockquote>
<p>解析：<a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/296">第 143 题</a></p>
<p>2019-10-17</p>
<blockquote>
<p>第 142 题：（算法题）求多个数组之间的交集（阿里）</p>
</blockquote>
<p>解析：<a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/293">第 142 题</a></p>
<p>2019-10-15</p>
<blockquote>
<p>第 141 题：Vue 中的 computed 是如何实现的（腾讯、平安）</p>
</blockquote>
<p>解析：<a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/291">第 141 题</a></p>
<p>2019-10-14</p>
<blockquote>
<p>第 140 题：为什么 HTTP1.1 不能实现多路复用（腾讯）</p>
</blockquote>
<p>解析：<a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/290">第 140 题</a></p>
<p>2019-09-17</p>
<blockquote>
<p>第 139 题：谈一谈 nextTick 的原理</p>
</blockquote>
<p>解析：<a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/281">第 139 题</a></p>
<p>2019-09-11</p>
<blockquote>
<p>第 138 题：反转链表，每 k 个节点反转一次，不足 k 就保持原有顺序（哔哩哔哩）</p>
</blockquote>
<p>解析：<a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/278">第 138 题</a></p>
<p>2019-09-04</p>
<blockquote>
<p>第 137 题：如何在 H5 和小程序项目中计算白屏时间和首屏时间，说说你的思路</p>
</blockquote>
<p>解析：<a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/272">第 137 题</a></p>
<h1 id="p6">面试分享：两年工作经验成功面试阿里P6总结<a class="headerlink" href="#p6" title="Permanent link">&para;</a></h1>
<h2 id="_3">前言<a class="headerlink" href="#_3" title="Permanent link">&para;</a></h2>
<p>本文主要给大家带来一些我面试的经历和经验，希望对正在求职的同学有所帮助。我先大致说下面试之前的个人情况：2017年7月正式入职海康威视数字技术股份有限公司，使用Vue.js技术栈。</p>
<p>我写的篇幅可能有点长，如果只想看成功的面试请直接从<a href="https://juejin.im/post/5d690c726fb9a06b155dd40d#heading-122">阿里企业智能事业部（一面）</a>开始，大家见谅哈。</p>
<p>这里推荐阅读之前写的文章（前面两篇实用型，后面三篇对面试应该会有帮助）：</p>
<ul>
<li><a href="https://juejin.im/post/5cb12844e51d456e7a303b64">Vue CLI 3结合Lerna进行UI框架设计</a></li>
<li><a href="https://juejin.im/post/5cc4694a6fb9a03238106eb9">Cz工具集使用介绍 - 规范Git提交说明</a></li>
<li><a href="https://juejin.im/post/5cd9854b5188252035420a13">你真的理解$nextTick么</a></li>
<li><a href="https://juejin.im/post/5cd8a7c1f265da037a3d0992">基于Vue实现一个简易MVVM</a></li>
<li><a href="https://juejin.im/post/5e11ef3b6fb9a0483a135fa7">2019 前端之路（干货满满）</a>（墙裂推荐）</li>
</ul>
<h2 id="_4">关于阿里<a class="headerlink" href="#_4" title="Permanent link">&para;</a></h2>
<p>Hi，大家好，我们是阿里巴巴新成立的BU，目前还有大量的Web前端职位空缺，机会难得，希望正在找工作的同学们可以来试试：</p>
<ul>
<li>目前Web前端急缺P6和P7（阿里的很多BU都只招P7了）</li>
<li>新的BU你进来即是元老😂😂😂</li>
<li>前端技术体系大部分需要一起重新开拓，可以学习到更多的新内容</li>
<li>主要负责PC端、客户端、钉钉E应用以及支付宝小程序的开发（我本人完全不会小程序，不用担心😂😂😂）</li>
<li>技术栈是React（如果你是Vue技术栈完全不用担心，因为我也是😂😂😂）</li>
<li>其他BU面试可能有五轮，我们这边只有4轮面试</li>
</ul>
<p>真的机会难得哦，如果想更多了解我们BU以及找我内推的同事加我钉钉或者微信（纯粹找我了解或者沟通技术也行，啊哈哈）：18768107826</p>
<h2 id="_5">简历<a class="headerlink" href="#_5" title="Permanent link">&para;</a></h2>
<p>我的简历只是简单的用MD做了一份，大致包含了以下几个部分：</p>
<ul>
<li>基本资料</li>
<li>专业技能</li>
<li>工作经历</li>
<li>实习经历（可选）</li>
<li>项目经历</li>
</ul>
<blockquote>
<p>小提示：在<strong>基本资料</strong>里一定要填写正确的邮箱地址，我在前期面试的时候都没有打开邮箱查看面试情况，导致一些面试的时间点和面试结果都不清楚（一直以为会发短信通知）。</p>
<p>如果去现场面试，一定要记得带上笔和简历。一方面你给面试官的简历必定是最新的（在不断面试的过程中你必定会修改简历），另一方面这也会给面试官一种非常舒心的感觉。</p>
</blockquote>
<p>对于简历这里提一点，在写自己的<strong>专业技能</strong>和<strong>项目经历</strong>时尽量不要给自己挖坑，这里展示一下我的专业技能（我会的不多）：</p>
<ul>
<li>熟悉嵌入式C、JavaScript、Node.js</li>
<li>熟悉Vue.js框架</li>
</ul>
<p>切忌写一大堆让人感觉花里胡哨的技能，尤其是一些很浅显的技能（基本技能除外）。如果你有一些别人很难替代的技能，那这些技能就是亮点了，我这里就没什么亮点技能。有些技能你会但是不熟练，你可以适当的在你的<strong>项目经历</strong>中体现出来。对于<strong>项目经历</strong>尽量挑自己觉得非常有技术含量的项目进行说明（宁缺毋滥），对于自己参加过但不是特别熟悉的项目尽量不要填写，防止给自己挖坑。</p>
<blockquote>
<p>小提示：这里附上的我的<a href="https://github.com/ziyi2/interview/blob/master/README.md">面试简历</a>供大家参考。感谢jsliang的文章<a href="https://juejin.im/post/5d05ca79f265da1bc75237ea">2019 面试系列 - 简历</a>，大家制作简历时也可以参考这篇文章。</p>
</blockquote>
<p>在投递简历时大家千万不要被招聘信息中的要求吓到，记得有一次投递简历时我对招聘者说自身不太符合要求，招聘者当时说要求都是唬人的，觉得有兴趣就投，有些招聘要求可能正是你未来学习或者深入的领域。</p>
<h2 id="_6">面试<a class="headerlink" href="#_6" title="Permanent link">&para;</a></h2>
<p>简历制作完后我大概投了四家公司：有赞、滴滴、51信用卡和阿里。其中有赞挂在二面，滴滴挂在一面，51信用卡挂在一面，阿里两个部门挂在一面，一个部门面试成功。很多面试者的经历可能都是像我这样，在一次次的面试失败中不断的总结进步，最终拿到理想的Offer。</p>
<blockquote>
<p>小提示：建议大家在投递简历时可以先投递一些试水的小公司，先检验一下自己是不是可以胜任这些公司的面试。同时在每一次面试完后记得把面试官提问的问题记录下来，对于没有答上来的问题还是要好好搞懂或者实践一下，因为很有可能下一家的面试官会问同样的问题。</p>
</blockquote>
<p>在面试的过程中，这里我给出几点意见：</p>
<ul>
<li>心态放平稳，假设第一题你答不上来很正常，面试官不会因为第一题你不会就PASS你</li>
<li>不会的题目一定不要瞎猜，往往面试官给你挖的坑就是希望你往错的方向猜，一定要答不知道</li>
<li>不要说太多跟当前面试题无关的内容，问你什么问题尽量就答什么问题，除非面试官指定你发散一下思维</li>
<li>如果没有听懂面试题可以试着询问面试官，您要问的是关于xxx的问题么</li>
<li>对于某些问题一定要自己先提前精炼一下（例如作用域链、继承以及原型链等问题）</li>
<li>如果面试官问的某项技术自己在某些场景使用过或看到别的场景有使用，可结合这些场景进行讲解（让面试官知道你不仅仅理解它，你还会很好的使用它）</li>
<li>如果是Vue技术栈希望可以深入源码或者至少理解一些别人的源码分析</li>
<li>如果面试阿里那么面试之前一定要好好准备这样一个问题：你觉得你最擅长什么</li>
<li>面试一定要真诚，切勿投机取巧</li>
<li>面试态度一定要谦虚</li>
</ul>
<p>接下来我会按照面试顺序给出面试题以及自己理解的一些答案：</p>
<ul>
<li>大部分答案都是借鉴别人的博客</li>
<li>有些答案不一定合理</li>
<li>有些答案写的很零散</li>
<li>有些答案会举一反三</li>
<li>有些题目太基础或者重复了就没有写答案</li>
<li>有些题目太宏观或者不知道怎么回答合理，希望大家可以在评论中补充答案供更多的人受益</li>
</ul>
<h2 id="_7">有赞（一面）<a class="headerlink" href="#_7" title="Permanent link">&para;</a></h2>
<h3 id="css">说说CSS选择器以及这些选择器的优先级<a class="headerlink" href="#css" title="Permanent link">&para;</a></h3>
<ul>
<li><code>!important</code></li>
<li>内联样式（1000）</li>
<li>ID选择器（0100）</li>
<li>类选择器/属性选择器/伪类选择器（0010）</li>
<li>元素选择器/关系选择器/伪元素选择器（0001）</li>
<li>通配符选择器（0000）</li>
</ul>
<h3 id="bfc">你知道什么是BFC么<a class="headerlink" href="#bfc" title="Permanent link">&para;</a></h3>
<blockquote>
<p>小提示：这个问题重点是BFC是什么，BFC触发的条件有哪些，BFC可以干什么。这里我试着讲解了一下Boostrap的清除浮动（display：table创建匿名table-cell间接触发BFC），如果有看到别的场景使用或者自身有使用的场景可以尝试讲解一下使用技巧。这样可以让面试官觉得你不仅仅知道他问的东西是什么，你还能很好的使用它。</p>
</blockquote>
<h4 id="bfc_1">什么是BFC<a class="headerlink" href="#bfc_1" title="Permanent link">&para;</a></h4>
<p>BFC 全称为块级格式化上下文 (Block Formatting Context) 。BFC是 W3C CSS 2.1 规范中的一个概念，它决定了元素如何对其内容进行定位以及与其他元素的关系和相互作用，当涉及到可视化布局的时候，Block Formatting Context提供了一个环境，HTML元素在这个环境中按照一定规则进行布局。一个环境中的元素不会影响到其它环境中的布局。比如浮动元素会形成BFC，浮动元素内部子元素的主要受该浮动元素影响，两个浮动元素之间是互不影响的。这里有点类似一个BFC就是一个独立的行政单位的意思。可以说BFC就是一个作用范围，把它理解成是一个独立的容器，并且这个容器里box的布局与这个容器外的box毫不相干。</p>
<h4 id="bfc_2">触发BFC的条件<a class="headerlink" href="#bfc_2" title="Permanent link">&para;</a></h4>
<ul>
<li>根元素或其它包含它的元素</li>
<li>浮动元素 (元素的 <code>float</code> 不是 <code>none</code>)</li>
<li>绝对定位元素 (元素具有 <code>position</code> 为 <code>absolute</code> 或 <code>fixed</code>)</li>
<li>内联块 (元素具有 <code>display: inline-block</code>)</li>
<li>表格单元格 (元素具有 <code>display: table-cell</code>，HTML表格单元格默认属性)</li>
<li>表格标题 (元素具有 <code>display: table-caption</code>, HTML表格标题默认属性)</li>
<li>具有<code>overflow</code> 且值不是 <code>visible</code> 的块元素</li>
<li>弹性盒（<code>flex</code>或<code>inline-flex</code>）</li>
<li><code>display: flow-root</code></li>
<li><code>column-span: all</code></li>
</ul>
<h4 id="bfc_3">BFC的约束规则<a class="headerlink" href="#bfc_3" title="Permanent link">&para;</a></h4>
<ul>
<li>内部的盒会在垂直方向一个接一个排列（可以看作BFC中有一个的常规流）</li>
<li>处于同一个BFC中的元素相互影响，可能会发生外边距重叠</li>
<li>每个元素的margin box的左边，与容器块border box的左边相接触(对于从左往右的格式化，否则相反)，即使存在浮动也是如此</li>
<li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然</li>
<li>计算BFC的高度时，考虑BFC所包含的所有元素，连浮动元素也参与计算</li>
<li>浮动盒区域不叠加到BFC上</li>
</ul>
<h4 id="bfc_4">BFC可以解决的问题<a class="headerlink" href="#bfc_4" title="Permanent link">&para;</a></h4>
<ul>
<li>垂直外边距重叠问题</li>
<li>去除浮动</li>
<li>自适用两列布局（<code>float</code> + <code>overflow</code>）</li>
</ul>
<h3 id="_8">了解盒模型么<a class="headerlink" href="#_8" title="Permanent link">&para;</a></h3>
<p>包括<strong>内容区域</strong>、<strong>内边距区域</strong>、<strong>边框区域</strong>和<strong>外边距区域</strong>。</p>
<p><img alt="enter image description here" src="https://user-gold-cdn.xitu.io/2019/8/30/16ce245b8f2a63c0?imageView2/0/w/1280/h/960/format/png/ignore-error/1" /></p>
<p><code>box-sizing: content-box</code>（W3C盒子模型）：元素的宽高大小表现为<strong>内容</strong>的大小。 <code>box-sizing: border-box</code>（IE盒子模型）：元素的宽高表现为<strong>内容 + 内边距 + 边框</strong>的大小。背景会延伸到边框的外沿。</p>
<p>IE5.x和IE6在怪异模式中使用非标准的盒子模型，这些浏览器的<code>width</code>属性不是<strong>内容</strong>的宽度，而是<strong>内容</strong>、<strong>内边距</strong>和<strong>边框</strong>的宽度的总和。</p>
<h3 id="_9">如何实现左侧宽度固定，右侧宽度自适应的布局<a class="headerlink" href="#_9" title="Permanent link">&para;</a></h3>
<blockquote>
<p>小提示：这个问题面试官会要求说出几种解决方法。</p>
</blockquote>
<p>DOM结构</p>
<div class="codehilite"><pre><span></span><code>&lt;div class=&quot;box&quot;&gt;
  &lt;div class=&quot;box-left&quot;&gt;&lt;/div&gt;
  &lt;div class=&quot;box-right&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
复制代码
</code></pre></div>

<h4 id="float-margin">利用<code>float + margin</code>实现<a class="headerlink" href="#float-margin" title="Permanent link">&para;</a></h4>
<div class="codehilite"><pre><span></span><code>.box {
 height: 200px;
}

.box &gt; div {
  height: 100%;
}

.box-left {
  width: 200px;
  float: left;
  background-color: blue;
}

.box-right {
  margin-left: 200px;
  background-color: red;
}
复制代码
</code></pre></div>

<h4 id="calc">利用<code>calc</code>计算宽度<a class="headerlink" href="#calc" title="Permanent link">&para;</a></h4>
<div class="codehilite"><pre><span></span><code>.box {
 height: 200px;
}

.box &gt; div {
  height: 100%;
}

.box-left {
  width: 200px;
  float: left;
  background-color: blue;
}

.box-right {
  width: calc(100% - 200px);
  float: right;
  background-color: red;
}
复制代码
</code></pre></div>

<h4 id="float-overflow">利用<code>float + overflow</code>实现<a class="headerlink" href="#float-overflow" title="Permanent link">&para;</a></h4>
<div class="codehilite"><pre><span></span><code>.box {
 height: 200px;
}

.box &gt; div {
  height: 100%;
}

.box-left {
  width: 200px;
  float: left;
  background-color: blue;
}

.box-right {
  overflow: hidden;
  background-color: red;
}
复制代码
</code></pre></div>

<h4 id="flex">利用<code>flex</code>实现<a class="headerlink" href="#flex" title="Permanent link">&para;</a></h4>
<p>这里不是最佳答案，应该是使用<code>flex-basis</code>实现更合理</p>
<div class="codehilite"><pre><span></span><code>.box {
  height: 200px;
  display: flex;
}

.box &gt; div {
  height: 100%;
}

.box-left {
  width: 200px;
  background-color: blue;
}

.box-right {
  flex: 1; // 设置flex-grow属性为1，默认为0
  overflow: hidden;
  background-color: red;
}
复制代码
</code></pre></div>

<h3 id="_10">了解跨域吗，一般什么情况下会导致跨域<a class="headerlink" href="#_10" title="Permanent link">&para;</a></h3>
<blockquote>
<p>小提示： 如果平常自身有使用场景可结合使用场景进行讲解，比如我在这里使用过的场景是CORS和Nginx反向代理。</p>
</blockquote>
<h4 id="_11">跨域行为<a class="headerlink" href="#_11" title="Permanent link">&para;</a></h4>
<ul>
<li>同源策略限制、安全性考虑</li>
<li>协议、IP和端口不一致都是跨域行为</li>
</ul>
<h4 id="jsonp">JSONP<a class="headerlink" href="#jsonp" title="Permanent link">&para;</a></h4>
<blockquote>
<p>小提示：如果你提到JSONP，面试官肯定会问你整个详细的实现过程，所以一定要搞懂JSONP的实现原理，如果不是很理解可以自己起一个Express服务实践一下。</p>
</blockquote>
<p>Web前端事先定义一个用于获取跨域响应数据的回调函数，并通过没有同源策略限制的script标签发起一个请求（将回调函数的名称放到这个请求的query参数里），然后服务端返回这个回调函数的执行，并将需要响应的数据放到回调函数的参数里，前端的script标签请求到这个执行的回调函数后会立马执行，于是就拿到了执行的响应数据。</p>
<p>缺点： JSONP只能发起GET请求</p>
<h4 id="jsonp_1">如何实现一个JSONP<a class="headerlink" href="#jsonp_1" title="Permanent link">&para;</a></h4>
<p>这里给出几个链接：</p>
<p><a href="https://segmentfault.com/a/1190000015597029">segmentfault.com/a/119000001…</a> <a href="https://zhangguixu.github.io/2016/12/02/JSONP/">zhangguixu.github.io/2016/12/02/…</a><a href="https://www.cnblogs.com/iovec/p/5312464.html">www.cnblogs.com/iovec/p/531…</a></p>
<h4 id="jsonp_2">JSONP安全性问题<a class="headerlink" href="#jsonp_2" title="Permanent link">&para;</a></h4>
<h5 id="csrf">CSRF攻击<a class="headerlink" href="#csrf" title="Permanent link">&para;</a></h5>
<p>前端构造一个恶意页面，请求JSONP接口，收集服务端的敏感信息。如果JSONP接口还涉及一些敏感操作或信息（比如登录、删除等操作），那就更不安全了。</p>
<p>解决方法：验证JSONP的调用来源（Referer），服务端判断Referer是否是白名单，或者部署随机Token来防御。</p>
<h5 id="xss">XSS漏洞<a class="headerlink" href="#xss" title="Permanent link">&para;</a></h5>
<p>不严谨的 content-type导致的 XSS 漏洞，想象一下 JSONP 就是你请求 <code>http://youdomain.com?callback=douniwan</code>, 然后返回 <code>douniwan({ data })</code>，那假如请求 <code>http://youdomain.com?callback=alert(1)</code> 不就返回 <code>alert(1)({ data })</code>了吗，如果没有严格定义好 Content-Type（ Content-Type: application/json ），再加上没有过滤 <code>callback</code> 参数，直接当 html 解析了，就是一个赤裸裸的 XSS 了。</p>
<p>解决方法：严格定义 Content-Type: application/json，然后严格过滤 <code>callback</code> 后的参数并且限制长度（进行字符转义，例如&lt;换成&amp;lt，&gt;换成&amp;gt）等，这样返回的脚本内容会变成文本格式，脚本将不会执行。</p>
<h5 id="_12">服务器被黑，返回一串恶意执行的代码<a class="headerlink" href="#_12" title="Permanent link">&para;</a></h5>
<p>可以将执行的代码转发到服务端进行校验JSONP内容校验，再返回校验结果。</p>
<h4 id="cors">CORS（跨域资款共享）<a class="headerlink" href="#cors" title="Permanent link">&para;</a></h4>
<blockquote>
<p>小提示：如果你回答跨域解决方案CORS，那么面试官一定会问你实现CORS的响应头信息Access-Control-Allow-Origin。</p>
</blockquote>
<h5 id="cors_1">什么是CORS<a class="headerlink" href="#cors_1" title="Permanent link">&para;</a></h5>
<p>CORS（跨域资源共享 Cross-origin resource sharing）允许浏览器向跨域服务器发出XMLHttpRequest请求，从而克服跨域问题，它需要浏览器和服务器的同时支持。</p>
<ul>
<li>浏览器端会自动向请求头添加origin字段，表明当前请求来源。</li>
<li>服务器端需要设置响应头的Access-Control-Allow-Methods，Access-Control-Allow-Headers，Access-Control-Allow-Origin等字段，指定允许的方法，头部，源等信息。</li>
<li>请求分为简单请求和非简单请求，非简单请求会先进行一次OPTION方法进行预检，看是否允许当前跨域请求。</li>
</ul>
<h5 id="_13">简单请求<a class="headerlink" href="#_13" title="Permanent link">&para;</a></h5>
<p>请求方法是以下三种方法之一：</p>
<ul>
<li>HEAD</li>
<li>GET</li>
<li>POST</li>
</ul>
<p>HTTP的请求头信息不超出以下几种字段：</p>
<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Last-Event-ID</li>
<li>Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</li>
</ul>
<p>后端的响应头信息：</p>
<ul>
<li>Access-Control-Allow-Origin：该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。</li>
<li>Access-Control-Allow-Credentials：该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。</li>
<li>Access-Control-Expose-Headers：该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。</li>
</ul>
<h5 id="_14">非简单请求<a class="headerlink" href="#_14" title="Permanent link">&para;</a></h5>
<p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为"预检"请求（preflight）。</p>
<ul>
<li>Access-Control-Request-Method：该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。</li>
<li>Access-Control-Request-Headers：该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。</li>
</ul>
<p>如果浏览器否定了"预检"请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。</p>
<h4 id="jsonpcors">JSONP和CORS的对比<a class="headerlink" href="#jsonpcors" title="Permanent link">&para;</a></h4>
<ul>
<li>JSONP只支持GET请求，CORS支持所有类型的HTTP请求</li>
<li>JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据</li>
</ul>
<h4 id="_15">其他跨域解决方案<a class="headerlink" href="#_15" title="Permanent link">&para;</a></h4>
<ul>
<li>Nginx反向代理</li>
<li><code>postMessage</code></li>
<li><code>document.domain</code></li>
</ul>
<h3 id="http2http1">HTTP2和HTTP1有什么区别<a class="headerlink" href="#http2http1" title="Permanent link">&para;</a></h3>
<p>相对于HTTP1.0，HTTP1.1的优化：</p>
<ul>
<li>缓存处理：多了Entity tag，If-Unmodified-Since, If-Match, If-None-Match等缓存信息（HTTTP1.0 If-Modified-Since,Expires）</li>
<li>带宽优化及网络连接的使用</li>
<li>错误通知的管理</li>
<li>Host头处理</li>
<li>长连接： HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</li>
</ul>
<p>相对于HTTP1.1，HTTP2的优化：</p>
<ul>
<li>HTTP2支持二进制传送（实现方便且健壮），HTTP1.x是字符串传送</li>
<li>HTTP2支持多路复用</li>
<li>HTTP2采用HPACK压缩算法压缩头部，减小了传输的体积</li>
<li>HTTP2支持服务端推送</li>
</ul>
<h3 id="_16">你能说说缓存么<a class="headerlink" href="#_16" title="Permanent link">&para;</a></h3>
<blockquote>
<p>小提示：如果平常有遇到过缓存的坑或者很好的利用缓存，可以讲解一下自己的使用场景。如果没有使用注意过缓存问题你也可以尝试讲解一下和我们息息相关的Webpack构建（每一次构建静态资源名称的hash值都会变化），它其实就跟缓存相关。有兴趣的同学可以查看张云龙的博客<a href="https://github.com/fouber/blog/issues/6">大公司里怎样开发和部署前端代码？</a>。</p>
</blockquote>
<p>缓存分为强缓存和协商缓存。强缓存不过服务器，协商缓存需要过服务器，协商缓存返回的状态码是304。两类缓存机制可以同时存在，强缓存的优先级高于协商缓存。当执行强缓存时，如若缓存命中，则直接使用缓存数据库中的数据，不再进行缓存协商。</p>
<h4 id="_17">强缓存<a class="headerlink" href="#_17" title="Permanent link">&para;</a></h4>
<p><strong>Expires(HTTP1.0)</strong>：Exprires的值为服务端返回的数据到期时间。当再次请求时的请求时间小于返回的此时间，则直接使用缓存数据。但由于服务端时间和客户端时间可能有误差，这也将导致缓存命中的误差。另一方面，Expires是HTTP1.0的产物，故现在大多数使用Cache-Control替代。</p>
<p>缺点：使用的是绝对时间，如果服务端和客户端的时间产生偏差，那么会导致命中缓存产生偏差。</p>
<p><strong>Pragma(HTTP1.0)</strong>：HTTP1.0时的遗留字段，当值为"no-cache"时强制验证缓存，Pragma禁用缓存，如果又给Expires定义一个还未到期的时间，那么Pragma字段的优先级会更高。服务端响应添加'Pragma': 'no-cache'，浏览器表现行为和刷新(F5)类似。</p>
<p><strong>Cache-Control(HTTP1.1)</strong>：有很多属性，不同的属性代表的意义也不同：</p>
<ul>
<li>private：客户端可以缓存</li>
<li>public：客户端和代理服务器都可以缓存</li>
<li>max-age=t：缓存内容将在t秒后失效</li>
<li>no-cache：需要使用协商缓存来验证缓存数据</li>
<li>no-store：所有内容都不会缓存</li>
</ul>
<p>请注意no-cache指令很多人误以为是不缓存，这是不准确的，no-cache的意思是可以缓存，但每次用应该去想服务器验证缓存是否可用。no-store才是不缓存内容。当在首部字段Cache-Control 有指定 max-age 指令时，比起首部字段 Expires，会优先处理 max-age 指令。命中强缓存的表现形式：Firefox浏览器表现为一个灰色的200状态码。Chrome浏览器状态码表现为200 (from disk cache)或是200 OK (from memory cache)。</p>
<h4 id="_18">协商缓存<a class="headerlink" href="#_18" title="Permanent link">&para;</a></h4>
<p>协商缓存需要进行对比判断是否可以使用缓存。浏览器第一次请求数据时，服务器会将缓存标识与数据一起响应给客户端，客户端将它们备份至缓存中。再次请求时，客户端会将缓存中的标识发送给服务器，服务器根据此标识判断。若未失效，返回304状态码，浏览器拿到此状态码就可以直接使用缓存数据了。</p>
<p><strong>Last-Modified</strong>：服务器在响应请求时，会告诉浏览器资源的最后修改时间。</p>
<p><strong>if-Modified-Since</strong>：浏览器再次请求服务器的时候，请求头会包含此字段，后面跟着在缓存中获得的最后修改时间。服务端收到此请求头发现有if-Modified-Since，则与被请求资源的最后修改时间进行对比，如果一致则返回304和响应报文头，浏览器只需要从缓存中获取信息即可。</p>
<ul>
<li>如果真的被修改：那么开始传输响应一个整体，服务器返回：200 OK</li>
<li>如果没有被修改：那么只需传输响应header，服务器返回：304 Not Modified</li>
</ul>
<p><strong>if-Unmodified-Since</strong>: 从某个时间点算起, 是否文件没有被修改，使用的是相对时间，不需要关心客户端和服务端的时间偏差。</p>
<ul>
<li>如果没有被修改：则开始`继续'传送文件，服务器返回: 200 OK</li>
<li>如果文件被修改：则不传输，服务器返回: 412 Precondition failed (预处理错误)</li>
</ul>
<p>这两个的区别是一个是修改了才下载一个是没修改才下载。如果在服务器上，一个资源被修改了，但其实际内容根本没发生改变，会因为Last-Modified时间匹配不上而返回了整个实体给客户端（即使客户端缓存里有个一模一样的资源）。为了解决这个问题，HTTP1.1推出了Etag。</p>
<p><strong>Etag</strong>：服务器响应请求时，通过此字段告诉浏览器当前资源在服务器生成的唯一标识（生成规则由服务器决定）</p>
<p><strong>If-Match</strong>：条件请求，携带上一次请求中资源的ETag，服务器根据这个字段判断文件是否有新的修改</p>
<p><strong>If-None-Match</strong>： 再次请求服务器时，浏览器的请求报文头部会包含此字段，后面的值为在缓存中获取的标识。服务器接收到次报文后发现If-None-Match则与被请求资源的唯一标识进行对比。</p>
<ul>
<li>不同，说明资源被改动过，则响应整个资源内容，返回状态码200。</li>
<li>相同，说明资源无心修改，则响应header，浏览器直接从缓存中获取数据信息。返回状态码304.</li>
</ul>
<p>但是实际应用中由于Etag的计算是使用算法来得出的，而算法会占用服务端计算的资源，所有服务端的资源都是宝贵的，所以就很少使用Etag了。</p>
<ul>
<li>浏览器地址栏中写入URL，回车浏览器发现缓存中有这个文件了，不用继续请求了，直接去缓存拿（最快）</li>
<li>F5就是告诉浏览器，别偷懒，好歹去服务器看看这个文件是否有过期了。于是浏览器就胆胆襟襟的发送一个请求带上If-Modify-since</li>
<li>Ctrl+F5告诉浏览器，你先把你缓存中的这个文件给我删了，然后再去服务器请求个完整的资源文件下来。于是客户端就完成了强行更新的操作</li>
</ul>
<h4 id="_19">缓存场景<a class="headerlink" href="#_19" title="Permanent link">&para;</a></h4>
<p>对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略</p>
<ul>
<li>对于某些不需要缓存的资源，可以使用 Cache-control: no-store ，表示该资源不需要缓存</li>
<li>对于频繁变动的资源，可以使用 Cache-Control: no-cache 并配合 ETag 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新</li>
<li>对于代码文件来说，通常使用 Cache-Control: max-age=31536000 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件</li>
</ul>
<h3 id="_20">能说说首屏加载优化有哪些方案么<a class="headerlink" href="#_20" title="Permanent link">&para;</a></h3>
<blockquote>
<p>小提示：如果做过类似优化的同学，可能就比较好回答，没有做过类似优化的同学可以重点讲解一下懒加载（当然我这里被面试官追问过懒加载的Webpack配置问题）。同时不知道使用Vue技术栈的同学们有没有仔细观察过Vue CLI 3构建的html文件中的link标签的rel属性。</p>
</blockquote>
<ul>
<li>Vue-Router路由懒加载（利用Webpack的代码切割）</li>
<li>使用CDN加速，将通用的库从vendor进行抽离</li>
<li>Nginx的gzip压缩</li>
<li>Vue异步组件</li>
<li>服务端渲染SSR</li>
<li>如果使用了一些UI库，采用按需加载</li>
<li>Webpack开启gzip压缩</li>
<li>如果首屏为登录页，可以做成多入口</li>
<li>Service Worker缓存文件处理</li>
<li>使用link标签的rel属性设置 prefetch（这段资源将会在未来某个导航或者功能要用到，但是本资源的下载顺序权重比较低，prefetch通常用于加速下一次导航）、preload（preload将会把资源得下载顺序权重提高，使得关键数据提前下载好，优化页面打开速度）</li>
</ul>
<h3 id="nodewebpackalias">如何在Node端配置路径别名（类似于Webpack中的alias配置）<a class="headerlink" href="#nodewebpackalias" title="Permanent link">&para;</a></h3>
<ul>
<li>全局变量</li>
<li>环境变量</li>
<li>自己HACK一个@符号，指向特定的路径</li>
<li>HACK <code>require</code>方法</li>
</ul>
<h4 id="_21">参考<a class="headerlink" href="#_21" title="Permanent link">&para;</a></h4>
<p>这种问题还是附上参考链接</p>
<p><a href="https://segmentfault.com/a/1190000010998044">segmentfault.com/a/119000001…</a> <a href="http://chashaobao.net/2017/09/03/alias-require-hack/">chashaobao.net/2017/09/03/…</a><a href="https://www.zhihu.com/question/26621212">www.zhihu.com/question/26…</a></p>
<h3 id="_22">谈谈你对作用域链的理解<a class="headerlink" href="#_22" title="Permanent link">&para;</a></h3>
<blockquote>
<p>小提示：同类型的问题还可以是原型链、继承、闭包等，这种概念性的问题你肯定不是一句两句能说清楚的，建议在理解之后自己尝试总结一下，如何把重要的知识点用简短的话语说明白。</p>
</blockquote>
<p>了解作用域链之前我们要知道一下几个概念：</p>
<ul>
<li>函数的生命周期</li>
<li>变量和函数的声明</li>
<li>Activetion Object（AO）、Variable Object（VO）</li>
</ul>
<p>函数的生命周期：</p>
<ul>
<li>创建：JS解析引擎进行预解析，会将函数声明提前，同时将该函数放到全局作用域中或当前函数的上一级函数的局部作用域中。</li>
<li>执行：JS引擎会将当前函数的局部变量和内部函数进行声明提前，然后再执行业务代码，当函数执行完退出时，释放该函数的执行上下文，并注销该函数的局部变量。</li>
</ul>
<p>变量和函数的声明：如果变量名和函数名声明时相同，函数优先声明。</p>
<p>Activetion Object（AO）、Variable Object（VO）：</p>
<ul>
<li>AO：Activetion Object（活动对象）</li>
<li>VO：Variable Object（变量对象）</li>
</ul>
<p>VO对应的是函数创建阶段，JS解析引擎进行预解析时，所有的变量和函数的声明，统称为Variable Object。该变量与执行上下文相关，知道自己的数据存储在哪里，并且知道如何访问。VO是一个与执行上下文相关的特殊对象，它存储着在上下文中声明的以下内容：</p>
<ul>
<li>变量 (var, 变量声明);</li>
<li>函数声明 (FunctionDeclaration, 缩写为FD);</li>
<li>函数的形参</li>
</ul>
<p>AO对应的是函数执行阶段，当函数被调用执行时，会建立一个执行上下文，该执行上下文包含了函数所需的所有变量，该变量共同组成了一个新的对象就是Activetion Object。该对象包含了：</p>
<ul>
<li>函数的所有局部变量</li>
<li>函数的所有命名参数</li>
<li>函数的参数集合</li>
<li>函数的this指向</li>
</ul>
<p>作用域链：</p>
<p>当代码在一个环境中创建时，会创建变量对象的一个作用域链（scope chain）来保证对执行环境有权访问的变量和函数。作用域第一个对象始终是当前执行代码所在环境的变量对象（VO）。如果是函数执行阶段，那么将其activation object（AO）作为作用域链第一个对象，第二个对象是上级函数的执行上下文AO，下一个对象依次类推。</p>
<p>在《JavaScript深入之变量对象》中讲到，当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。</p>
<h3 id="nullundefined">你知道<code>null</code>和<code>undefined</code>有什么区别么<a class="headerlink" href="#nullundefined" title="Permanent link">&para;</a></h3>
<h3 id="_23">闭包有什么作用<a class="headerlink" href="#_23" title="Permanent link">&para;</a></h3>
<h3 id="vue">Vue响应式原理<a class="headerlink" href="#vue" title="Permanent link">&para;</a></h3>
<blockquote>
<p>小提示：如果面试者使用的是Vue技术栈，那么响应式原理是一个必问的问题，同时面试官经常也会问Vue 3.0在响应式原理上的优化方案。</p>
</blockquote>
<p>如果对于响应式原理不是很清楚可以查看我之前写的文章<a href="https://juejin.im/post/5cd8a7c1f265da037a3d0992#heading-22">基于Vue实现一个简易MVVM/数据劫持的实现</a>。</p>
<h3 id="event-loop">了解Event Loop么<a class="headerlink" href="#event-loop" title="Permanent link">&para;</a></h3>
<blockquote>
<p>小提示：这个题目问到的概率还是蛮大的，这里面试官询问了我浏览器端和Node端的Event Loop有什么不同点。如果想要知道更多浏览器端的Event Loop机制可以查看我之前写的文章<a href="https://juejin.im/post/5cd9854b5188252035420a13#heading-3">你真的理解$nextTick么/JS引擎线程和事件触发线程/事件循环机制</a>。</p>
</blockquote>
<p>事件触发线程管理的任务队列是如何产生的呢？事实上这些任务就是从JS引擎线程本身产生的，主线程在运行时会产生执行栈，栈中的代码调用某些异步API时会在任务队列中添加事件，栈中的代码执行完毕后，就会读取任务队列中的事件，去执行事件对应的回调函数，如此循环往复，形成事件循环机制。JS中有两种任务类型：微任务（microtask）和宏任务（macrotask），在ES6中，microtask称为 jobs，macrotask称为 task：</p>
<ul>
<li>宏任务： script （主代码块）、<code>setTimeout</code> 、<code>setInterval</code> 、<code>setImmediate</code> 、I/O 、UI rendering</li>
<li>微任务：<code>process.nextTick</code>（Nodejs） 、<code>Promise</code> 、<code>Object.observe</code>、<code>MutationObserver</code></li>
</ul>
<p>Node.js中Event Loop和浏览器中Event Loop有什么区别</p>
<div class="codehilite"><pre><span></span><code>   ┌───────────────────────┐
┌─&gt;│        timers         │&lt;————— 执行 setTimeout()、setInterval() 的回调
│  └──────────┬────────────┘
|             |&lt;-- 执行所有 Next Tick Queue 以及 MicroTask Queue 的回调
│  ┌──────────┴────────────┐
│  │     pending callbacks │&lt;————— 执行由上一个 Tick 延迟下来的 I/O 回调（待完善，可忽略）
│  └──────────┬────────────┘
|             |&lt;-- 执行所有 Next Tick Queue 以及 MicroTask Queue 的回调
│  ┌──────────┴────────────┐
│  │     idle, prepare     │&lt;————— 内部调用（可忽略）
│  └──────────┬────────────┘     
|             |&lt;-- 执行所有 Next Tick Queue 以及 MicroTask Queue 的回调
|             |                   ┌───────────────┐
│  ┌──────────┴────────────┐      │   incoming:   │ - (执行几乎所有的回调，除了 close callbacks、timers、setImmediate)
│  │         poll          │&lt;─────┤  connections, │ 
│  └──────────┬────────────┘      │   data, etc.  │ 
│             |                   |               | 
|             |                   └───────────────┘
|             |&lt;-- 执行所有 Next Tick Queue 以及 MicroTask Queue 的回调
|  ┌──────────┴────────────┐      
│  │        check          │&lt;————— setImmediate() 的回调将会在这个阶段执行
│  └──────────┬────────────┘
|             |&lt;-- 执行所有 Next Tick Queue 以及 MicroTask Queue 的回调
│  ┌──────────┴────────────┐
└──┤    close callbacks    │&lt;————— socket.on(&#39;close&#39;, ...)
   └───────────────────────┘
复制代码
</code></pre></div>

<p>Node.js中宏任务分成了几种类型，并且放在了不同的task queue里。不同的task queue在执行顺序上也有区别，微任务放在了每个task queue的末尾：</p>
<ul>
<li><code>setTimeout/setInterval</code> 属于 timers 类型；</li>
<li><code>setImmediate</code> 属于 check 类型；</li>
<li>socket 的 close 事件属于 close callbacks 类型；</li>
<li>其他 MacroTask 都属于 poll 类型。</li>
<li><code>process.nextTick</code> 本质上属于 MicroTask，但是它先于所有其他 MicroTask 执行；</li>
<li>所有 MicroTask 的执行时机在不同类型的 MacroTask 切换后。</li>
<li>idle/prepare 仅供内部调用，我们可以忽略。</li>
<li>pending callbacks 不太常见，我们也可以忽略。</li>
</ul>
<h3 id="_24">如何避免回流和重绘<a class="headerlink" href="#_24" title="Permanent link">&para;</a></h3>
<h4 id="_25">浏览器渲染过程<a class="headerlink" href="#_25" title="Permanent link">&para;</a></h4>
<p><img alt="enter image description here" src="data:image/svg+xml;utf8,&lt;?xml%20version=%221.0%22?%3E%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20version=%221.1%22%20width=%22624%22%20height=%22289%22%3E%3C/svg%3E" /></p>
<ul>
<li>浏览器使用流式布局模型 (Flow Based Layout)</li>
<li>浏览器会把HTML解析成DOM，把CSS解析成CSSOM，DOM和CSSOM合并就产生了Render Tree</li>
<li>有了RenderTree就能知道所有节点的样式，计算节点在页面上的大小和位置，把节点绘制到页面上</li>
<li>由于浏览器使用流式布局，对Render Tree的计算通常只需要遍历一次就可以完成，但table及其内部元素除外，通常需要多次计算且要花费3倍于同等元素的时间，这也是为什么要避免使用table布局的原因之一</li>
</ul>
<p>浏览器渲染过程如下：</p>
<ul>
<li>解析HTML，生成DOM树</li>
<li>解析CSS，生成CSSOM树</li>
<li>将DOM树和CSSOM树结合，生成渲染树(Render Tree)</li>
<li>Layout(回流)：根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）</li>
<li>Painting(重绘)：根据渲染树以及回流得到的几何信息，得到节点的绝对像素</li>
<li>Display：将像素发送给GPU，展示在页面上。（这一步其实还有很多内容，比如会在GPU将多个合成层合并为同一个层，并展示在页面中。而css3硬件加速的原理则是新建合成层，这里我们不展开，之后有机会会写一篇博客）</li>
</ul>
<h4 id="_26">何时触发回流和重绘<a class="headerlink" href="#_26" title="Permanent link">&para;</a></h4>
<p>何时发生回流：</p>
<ul>
<li>添加或删除可见的DOM元素</li>
<li>元素的位置发生变化</li>
<li>元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）</li>
<li>内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。</li>
<li>页面一开始渲染的时候（这肯定避免不了）</li>
<li>浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）</li>
</ul>
<p>何时发生重绘（回流一定会触发重绘）：</p>
<p>当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。</p>
<p>有时即使仅仅回流一个单一的元素，它的父元素以及任何跟随它的元素也会产生回流。现代浏览器会对频繁的回流或重绘操作进行优化，浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。你访问以下属性或方法时，浏览器会立刻清空队列：</p>
<ul>
<li><code>clientWidth</code>、<code>clientHeight</code>、<code>clientTop</code>、<code>clientLeft</code></li>
<li><code>offsetWidth</code>、<code>offsetHeight</code>、<code>offsetTop</code>、<code>offsetLeft</code></li>
<li><code>scrollWidth</code>、<code>scrollHeight</code>、<code>scrollTop</code>、<code>scrollLeft</code></li>
<li><code>width</code>、<code>height</code></li>
<li><code>getComputedStyle()</code></li>
<li><code>getBoundingClientRect()</code></li>
</ul>
<p>以上属性和方法都需要返回最新的布局信息，因此浏览器不得不清空队列，触发回流重绘来返回正确的值。因此，我们在修改样式的时候，<strong>最好避免使用上面列出的属性，他们都会刷新渲染队列。</strong>如果要使用它们，最好将值缓存起来。</p>
<h4 id="_27">如何避免触发回流和重绘<a class="headerlink" href="#_27" title="Permanent link">&para;</a></h4>
<p>CSS：</p>
<ul>
<li>避免使用table布局。</li>
<li>尽可能在DOM树的最末端改变class。</li>
<li>避免设置多层内联样式。</li>
<li>将动画效果应用到<code>position</code>属性为<code>absolute</code>或<code>fixed</code>的元素上</li>
<li>避免使用CSS表达式（例如：<code>calc()</code>）</li>
<li>CSS3硬件加速（GPU加速）</li>
</ul>
<p>JavaScript：</p>
<ul>
<li>避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性</li>
<li>避免频繁操作DOM，创建一个<code>documentFragment</code>，在它上面应用所有DOM操作，最后再把它添加到文档中</li>
<li>也可以先为元素设置<code>display: none</code>，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘</li>
<li>避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来</li>
<li>对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流</li>
</ul>
<h2 id="_28">有赞（二面）<a class="headerlink" href="#_28" title="Permanent link">&para;</a></h2>
<blockquote>
<p>小提示：进入现场面试需要注意好好准备自己的简历，面试官一般会根据项目进行问答。</p>
</blockquote>
<h3 id="_29">笔试题环节<a class="headerlink" href="#_29" title="Permanent link">&para;</a></h3>
<p>一开始面试官就发了两张笔试题试卷，总共四道题目，大致考了以下知识点：</p>
<ul>
<li>作用域</li>
<li>原型链（例如实例属性和原型属性一样，删除实例属性后可以继续访问原型属性问题）</li>
<li>宏任务和微任务的打印顺序</li>
<li><code>Array.prototype.map</code>的第二个参数</li>
</ul>
<h3 id="_30">项目问答环节<a class="headerlink" href="#_30" title="Permanent link">&para;</a></h3>
<p>答完试卷面试官就开始问简历上的一些项目，我记得其中几个问题如下（事实上他问的一些问题和简历不是很相关）：</p>
<ul>
<li>你们产品的服务器部署在哪里</li>
<li>你是如何实现一个Tooltip组件的，能写一下怎么使用这个组件么（这算什么问题...）</li>
<li>我认识你们海康的一些开发，我知道你们的产品按套数卖的...</li>
</ul>
<p>我当场就感受到了面试官问的问题很敷衍，可能他觉得我的简历不够好，又或者觉得我能力不行，接下来面试官又让我做了一道算法题...</p>
<h3 id="_31">算法题环节<a class="headerlink" href="#_31" title="Permanent link">&para;</a></h3>
<ul>
<li>1块、4块、5块，求总数n块的最小硬币数</li>
</ul>
<p>当时没做出来，非科班出身可能做这些确实有些困难，也没有系统的学习，面试官看我很困难的样子，就换了一道题。</p>
<ul>
<li>1、1、2、3、5、8...计算第n个数的值（斐波那契数列）</li>
</ul>
<p>这道题还是做出来了，毕竟比较简单，然后面试官说今天先到这里，面试结果会在一星期内通知，然后回来的那天晚上就收到了面试没过的通知。</p>
<h3 id="_32">小结<a class="headerlink" href="#_32" title="Permanent link">&para;</a></h3>
<p>还是蛮感谢这次现场面试的经历，让我知道如果自身不够硬，到哪里都会很被动。面试的好处不仅仅在于检验自己到底有多少能力，更应该发现自身的不足，同时不断的去弥补这些不足。于是我再次捧起之前搁置的《算法导论》，并且创建了一个算法学习演示文档<a href="https://ziyi2.github.io/algorithms/">I-Algorithms</a>，希望可以简化《算法导论》的一些理论知识，使大家对于算法的学习可以变得更加系统全面和简单，也希望通过这个学习使得算法面试会变得更加得心应手，希望感兴趣的同学可以<a href="https://github.com/ziyi2/algorithms">star</a>一下。</p>
<p><img alt="enter image description here" src="data:image/svg+xml;utf8,&lt;?xml%20version=%221.0%22?%3E%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20version=%221.1%22%20width=%221280%22%20height=%22800%22%3E%3C/svg%3E" /></p>
<h2 id="_33">滴滴（一面）<a class="headerlink" href="#_33" title="Permanent link">&para;</a></h2>
<h3 id="_34">你知道哪些安全问题，如何避免<a class="headerlink" href="#_34" title="Permanent link">&para;</a></h3>
<blockquote>
<p>小提示：这里我简单讲解了一下Vue中的<code>v-html</code>防范XSS攻击。</p>
</blockquote>
<h4 id="xss_1">XSS（跨站脚本攻击）<a class="headerlink" href="#xss_1" title="Permanent link">&para;</a></h4>
<p>XSS，即 Cross Site Script，中译是跨站脚本攻击；其原本缩写是 CSS，但为了和层叠样式表(Cascading Style Sheet)有所区分，因而在安全领域叫做 XSS。</p>
<p>XSS 攻击是指攻击者在网站上注入恶意的客户端代码，通过恶意脚本对客户端网页进行篡改，从而在用户浏览网页时，对用户浏览器进行控制或者获取用户隐私数据的一种攻击方式。</p>
<p>攻击者对客户端网页注入的恶意脚本一般包括 JavaScript，有时也会包含 HTML 和 Flash。有很多种方式进行 XSS 攻击，但它们的共同点为：将一些隐私数据像 cookie、session 发送给攻击者，将受害者重定向到一个由攻击者控制的网站，在受害者的机器上进行一些恶意操作。</p>
<p>XSS攻击可以分为3类：反射型（非持久型）、存储型（持久型）、基于DOM。</p>
<h5 id="_35">反射型<a class="headerlink" href="#_35" title="Permanent link">&para;</a></h5>
<p>反射型 XSS 只是简单地把用户输入的数据 “反射” 给浏览器，这种攻击方式往往需要攻击者诱使用户点击一个恶意链接（攻击者可以将恶意链接直接发送给受信任用户，发送的方式有很多种，比如 email, 网站的私信、评论等，攻击者可以购买存在漏洞网站的广告，将恶意链接插入在广告的链接中），或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。最简单的示例是访问一个链接，服务端返回一个可执行脚本：</p>
<div class="codehilite"><pre><span></span><code>const http = require(&#39;http&#39;);
function handleReequest(req, res) {
    res.setHeader(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;);
    res.writeHead(200, {&#39;Content-Type&#39;: &#39;text/html; charset=UTF-8&#39;});
    res.write(&#39;&lt;script&gt;alert(&quot;反射型 XSS 攻击&quot;)&lt;/script&gt;&#39;);
    res.end();
}

const server = new http.Server();
server.listen(8001, &#39;127.0.0.1&#39;);
server.on(&#39;request&#39;, handleReequest);
复制代码
</code></pre></div>

<h5 id="_36">存储型<a class="headerlink" href="#_36" title="Permanent link">&para;</a></h5>
<p>存储型 XSS 会把用户输入的数据 "存储" 在服务器端，当浏览器请求数据时，脚本从服务器上传回并执行。这种 XSS 攻击具有很强的稳定性。比较常见的一个场景是攻击者在社区或论坛上写下一篇包含恶意 JavaScript 代码的文章或评论，文章或评论发表后，所有访问该文章或评论的用户，都会在他们的浏览器中执行这段恶意的 JavaScript 代码：</p>
<div class="codehilite"><pre><span></span><code>// 例如在评论中输入以下留言
// 如果请求这段留言的时候服务端不做转义处理，请求之后页面会执行这段恶意代码
&lt;script&gt;alert(&#39;xss 攻击&#39;)&lt;/script&gt;
复制代码
</code></pre></div>

<h5 id="dom">基于DOM<a class="headerlink" href="#dom" title="Permanent link">&para;</a></h5>
<p>基于 DOM 的 XSS 攻击是指通过恶意脚本修改页面的 DOM 结构，是纯粹发生在客户端的攻击：</p>
<div class="codehilite"><pre><span></span><code>&lt;h2&gt;XSS: &lt;/h2&gt;
&lt;input type=&quot;text&quot; id=&quot;input&quot;&gt;
&lt;button id=&quot;btn&quot;&gt;Submit&lt;/button&gt;
&lt;div id=&quot;div&quot;&gt;&lt;/div&gt;
&lt;script&gt;
    const input = document.getElementById(&#39;input&#39;);
    const btn = document.getElementById(&#39;btn&#39;);
    const div = document.getElementById(&#39;div&#39;);

    let val;

    input.addEventListener(&#39;change&#39;, (e) =&gt; {
        val = e.target.value;
    }, false);

    btn.addEventListener(&#39;click&#39;, () =&gt; {
        div.innerHTML = `&lt;a href=${val}&gt;testLink&lt;/a&gt;`
    }, false);
&lt;/script&gt;
复制代码
</code></pre></div>

<p>点击 Submit 按钮后，会在当前页面插入一个链接，其地址为用户的输入内容。如果用户在输入时构造了如下内容：</p>
<div class="codehilite"><pre><span></span><code>&#39;&#39; onclick=alert(/xss/)
复制代码
</code></pre></div>

<p>用户提交之后，页面代码就变成了：</p>
<div class="codehilite"><pre><span></span><code>&lt;a href onlick=&quot;alert(/xss/)&quot;&gt;testLink&lt;/a&gt;
复制代码
</code></pre></div>

<p>此时，用户点击生成的链接，就会执行对应的脚本。</p>
<h5 id="xss_2">XSS攻击防范<a class="headerlink" href="#xss_2" title="Permanent link">&para;</a></h5>
<p><strong>HttpOnly 防止劫取 Cookie</strong>：HttpOnly 最早由微软提出，至今已经成为一个标准。浏览器将禁止页面的Javascript 访问带有 HttpOnly 属性的Cookie。上文有说到，攻击者可以通过注入恶意脚本获取用户的 Cookie 信息。通常 Cookie 中都包含了用户的登录凭证信息，攻击者在获取到 Cookie 之后，则可以发起 Cookie 劫持攻击。所以，严格来说，HttpOnly 并非阻止 XSS 攻击，而是能阻止 XSS 攻击后的 Cookie 劫持攻击。</p>
<p><strong>输入检查</strong>：不要相信用户的任何输入。 对于用户的任何输入要进行检查、过滤和转义。建立可信任的字符和 HTML 标签白名单，对于不在白名单之列的字符或者标签进行过滤或编码。在 XSS 防御中，输入检查一般是检查用户输入的数据中是否包含 &lt;，&gt; 等特殊字符，如果存在，则对特殊字符进行过滤或编码，这种方式也称为 XSS Filter。而在一些前端框架中，都会有一份 decodingMap， 用于对用户输入所包含的特殊字符或标签进行编码或过滤，如 &lt;，&gt;，script，防止 XSS 攻击：</p>
<div class="codehilite"><pre><span></span><code>// vuejs 中的 decodingMap
// 在 vuejs 中，如果输入带 script 标签的内容，会直接过滤掉
const decodingMap = {
  &#39;&amp;lt;&#39;: &#39;&lt;&#39;,
  &#39;&amp;gt;&#39;: &#39;&gt;&#39;,
  &#39;&amp;quot;&#39;: &#39;&quot;&#39;,
  &#39;&amp;amp;&#39;: &#39;&amp;&#39;,
  &#39;&amp;#10;&#39;: &#39;\n&#39;
}
复制代码
</code></pre></div>

<p><strong>输出检查</strong>：用户的输入会存在问题，服务端的输出也会存在问题。一般来说，除富文本的输出外，在变量输出到 HTML 页面时，可以使用编码或转义的方式来防御 XSS 攻击。例如利用 sanitize-html 对输出内容进行有规则的过滤之后再输出到页面中。</p>
<h4 id="csrfxsrf">CSRF/XSRF（跨站请求伪造）<a class="headerlink" href="#csrfxsrf" title="Permanent link">&para;</a></h4>
<p>CSRF，即 Cross Site Request Forgery，中译是跨站请求伪造，是一种劫持受信任用户向服务器发送非预期请求的攻击方式。通常情况下，CSRF 攻击是攻击者借助受害者的 Cookie 骗取服务器的信任，可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击服务器，从而在并未授权的情况下执行在权限保护之下的操作。</p>
<h5 id="cookie">Cookie<a class="headerlink" href="#cookie" title="Permanent link">&para;</a></h5>
<p>Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。Cookie 主要用于以下三个方面：</p>
<ul>
<li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li>
<li>个性化设置（如用户自定义设置、主题等）</li>
<li>浏览器行为跟踪（如跟踪分析用户行为等）</li>
</ul>
<p>而浏览器所持有的 Cookie 分为两种：</p>
<ul>
<li>Session Cookie(会话期 Cookie)：会话期 Cookie 是最简单的Cookie，它不需要指定过期时间（Expires）或者有效期（Max-Age），它仅在会话期内有效，浏览器关闭之后它会被自动删除。</li>
<li>Permanent Cookie(持久性 Cookie)：与会话期 Cookie 不同的是，持久性 Cookie 可以指定一个特定的过期时间（Expires）或有效期（Max-Age）。</li>
</ul>
<div class="codehilite"><pre><span></span><code>res.setHeader(&#39;Set-Cookie&#39;, [&#39;mycookie=222&#39;, &#39;test=3333; expires=Sat, 21 Jul 2018 00:00:00 GMT;&#39;]);
复制代码
</code></pre></div>

<p>上述代码创建了两个 Cookie：mycookie 和 test，前者属于会话期 Cookie，后者则属于持久性 Cookie。</p>
<h5 id="csrf_1">CSRF攻击<a class="headerlink" href="#csrf_1" title="Permanent link">&para;</a></h5>
<p>使登录用户访问攻击者的网站，发起一个请求，由于 Cookie 中包含了用户的认证信息，当用户访问攻击者准备的攻击环境时，攻击者就可以对服务器发起 CSRF 攻击。</p>
<p>在这个攻击过程中，攻击者借助受害者的 Cookie 骗取服务器的信任，但并不能拿到 Cookie，也看不到 Cookie 的内容。而对于服务器返回的结果，由于浏览器同源策略的限制，攻击者也无法进行解析。（攻击者的网站虽然是跨域的，但是他构造的链接是源网站的，跟源网站是同源的，所以能够携带cookie发起访问）。</p>
<p>但是攻击者无法从返回的结果中得到任何东西，他所能做的就是给服务器发送请求，以执行请求中所描述的命令，在服务器端直接改变数据的值，而非窃取服务器中的数据。例如删除数据、修改数据，新增数据等，无法获取数据。</p>
<h5 id="csrf_2">CSRF攻击防范<a class="headerlink" href="#csrf_2" title="Permanent link">&para;</a></h5>
<p><strong>验证码</strong>：验证码被认为是对抗 CSRF 攻击最简洁而有效的防御方法。从上述示例中可以看出，CSRF 攻击往往是在用户不知情的情况下构造了网络请求。而验证码会强制用户必须与应用进行交互，才能完成最终请求。因为通常情况下，验证码能够很好地遏制 CSRF 攻击。但验证码并不是万能的，因为出于用户考虑，不能给网站所有的操作都加上验证码。因此，验证码只能作为防御 CSRF 的一种辅助手段，而不能作为最主要的解决方案。</p>
<p><strong>Referer Check</strong>：根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。通过 Referer Check，可以检查请求是否来自合法的"源"。</p>
<p><strong>添加token验证</strong>：要抵御 CSRF，关键在于在请求中放入攻击者所不能伪造的信息，并且该信息不存在于 Cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。</p>
<h3 id="graphql">介绍一下Graphql<a class="headerlink" href="#graphql" title="Permanent link">&para;</a></h3>
<blockquote>
<p>小提示：这道题是给自己挖了一个坑，抱着学习的心态尝试使用Graphql技术，却没有好好理解是在什么场景下为了解决什么问题才应该使用，也没有好好准备如何描述新技术，往往这种不熟悉的技术自己在简历中应该留存一些心眼，尽量不要提，否则答不上来会很尴尬，让面试官怀疑你的项目成分。</p>
</blockquote>
<h4 id="graphql_1">什么是Graphql<a class="headerlink" href="#graphql_1" title="Permanent link">&para;</a></h4>
<p>GraphQL是一种API查询语言。API接口的返回值可以从静态变为动态，即调用者来声明接口返回什么数据，可以进一步解耦前后端。在Graphal中，预先定义Schema和声明Type来达到动态获取接口数据的目的：</p>
<ul>
<li>对于数据模型的抽象是通过Type来描述的</li>
<li>对于接口获取数据的逻辑是通过Schema来描述的</li>
</ul>
<h4 id="graphql_2">为什么要使用Graphql：<a class="headerlink" href="#graphql_2" title="Permanent link">&para;</a></h4>
<ul>
<li>接口数量众多维护成本高</li>
<li>接口扩展成本高</li>
<li>接口响应的数据格式无法预知</li>
<li>减少无用数据的请求， 按需获取</li>
<li>强类型约束（API的数据格式让前端来定义，而不是后端定义）</li>
</ul>
<h4 id="type">Type（数据模型的抽象）<a class="headerlink" href="#type" title="Permanent link">&para;</a></h4>
<p>Type简单可以分为两种，一种叫做Scalar Type(标量类型)，另一种叫做Object Type(对象类型)：</p>
<ul>
<li>Scalar Type（标量类型）：内建的标量包含，String、Int、Float、Boolean、Enum</li>
<li>Object Type（对象类型）：感觉类似于TypeScript的接口类型</li>
<li>Type Modifier（类型修饰符）：用于表明是否必填等</li>
</ul>
<h4 id="schema">Schema（模式）<a class="headerlink" href="#schema" title="Permanent link">&para;</a></h4>
<p>定义了字段的类型、数据的结构，描述了接口数据请求的规则</p>
<h5 id="query">Query（查询、操作类型）<a class="headerlink" href="#query" title="Permanent link">&para;</a></h5>
<p>查询类型： query（查询）、mutation（更改）和subscription（订阅）</p>
<ul>
<li>query（查询）：当获取数据时，应当选取Query类型</li>
<li>mutation（更改）：当尝试修改数据时，应当使用mutation类型</li>
<li>subscription（订阅）：当希望数据更改时，可以进行消息推送，使用subscription类型</li>
</ul>
<h5 id="resolver">Resolver（解析函数）<a class="headerlink" href="#resolver" title="Permanent link">&para;</a></h5>
<p>提供相关Query所返回数据的逻辑。Query和与之对应的Resolver是同名的，这样在GraphQL才能把它们对应起来。解析的过程可能是递归的，只要遇到非标量类型，会尝试继续解析，如果遇到标量类型，那么解析完成，这个过程叫做解析链。</p>
<h3 id="vuenexttick">说说Vue中<code>$nextTick</code>的实现原理<a class="headerlink" href="#vuenexttick" title="Permanent link">&para;</a></h3>
<blockquote>
<p>小提示：如果面试者使用的是Vue技术栈，那么<code>$nextTick</code>的原理是一个高频问题，面试者借此可以追问的东西较多，例如浏览器的Event Loop、微任务和宏任务、Node.js的Event Loop、异步更新DOM（响应式的数据for循环改变了1000次为什么视图只更新了一次）、<code>$nextTick</code>历史版本问题等等。</p>
</blockquote>
<p>这个如果不是很清楚的具体可查看我之前写的文章<a href="https://juejin.im/post/5cd9854b5188252035420a13">你真的理解$nextTick么</a>。</p>
<h3 id="vue_1">Vue响应式原理<a class="headerlink" href="#vue_1" title="Permanent link">&para;</a></h3>
<h3 id="_37">谈谈对闭包的理解<a class="headerlink" href="#_37" title="Permanent link">&para;</a></h3>
<h3 id="jsonp_3">JSONP的实现原理<a class="headerlink" href="#jsonp_3" title="Permanent link">&para;</a></h3>
<h3 id="cssbfc">CSS中的BFC<a class="headerlink" href="#cssbfc" title="Permanent link">&para;</a></h3>
<h3 id="_38">如何实现居中<a class="headerlink" href="#_38" title="Permanent link">&para;</a></h3>
<h4 id="_39">水平居中<a class="headerlink" href="#_39" title="Permanent link">&para;</a></h4>
<ul>
<li>若是行内元素，给其父元素设置<code>text-align:center</code>即可实现行内元素水平居中</li>
<li>若是块级元素，该元素设置<code>margin:0 auto</code>即可（元素需要定宽）</li>
<li>若是块级元素，设置父元素为flex布局，子元素设置<code>margin:0 auto</code>即可（子元素不需要定宽）</li>
<li>使用flex 2012年版本布局，可以轻松的实现水平居中，子元素设置如下:</li>
</ul>
<div class="codehilite"><pre><span></span><code>// flex容器
&lt;div class=&quot;box&quot;&gt; 
 // flex项目
 &lt;div class=&quot;box-center&quot;&gt;
 &lt;/div&gt;
&lt;/div&gt;


.box {
  width: 200px;
  height: 200px;
  display: flex;
  // 使内部的flex项目水平居中
  justify-content: center;
  background-color: pink;
}

/* .box-center {
  width: 50%;
  background-color: greenyellow;
} */


复制代码
</code></pre></div>

<ul>
<li>使用绝对定位和CSS3新增的属性<code>transform</code>（这个属性还和GPU硬件加速、固定定位相关）</li>
</ul>
<div class="codehilite"><pre><span></span><code>.box {
  width: 200px;
  height: 200px;
  position: relative;
  background-color: pink;
}

.box-center {
  position: absolute;
  left:50%;
  // width: 50%;
  height: 100%;
  // 通过 translate() 方法，元素从其当前位置移动，根据给定的 left（x 坐标） 和 top（y 坐标） 位置参数：
  // translate(x,y) 定义 2D 转换。
  // translateX(x)  定义转换，只是用 X 轴的值。
  // translateY(y)  定义转换，只是用 Y 轴的值。
  // left: 50% 先整体向父容器的左侧偏移50%，此时是不能居中的，因为元素本身有大小
  // 接着使用transform使用百分比向左偏移本身的宽度的一半实现水平居中（这里的百分比以元素本身的宽高为基准）
  transform:translate(-50%,0);
  background-color: greenyellow;
}
复制代码
</code></pre></div>

<ul>
<li>使用绝对定位和<code>margin-left</code>（元素定宽）</li>
</ul>
<div class="codehilite"><pre><span></span><code>.box {
  width: 200px;
  height: 200px;
  position: relative;
  background-color: pink;
}

.box-center {
  position: absolute;
  left:50%;
  height: 100%;
  // 类似于transform
  // width: 50%;
  // margin-left: -25%;
  width: 100px;
  margin-left: -50px;
  background-color: greenyellow;
}
复制代码
</code></pre></div>

<h4 id="_40">垂直居中<a class="headerlink" href="#_40" title="Permanent link">&para;</a></h4>
<ul>
<li>若元素是单行文本, 则可设置<code>line-height</code>等于父元素高度</li>
<li>若是块级元素，设置父元素为flex布局，子元素设置<code>margin: auto 0</code>即可（子元素不需要定宽）</li>
<li>若元素是行内块级元素，基本思想是使用<code>display: inline-block, vertical-align: middle</code>和一个伪元素让内容块处于容器中央：</li>
</ul>
<div class="codehilite"><pre><span></span><code>.box {
  height: 100px;
}

.box::after, .box-center{
  display:inline-block;
  vertical-align:middle;
}
.box::after{
  content:&#39;&#39;;
  height:100%;
}
复制代码
</code></pre></div>

<h5 id="_41">居中元素高度不定<a class="headerlink" href="#_41" title="Permanent link">&para;</a></h5>
<ul>
<li>可用 <code>vertical-align</code> 属性（<code>vertical-align</code>只有在父层为 td 或者 th 时才会生效,，对于其他块级元素，例如 div、p 等，默认情况是不支持的），为了使用<code>vertical-align</code>，我们需要设置父元素<code>display:table</code>, 子元素 <code>display:table-cell;vertical-align:middle</code>：</li>
</ul>
<div class="codehilite"><pre><span></span><code>.box {
  height: 100px;
  display: table;
}

 .box-center{
    display: table-cell;
    vertical-align:middle;
}
复制代码
</code></pre></div>

<ul>
<li>可用 Flex 2012版, 这是CSS布局未来的趋势。Flexbox是CSS3新增属性，设计初衷是为了解决像垂直居中这样的常见布局问题：</li>
</ul>
<div class="codehilite"><pre><span></span><code>.box {
  height: 100px;
  display: flex;
  align-items: center;
}
复制代码
</code></pre></div>

<p>优点：内容块的宽高任意, 优雅的溢出. 可用于更复杂高级的布局技术中. 缺点：IE8/IE9不支持、需要浏览器厂商前缀、渲染上可能会有一些问题。</p>
<ul>
<li>可用 <code>transform</code> ，设置父元素相对定位：</li>
</ul>
<div class="codehilite"><pre><span></span><code>.box {
  height: 100px;
  position: relative;
  background-color: pink;
}

.box-center {
  position: absolute;
  top: 50%;
  transform: translate(0, -50%);
  background-color: greenyellow;
}
复制代码
</code></pre></div>

<p>缺点：IE8不支持, 属性需要追加浏览器厂商前缀，可能干扰其他 <code>transform</code> 效果，某些情形下会出现文本或元素边界渲染模糊的现象。</p>
<h5 id="_42">居中元素高度固定<a class="headerlink" href="#_42" title="Permanent link">&para;</a></h5>
<ul>
<li>设置父元素相对定位，子元素如下css样式:</li>
</ul>
<div class="codehilite"><pre><span></span><code>.box {
  position:relative;
  height: 100px;
  background-color: pink;
}

.box-center{
  position:absolute;
  top:50%;
  // 注意不能使用百分比
  // margin的百分比计算是相对于父容器的width来计算的，甚至包括margin-top和margin-bottom
  height: 50px;
  margin-top: -25px;
}
复制代码
</code></pre></div>

<ul>
<li>设置父元素相对定位, 子元素如下css样式:</li>
</ul>
<div class="codehilite"><pre><span></span><code>.box {
  position:relative;
  width: 200px;
  height: 200px;
  background-color: pink;
}

.box-center{
  position:absolute;
  top: 0;
  bottom: 0;
  margin: auto 0;
  height: 100px;
  background-color: greenyellow;
}
复制代码
</code></pre></div>

<h4 id="_43">水平垂直居中<a class="headerlink" href="#_43" title="Permanent link">&para;</a></h4>
<ul>
<li>Flex布局（子元素是块级元素）</li>
</ul>
<div class="codehilite"><pre><span></span><code>.box {
  display: flex;
  width: 100px;
  height: 100px;
  background-color: pink;
}

.box-center{
  margin: auto;
  background-color: greenyellow;
}
复制代码
</code></pre></div>

<ul>
<li>Flex布局</li>
</ul>
<div class="codehilite"><pre><span></span><code>.box {
  display: flex;
  width: 100px;
  height: 100px;
  background-color: pink;
  justify-content: center;
  align-items: center;
}

.box-center{
  background-color: greenyellow;
}
复制代码
</code></pre></div>

<ul>
<li>绝对定位实现(定位元素定宽定高)</li>
</ul>
<div class="codehilite"><pre><span></span><code>.box {
  position: relative;
  height: 100px;
  width: 100px;
  background-color: pink;
}

.box-center{
  position: absolute;
  left: 0;
  right: 0;
  bottom: 0;
  top: 0;
  margin: auto;
  width: 50px;
  height: 50px;
  background-color: greenyellow;
}
复制代码
</code></pre></div>

<h3 id="flex_1">用过Flex么，能简单介绍一下么<a class="headerlink" href="#flex_1" title="Permanent link">&para;</a></h3>
<blockquote>
<p>小提示：如果在项目中使用过，可简单介绍一下自己使用Flex解决过什么问题，这里我在项目中印象比较深刻的是使用Flex解决上面内容高度不固定，下面内容高度自动撑满父容器剩余高度的问题。</p>
</blockquote>
<p>如果不是很清楚Flex，可以查看阮一峰的文章<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">Flex 布局教程：语法篇</a>。面试官追问，那么除了Flex，你还知道Grid么？这个由于兼容性问题，我一直没有好好研究过，这里可查看阮一峰的文章<a href="http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html">CSS Grid网格布局教程</a>。</p>
<h3 id="bind"><code>bind</code>的源码实现<a class="headerlink" href="#bind" title="Permanent link">&para;</a></h3>
<blockquote>
<p>小提示：这里我回答使用函数柯里化加上<code>apply</code>或者<code>call</code>可实现<code>bind</code>，面试官追问了一些具体的实现细节。</p>
</blockquote>
<p>后来我自己粗糙的实现了一下，仅供参考：</p>
<div class="codehilite"><pre><span></span><code>Function.prototype.myCall = function (obj) {
  obj.fn = this
  let args = [...arguments].splice(1)
  let result = obj.fn(...args)
  delete obj.fn
  return result
}

Function.prototype.myApply = function (obj) {
  obj.fn = this
  let args = arguments[1]
  let result
  if (args) {
    result = obj.fn(...args)
  } else {
    result = obj.fn()
  }

  delete obj.fn

  return result
}

Function.prototype.myBind = function (obj) {
  let context = obj || window
  let _this = this
  let _args = [...arguments].splice(1)

  return function () {
    let args = arguments
    // 产生副作用
    // return obj.fn(..._args, ...args)
    return _this.apply(context, [..._args, ...args])
  }
}

function myFun (argumentA, argumentB) {
  console.log(this.value)
  console.log(argumentA)
  console.log(argumentB)
  return this.value
}

let obj = {
  value: &#39;ziyi2&#39;
}
console.log(myFun.myCall(obj, 11, 22))
console.log(myFun.myApply(obj, [11, 22]))
console.log(myFun.myBind(obj, 33)(11, 22))
复制代码
</code></pre></div>

<h3 id="_44">伪类和伪元素的区别<a class="headerlink" href="#_44" title="Permanent link">&para;</a></h3>
<blockquote>
<p>小提示：这个问题我当时懵了一下，一下子没反应过来面试官想要问什么，就答了这两者在CSS优先级上有区别，然后由于遇到不会的问题有些紧张就多说了一些废话，但显然这不是面试官想要的答案并且消耗了面试官面试的耐心，说他问的不是这个。这里再次提示大家，如果你感觉你说不清楚，但是你又知道一点，我建议你说不知道，不要纠结，面试官不会因为你不知道一个问题就PASS你，相反你说了一些无关紧要的废话，反而在消耗面试官的耐性，增加负面印象。</p>
</blockquote>
<p>伪类和伪元素是用来修饰不在文档树中的部分，比如，一句话中的第一个字母，或者是列表中的第一个元素。下面分别对伪类和伪元素进行解释：</p>
<p>伪类用于当已有元素处于的某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。比如说，当用户悬停在指定的元素时，我们可以通过:hover来描述这个元素的状态。虽然它和普通的css类相似，可以为已有的元素添加样式，但是它只有处于dom树无法描述的状态下才能为元素添加样式，所以将其称为伪类。</p>
<p>伪元素用于创建一些不在文档树中的元素，并为其添加样式。比如说，我们可以通过:before来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。</p>
<h4 id="_45">区别<a class="headerlink" href="#_45" title="Permanent link">&para;</a></h4>
<p>伪类的操作对象是文档树中已有的元素，而伪元素则创建了一个文档树外的元素。因此，伪类与伪元素的区别在于：<strong>有没有创建一个文档树之外的元素。</strong></p>
<p>CSS3规范中的要求使用双冒号(::)表示伪元素，以此来区分伪元素和伪类，比如::before和::after等伪元素使用双冒号(::)，:hover和:active等伪类使用单冒号(:)。除了一些低于IE8版本的浏览器外，大部分浏览器都支持伪元素的双冒号(::)表示方法。</p>
<h3 id="_46">小结<a class="headerlink" href="#_46" title="Permanent link">&para;</a></h3>
<p>对于滴滴的这次面试，我感觉到自己准备的不是很充分，尤其是自己简历上的项目技术Graphql。同时对于自己不会的题目强行做了一些解释说明，其实应该简洁明了的告诉面试官不会。</p>
<h2 id="51">51信用卡（一面）<a class="headerlink" href="#51" title="Permanent link">&para;</a></h2>
<h3 id="dom_1">说说DOM事件流<a class="headerlink" href="#dom_1" title="Permanent link">&para;</a></h3>
<h3 id="es5">在ES5中如何实现继承<a class="headerlink" href="#es5" title="Permanent link">&para;</a></h3>
<blockquote>
<p>小提示：这里我说了很多，从借用构造函数到组合继承到寄生组合继承，但面试官其实最想听到的是寄生组合继承。面试官还追问我具体要如何实现寄生组合继承。当然这里其实问的问题还可以很多，比如ES6的类继承和ES5中的继承有什么区别。</p>
</blockquote>
<p>如果对于继承以及继承的区别不是很清楚的，可以随便看看我之前写的大笔记<a href="https://github.com/ziyi2/js/blob/master/JS类和继承.md">js类和继承</a>。</p>
<h3 id="_47">绝对定位<a class="headerlink" href="#_47" title="Permanent link">&para;</a></h3>
<blockquote>
<p>小提示：这个建议大家好好回忆一下，例如子元素是相对父元素的padding、border还是content进行定位之类的，当时面试官问的就这么细。</p>
</blockquote>
<h3 id="_48">消抖和节流<a class="headerlink" href="#_48" title="Permanent link">&para;</a></h3>
<blockquote>
<p>小提示：面试官只是问了一下具体的使用场景，没有问实现原理。</p>
</blockquote>
<h4 id="_49">简单消抖<a class="headerlink" href="#_49" title="Permanent link">&para;</a></h4>
<div class="codehilite"><pre><span></span><code>function debounce (fn, wait = 1000) {
  let timeOutId

  return function () {
    let context = this

    if (timeOutId) {
      clearTimeout(timeOutId)
    }

    timeOutId = setTimeout(() =&gt; {
      fn.apply(context, arguments)
    }, wait)
  }
}
复制代码
</code></pre></div>

<h4 id="_50">带立即执行参数的消抖<a class="headerlink" href="#_50" title="Permanent link">&para;</a></h4>
<div class="codehilite"><pre><span></span><code>function debounceImmediate (fn, wait = 1000, immediate) {
  let timeOutId, context, args

  const later = (immediate) =&gt; setTimeout(() =&gt; {
    if (!immediate) {
      fn.apply(context, args)
      timeOutId = context = args = null
    }
  }, wait)

  return function () {
    if (!timeOutId) {
      timeOutId = later(true)

      if (immediate) {
        fn.apply(this, arguments)
      }

      context = this
      args = arguments
    } else {
      clearTimeout(timeOutId)
      timeOutId = later(false)
    }
  }
}
复制代码
</code></pre></div>

<h4 id="_51">节流<a class="headerlink" href="#_51" title="Permanent link">&para;</a></h4>
<div class="codehilite"><pre><span></span><code>function throttle (fn, wait) {
  let timeoutId = null
  return function () {
    let context = this
    if (!timeoutId) {
      timeoutId = setTimeout(() =&gt; {
        fn.apply(context, arguments)
        timeoutId = null
      }, wait)
    }
  }
}
复制代码
</code></pre></div>

<h3 id="vuecomputed">Vue中的computed实现原理<a class="headerlink" href="#vuecomputed" title="Permanent link">&para;</a></h3>
<blockquote>
<p>小提示：这个问题面试官问的很细，绝对是想问你是否阅读过源码。他首先问computed的实现原理，其次问了这样一个问题：现在有两个computed计算值，其中一个computed计算值为什么可以依赖另外一个computed计算值。这里顺便将watch的实现原理也贴上。</p>
</blockquote>
<h4 id="watch">watch的实现原理<a class="headerlink" href="#watch" title="Permanent link">&para;</a></h4>
<p>watch的分类：</p>
<ul>
<li>deep watch（深层次监听）</li>
<li>user watch（用户监听）</li>
<li>computed watcher（计算属性）</li>
<li>sync watcher（同步监听）</li>
</ul>
<p>watch实现过程：</p>
<ul>
<li>watch的初始化在data初始化之后（此时的data已经通过<code>Object.defineProperty</code>的设置成响应式）</li>
<li>watch的key会在Watcher里进行值的读取，也就是立马执行get获取value（从而实现data对应的key执行getter实现对于watch的依赖收集），此时如果有<code>immediate</code>属性那么立马执行watch对应的回调函数</li>
<li>当data对应的key发生变化时，触发user watch实现watch回调函数的执行</li>
</ul>
<h4 id="computed">computed运行原理<a class="headerlink" href="#computed" title="Permanent link">&para;</a></h4>
<ul>
<li>computed的属性是动态挂载到vm实例上的，和普通的响应式数据在data里声明不同</li>
<li>设置computed的getter，如果执行了computed对应的函数，由于函数会读取data属性值，因此又会触发data属性值的getter函数，在这个执行过程中就可以处理computed相对于data的依赖收集关系了</li>
<li>首次计算computed的值时，会执行vm.computed属性对应的getter函数（用户指定的computed函数，如果没有设置getter，那么将当前指定的函数赋值computed属性的getter），进行上述的依赖收集</li>
<li>如果computed的属性值又依赖了其他computed计算属性值，那么会将当前target暂存到栈中，先进行其他computed计算属性值的依赖收集，等其他计算属性依赖收集完成后，在从栈中pop出来，继续进行当前computed的依赖收集</li>
</ul>
<div class="codehilite"><pre><span></span><code>var vm = new Vue({
  el: &#39;#demo&#39;,
  data: {
    firstName: &#39;Foo&#39;,
    lastName: &#39;Bar&#39;
  },
  computed: {
    fullName: function () {
      return this.firstName + &#39; &#39; + this.lastName
    }
  }
})
复制代码
</code></pre></div>

<p>由于 <code>this.firstName</code> 和 <code>this.lastName</code> （上面是Vue官方示例）都是响应式变量，因此会触发它们的 getter，根据我们之前的分析，它们会把自身持有的 dep 添加到当前正在计算的 watcher 中，这个时候<code>Dep.target</code>就是这个 computed watcher，具体步骤如下：</p>
<ul>
<li>data 属性初始化 getter setter</li>
<li>computed 计算属性初始化，提供的函数将用作属性 <code>vm.fullName</code> 的 getter</li>
<li>当首次获取 <code>fullName</code> 计算属性的值时，Dep 开始依赖收集</li>
<li>在执行 message getter 方法时，如果 Dep 处于依赖收集状态，则判定<code>firstName</code>和<code>lastName</code>为<code>fullName</code> 的依赖，并建立依赖关系</li>
<li>当<code>firstName</code>或<code>lastName</code> 发生变化时，根据依赖关系，触发 <code>fullName</code> 的重新计算</li>
<li>如果计算值没有发生变化，不会触发视图更新</li>
</ul>
<p>通过以上的分析，我们知道计算属性本质上就是一个 computed watcher，也了解了它的创建过程和被访问触发 getter 以及依赖更新的过程，其实这是最新的计算属性的实现，之所以这么设计是因为 Vue 想确保不仅仅是计算属性依赖的值发生变化，而是当计算属性最终计算的值发生变化才会触发渲染 watcher 重新渲染，本质上是一种优化。</p>
<h4 id="computedcomputed">computed计算值为什么还可以依赖另外一个computed计算值<a class="headerlink" href="#computedcomputed" title="Permanent link">&para;</a></h4>
<blockquote>
<p>小提示：这个问题当时完全不知道，哎，官方源码的套路太深了......</p>
</blockquote>
<p>这里希望有大神可以补充说明一下。</p>
<h3 id="beforecreatedcreated">周期函数有哪些（<code>beforeCreated</code>和<code>created</code>中间都做了什么<a class="headerlink" href="#beforecreatedcreated" title="Permanent link">&para;</a></h3>
<p>）</p>
<p>初始化 <code>data</code>、<code>props</code>、<code>computed</code>、<code>watcher</code>、<code>provide</code>。官方源码具体位置<a href="https://github.com/vuejs/vue/blob/dev/src/core/instance/init.js"><code>src/core/instance/init.js</code></a>：</p>
<div class="codehilite"><pre><span></span><code>callHook(vm, &#39;beforeCreate&#39;)
initInjections(vm) // resolve injections before data/props
initState(vm)
initProvide(vm) // resolve provide after data/props
callHook(vm, &#39;created&#39;)
复制代码
</code></pre></div>

<h3 id="_52">小结<a class="headerlink" href="#_52" title="Permanent link">&para;</a></h3>
<p>51信用卡的这次面试其实面试官考察的点还是蛮深入的，问了一些Vue底层源码的实现，总体感觉自己回答的还可以，但是面试官说：你应该去阿里...</p>
<h2 id="_53">阿里部门未知（一面）<a class="headerlink" href="#_53" title="Permanent link">&para;</a></h2>
<h3 id="webpack">说说Webpack的实现原理<a class="headerlink" href="#webpack" title="Permanent link">&para;</a></h3>
<blockquote>
<p>小提示：这个直接回答不知道，问题较大，我这里猜测一下是类似Babel和AST抽象语法树相关，有空去看下源码。</p>
</blockquote>
<p>这个问题希望同学可以补充一下。</p>
<h3 id="_54">首屏优化有哪些解决方案<a class="headerlink" href="#_54" title="Permanent link">&para;</a></h3>
<blockquote>
<p>小提示：这个问题在回答懒加载的过程中，面试官追问懒加载的Webpack配置，我说了和代码切割相关。</p>
</blockquote>
<p>关于懒加载，这里推荐一篇非常好的文章：<a href="https://zhuanlan.zhihu.com/p/26710831">Webpack 大法之 Code Splitting</a>。</p>
<h3 id="nodejsrequiremoduleexports">Node.js的加载机制（<code>require</code>和<code>module.exports</code>）<a class="headerlink" href="#nodejsrequiremoduleexports" title="Permanent link">&para;</a></h3>
<blockquote>
<p>小提示：这个问题其实是非常常见的问题，建议大家阅读一下源码，有些也可能会问一下比较简单的问题，例如<code>module.exports</code>和<code>exports</code>的区别，或者也可能问CommonJS引入和ES6引入的区别。</p>
</blockquote>
<h3 id="_55">你觉得你最擅长什么<a class="headerlink" href="#_55" title="Permanent link">&para;</a></h3>
<blockquote>
<p>小提示：这个问题是个大坑阿，我这里直接回答我什么都不擅长，这样回答显然面试官是不会不满意的，建议大家在面试前好好想想自己到底擅长啥。</p>
</blockquote>
<h3 id="reactvue">React和Vue的区别<a class="headerlink" href="#reactvue" title="Permanent link">&para;</a></h3>
<blockquote>
<p>小提示：这里React真的好久没用了，几乎忘记了，大致说了下单向数据流、双向数据绑定、数据监听方式、JSX以及Vue的单文件组件、函数式编程、Vue的指令之类的。</p>
</blockquote>
<p>这个问题希望同时熟悉React和Vue的同学可以补充一下。</p>
<h3 id="reactvuejquery">React、Vue和JQuery在什么场景下怎么选型<a class="headerlink" href="#reactvuejquery" title="Permanent link">&para;</a></h3>
<p>这个问题希望同学可以补充一下。</p>
<h3 id="vue_2">Vue的响应式原理<a class="headerlink" href="#vue_2" title="Permanent link">&para;</a></h3>
<h3 id="dom_2">什么情况下会阻塞DOM渲染<a class="headerlink" href="#dom_2" title="Permanent link">&para;</a></h3>
<blockquote>
<p>小提示：面试官这里应该想问DOM渲染的过程中可能有哪些情况会阻塞渲染。我当时回答不知道。</p>
</blockquote>
<p>这个问题希望同学可以补充一下。</p>
<h3 id="_56">有哪些异步函数<a class="headerlink" href="#_56" title="Permanent link">&para;</a></h3>
<blockquote>
<p>小提示：回答了宏任务和微任务。</p>
</blockquote>
<h3 id="mvvmmvc">讲讲MVVM，说说与MVC有什么区别<a class="headerlink" href="#mvvmmvc" title="Permanent link">&para;</a></h3>
<blockquote>
<p>小提示：这个问题我专门发了一篇掘金文章，但是很多人好像都不是很感兴趣的样子，但是面试官真的就问了这样一个问题。</p>
</blockquote>
<p>这里推荐我之前写的掘金文章<a href="https://juejin.im/post/5cd8a7c1f265da037a3d0992#heading-0">基于Vue实现一个简易MVVM/MV*设计模式的演变历史</a>，一开始重点讲解了MVC、MVP以及MVVM的演变过程和区别。</p>
<h2 id="cbu">阿里CBU技术部（一面）<a class="headerlink" href="#cbu" title="Permanent link">&para;</a></h2>
<h3 id="z-index">说说z-index有什么需要注意的地方<a class="headerlink" href="#z-index" title="Permanent link">&para;</a></h3>
<blockquote>
<p>小提示：真的忘记的差不多了，就简单说了只能在同一层叠上下文中进行<code>z-index</code>值比较、和绝对定位的关系，<code>z-index</code>值不需要设置过大，只需要理清楚层级关系即可。面试官追问了<code>z-index</code>值和<code>background</code>的覆盖关系，还追问了绝对定位元素以及后来居上的准则。面试官还问了z-index默认值是什么，<code>0</code>和<code>auto</code>有没有区别？真的对于CSS可能平常就用的不多，所以这个问题答的不是很好。</p>
</blockquote>
<p>可能面试官最想知道的是下面这张图：</p>
<p><img alt="enter image description here" src="data:image/svg+xml;utf8,&lt;?xml%20version=%221.0%22?%3E%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20version=%221.1%22%20width=%22768%22%20height=%22383%22%3E%3C/svg%3E" /></p>
<p>这里附上张鑫旭的文章<a href="https://www.zhangxinxu.com/wordpress/2016/01/understand-css-stacking-context-order-z-index/">深入理解CSS中的层叠上下文和层叠顺序</a>。</p>
<p>这里由于回答了定位，面试官追问固定定位的元素是相对于什么进行定位？相对定位会脱离正常文档流么？绝对定位是相对于什么元素进行定位？</p>
<h3 id="css3">熟悉CSS3动画么<a class="headerlink" href="#css3" title="Permanent link">&para;</a></h3>
<blockquote>
<p>小提示：CSS3动画硬件加速？CSS3动画的性能问题（重绘和重流，是否需要脱离正常文档流）？这个我当时答不知道，确实平常用的很少，如果熟悉Vue过渡动画的同学可以讲讲过渡动画？</p>
</blockquote>
<h3 id="_57">有没有做过什么可视化的项目<a class="headerlink" href="#_57" title="Permanent link">&para;</a></h3>
<blockquote>
<p>小提示：我的回答：地图算么？基于OpenLayers设计过地图的Vue组件库。</p>
</blockquote>
<p>对于可视化希望同学可以补充一下。</p>
<h3 id="_58">你觉得你最擅长的是什么<a class="headerlink" href="#_58" title="Permanent link">&para;</a></h3>
<blockquote>
<p>小提示：这个问题简直就是给人挖坑。</p>
</blockquote>
<h3 id="flex_2">Flex实现两列布局<a class="headerlink" href="#flex_2" title="Permanent link">&para;</a></h3>
<p>这里简单实现一下（其实应该使用<code>flex-basis</code>属性）：</p>
<div class="codehilite"><pre><span></span><code>&lt;div class=&quot;box&quot;&gt;
  &lt;div class=&quot;box-left&quot;&gt;&lt;/div&gt;
  &lt;div class=&quot;box-right&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
复制代码
.box {
  height: 200px;
  display: flex;
}

.box &gt; div {
  height: 100%;
}

.box-left {
  width: 200px;
  background-color: blue;
}

.box-right {
  flex: 1; // 设置flex-grow属性为1，默认为0
  overflow: hidden;
  background-color: red;
}
复制代码
</code></pre></div>

<h3 id="es6es7es8">ES6/ES7/ES8的特性<a class="headerlink" href="#es6es7es8" title="Permanent link">&para;</a></h3>
<h3 id="dom_3">说说DOM事件流<a class="headerlink" href="#dom_3" title="Permanent link">&para;</a></h3>
<blockquote>
<p>小提示：面试官追问事件委托有什么优点（起码两个以上）、<code>target</code>/<code>currentTarget</code>/<code>relateTarget</code>具体指向什么目标。</p>
</blockquote>
<h3 id="_59">你觉得你有做过推动流程或者改善流程的事件么，举例说明<a class="headerlink" href="#_59" title="Permanent link">&para;</a></h3>
<blockquote>
<p>小提示：这个如果做过什么规范或者开发工具之类的，应该比较好回答。</p>
</blockquote>
<h3 id="_60">小结<a class="headerlink" href="#_60" title="Permanent link">&para;</a></h3>
<p>总体来说这次面试面得很细，有些知识点已经忘记，建议大家面试前把一些感觉不是很熟悉的原生知识点回忆起来，尤其是在开发中都不怎么会使用一些CSS样式设计的童鞋（现在很多都是组件库的设计方案，样式早已经封装掉了）。</p>
<h2 id="_61">阿里企业智能事业部（一面）<a class="headerlink" href="#_61" title="Permanent link">&para;</a></h2>
<h3 id="event-loop_1">Event Loop<a class="headerlink" href="#event-loop_1" title="Permanent link">&para;</a></h3>
<h3 id="webpackloaderplugins">Webpack的loader和plugins的区别<a class="headerlink" href="#webpackloaderplugins" title="Permanent link">&para;</a></h3>
<blockquote>
<p>小提示：当时直接回答不知道，确实Webpack我只会用，还没了解过内部的实现原理和构成。这个后续无论如何都要好好理解一下原理。</p>
</blockquote>
<p>这个问题希望同学可以补充一下。</p>
<h3 id="http206">HTTP状态码206是干什么的<a class="headerlink" href="#http206" title="Permanent link">&para;</a></h3>
<blockquote>
<p>小提示：工作中没有遇到过需要上传下载大型文件，所以这个问题当时老老实实回答不知道。具体应该和断点续传相关，可能也需要回答一些<code>range</code>的头部信息等。</p>
</blockquote>
<h3 id="react">React高阶组件的作用有哪些<a class="headerlink" href="#react" title="Permanent link">&para;</a></h3>
<blockquote>
<p>小提示：好久没用过React了，大致只知道Racct是单向数据流的，利用高阶组件可以实现类似于Vue的双向数据绑定。</p>
</blockquote>
<p>这个问题希望同学可以补充一下。</p>
<h3 id="reactvue_1">React和Vue的区别<a class="headerlink" href="#reactvue_1" title="Permanent link">&para;</a></h3>
<h3 id="service-worker">Service Worker有哪些作用<a class="headerlink" href="#service-worker" title="Permanent link">&para;</a></h3>
<blockquote>
<p>小提示：当时怕说错，老老实实回答不知道。后来查了一下应该和缓存以及HTTP请求拦截相关。</p>
</blockquote>
<p>这个问题希望同学可以补充一下。</p>
<h3 id="_62">跨域<a class="headerlink" href="#_62" title="Permanent link">&para;</a></h3>
<h3 id="_63">文件上传的二进制具体是怎么处理的<a class="headerlink" href="#_63" title="Permanent link">&para;</a></h3>
<blockquote>
<p>小提示：只知道上传的头信息是<code>application/x-www-form-urlencoded</code>，也可以对上传的文件的数据进行拦截处理，例如对上传文件的信息进行加密处理。</p>
</blockquote>
<p>这个问题希望同学可以补充一下。</p>
<h3 id="vue_3">Vue响应式原理<a class="headerlink" href="#vue_3" title="Permanent link">&para;</a></h3>
<h3 id="_64">首屏加载性能优化<a class="headerlink" href="#_64" title="Permanent link">&para;</a></h3>
<h3 id="_65">小结<a class="headerlink" href="#_65" title="Permanent link">&para;</a></h3>
<p>其实这一次面试自己感觉面试的不是很好（尽管面试官问的确实比我上面列出的问题多），因为有好几个问题自己确实不清楚。这里再次建议大家不知道就是回答不知道，这样不会对面试官造成一些负面印象。这一次面试能够通过运气占了很大一部分。</p>
<h2 id="_66">阿里企业智能事业部（二面）<a class="headerlink" href="#_66" title="Permanent link">&para;</a></h2>
<h3 id="computed_1">computed的实现原理<a class="headerlink" href="#computed_1" title="Permanent link">&para;</a></h3>
<h3 id="vue_4">Vue的整个实现原理<a class="headerlink" href="#vue_4" title="Permanent link">&para;</a></h3>
<blockquote>
<p>小提示：当时面试官问的蛮好玩的，他问从开始写一个.vue文件开始到DOM渲染到页面上，Vue做了哪些工作。然后我当时没理解面试官是要问vue-loader？DOM树的渲染过程？来来回回试探性的问了面试官几次，才理解原来面试官想知道Vue源码的整个实现过程。</p>
</blockquote>
<p>大家如果想了解Vue源码实现的整个粗略过程，可以看下之前写的文章<a href="https://juejin.im/post/5cd8a7c1f265da037a3d0992#heading-13">基于Vue实现一个简易MVVM/Vue的运行机制简述</a>。</p>
<h3 id="_67">通讯<a class="headerlink" href="#_67" title="Permanent link">&para;</a></h3>
<blockquote>
<p>小提示：由于这边涉及到一些海康的设备（上下位机通信），面试官问我如何知道上位机软件给下位机设备发送了5次信息。这个其实大部分Web前端开发在工作上很难遇到类似的问题，辛亏我以前毕业设计中做过上下位机的TCP通讯。后来我从Leader面那里了解到二面面试官应该是做iot物联网开发这一块的。</p>
</blockquote>
<p>请求帧数据结构如下：</p>
<table>
<thead>
<tr>
<th>帧头</th>
<th>帧序号</th>
<th>帧负载</th>
<th>帧校验</th>
<th>帧尾</th>
</tr>
</thead>
<tbody>
<tr>
<td>2 Byte</td>
<td>1 Byte</td>
<td>N Byte</td>
<td>1 Byte</td>
<td>1 Byte</td>
</tr>
</tbody>
</table>
<p>这里帧头使用2字节识别，校验可以采用CRC校验，帧序号用来识别发送了几次信息。</p>
<h3 id="chrome">Chrome插件如何屏蔽广告<a class="headerlink" href="#chrome" title="Permanent link">&para;</a></h3>
<blockquote>
<p>小提示：这个问题当时回答不知道，其实后面想想最简单的办法是先找出广告元素的一些通用特性，然后在Chrome插件中通过注入脚本的形式将这些广告元素隐藏掉。</p>
</blockquote>
<p>这里不知道有没有更好的其他方式，例如不知道Service Work对请求拦截处理是否可以有效屏蔽广告等，这个问题希望同学可以补充一下。</p>
<h3 id="_68">如何判断两个变量相等<a class="headerlink" href="#_68" title="Permanent link">&para;</a></h3>
<blockquote>
<p>小提示：这里需要分基本类型和引用类型，面试官在这里具体想问的是<code>Object.is</code>的实现原理。这是面试官问我的第一个问题，当时直接回答不知道，内心都觉得接下来要凉凉了。</p>
</blockquote>
<h3 id="watch_1">Watch的运行原理<a class="headerlink" href="#watch_1" title="Permanent link">&para;</a></h3>
<h3 id="vue_5">Vue的数据为什么频繁变化但只会更新一次<a class="headerlink" href="#vue_5" title="Permanent link">&para;</a></h3>
<blockquote>
<p>小提示：这里问的是Vue源码对于视图更新的优化。我这里的回答是乱糟糟的，希望有同学能够给出一个精准并且简短的回答。</p>
</blockquote>
<p>Vue 异步执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部尝试对异步队列使用原生的 <code>Promise.then</code> 和 <code>MessageChannel</code>，如果执行环境不支持，会采用 setTimeout(fn, 0) 代替。</p>
<p>另外，关于<code>waiting</code>变量，这是很重要的一个标志位，它保证<code>flushSchedulerQueue</code>回调（$nextTick中执行）允许被置入<code>callbacks</code>一次。</p>
<p>因为Vue的事件机制是通过事件队列来调度执行，会等主进程执行空闲后进行调度，所以先会去等待所有的同步代码执行完成之后再去一次更新。这样的性能优势很明显，比如：</p>
<p>现在有这样的一种情况，<code>mounted</code>的时候<code>test</code>的值会被循环执行++1000次。 每次++时，都会根据响应式触发<code>setter-&gt;Dep-&gt;Watcher-&gt;update-&gt;run</code>。 如果这时候没有异步更新视图，那么每次++都会直接操作DOM更新视图，这是非常消耗性能的。 所以Vue实现了一个queue队列，在下一个tick（或者是当前tick的微任务阶段）统一执行queue中Watcher的run。同时，拥有相同id的Watcher不会被重复加入到该queue中去，所以不会执行1000次Watcher的run。最终更新视图只会直接将test对的DOM的0变成1000。 保证更新视图操作DOM的动作是在当前栈执行完以后下一个tick（或者是当前tick的微任务阶段）的时候调用，大大优化了性能。</p>
<p>执行顺序<code>update -&gt; queueWatcher -&gt; 维护观察者队列（重复id的Watcher处理） -&gt; waiting标志位处理（保证需要更新DOM或者Watcher视图更新的方法flushSchedulerQueue只会被推入异步执行的$nextTick回调数组一次） -&gt; 处理$nextTick（在为微任务或者宏任务中异步更新DOM）-&gt;</code></p>
<ul>
<li>Vue是异步更新Dom的，Dom的更新放在下一个宏任务或者当前宏任务的末尾（微任务）中进行执行</li>
</ul>
<p>由于VUE的数据驱动视图更新是异步的，即修改数据的当下，视图不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新。在同一事件循环中的数据变化后，DOM完成更新，立即执行<code>nextTick(callback)</code>内的回调。</p>
<p>vue和react一样，对dom的修改都是异步的。它会在队列里记录你对dom的操作并进行diff操作，后一个操作会覆盖前一个，然后更新dom。</p>
<h3 id="event-loop_2">Event Loop<a class="headerlink" href="#event-loop_2" title="Permanent link">&para;</a></h3>
<h3 id="flex_3">除了Flex还可以用什么进行布局<a class="headerlink" href="#flex_3" title="Permanent link">&para;</a></h3>
<blockquote>
<p>小提示：我猜这里面试官想问的是Grid，当时说不知道。</p>
</blockquote>
<h3 id="z-index_1">绝对定位、固定定位和z-index<a class="headerlink" href="#z-index_1" title="Permanent link">&para;</a></h3>
<blockquote>
<p>小提示：感谢CBU技术部的面试官。</p>
</blockquote>
<h4 id="_69">绝对定位<a class="headerlink" href="#_69" title="Permanent link">&para;</a></h4>
<ul>
<li>一旦给元素加上<code>absolute</code>或<code>float</code>就相当于给元素加上了<code>display:block</code></li>
<li><code>absolute</code>元素覆盖正常文档流内元素（不用设z-index，自然覆盖）</li>
<li>可以减少重绘和回流的开销（如<code>absolute+ top:-9999em</code>，或<code>absolute + visibility:hidden</code>，将动画效果放到<code>absolute</code>元素中）</li>
</ul>
<h4 id="_70">属性介绍<a class="headerlink" href="#_70" title="Permanent link">&para;</a></h4>
<ul>
<li><code>static</code>，默认值。位置设置为static的元素，它始终会处于文档流给予的位置。</li>
<li><code>inherit</code>，规定应该从父元素继承 position 属性的值。但是任何的版本的 Internet Explorer （包括 IE8）都不支持属性值 “inherit”。</li>
<li><code>fixed</code>，生成绝对定位的元素。默认情况下，可定位于相对于浏览器窗口的指定坐标。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。不论窗口滚动与否，元素都会留在那个位置。但当祖先元素具有<code>transform</code>属性且不为none时，就会相对于祖先元素指定坐标，而不是浏览器窗口。</li>
<li><code>absolute</code>，生成绝对定位的元素，相对于距该元素最近的已定位的祖先元素进行定位。此元素的位置可通过 “left”、”top”、”right” 以及 “bottom” 属性来规定。</li>
<li><code>relative</code>，生成相对定位的元素，相对于该元素在文档中的初始位置进行定位。通过 “left”、”top”、”right” 以及 “bottom” 属性来设置此元素相对于自身位置的偏移。</li>
</ul>
<p>浮动、绝对定位和固定定位会脱离文档流，相对定位不会脱离文档流，绝对定位相对于该元素最近的已定位的祖先元素，如果没有一个祖先元素设置定位，那么参照物是body层。</p>
<p>绝对定位相对于包含块的起始位置：</p>
<ul>
<li>如果祖先元素是块级元素，包含块则设置为该元素的内边距边界。</li>
<li>如果祖先元素是行内元素，包含块则设置为该祖先元素的内容边界。</li>
</ul>
<p>问答题：</p>
<ul>
<li>定位的元素的起始位置为父包含块的内边距（不会在border里，除非使用负值，会在padding里）</li>
<li>定位的元素的margin还是能起作用的</li>
<li>background属性是会显示在border里的</li>
<li>z-index是有层叠层级的，需要考虑同一个层叠上下文的层叠优先级</li>
<li>z-index是负值不会覆盖包含块的背景色（但是如果有内容，会被包含块的内容覆盖）</li>
<li>z-index的值影响的元素是定位元素以及flex盒子</li>
<li>上面一个定位元素，下面一个正常流的元素，定位元素会覆盖在正常流元素之上，除非给z-index是负值</li>
<li>页面根元素html天生具有层叠上下文，称之为“根层叠上下文”</li>
</ul>
<h3 id="_71">小结<a class="headerlink" href="#_71" title="Permanent link">&para;</a></h3>
<p>这一次面试官问我的第一个问题<code>Object.is</code>就没答上来，不过面试官显然没有因为开头答的不好就否定面试者。大家如果在面试时第一个问题就答不上来，不要慌，要保持良好的心态，把接下来能答的问题好好答上来。可能很多同学会疑问，好像还有好几个问题感觉没答上来，但是可能只要有一个问题答的非常出彩，仍然可以弥补那些没答上来的问题（这里面试官当时说Vue源码的实现过程我说的比较清楚，还没有一个面试者答的比我更清楚的）。</p>
<h2 id="leader">阿里企业智能事业部（Leader面）<a class="headerlink" href="#leader" title="Permanent link">&para;</a></h2>
<p>三面是Leader现场面，我当时特别担心有赞二面的情况发生，冷不丁又给你来一道算法题，这些真是我最不擅长的点。因为有点心虚我就问了下在阿里的师兄（师兄可能也做招聘工作，当时还怪我没有找他内推...），他说现场面其实最主要的是好好准备简历上的内容，面试官一般都会根据简历进行问答，还说他当时面试阿里时会让他画一些框架层次图（这个我当时没在意，结果面试官确实让我根据其中某个项目画一个框架层次图）。Leader面的时候在场的有两个面试官和一个HR。</p>
<h3 id="leader_1">Leader（一）面试<a class="headerlink" href="#leader_1" title="Permanent link">&para;</a></h3>
<p>先是进来一个气场很足的Leader，看起来很权威，但是问问题还蛮随意的，就简单的让我介绍一下自己做的项目，然后翻看了我做的一些东西。感觉他好像有点心不在焉，翻看的很随意，我在回答问题的时候用余光关注了一下大佬的表情，感觉他在我<strong>项目经历</strong>那一块停留了非常长的时间。</p>
<h3 id="leader_2">Leader（二）面试<a class="headerlink" href="#leader_2" title="Permanent link">&para;</a></h3>
<p>我正回答着自己的项目经历，Leader二和HR进来了，等我回答完Leader一就让Leader二开始面我。Leader二就问了我其中的两个项目。问我的第一个项目是自己做的公司内部的工具，他问这个平台有什么可以衡量的数据表明公司内部人员的使用情况。我回答当时因为领导觉得没必要做，就没有做数据统计这一块，告诉了他数据库里的一些真实数据情况。然后他问PV、UV应该怎么统计（我当时还厚脸皮的问他PV和UV是什么）？如果访问的页面出不来PV怎么统计？页面有没有做什么行为监测？页面访问量过大怎么处理？我大致讲了一些我的思路。</p>
<p>接着问我第二个项目（Low Code相关），我就回答了这个项目的技术体系，从以前做了什么到现在做到什么程度，到未来需要做成什么样，统统仔细的说了一遍。Leader二就问我未来做成什么样能不能思考一下怎么做，给了我5分钟的时间（这期间他一直反复的在翻阅我的简历）。然后我就假装思考了5分钟左右，其实脑子里一片空白，当时对于未来要做成什么样还只是个构思。然后Leader二还是很体贴的，他说你可以在墙上画一画（墙上可以写字），我就大致画了画，Leader二问我能不能画一画这个项目的框架层次图，我就简单的画了画...最后Leader二直接说你们做的太Low了，这个（Low Code）在我们这里已经是两年前的技术了...（这个我还是要解释下，我所在的部门从开始用Vue到目前只有短短的两年时间，在这两年时间里技术体系还是飞速的在沉淀和发展，我离开之前已经构思并实现了部分Vue技术栈的Low Code解决方案，如果这方面感兴趣的同学也可以找我沟通）。</p>
<p>Leader二还蛮好玩的，他说Low Code如果真的做出来了，都没前端什么事情了，那你干嘛去？顺着这个问题他还问我未来的前端应该怎么发展？未来前端有哪些可以挖掘的点？我回答了一些Graphql、可视化等，我还说了一个特别搞笑的回答，我说从以往的发展来看，前端应该抢占后端的资源，把后端限制我们的事情让前端也能做，让前端更加解放。Leader二当场就进行了反驳，说是要有价值才做，而不是为了能做而做，吓得我不轻...然后Leader二还详细的跟我解释了未来发展这个问题他希望得到什么回答，当时还是觉得Leader二蛮亲切的。</p>
<h3 id="hr">HR面试<a class="headerlink" href="#hr" title="Permanent link">&para;</a></h3>
<p>Leader二问完以后HR就接着问我了以下几个问题：</p>
<ul>
<li>为什么要离开现在的公司</li>
<li>以前公司的岗位制度是什么样</li>
<li>你是校招进去的么</li>
<li>你现在的岗位等级情况</li>
<li>你的绩效情况</li>
<li>你领导对你的评价是怎么样的</li>
<li>领导是不是经常找你沟通</li>
</ul>
<p>然后Leader一顺着HR问了一个小问题：</p>
<ul>
<li>你未来对于你的职业有什么规划</li>
</ul>
<p>最后问我还有什么想问的，我当时已经被三个人问的有点迷迷糊糊了，然后想了想说没有。</p>
<h3 id="_72">小结<a class="headerlink" href="#_72" title="Permanent link">&para;</a></h3>
<p>这次现场面其实我感觉自己面得不是很好，总感觉自己要挂了。总共面了将近1个半小时左右，尤其是Leader二的问题很多不是他想要的答案，但是最终居然过了。</p>
<h2 id="hr_1">阿里企业智能事业部（HR面）<a class="headerlink" href="#hr_1" title="Permanent link">&para;</a></h2>
<p>企业智能事业部Leader面后又收到了HR面的面试通知，这一轮面试大致问了以下问题：</p>
<ul>
<li>你为什么要离开现在的公司</li>
<li>你们公司的岗位等级是怎么评定的，你现在是什么岗位等级</li>
<li>谈谈你在公司的绩效情况</li>
<li>你觉得你做的最有成就感的一件事</li>
<li>你一般解决问题的方法有哪些</li>
<li>你是因为什么契机选择做前端</li>
<li>你有对你所在的公司做过什么流程或制度规范上的改进么</li>
<li>你最近在看什么书，和工作相关么，你为什么要看这些书</li>
<li>看到你之前还面试了其他两个部门都挂在了一面，你感觉是什么原因</li>
<li>你期望的薪资待遇是多少</li>
</ul>
<blockquote>
<p>小提示：这里HR会问的其实不止这些问题，例如你为什么喜欢Web前端这个岗位、你未来的职业规划、你觉得你的优点和缺点有哪些、为什么选择阿里巴巴、对之前几个面试官做下评价、你用过阿里的哪些产品顺便谈谈这些产品的优缺点、你对于互联网是怎么理解的...</p>
</blockquote>
<h3 id="_73">小结<a class="headerlink" href="#_73" title="Permanent link">&para;</a></h3>
<p>对于HR面还是要好好准备的，尤其是有些问题还是很容易挖坑的，例如你为什么离开现在的公司（你当然不应该抱怨现在的公司有哪些不好的地方，更多的应该表明自己想要寻找更好的发展机会，自己的一些现实因素，比如对于我而言是现在应聘的公司离自己的家更近，又或者是自己工作到达了迷茫期，想跳出迷茫期等等），你觉得你做的最有成就感的一件事（你要是说个简单的，HR会觉得你工作能力不强），你一般解决问题的方法有哪些（HR当然也想考察你解决问题的能力，你要是说什么百度啊之类的HR当然会觉得你解决问题的能力不强），你期望的薪资待遇是多少（你要是不喜欢这家公司，可以期望高一些，你要是很喜欢这家公司面试过程很愉快上浮个30%左右，面试过程一般上浮个20%左右）。</p>
<h2 id="_74">友情链接<a class="headerlink" href="#_74" title="Permanent link">&para;</a></h2>
<p>这里推荐阅读之前写的文章（前面两篇实用型，后面三篇对面试应该会有帮助）：</p>
<ul>
<li><a href="https://juejin.im/post/5cb12844e51d456e7a303b64">Vue CLI 3结合Lerna进行UI框架设计</a></li>
<li><a href="https://juejin.im/post/5cc4694a6fb9a03238106eb9">Cz工具集使用介绍 - 规范Git提交说明</a></li>
<li><a href="https://juejin.im/post/5cd9854b5188252035420a13">你真的理解$nextTick么</a></li>
<li><a href="https://juejin.im/post/5cd8a7c1f265da037a3d0992">基于Vue实现一个简易MVVM</a></li>
<li><a href="https://juejin.im/post/5e11ef3b6fb9a0483a135fa7">2019 前端之路（干货满满）</a>（墙裂推荐）</li>
</ul>
<h2 id="_75">前端面试题<a class="headerlink" href="#_75" title="Permanent link">&para;</a></h2>
<p><strong>一、TCP（Transmission Control Protocol）</strong></p>
<p>​    TCP传输控制协议，是一种面向连接的、可靠的、基于字节流的传输层通信协议。通讯双方建立一次tcp连接，需要经过三次步骤1、客户端发送syn包（syn=j）到服务器，并入SYN_SEND状态，等待服务器确认。2、服务器收入syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），既SYN+ACK包，此时服务器进入SYN_RECV状态。3、客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK（ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。（tcp在握手过程中并不携带数据，而是在三次握手完成之后才会进行数据传送）</p>
<p>SYN：synchronous 建立联机</p>
<p>ACK：acknowledgement 确认</p>
<p>SYN_SENT 请求连接</p>
<p>SYN_RECV 服务端被动打开后，接收到了客户端的SYN并且发送了ACK时的状态，再进一步接收到客户端的ACK就进入ESTABISHED状态。</p>
<p>UDP（User Datagram Protocol ）用户数据报协议</p>
<p>UDP是非面向连接协议，使用udp协议通讯并不需要建立连接，它只负责把数据尽可能发送出去，并不可靠，在接收端，UDP把每个消息断放入队列中，接收端程序从队列中读取数据。</p>
<p>TCP/IP是位于传输层上的一种协议，用于在网络中传输数据；</p>
<p><strong>二、socket（嵌套字）</strong></p>
<p>​    socket是一组实现TCP/UDP通信的接口API，既无论TCP还是UDP，通过对scoket的编程，都可以实现TCP/UCP通信。（TCP或UDP是一种计算机网络通信中在传输层的一种协议，可以简单的理解成是一种约定，只有履行合同才是实质性的行动，所以无论是TCP还是UDP要产生作用，都需要有实际性的行为去执行才能体现协议的作用。socket就是实现这种作用的方法）socket作为一个通信链的句柄，它包含了网络通信必备的5种信息。1、连接使用的协议。2、本地主机的IP地址。3、本地进程的协议端口。4、远地主机的IP地址。5、远地进程的协议端口。即可知道，socket包含了通信本方和对方的ip和端口以及连接使用的协议（TCP/UDP）。通信双方中的一方（客户端）通过socket对另一方（服务端）发起连接请求，服务端在网络上监听请求，当收到客户端发来的请求之后，根据socket里携带的信息，定位到客户端，就相应请求，把socket描述发给客户端，双方确认之后连接就建立了。</p>
<p>socket连接过程的三个步骤</p>
<p>1、服务器监听：服务器实时监控网络状态等待客户端发来的连接请求</p>
<p>2、客户端请求：客户端根据远程主机服务器的IP地址和协议端口向其发起连接请求</p>
<p>3、连接确认：服务端收到socket的连接请求之后，就响应请求，把服务端socket描述发给客户端，客户端收到后一但确认。则双方建立连接，进行数据交互。</p>
<p>socket连接一旦建立就保持连接状态，而HTTP连接则不一样，它基于tcp协议的短连接，也就是客户端发起请求，服务器响应请求之后，连接就会自动断开，不会一直保持。</p>
<p><strong>三、URL（Uniform Resource Locator）统一资源定位符</strong></p>
<p>URL是因特网上标准的资源地址</p>
<p>URL标准格式：协议类型：[//服务器地址[:端口号]][/资源层级UNIX文件路径]文件名？查询</p>
<p>URL的语法规则：scheme：//host/domain:port/path/filename  (1、scheme：定义因特网服务的类型，最常见的有http。2、host：定义域主机（http默认主机是www）。3、domain：定义因特网域名，比如“<a href="http://link.zhihu.com/?target=https%3A//www.imooc.com/article/271528">www.baidu.com”。4、path：定义服务器上的路径。5、filename：资源名)</a></p>
<p>scheme类型</p>
<p>1、http 超文本传输协议：以http：//开头的不同网页，不加密</p>
<p>2、https 安全超文本传输协议。安全网页，加密所有信息交换</p>
<p>3、ftp 文件传输协议 用于将文件下载或上传</p>
<p>4、file 本地文件</p>
<p>HTTP协议是应用层协议，基于TCP协议，用于包装数据，程序使用它进行通信，可以简单高效的处理通信中数据的传输和识别处理</p>
<p><strong>四、DNS（Domain Name Server）域名服务器</strong></p>
<p>DNS是进行域名(domain name)和与之相对应的IP地址 (IP address)转换的服务器。DNS中保存了一张域名(domain name)和与之相对应的IP地址 (IP address)的表，以解析消息的域名。</p>
<p>在浏览器输入域名后的解析过程</p>
<ol>
<li>浏览器根据地址去本身缓存中查找dns解析记录，如果有，则直接返回IP地址，否则浏览器会查找操作系统中（hosts文件）是否有该域名的dns解析记录，如果有则返回。</li>
<li>如果浏览器缓存和操作系统hosts中均无该域名的dns解析记录，或者已经过期，此时就会向域名服务器发起请求来解析这个域名。</li>
<li>请求会先到LDNS（本地域名服务器），让它来尝试解析这个域名，如果LDNS也解析不了，则直接到根域名解析器请求解析</li>
<li>根域名服务器给LDNS返回一个所查询余的主域名服务器（gTLDServer）地址。</li>
<li>此时LDNS再向上一步返回的gTLD服务器发起解析请求。</li>
<li>gTLD服务器接收到解析请求后查找并返回此域名对应的Name Server域名服务器的地址，这个Name Server通常就是你注册的域名服务器（比如阿里dns、腾讯dns等）</li>
<li>Name Server域名服务器会查询存储的域名和IP的映射关系表，正常情况下都根据域名得到目标IP记录，连同一个TTL值返回给DNS Server域名服务器</li>
<li>返回该域名对应的IP和TTL值，Local DNS Server会缓存这个域名和IP的对应关系，缓存的时间有TTL值控制。</li>
<li>把解析的结果返回给用户，用户根据TTL值缓存在本地系统缓存中，域名解析过程结束.</li>
</ol>
<p><strong>五、HTTP请求发起和响应</strong></p>
<p>在一个web程序开发中，一般都有前端和后端之分，前端负责向后端请求数据和展示页面，后端负责接收请求和做出响应发回给前端，他们之间的协作桥梁是API，而API其实就是一个URL，作为HTTP连接的一种具体载体。</p>
<p>用户输入URL到浏览器显现给用户页面经过了什么过程</p>
<ol>
<li>用户输入URL，浏览器获取到URL</li>
<li>浏览器(应用层)进行DNS解析（直接输入IP地址既跳过该步骤）</li>
<li>根据解析出的IP地址+端口，浏览器（应用层）发起HTTP请求，请求中携带（请求头header（也可细分为请求行和请求头）、请求体body）</li>
<li>请求到达传输层，tcp协议为传输报文提供可靠的字节流传输服务，它通过三次握手等手段来保证传输过程中的安全可靠。通过对大块数据的分割成一个个报文段的方式提供给大量数据的便携传输。</li>
<li>到网络层， 网络层通过ARP寻址得到接收方的Mac地址，IP协议把在传输层被分割成一个个数据包传送接收方。</li>
<li>数据到达数据链路层，请求阶段完成</li>
<li>接收方在数据链路层收到数据包之后，层层传递到应用层，接收方应用程序就获得到请求报文。</li>
<li>接收方收到发送方的HTTP请求之后，进行请求文件资源（如HTML页面）的寻找并响应报文</li>
<li>发送方收到响应报文后，如果报文中的状态码表示请求成功，则接受返回的资源（如HTML文件），进行页面渲染。</li>
</ol>
<p>（header：1、请求的方法（get、post、put..）2、协议（http、https、ftp、sftp…）3目标url（具体的请求路径已经文件名）4一些必要信息（缓存、cookie之类）。)</p>
<p>（body包含请求的内容）</p>
<p><strong>六、页面渲染过程</strong></p>
<p><img alt="img" src="https://pic2.zhimg.com/v2-4929b8d7a9b75216c66f8f9440f36b61_b.jpg" /></p>
<p>内容解释</p>
<ol>
<li>HTML parser：HTML解析器，其本质是将HTML文本解释成DOM tree。</li>
<li>CSS  parser：CSS解析器，其本质是讲DOM中各元素对象加入样式信息</li>
<li>JavaScript引擎：专门处理JavaScript脚本的虚拟机，其本质是解析JS代码并且把逻辑（HTML和CSS的操作）应用到布局中，从而按程序要的要求呈现相应的结果</li>
<li>DOM tree:文档对象模型树，也就是浏览器通过HTMLparser解析HTML页面生成的HTML树状结构以及相应的接口。</li>
<li>render tree：渲染树，也就是浏览器引擎通过DOM Tree和CSS Rule Tree构建出来的一个树状结构，和dom tree不一样的是，它只有要最终呈现出来的内容，像或者带有display:none的节点是不存在render tree中的。</li>
<li>layout：也叫reflow 重排，渲染中的一种行为。当rendertree中任一节点的几何尺寸发生改变了，render tree都会重新布局。</li>
<li>repaint：重绘，渲染中的一种行为。render tree中任一元素样式属性（几何尺寸没改变）发生改变了，render tree都会重新画，比如字体颜色、背景等变化。</li>
</ol>
<p><strong>七、href与src</strong></p>
<p>href (Hypertext Reference)指定网络资源的位置，从而在当前元素或者当前文档和由当前属性定义的需要的锚点或资源之间定义一个链接或者关系。（目的不是为了引用资源，而是为了建立联系，让当前标签能够链接到目标地址。）</p>
<p>src source（缩写），指向外部资源的位置，指向的内容将会应用到文档中当前标签所在位置。</p>
<p>href与src的区别</p>
<p>1、请求资源类型不同：href 指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的联系。在请求 src 资源时会将其指向的资源下载并应用到文档中，比如 JavaScript 脚本，img 图片；</p>
<p>2、作用结果不同：href 用于在当前文档和引用资源之间确立联系；src 用于替换当前内容；</p>
<p>3、浏览器解析方式不同：当浏览器解析到src ，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等也如此，类似于将所指向资源应用到当前内容。这也是为什么建议把 js 脚本放在底部而不是头部的原因。</p>
<p><strong>八、link和@import的区别</strong></p>
<p>两者都是外部引用 CSS 的方式，但是存在一定的区别：</p>
<p>（1）link是XHTML标签，除了能够加载CSS，还可以定义RSS等其他事务；而@import属于CSS范畴，只可以加载CSS。</p>
<p>（2）link引用CSS时，在页面载入时同时加载；@import需要页面完全载入以后再加载。</p>
<p>（3）link是XHTML标签，无兼容问题；@import则是在CSS2.1提出的，低版本的浏览器不支持。</p>
<p>（4）link支持使用Javascript控制DOM改变样式；而@import不支持。</p>
<p><strong>九、HTML</strong></p>
<p>1.HTML5的新特性：</p>
<p>新的内容标签：header nav content footer article aside</p>
<p>更好的单元格体系:</p>
<p>音频、视频API:video radio</p>
<p>画布(Canvas) API</p>
<p>地理(Geolocation) API</p>
<p>网页存储(Web storage) API:localStorage,sessionStorage</p>
<p>拖拽释放(Drag and drop) API</p>
<p>2.Doctype作用？标准模式与兼容模式各有什么区别?</p>
<div class="codehilite"><pre><span></span><code>&lt;!DOCTYPE&gt;声明位于位于HTML文档中的第一行，处于 &lt;html&gt; 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。
</code></pre></div>

<p>3.行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？</p>
<div class="codehilite"><pre><span></span><code>首先：CSS规范规定，每个元素都有display属性，确定该元素的类型，每个元素都有默认的display值，如div的display默认值为“block”，则为“块级”元素；span默认display属性值为“inline”，是“行内”元素。

（1）行内元素有：a b span img input select strong（强调的语气）
（2）块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p

（3）常见的空元素：    &lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt;
    鲜为人知的是：    &lt;area&gt; &lt;base&gt; &lt;col&gt; &lt;command&gt; &lt;embed&gt; &lt;keygen&gt; &lt;param&gt; &lt;source&gt; &lt;track&gt; &lt;wbr&gt;
不同浏览器（版本）、HTML4（5）、CSS2等实际略有差异
</code></pre></div>

<p>4.介绍一下你对浏览器内核的理解？</p>
<div class="codehilite"><pre><span></span><code>主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。
渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。

JS引擎则：解析和执行javascript来实现网页的动态效果。

最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。

常见内核
Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]
Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等
Presto内核：Opera7及以上。      [Opera内核原为：Presto，现为：Blink;]
Webkit内核：Safari,Chrome等。   [ Chrome的：Blink（WebKit的分支）]
</code></pre></div>

<p>5、请描述一下 cookies，sessionStorage 和 localStorage 的区别？</p>
<div class="codehilite"><pre><span></span><code>cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。
cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。
sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。

存储大小：
    cookie数据大小不能超过4k。
    sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。

有期时间：
    localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；
    sessionStorage  数据在当前浏览器窗口关闭后自动删除。
    cookie          设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭
</code></pre></div>

<p>6.iframe有那些缺点？</p>
<div class="codehilite"><pre><span></span><code>iframe会阻塞主页面的Onload事件；
搜索引擎的检索程序无法解读这种页面，不利于SEO;
iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。
使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript动态给iframe添加src属性值，这样可以绕开以上两个问题
</code></pre></div>

<p>7.如何实现浏览器内多个标签页之间的通信? (阿里)</p>
<div class="codehilite"><pre><span></span><code>WebSocket、SharedWorker；
也可以调用localstorge、cookies等本地存储方式；

localstorge另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件，
我们通过监听事件，控制它的值来进行页面信息通信；
注意quirks：Safari 在无痕模式下设置localstorge值时会抛出 QuotaExceededError 的异常
</code></pre></div>

<p>8.HTML5的离线储存怎么使用，工作原理能不能解释一下？</p>
<div class="codehilite"><pre><span></span><code>在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。
原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。

如何使用：
1、页面头部像下面一样加入一个manifest的属性；
2、在cache.manifest文件的编写离线存储的资源；
    CACHE MANIFEST
    #v0.11
    CACHE:
    js/app.js
    css/style.css
    NETWORK:
    resourse/logo.png
    FALLBACK:
    / /offline.html
3、在离线状态时，操作window.applicationCache进行需求实现。
</code></pre></div>

<p><strong>十、CSS</strong></p>
<p>1.CSS选择符有哪些？哪些属性可以继承？</p>
<div class="codehilite"><pre><span></span><code>*   1.id选择器（ # myid）
    2.类选择器（.myclassname）
    3.标签选择器（div, h1, p）
    4.相邻选择器（h1 + p）
    5.子选择器（ul &gt; li）
    6.后代选择器（li a）
    7.通配符选择器（ * ）
    8.属性选择器（a[rel = &quot;external&quot;]）
    9.伪类选择器（a:hover, li:nth-child）

*   可继承的样式： font-size font-family color, UL LI DL DD DT;

*   不可继承的样式：border padding margin width height ;
</code></pre></div>

<p>2.CSS优先级算法如何计算？</p>
<div class="codehilite"><pre><span></span><code>*   优先级就近原则，同权重情况下样式定义最近者为准;
*   载入样式以最后载入的定位为准;

优先级为:
    同权重: 内联样式表（标签内部）&gt; 嵌入样式表（当前文件中）&gt; 外部样式表（外部文件中）。
    !important &gt;  id &gt; class &gt; tag
    important 比 内联优先级高
</code></pre></div>

<p>3.CSS3新增伪类有那些？</p>
<div class="codehilite"><pre><span></span><code>  举例：
    p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。
    p:last-of-type  选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。
    p:only-of-type  选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。
    p:only-child        选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。
    p:nth-child(2)  选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。

    :after          在元素之前添加内容,也可以用来做清除浮动。
    :before         在元素之后添加内容
    :enabled        
    :disabled       控制表单控件的禁用状态。
    :checked        单选框或复选框被选中。
</code></pre></div>

<p>4.如何居中div？</p>
<div class="codehilite"><pre><span></span><code>1、水平居中：给div设置一个宽度，然后添加margin:0 auto属性

div{
    width:200px;
    margin:0 auto;
 }

2、水平垂直居中一

确定容器的宽高 宽500 高 300 的层
设置层的外边距

div {
    position: relative;     /* 相对定位或绝对定位均可 */
    width:500px; 
    height:300px;
    top: 50%;
    left: 50%;
    margin: -150px 0 0 -250px;      /* 外边距为自身宽高的一半 */
    background-color: pink;     /* 方便看效果 */

 }

3、水平垂直居中二

未知容器的宽高，利用 `transform` 属性

div {
    position: absolute;     /* 相对定位或绝对定位均可 */
    width:500px; 
    height:300px;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: pink;     /* 方便看效果 */

}

4、水平垂直居中三

利用 flex 布局
实际使用时应考虑兼容性

.container {
    display: flex; 
    align-items: center;        /* 垂直居中 */
    justify-content: center;    /* 水平居中 */

}
.container div {
    width: 100px;
    height: 100px;
    background-color: pink;     /* 方便看效果 */
}
</code></pre></div>

<p>5.CSS3有哪些新特性？</p>
<div class="codehilite"><pre><span></span><code> 新增各种CSS选择器  （: not(.input)：所有 class 不是“input”的节点）
  圆角            （border-radius:8px）
  多列布局      （multi-column layout）
  阴影和反射   （Shadow\Reflect）
  文字特效      （text-shadow、）
  文字渲染      （Text-decoration）
  线性渐变      （gradient）
  旋转            （transform）
  缩放,定位,倾斜,动画,多背景
  例如:transform:\scale(0.85,0.90)\ translate(0px,-30px)\ skew(-9deg,0deg)\Animation:
</code></pre></div>

<p>6.请解释一下CSS3的Flexbox（弹性盒布局模型）,以及适用场景？</p>
<div class="codehilite"><pre><span></span><code> 一个用于页面布局的全新CSS3功能，Flexbox可以把列表放在同一个方向（从上到下排列，从左到右），并让列表能延伸到占用可用的空间。
 较为复杂的布局还可以通过嵌套一个伸缩容器（flex container）来实现。
 采用Flex布局的元素，称为Flex容器（flex container），简称&quot;容器&quot;。
 它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称&quot;项目&quot;。
 常规布局是基于块和内联流方向，而Flex布局是基于flex-flow流可以很方便的用来做局中，能对不同屏幕大小自适应。
 在布局上有了比以前更加灵活的空间。
</code></pre></div>

<p>7.为什么要初始化CSS样式</p>
<div class="codehilite"><pre><span></span><code>- 因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。

- 当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。

最简单的初始化方法： * {padding: 0; margin: 0;} （强烈不建议）

淘宝的样式初始化代码：
body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, dl, dt, dd, ul, ol, li, pre, form, fieldset, legend, button, input, textarea, th, td { margin:0; padding:0; }
body, button, input, select, textarea { font:12px/1.5tahoma, arial, \5b8b\4f53; }
h1, h2, h3, h4, h5, h6{ font-size:100%; }
address, cite, dfn, em, var { font-style:normal; }
code, kbd, pre, samp { font-family:couriernew, courier, monospace; }
small{ font-size:12px; }
ul, ol { list-style:none; }
a { text-decoration:none; }
a:hover { text-decoration:underline; }
sup { vertical-align:text-top; }
sub{ vertical-align:text-bottom; }
legend { color:#000; }
fieldset, img { border:0; }
button, input, select, textarea { font-size:100%; }
table { border-collapse:collapse; border-spacing:0; }
</code></pre></div>

<p><strong>十一、js</strong></p>
<ol>
<li>js的基本数据类型。</li>
</ol>
<div class="codehilite"><pre><span></span><code> Undefined、Null、Boolean、Number、String、
 ECMAScript 2015 新增:Symbol(创建后独一无二且不可变的数据类型 )
</code></pre></div>

<p>2.JavaScript原型，原型链 ? 有什么特点？</p>
<div class="codehilite"><pre><span></span><code>每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时，
如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，
于是就这样一直找下去，也就是我们平时所说的原型链的概念。
关系：instance.constructor.prototype = instance.__proto__

特点：
JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。

 当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性， 如果没有的话，
 就会查找他的Prototype对象是否有这个属性，如此递推下去，一直检索到 Object 内建对象。    function Func(){}
    Func.prototype.name = &quot;Sean&quot;;
    Func.prototype.getInfo = function() {      return this.name;
    }    var person = new Func();//现在可以参考var person = Object.create(oldObject);
    console.log(person.getInfo());//它拥有了Func的属性和方法
    //&quot;Sean&quot;    console.log(Func.prototype);    // Func { name=&quot;Sean&quot;, getInfo=function()}
</code></pre></div>

<p>3.如何实现数组的随机排序？</p>
<div class="codehilite"><pre><span></span><code>方法一： 
​```javascript 

　　var arr = [1,2,3,4,5,6,7,8,9,10]; 
     function randSort1(arr){ 
        for(var i = 0,len = arr.length;i &lt; len; i++ ){ 
            var rand = parseInt(Math.random()*len); 
            var temp = arr[rand]; 
            arr[rand] = arr[i]; 
            arr[i] = temp; 
        }         return arr;
     }
     console.log(randSort1(arr));

​```
方法二：
​```javascript        var arr = [1,2,3,4,5,6,7,8,9,10];        function randSort2(arr){            var mixedArray = [];            while(arr.length &gt; 0){                var randomIndex = parseInt(Math.random()*arr.length);
                mixedArray.push(arr[randomIndex]);
                arr.splice(randomIndex, 1);
            }            return mixedArray;
        }
        console.log(randSort2(arr));

​```
方法三：
​```javascript        var arr = [1,2,3,4,5,6,7,8,9,10];
        arr.sort(function(){            return Math.random() - 0.5;
        })
        console.log(arr);
</code></pre></div>

<p>4.Javascript如何实现继承？</p>
<div class="codehilite"><pre><span></span><code>1、构造继承2、原型继承3、实例继承4、拷贝继承

原型prototype机制或apply和call方法去实现较简单，建议使用构造函数与原型混合方式。
​```javascript        function Parent(){            this.name = &#39;wang&#39;;
        }        function Child(){            this.age = 28;
        }
        Child.prototype = new Parent();//继承了Parent，通过原型

        var demo = new Child();
        alert(demo.age);
        alert(demo.name);//得到被继承的属性
</code></pre></div>

<p>5.javascript创建对象的几种方式？</p>
<div class="codehilite"><pre><span></span><code>javascript创建对象简单的说,无非就是使用内置对象或各种自定义对象，当然还可以用JSON；但写法有很多种，也能混合使用。1、对象字面量的方式

    person={firstname:&quot;Mark&quot;,lastname:&quot;Yun&quot;,age:25,eyecolor:&quot;black&quot;};2、用function来模拟无参的构造函数    function Person(){}    var person=new Person();//定义一个function，如果使用new&quot;实例化&quot;,该function可以看作是一个Class
    person.name=&quot;Mark&quot;;
    person.age=&quot;25&quot;;
    person.work=function(){
    alert(person.name+&quot; hello...&quot;);
    }
    person.work();3、用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性）    function Pet(name,age,hobby){       this.name=name;//this作用域：当前对象
       this.age=age;       this.hobby=hobby;       this.eat=function(){
          alert(&quot;我叫&quot;+this.name+&quot;,我喜欢&quot;+this.hobby+&quot;,是个程序员&quot;);
       }
    }    var maidou =new Pet(&quot;麦兜&quot;,25,&quot;coding&quot;);//实例化、创建对象
    maidou.eat();//调用eat方法4、用工厂方式来创建（内置对象）     var wcDog =new Object();
     wcDog.name=&quot;旺财&quot;;
     wcDog.age=3;
     wcDog.work=function(){
       alert(&quot;我是&quot;+wcDog.name+&quot;,汪汪汪......&quot;);
     }
     wcDog.work();5、用原型方式来创建    function Dog(){

     }
     Dog.prototype.name=&quot;旺财&quot;;
     Dog.prototype.eat=function(){
     alert(this.name+&quot;是个吃货&quot;);
     }     var wangcai =new Dog();
     wangcai.eat();5、用混合方式来创建    function Car(name,price){      this.name=name;      this.price=price; 
    }
     Car.prototype.sell=function(){
       alert(&quot;我是&quot;+this.name+&quot;，我现在卖&quot;+this.price+&quot;万元&quot;);
      }    var camry =new Car(&quot;凯美瑞&quot;,27);
    camry.sell();
</code></pre></div>

<p>6.闭包</p>
<div class="codehilite"><pre><span></span><code>闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域，将函数内部的变量和方法传递到外部。

闭包的特性：1.函数内再嵌套函数2.内部函数可以引用外层的参数和变量3.参数和变量不会被垃圾回收机制回收//li节点的onclick事件都能正确的弹出当前被点击的li索引
 &lt;ul id=&quot;testUL&quot;&gt;
    &lt;li&gt; index = 0&lt;/li&gt;
    &lt;li&gt; index = 1&lt;/li&gt;
    &lt;li&gt; index = 2&lt;/li&gt;
    &lt;li&gt; index = 3&lt;/li&gt;
&lt;/ul&gt;
&lt;script type=&quot;text/javascript&quot;&gt;    var nodes = document.getElementsByTagName(&quot;li&quot;);    for(i = 0;i&lt;nodes.length;i+= 1){
        nodes[i].onclick = (function(i){                  return function() {
                     console.log(i);
                  } //不用闭包的话，值每次都是4                })(i);
    }&lt;/script&gt;执行say667()后,say667()闭包内部变量会存在,而闭包内部函数的内部变量不会存在
使得Javascript的垃圾回收机制GC不会收回say667()所占用的资源
因为say667()的内部函数的执行需要依赖say667()中的变量
这是对闭包作用的非常直白的描述  function say667() {    // Local variable that ends up within closure
    var num = 666;    var sayAlert = function() {
        alert(num);
    }
    num++;    return sayAlert;
} var sayAlert = say667();
 sayAlert()//执行结果应该弹出的667
</code></pre></div>

<p>7.Ajax 是什么? 如何创建一个Ajax？</p>
<div class="codehilite"><pre><span></span><code>ajax的全称：Asynchronous Javascript And XML。
异步传输+js+xml。
所谓异步，在这里简单地解释就是：向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验。

(1)创建XMLHttpRequest对象,也就是创建一个异步调用对象
(2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息
(3)设置响应HTTP请求状态变化的函数
(4)发送HTTP请求
(5)获取异步调用返回的数据
(6)使用JavaScript和DOM实现局部刷新
</code></pre></div>

<p>作者：雷灵初心#### 酷狗（广州）</p>
<p>http://www.kugou.com/hr/html/jobDetail.html?from=1&amp;jobId=390051401</p>
<p>10k </p>
<h4 id="_76">岗位职责：<a class="headerlink" href="#_76" title="Permanent link">&para;</a></h4>
<p>1、酷狗直播web前端页面架构设计； 
2、前后端分离方案的设计与实施； 
3、开发通用功能sdk或者组件； 
4、酷狗直播网站前端性能优化方案设计以及执行； 
5、设计酷狗直播前端开发工程化、自动化方案； 
6、设计与实施酷狗直播web前端组件化开发方案。 </p>
<h4 id="_77">任职要求：<a class="headerlink" href="#_77" title="Permanent link">&para;</a></h4>
<p>1、3年以上web前端开发经验，精通html、javascript、css； 
2、熟悉nodejs开发，有express项目开发经验者优先； 
3、可用原生javascript开发通用sdk； 
4、熟练使用grunt、gulp、webpack、fis3等工程化工具； 
5、较强的学习能力、优秀的团队沟通与协作能力； 
6、具备创新意识,不愿拘泥现状,勇于挑战项目历史遗留问题； 
7、开发过大型海量用户web应用者优先。 </p>
<h4 id="_78">知乎<a class="headerlink" href="#_78" title="Permanent link">&para;</a></h4>
<p>https://app.mokahr.com/apply/zhihu/3819#/jobs/?keyword=%E5%89%8D%E7%AB%AF&amp;_k=hda7ta ## 前端开发面试知识点大纲：</p>
<p>HTML&amp;CSS：  对Web标准的理解、浏览器内核差异、兼容性、hack</p>
<p>CSS基本功：布局、盒子模型、选择器优先级及使用、HTML5、CSS3、移动端适应。</p>
<p>JavaScript：   数据类型、面向对象、继承、闭包、插件、作用域、跨域、原型链、模块化、自定义事件、内存泄漏、事件机制、异步装载回调、模板引擎、Nodejs、JSON、ajax等。</p>
<p>其他：  HTTP、安全、正则、优化、重构、响应式、移动端、团队协作、可维护、SEO、UED、架构、职业生涯 </p>
<h2 id="1cookie">1.Cookie的弊端<a class="headerlink" href="#1cookie" title="Permanent link">&para;</a></h2>
<p>cookie 虽然在持久保存客户端数据提供了方便，分担了服务器存储的负担，但还是有很多局限性的。</p>
<p>第一：每个特定的域名下最多生成20个cookie</p>
<p>1.IE6或更低版本最多20个cookie</p>
<p>2.IE7和之后的版本最后可以有50个cookie。</p>
<p>3.Firefox最多50个cookie</p>
<p>4.chrome和Safari没有做硬性限制</p>
<p><code>IE</code>和<code>Opera</code> 会清理近期最少使用的<code>cookie</code>，<code>Firefox</code>会随机清理<code>cookie</code>。</p>
<p><code>cookie</code>的最大大约为<code>4096</code>字节，为了兼容性，一般不能超过<code>4095</code>字节。</p>
<p>IE 提供了一种存储可以持久化用户数据，叫做<code>uerData</code>，从<code>IE5.0</code>就开始支持。每个数据最多128K，每个域名下最多1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一直存在。</p>
<h4 id="_79">优点：极高的扩展性和可用性<a class="headerlink" href="#_79" title="Permanent link">&para;</a></h4>
<p>1.通过良好的编程，控制保存在cookie中的session对象的大小。</p>
<p>2.通过加密和安全传输技术（SSL），减少cookie被破解的可能性。</p>
<p>3.只在cookie中存放不敏感数据，即使被盗也不会有重大损失。</p>
<p>4.控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。</p>
<h4 id="_80">缺点：<a class="headerlink" href="#_80" title="Permanent link">&para;</a></h4>
<p>1.<code>Cookie</code>数量和长度的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB，否则会被截掉。</p>
<p>2.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目的了。</p>
<p>3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。</p>
<h2 id="2">2.浏览器本地存储<a class="headerlink" href="#2" title="Permanent link">&para;</a></h2>
<p><code>html5</code>中的<code>Web Storage</code>包括了两种存储方式：<code>sessionStorage</code>和<code>localStorage</code>。</p>
<p><code>sessionStorage</code>用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此<code>sessionStorage</code>不是一种持久化的本地存储，仅仅是会话级别的存储。</p>
<p>而<code>localStorage</code>用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。</p>
<h2 id="3web-storagecookie">3.web storage和cookie的区别<a class="headerlink" href="#3web-storagecookie" title="Permanent link">&para;</a></h2>
<p><code>Web Storage</code>的概念和<code>cookie</code>相似，区别是它是为了更大容量存储设计的。<code>Cookie</code>的大小是受限的，并且每次你请求一个新的页面的时候<code>Cookie</code>都会被发送过去，这样无形中浪费了带宽，另外<code>cookie</code>还需要指定作用域，不可以跨域调用。</p>
<p>除此之外，<code>Web Storage</code>拥有<code>setItem,getItem,removeItem,clear</code>等方法，不像<code>cookie</code>需要前端开发者自己封装<code>setCookie，getCookie</code>。</p>
<p>但是<code>Cookie</code>也是不可以或缺的：<code>Cookie</code>的作用是与服务器进行交互，作为<code>HTTP</code>规范的一部分而存在 ，而<code>Web Storage</code>仅仅是为了在本地“存储”数据而生</p>
<p><code>localStorage</code>和<code>sessionStorage</code>都具有相同的操作方法，例如<code>setItem、getItem</code>和<code>removeItem</code>等</p>
<h2 id="css_1">CSS 相关问题<a class="headerlink" href="#css_1" title="Permanent link">&para;</a></h2>
<h3 id="displaynonevisibilityhidden">display:none和visibility:hidden的区别？<a class="headerlink" href="#displaynonevisibilityhidden" title="Permanent link">&para;</a></h3>
<p>display:none  隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在，会造成界面的重新排布和重新绘制（reflow + repaint）。</p>
<p>visibility:hidden  隐藏对应的元素，但是在文档布局中仍保留原来的空间。不会造成界面的重排，所以性能消耗较小（设置鼠标经过的按钮等频繁触发区域优先使用这个实现）。</p>
<h3 id="css-link-import">CSS中 link 和@import 的区别是？<a class="headerlink" href="#css-link-import" title="Permanent link">&para;</a></h3>
<p>(1) link属于HTML标签，而@import是CSS提供的;</p>
<p>(2) 页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;</p>
<p>(3) import只在IE5以上才能识别，而link是HTML标签，无兼容问题; </p>
<p>(4) link方式的样式的权重 高于@import的权重.</p>
<p>==---------==</p>
<h3 id="positionabsolutefixed">position的absolute与fixed共同点与不同点<a class="headerlink" href="#positionabsolutefixed" title="Permanent link">&para;</a></h3>
<p>A：共同点：</p>
<p>1.改变行内元素的呈现方式，display被置为block；</p>
<p>2.让元素脱离普通流，不占据空间；</p>
<p>3.默认会覆盖到非定位元素上</p>
<p>B不同点：</p>
<p>absolute的”根元素“是可以设置的，而fixed的”根元素“固定为浏览器窗口。当你滚动网页，fixed元素与浏览器窗口之间的距离是不变的。  </p>
<h3 id="css_2">介绍一下CSS的盒子模型？<a class="headerlink" href="#css_2" title="Permanent link">&para;</a></h3>
<p>1）有两种， IE 盒子模型、标准 W3C 盒子模型；IE的content部分包含了 border 和 pading;</p>
<p>2）盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border).</p>
<p><img alt="图片描述" src="http://segmentfault.com/img/bVldFY" /></p>
<h3 id="css-css3">CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？<a class="headerlink" href="#css-css3" title="Permanent link">&para;</a></h3>
<p>css</p>
<div class="codehilite"><pre><span></span><code>1.id选择器（ # myid）
2.类选择器（.myclassname）
3.标签选择器（div, h1, p）
4.相邻选择器（h1 + p）
5.子选择器（ul &gt; li）
6.后代选择器（li a）
7.通配符选择器（ * ）
8.属性选择器（a[rel = &quot;external&quot;]）
9.伪类选择器（a: hover, li:nth-child）
</code></pre></div>

<ul>
<li>可继承的样式： font-size font-family color, text-indent;</li>
<li>不可继承的样式：border padding margin width height ;</li>
<li>优先级就近原则，同权重情况下样式定义最近者为准;</li>
<li>载入样式以最后载入的定位为准;</li>
</ul>
<p>优先级为:</p>
<p>!important &gt;  id &gt; class &gt; tag  </p>
<p>important 比 内联优先级高,但内联比 id 要高</p>
<p>CSS3新增伪类举例：</p>
<p>p:first-of-type 选择属于其父元素的首个 <p> 元素的每个 <p> 元素。</p>
<p>p:last-of-type  选择属于其父元素的最后 <p> 元素的每个 <p> 元素。</p>
<p>p:only-of-type  选择属于其父元素唯一的 <p> 元素的每个 <p> 元素。</p>
<p>p:only-child    选择属于其父元素的唯一子元素的每个 <p> 元素。</p>
<p>p:nth-child(2)  选择属于其父元素的第二个子元素的每个 <p> 元素。</p>
<p>:enabled  :disabled 控制表单控件的禁用状态。</p>
<p>:checked        单选框或复选框被选中。</p>
<h3 id="displayposition-relativeabsolute">列出display的值，说明他们的作用。position的值， relative和absolute分别是相对于谁进行定位的？<a class="headerlink" href="#displayposition-relativeabsolute" title="Permanent link">&para;</a></h3>
<p>cpp</p>
<ol>
<li></li>
</ol>
<p>block 象块类型元素一样显示。</p>
<p>inline 缺省值。象行内元素类型一样显示。</p>
<p>inline-block 象行内元素一样显示，但其内容象块类型元素一样显示。</p>
<p>list-item 象块类型元素一样显示，并添加样式列表标记。</p>
<ol>
<li></li>
</ol>
<p>*absolute </p>
<div class="codehilite"><pre><span></span><code>生成绝对定位的元素，相对于 static 定位以外的第一个祖先元素进行定位。 
</code></pre></div>

<p>*fixed （老IE不支持）</p>
<div class="codehilite"><pre><span></span><code>生成绝对定位的元素，相对于浏览器窗口进行定位。 
</code></pre></div>

<p>*relative </p>
<div class="codehilite"><pre><span></span><code>生成相对定位的元素，相对于其在普通流中的位置进行定位。 
</code></pre></div>

<ul>
<li>static  默认值。没有定位，元素出现在正常的流中</li>
</ul>
<p>*（忽略 top, bottom, left, right z-index 声明）。</p>
<ul>
<li>inherit 规定从父元素继承 position 属性的值。</li>
</ul>
<h3 id="css3_1">CSS3有哪些新特性？<a class="headerlink" href="#css3_1" title="Permanent link">&para;</a></h3>
<p>ruby
CSS3实现圆角（border-radius），阴影（box-shadow），</p>
<p>对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform）</p>
<p>transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);//旋转,缩放,定位,倾斜</p>
<p>增加了更多的CSS选择器  多背景 rgba </p>
<p>在CSS3中唯一引入的伪元素是::selection.</p>
<p>媒体查询，多栏布局</p>
<p>border-image</p>
<h3 id="css_3">为什么要初始化CSS样式。<a class="headerlink" href="#css_3" title="Permanent link">&para;</a></h3>
<p>css
    因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。</p>
<p>当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。</p>
<p>_最简单的初始化方法就是： _ {padding: 0; margin: 0;} （不建议）</p>
<p>淘宝的样式初始化： </p>
<p>body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, dl, dt, dd, ul, ol, li, pre, form, fieldset, legend, button, input, textarea, th, td { margin:0; padding:0; }</p>
<p>body, button, input, select, textarea { font:12px/1.5tahoma, arial, \5b8b\4f53; }</p>
<p>h1, h2, h3, h4, h5, h6{ font-size:100%; }</p>
<p>address, cite, dfn, em, var { font-style:normal; }</p>
<p>code, kbd, pre, samp { font-family:couriernew, courier, monospace; }</p>
<p>small{ font-size:12px; }</p>
<p>ul, ol { list-style:none; }</p>
<p>a { text-decoration:none; }</p>
<p>a:hover { text-decoration:underline; }</p>
<p>sup { vertical-align:text-top; }</p>
<p>sub{ vertical-align:text-bottom; }</p>
<p>legend { color:#000; }</p>
<p>fieldset, img { border:0; }</p>
<p>button, input, select, textarea { font-size:100%; }</p>
<p>table { border-collapse:collapse; border-spacing:0; } </p>
<h3 id="bfc_5">对BFC规范的理解？<a class="headerlink" href="#bfc_5" title="Permanent link">&para;</a></h3>
<p>BFC，块级格式化上下文，一个创建了新的BFC的盒子是独立布局的，盒子里面的子元素的样式不会影响到外面的元素。在同一个BFC中的两个毗邻的块级盒在垂直方向（和布局方向有关系）的margin会发生折叠。</p>
<p>（W3C CSS 2.1 规范中的一个概念，它决定了元素如何对其内容进行布局，以及与其他元素的关系和相互作用。）</p>
<h3 id="css-sprites">解释下 CSS sprites，以及你要如何在页面或网站中使用它。<a class="headerlink" href="#css-sprites" title="Permanent link">&para;</a></h3>
<p>CSS Sprites其实就是把网页中一些背景图片整合到一张图片文件中，再利用CSS的“background-image”，“background- repeat”，“background-position”的组合进行背景定位，background-position可以用数字能精确的定位出背景图片的位置。这样可以减少很多图片请求的开销，因为请求耗时比较长；请求虽然可以并发，但是也有限制，一般浏览器都是6个。对于未来而言，就不需要这样做了，因为有了<code>http2</code>。</p>
<h2 id="html">html部分<a class="headerlink" href="#html" title="Permanent link">&para;</a></h2>
<h3 id="_81">说说你对语义化的理解？<a class="headerlink" href="#_81" title="Permanent link">&para;</a></h3>
<p>1，去掉或者丢失样式的时候能够让页面呈现出清晰的结构</p>
<p>2，有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；</p>
<p>3，方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；</p>
<p>4，便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。</p>
<h3 id="doctype">Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?<a class="headerlink" href="#doctype" title="Permanent link">&para;</a></h3>
<p>（1）、\&lt;!DOCTYPE&gt; 声明位于文档中的最前面，处于 <html> 标签之前。告知浏览器以何种模式来渲染文档。 </p>
<p>（2）、严格模式的排版和 JS 运作模式是  以该浏览器支持的最高标准运行。</p>
<p>（3）、在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。</p>
<p>（4）、DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。   </p>
<h3 id="doctype_1">你知道多少种Doctype文档类型？<a class="headerlink" href="#doctype_1" title="Permanent link">&para;</a></h3>
<p>该标签可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的 HTML 文档。</p>
<p>HTML 4.01 规定了三种文档类型：Strict、Transitional 以及 Frameset。</p>
<p>XHTML 1.0 规定了三种 XML 文档类型：Strict、Transitional 以及 Frameset。</p>
<p>Standards （标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页，而 Quirks</p>
<p>（包容）模式（也就是松散呈现模式或者兼容模式）用于呈现为传统浏览器而设计的网页。</p>
<h2 id="htmlxhtml">HTML与XHTML——二者有什么区别<a class="headerlink" href="#htmlxhtml" title="Permanent link">&para;</a></h2>
<p>区别：</p>
<p>1.所有的标记都必须要有一个相应的结束标记</p>
<p>2.所有标签的元素和属性的名字都必须使用小写</p>
<p>3.所有的XML标记都必须合理嵌套</p>
<p>4.所有的属性必须用引号""括起来</p>
<p>5.把所有\&lt;和&amp;特殊符号用编码表示</p>
<p>6.给所有属性赋一个值</p>
<p>7.不要在注释内容中使“--”</p>
<p>8.图片必须有说明文字</p>
<h2 id="_82">常见兼容性问题？<a class="headerlink" href="#_82" title="Permanent link">&para;</a></h2>
<ul>
<li>png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.也可以引用一段脚本处理.</li>
<li>浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一。</li>
<li>IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。 </li>
<li>浮动ie产生的双倍距离（IE6双边距问题：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或margin-right，margin值会加倍。）</li>
</ul>
<p>#box{ float:left; width:10px; margin:0 0 0 100px;} </p>
<p>这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入 ——_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别)</p>
<ul>
<li>渐进识别的方式，从总体中逐渐排除局部。 </li>
</ul>
<p>首先，巧妙的使用“\9”这一标记，将IE游览器从所有情况中分离出来。 </p>
<p>接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。</p>
<p>css</p>
<p>.bb{</p>
<p>background-color:#f1ee18;/<em>所有识别</em>/</p>
<p>.background-color:#00deff\9; /<em>IE6、7、8识别</em>/</p>
<p>+background-color:#a200ff;/<em>IE6、7识别</em>/</p>
<p>_background-color:#1e0bd1;/<em>IE6识别</em>/ </p>
<p>} </p>
<ul>
<li>IE下,可以使用获取常规属性的方法来获取自定义属性,</li>
</ul>
<p>也可以使用getAttribute()获取自定义属性;</p>
<p>Firefox下,只能使用getAttribute()获取自定义属性. </p>
<p>解决方法:统一通过getAttribute()获取自定义属性.</p>
<ul>
<li>IE下,event对象有x,y属性,但是没有pageX,pageY属性; </li>
</ul>
<p>Firefox下,event对象有pageX,pageY属性,但是没有x,y属性.</p>
<ul>
<li>解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。</li>
<li>Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示, </li>
</ul>
<p>可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决.</p>
<ul>
<li>超链接访问过后hover样式就不出现了 被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序:</li>
</ul>
<p>L-V-H-A :  a:link {} a:visited {} a:hover {} a:active {}</p>
<ul>
<li>怪异模式问题：漏写DTD声明，Firefox仍然会按照标准模式来解析网页，但在IE中会触发怪异模式。为避免怪异模式给我们带来不必要的麻烦，最好养成书写DTD声明的好习惯。现在可以使用<a href="http://www.w3.org/TR/html5/single-page.html">html5</a>推荐的写法：<code>&lt;doctype html&gt;</code></li>
<li>上下margin重合问题</li>
</ul>
<p>ie和ff都存在，相邻的两个div的margin-left和margin-right不会重合，但是margin-top和margin-bottom却会发生重合。</p>
<p>解决方法，养成良好的代码编写习惯，同时采用margin-top或者同时采用margin-bottom。</p>
<ul>
<li>ie6对png图片格式支持不好(引用一段脚本处理)</li>
</ul>
<h3 id="_83">解释下浮动和它的工作原理？清除浮动的技巧<a class="headerlink" href="#_83" title="Permanent link">&para;</a></h3>
<p>css
浮动元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。</p>
<p>1.使用空标签清除浮动。</p>
<p>这种方法是在所有浮动标签后面添加一个空标签 定义css clear:both. 弊端就是增加了无意义标签。</p>
<p>2.使用overflow。</p>
<p>给包含浮动元素的父标签添加css属性 overflow:auto; zoom:1; zoom:1用于兼容IE6。</p>
<p>3.使用after伪对象清除浮动。</p>
<p>该方法只适用于非IE浏览器。具体写法可参照以下示例。使用中需注意以下几点。一、该方法中必须为需要清除浮动元素的伪对象中设置 height:0，否则该元素会比实际高出若干像素；</p>
<h3 id="_84">浮动元素引起的问题和解决办法？<a class="headerlink" href="#_84" title="Permanent link">&para;</a></h3>
<p>浮动元素引起的问题：</p>
<p>（1）父元素的高度无法被撑开，影响与父元素同级的元素</p>
<p>（2）与浮动元素同级的非浮动元素会跟随其后</p>
<p>（3）若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构</p>
<p>解决方法：
使用<code>CSS</code>中的<code>clear:both</code>;属性来清除元素的浮动可解决2、3问题，对于问题1，添加如下样式，给父元素添加<code>clearfix</code>样式：</p>
<p>css
.clearfix:after{content: ".";display: block;height: 0;clear: both;visibility: hidden;}</p>
<p>.clearfix{display: inline-block;} /<em> for IE/Mac </em>/</p>
<p>清除浮动的几种方法：</p>
<p>1，额外标签法，<div style="clear:both;"></div>（缺点：不过这个办法会增加额外的标签使HTML结构看起来不够简洁。）</p>
<p>2，使用after伪类</p>
<p>#parent:after{</p>
<p>content:".";</p>
<p>height:0;</p>
<p>visibility:hidden;</p>
<p>display:block;</p>
<p>clear:both;</p>
<p>}</p>
<p>3,浮动外部元素</p>
<p>4,设置<code>overflow</code>为<code>hidden</code>或者auto</p>
<h3 id="ie-8">IE 8以下版本的浏览器中的盒模型有什么不同<a class="headerlink" href="#ie-8" title="Permanent link">&para;</a></h3>
<p>IE8以下浏览器的盒模型中定义的元素的宽高不包括内边距和边框</p>
<h3 id="dom_4">DOM操作——怎样添加、移除、移动、复制、创建和查找节点。<a class="headerlink" href="#dom_4" title="Permanent link">&para;</a></h3>
<p>（1）创建新节点</p>
<p>createDocumentFragment()    //创建一个DOM片段</p>
<p>createElement()   //创建一个具体的元素</p>
<p>createTextNode()   //创建一个文本节点</p>
<p>（2）添加、移除、替换、插入</p>
<p>appendChild()</p>
<p>removeChild()</p>
<p>replaceChild()</p>
<p>insertBefore() //在已有的子节点前插入一个新的子节点</p>
<p>（3）查找</p>
<p>getElementsByTagName()    //通过标签名称</p>
<p>getElementsByName()    //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)</p>
<p>getElementById()    //通过元素Id，唯一性</p>
<h3 id="html5html5-html-html5">html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？<a class="headerlink" href="#html5html5-html-html5" title="Permanent link">&para;</a></h3>
<ul>
<li>HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。</li>
<li>拖拽释放(Drag and drop) API </li>
</ul>
<p>语义化更好的内容标签（header,nav,footer,aside,article,section）</p>
<p>音频、视频API(audio,video)</p>
<p>画布(Canvas) API</p>
<p>地理(Geolocation) API</p>
<p>本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；</p>
<p>sessionStorage 的数据在浏览器关闭后自动删除</p>
<p>表单控件，calendar、date、time、email、url、search  </p>
<p>新的技术webworker, websocket, Geolocation</p>
<ul>
<li>移除的元素</li>
</ul>
<p>纯表现的元素：basefont，big，center，font, s，strike，tt，u；</p>
<p>对可用性产生负面影响的元素：frame，frameset，noframes；</p>
<p>支持HTML5新标签：</p>
<ul>
<li>IE8/IE7/IE6支持通过document.createElement方法产生的标签，</li>
</ul>
<p>可以利用这一特性让这些浏览器支持HTML5新标签，</p>
<p>浏览器支持新标签后，还需要添加标签默认的样式：</p>
<ul>
<li>当然最好的方式是直接使用成熟的框架、使用最多的是html5shim框架</li>
</ul>
<p>如何区分： DOCTYPE声明\新增的结构元素\功能元素</p>
<h2 id="iframe">iframe的优缺点？<a class="headerlink" href="#iframe" title="Permanent link">&para;</a></h2>
<p>1.<iframe>优点：</p>
<p>解决加载缓慢的第三方内容如图标和广告等的加载问题</p>
<p>Security sandbox</p>
<p>并行加载脚本</p>
<p>2.<iframe>的缺点：</p>
<p>*iframe会阻塞主页面的Onload事件；</p>
<p>*即时内容为空，加载也需要时间</p>
<p>*没有语意 </p>
<h2 id="_85">如何实现浏览器内多个标签页之间的通信?<a class="headerlink" href="#_85" title="Permanent link">&para;</a></h2>
<p>调用localstorge、cookies等本地存储方式</p>
<h2 id="websocket">webSocket如何兼容低浏览器？<a class="headerlink" href="#websocket" title="Permanent link">&para;</a></h2>
<p>Adobe Flash Socket 、 ActiveX HTMLFile (IE) 、 基于 multipart 编码发送 XHR 、 基于长轮询的 XHR</p>
<h2 id="_86">线程与进程的区别<a class="headerlink" href="#_86" title="Permanent link">&para;</a></h2>
<p>一个程序至少有一个进程,一个进程至少有一个线程. </p>
<p>线程的划分尺度小于进程，使得多线程程序的并发性高。 </p>
<p>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。 </p>
<p>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 </p>
<p>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</p>
<h2 id="_87">你如何对网站的文件和资源进行优化？<a class="headerlink" href="#_87" title="Permanent link">&para;</a></h2>
<p>期待的解决方案包括：</p>
<p>文件合并</p>
<p>文件最小化/文件压缩</p>
<p>使用 CDN 托管</p>
<p>缓存的使用（多个域名来提供缓存）</p>
<p>其他</p>
<h2 id="_88">请说出三种减少页面加载时间的方法。<a class="headerlink" href="#_88" title="Permanent link">&para;</a></h2>
<p>1.优化图片 </p>
<p>2.图像格式的选择（GIF：提供的颜色较少，可用在一些对颜色要求不高的地方） </p>
<p>3.优化CSS（压缩合并css，如margin-top,margin-left...) </p>
<p>4.网址后加斜杠（如www.campr.com/目录，会判断这个“目录是什么文件类型，或者是目录。） </p>
<p>5.标明高度和宽度（如果浏览器没有找到这两个参数，它需要一边下载图片一边计算大小，如果图片很多，浏览器需要不断地调整页面。这不但影响速度，也影响浏览体验。 </p>
<p>当浏览器知道了高度和宽度参数后，即使图片暂时无法显示，页面上也会腾出图片的空位，然后继续加载后面的内容。从而加载时间快了，浏览体验也更好了。） </p>
<p>6.减少http请求（合并文件，合并图片）。</p>
<h2 id="_89">你都使用哪些工具来测试代码的性能？<a class="headerlink" href="#_89" title="Permanent link">&para;</a></h2>
<p>Profiler, JSPerf（<a href="http://jsperf.com/nexttick-vs-setzerotimeout-vs-settimeout）">http://jsperf.com/nexttick-vs-setzerotimeout-vs-settimeout）</a>, Dromaeo</p>
<h2 id="fouc-fouc">什么是 FOUC（无样式内容闪烁）？你如何来避免 FOUC？<a class="headerlink" href="#fouc-fouc" title="Permanent link">&para;</a></h2>
<p>FOUC - Flash Of Unstyled Content 文档样式闪烁</p>
<p>而引用CSS文件的@import就是造成这个问题的罪魁祸首。IE会先加载整个HTML文档的DOM，然后再去导入外部的CSS文件，因此，在页面DOM加载完成到CSS导入完成中间会有一段时间页面上的内容是没有样式的，这段时间的长短跟网速，电脑速度都有关系。</p>
<p>解决方法简单的出奇，只要在<head>之间加入一个<link>或者<script>元素就可以了。</p>
<h2 id="nullundefined_1">null和undefined的区别？<a class="headerlink" href="#nullundefined_1" title="Permanent link">&para;</a></h2>
<p><code>null</code>是一个表示"无"的对象，转为数值时为0；<code>undefined</code>是一个表示"无"的原始值，转为数值时为<code>NaN</code>。</p>
<p>当声明的变量还未被初始化时，变量的默认值为<code>undefined</code>。
<code>null</code>用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。</p>
<p><code>undefined</code>表示"缺少值"，就是此处应该有一个值，但是还没有定义。典型用法是：</p>
<p>（1）变量被声明了，但没有赋值时，就等于undefined。</p>
<p>（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。</p>
<p>（3）对象没有赋值的属性，该属性的值为undefined。</p>
<p>（4）函数没有返回值时，默认返回undefined。</p>
<p><code>null</code>表示"没有对象"，即该处不应该有值。典型用法是：</p>
<p>（1） 作为函数的参数，表示该函数的参数不是对象。</p>
<p>（2） 作为对象原型链的终点。</p>
<h2 id="new">new操作符具体干了什么呢?<a class="headerlink" href="#new" title="Permanent link">&para;</a></h2>
<p>1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。</p>
<p>2、属性和方法被加入到 this 引用的对象中。</p>
<p>3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。</p>
<p>var obj  = {};</p>
<p>obj.<strong>proto</strong> = Base.prototype;</p>
<p>Base.call(obj); </p>
<h2 id="json">JSON 的了解？<a class="headerlink" href="#json" title="Permanent link">&para;</a></h2>
<p>javascript
JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。</p>
<p>它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小</p>
<p>{'age':'12', 'name':'back'}</p>
<h2 id="js">js延迟加载的方式有哪些？<a class="headerlink" href="#js" title="Permanent link">&para;</a></h2>
<p>defer和async、动态创建DOM方式（创建script，插入到DOM中，加载完毕后callBack）、按需异步载入js</p>
<h2 id="_90">如何解决跨域问题?<a class="headerlink" href="#_90" title="Permanent link">&para;</a></h2>
<p>jsonp、 document.domain+iframe、window.name、window.postMessage、服务器上设置代理页面</p>
<p>jsonp的原理是动态插入script标签</p>
<p>具体参见：<a href="http://segmentfault.com/blog/trigkit4/1190000000718840">详解js跨域问题</a></p>
<h2 id="documenwrite-innerhtml">documen.write和 innerHTML的区别<a class="headerlink" href="#documenwrite-innerhtml" title="Permanent link">&para;</a></h2>
<p>document.write只能重绘整个页面</p>
<p>innerHTML可以重绘页面的一部分</p>
<h2 id="call-apply">.call() 和 .apply() 的区别和作用？<a class="headerlink" href="#call-apply" title="Permanent link">&para;</a></h2>
<p>作用：动态改变某个类的某个方法的运行环境。
区别参见：<a href="http://segmentfault.com/blog/trigkit4/1190000000660786#articleHeader15">JavaScript学习总结（四）function函数部分</a></p>
<h2 id="_91">哪些操作会造成内存泄漏？<a class="headerlink" href="#_91" title="Permanent link">&para;</a></h2>
<p>内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。</p>
<p>垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。</p>
<p>setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。</p>
<p>闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）</p>
<p>详见：<a href="http://segmentfault.com/blog/trigkit4/1190000000687844">详解js变量、作用域及内存</a></p>
<h2 id="javascript">JavaScript中的作用域与变量声明提升？<a class="headerlink" href="#javascript" title="Permanent link">&para;</a></h2>
<p>详见：<a href="http://segmentfault.com/blog/trigkit4/1190000000758184#articleHeader5">详解JavaScript函数模式</a></p>
<h2 id="node">如何判断当前脚本运行在浏览器还是node环境中？<a class="headerlink" href="#node" title="Permanent link">&para;</a></h2>
<p>通过判断Global对象是否为window，如果不为window，当前脚本没有运行在浏览器中</p>
<h2 id="_92">其他问题？<a class="headerlink" href="#_92" title="Permanent link">&para;</a></h2>
<h3 id="_93">你遇到过比较难的技术问题是？你是如何解决的？<a class="headerlink" href="#_93" title="Permanent link">&para;</a></h3>
<h3 id="_94">常使用的库有哪些？常用的前端开发工具？开发过什么应用或组件？<a class="headerlink" href="#_94" title="Permanent link">&para;</a></h3>
<h3 id="ie">列举IE 与其他浏览器不一样的特性？<a class="headerlink" href="#ie" title="Permanent link">&para;</a></h3>
<h3 id="99">99%的网站都需要被重构是那本书上写的？<a class="headerlink" href="#99" title="Permanent link">&para;</a></h3>
<ul>
<li>网站重构：应用web标准进行设计（第2版）</li>
</ul>
<h3 id="_95">什么叫优雅降级和渐进增强？<a class="headerlink" href="#_95" title="Permanent link">&para;</a></h3>
<p>优雅降级：Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。由于IE独特的盒模型布局问题，针对不同版本的IE的hack实践过优雅降级了,为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效.</p>
<p>渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能,向页面增加无害于基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。</p>
<p>详见：<a href="http://segmentfault.com/blog/trigkit4/1190000000800711#articleHeader30">css学习归纳总结（一）</a></p>
<h3 id="webdata">WEB应用从服务器主动推送Data到客户端有那些方式？<a class="headerlink" href="#webdata" title="Permanent link">&para;</a></h3>
<h3 id="node_1">对Node的优点和缺点提出了自己的看法？<a class="headerlink" href="#node_1" title="Permanent link">&para;</a></h3>
<p>*（优点）因为Node是基于事件驱动和无阻塞的，所以非常适合处理并发请求，</p>
<p>因此构建在Node上的代理服务器相比其他技术实现（如Ruby）的服务器表现要好得多。</p>
<p>此外，与Node代理服务器交互的客户端代码是由javascript语言编写的，</p>
<p>因此客户端和服务器端都用同一种语言编写，这是非常美妙的事情。</p>
<p>*（缺点）Node是一个相对新的开源项目，所以不太稳定，它总是一直在变，</p>
<p>而且缺少足够多的第三方库支持。看起来，就像是Ruby/Rails当年的样子。</p>
<h3 id="_96">除了前端以外还了解什么其它技术么？你最最厉害的技能是什么？<a class="headerlink" href="#_96" title="Permanent link">&para;</a></h3>
<h3 id="_97">你常用的开发工具是什么，为什么？<a class="headerlink" href="#_97" title="Permanent link">&para;</a></h3>
<h3 id="_98">对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？<a class="headerlink" href="#_98" title="Permanent link">&para;</a></h3>
<p>前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近。</p>
<p>1、实现界面交互</p>
<p>2、提升用户体验</p>
<p>3、有了Node.js，前端可以实现服务端的一些事情</p>
<p>前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好，</p>
<p>参与项目，快速高质量完成实现效果图，精确到1px；</p>
<p>与团队成员，UI设计，产品经理的沟通；</p>
<p>做好的页面结构，页面重构和用户体验；</p>
<p>处理hack，兼容、写出优美的代码格式；</p>
<p>针对服务器的优化、拥抱最新前端技术。</p>
<h3 id="_99">你在现在的团队处于什么样的角色，起到了什么明显的作用？<a class="headerlink" href="#_99" title="Permanent link">&para;</a></h3>
<h3 id="full-stack-developer">你认为怎样才是全端工程师（Full Stack developer）？<a class="headerlink" href="#full-stack-developer" title="Permanent link">&para;</a></h3>
<h3 id="_100">介绍一个你最得意的作品吧？<a class="headerlink" href="#_100" title="Permanent link">&para;</a></h3>
<h3 id="_101">项目中遇到什么问题？如何解决？<a class="headerlink" href="#_101" title="Permanent link">&para;</a></h3>
<h3 id="_102">你的优点是什么？缺点是什么？<a class="headerlink" href="#_102" title="Permanent link">&para;</a></h3>
<h3 id="_103">如何管理前端团队?<a class="headerlink" href="#_103" title="Permanent link">&para;</a></h3>
<h3 id="35">最近在学什么？能谈谈你未来3，5年给自己的规划吗？<a class="headerlink" href="#35" title="Permanent link">&para;</a></h3>
<h2 id="_104">你有哪些性能优化的方法？<a class="headerlink" href="#_104" title="Permanent link">&para;</a></h2>
<p>（<a href="http://segmentfault.com/blog/trigkit4/1190000000656717">详情请看雅虎14条性能优化原则</a>）。</p>
<p>（1） 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。</p>
<p>（2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数</p>
<p>（3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。</p>
<p>（4） 当需要设置的样式很多时设置className而不是直接操作style。</p>
<p>（5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。</p>
<p>（6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。</p>
<p>（7） 图片预加载，将样式表放在顶部，将脚本放在底部  加上时间戳。</p>
<h2 id="http">http状态码有那些？分别代表是什么意思？<a class="headerlink" href="#http" title="Permanent link">&para;</a></h2>
<p>100-199 用于指定客户端应相应的某些动作。 </p>
<p>200-299 用于表示请求成功。 </p>
<p>300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。 </p>
<p>400-499 用于指出客户端的错误。400    1、语义有误，当前请求无法被服务器理解。401   当前请求需要用户验证 403  服务器已经理解请求，但是拒绝执行它。</p>
<p>500-599 用于支持服务器错误。 503 – 服务不可用</p>
<p>详情：<a href="http://segmentfault.com/blog/trigkit4/1190000000691919">http://segmentfault.com/blog/trigkit4/1190000000691919</a></p>
<h2 id="url">一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？<a class="headerlink" href="#url" title="Permanent link">&para;</a></h2>
<p>分为4个步骤：</p>
<p>（1），当发送一个URL请求时，不管这个URL是Web页面的URL还是Web页面上每个资源的URL，浏览器都会开启一个线程来处理这个请求，同时在远程DNS服务器上启动一个DNS查询。这能使浏览器获得请求对应的IP地址。</p>
<p>（2）， 浏览器与远程Web服务器通过TCP三次握手协商来建立一个TCP/IP连接。该握手包括一个同步报文，一个同步-应答报文和一个应答报文，这三个报文在 浏览器和服务器之间传递。该握手首先由客户端尝试建立起通信，而后服务器应答并接受客户端的请求，最后由客户端发出该请求已经被接受的报文。</p>
<p>（3），一旦TCP/IP连接建立，浏览器会通过该连接向远程服务器发送HTTP的GET请求。远程服务器找到资源并使用HTTP响应返回该资源，值为200的HTTP响应状态表示一个正确的响应。</p>
<p>（4），此时，Web服务器提供资源服务，客户端开始下载资源。</p>
<p>请求返回后，便进入了我们关注的前端模块</p>
<p>简单来说，浏览器会解析HTML生成DOM Tree，其次会根据CSS生成CSS Rule Tree，而javascript又可以根据DOM API操作DOM</p>
<p>详情：<a href="http://segmentfault.com/blog/trigkit4/1190000000697254">从输入 URL 到浏览器接收的过程中发生了什么事情？</a></p>
<h2 id="_105">平时如何管理你的项目？<a class="headerlink" href="#_105" title="Permanent link">&para;</a></h2>
<p>先期团队必须确定好全局样式（globe.css），编码模式(utf-8) 等；</p>
<div class="codehilite"><pre><span></span><code>编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）；
标注样式编写人，各模块都及时标注（标注关键样式调用的地方）；
页面进行标注（例如 页面 模块 开始和结束）；
CSS跟HTML 分文件夹并行存放，命名都得统一（例如style.css）；
JS 分文件夹存放 命名以该JS功能为准的英文翻译。
图片采用整合的 images.png png8 格式文件使用 尽量整合在一起使用方便将来的管理 
</code></pre></div>

<h2 id="_106">说说最近最流行的一些东西吧？常去哪些网站？<a class="headerlink" href="#_106" title="Permanent link">&para;</a></h2>
<p>Node.js、Mongodb、npm、MVVM、MEAN、three.js,React 。</p>
<p>网站：w3cfuns,sf,hacknews,CSDN,慕课，博客园，InfoQ,w3cplus等</p>
<h2 id="javascript_1">javascript对象的几种创建方式<a class="headerlink" href="#javascript_1" title="Permanent link">&para;</a></h2>
<p>1，工厂模式</p>
<p>2，构造函数模式</p>
<p>3，原型模式</p>
<p>4，混合构造函数和原型模式</p>
<p>5，动态原型模式</p>
<p>6，寄生构造函数模式</p>
<p>7，稳妥构造函数模式</p>
<h2 id="javascript6">javascript继承的6种方法<a class="headerlink" href="#javascript6" title="Permanent link">&para;</a></h2>
<p>1，原型链继承</p>
<p>2，借用构造函数继承</p>
<p>3，组合继承(原型+借用构造)</p>
<p>4，原型式继承</p>
<p>5，寄生式继承</p>
<p>6，寄生组合式继承</p>
<p>详情：<a href="http://segmentfault.com/blog/trigkit4/1190000002440502">JavaScript继承方式详解</a></p>
<h2 id="ajax">ajax过程<a class="headerlink" href="#ajax" title="Permanent link">&para;</a></h2>
<p>(1)创建XMLHttpRequest对象,也就是创建一个异步调用对象.</p>
<p>(2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息.</p>
<p>(3)设置响应HTTP请求状态变化的函数.</p>
<p>(4)发送HTTP请求.</p>
<p>(5)获取异步调用返回的数据.</p>
<p>(6)使用JavaScript和DOM实现局部刷新.</p>
<p>详情：<a href="http://segmentfault.com/blog/trigkit4/1190000000691919">JavaScript学习总结（七）Ajax和Http状态字</a></p>
<h2 id="_107">异步加载和延迟加载<a class="headerlink" href="#_107" title="Permanent link">&para;</a></h2>
<p>1.异步加载的方案： 动态插入script标签</p>
<p>2.通过ajax去获取js代码，然后通过eval执行</p>
<p>3.script标签上添加defer或者async属性</p>
<p>4.创建并插入iframe，让它异步执行js</p>
<p>5.延迟加载：有些 js 代码并不是页面初始化的时候就立刻需要的，而稍后的某些情况才需要的。</p>
<h2 id="_108">前端安全问题？<a class="headerlink" href="#_108" title="Permanent link">&para;</a></h2>
<p>（XSS，sql注入，CSRF）</p>
<p>CSRF：是跨站请求伪造，很明显根据刚刚的解释，他的核心也就是请求伪造，通过伪造身份提交POST和GET请求来进行跨域的攻击。</p>
<p><strong>完成CSRF需要两个步骤：</strong></p>
<p>1.登陆受信任的网站A，在本地生成COOKIE</p>
<p>2.在不登出A的情况下，或者本地COOKIE没有过期的情况下，访问危险网站B。</p>
<h2 id="iechrome">ie各版本和chrome可以并行下载多少个资源<a class="headerlink" href="#iechrome" title="Permanent link">&para;</a></h2>
<p>IE6 两个并发，iE7升级之后的6个并发，之后版本也是6个</p>
<p>Firefox，chrome也是6个</p>
<h2 id="javascript_2">javascript里面的继承怎么实现，如何避免原型链上面的对象共享<a class="headerlink" href="#javascript_2" title="Permanent link">&para;</a></h2>
<p>用构造函数和原型链的混合模式去实现继承，避免对象共享可以参考经典的extend()函数，很多前端框架都有封装的，就是用一个空函数当做中间变量</p>
<h2 id="grunt-yui-compressor-google-clojure">grunt， YUI compressor 和 google clojure用来进行代码压缩的用法。<a class="headerlink" href="#grunt-yui-compressor-google-clojure" title="Permanent link">&para;</a></h2>
<p>YUI Compressor 是一个用来压缩 JS 和 CSS 文件的工具，采用Java开发。</p>
<p>使用方法：</p>
<p>//压缩JS</p>
<p>java -jar yuicompressor-2.4.2.jar --type js --charset utf-8 -v src.js &gt; packed.js</p>
<p>//压缩CSS</p>
<p>java -jar yuicompressor-2.4.2.jar --type css --charset utf-8 -v src.css &gt; packed.css</p>
<p>详情请见：<a href="http://segmentfault.com/blog/trigkit4/1190000002585760">你需要掌握的前端代码性能优化工具</a></p>
<h2 id="flashajax">Flash、Ajax各自的优缺点，在使用中如何取舍？<a class="headerlink" href="#flashajax" title="Permanent link">&para;</a></h2>
<p>1、Flash ajax对比</p>
<p>Flash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜索。</p>
<p>Ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。</p>
<p>共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM</p>
<h2 id="javascript_3">请解释一下 JavaScript 的同源策略。<a class="headerlink" href="#javascript_3" title="Permanent link">&para;</a></h2>
<p>概念:同源策略是客户端脚本（尤其是<code>Javascript</code>）的重要的安全度量标准。它最早出自<code>Netscape Navigator2.0</code>，其目的是防止某个文档或脚本从多个不同源装载。</p>
<p>这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。
指一段脚本只能读取来自同一来源的窗口和文档的属性。</p>
<h3 id="_109">为什么要有同源限制？<a class="headerlink" href="#_109" title="Permanent link">&para;</a></h3>
<p>我们举例说明：比如一个黑客程序，他利用<code>Iframe</code>把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过<code>Javascript</code>读取到你的表单中<code>input</code>中的内容，这样用户名，密码就轻松到手了。</p>
<h2 id="use-strict">什么是 "use strict"; ? 使用它的好处和坏处分别是什么？<a class="headerlink" href="#use-strict" title="Permanent link">&para;</a></h2>
<p><code>ECMAscript 5</code>添加了第二种运行模式："严格模式"（strict mode）。顾名思义，这种模式使得<code>Javascript</code>在更严格的条件下运行。</p>
<p>设立"严格模式"的目的，主要有以下几个：</p>
<ul>
<li>消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;</li>
<li>消除代码运行的一些不安全之处，保证代码运行的安全；</li>
<li>提高编译器效率，增加运行速度；</li>
<li>为未来新版本的Javascript做好铺垫。</li>
</ul>
<p>注：经过测试<code>IE6,7,8,9</code>均不支持严格模式。</p>
<p>缺点：
现在网站的<code>JS</code> 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严格模式的文件，被 <code>merge</code> 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在压缩后浪费了字节。</p>
<h2 id="getpostpost">GET和POST的区别，何时使用POST？<a class="headerlink" href="#getpostpost" title="Permanent link">&para;</a></h2>
<p>GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符</p>
<p>POST：一般用于修改服务器上的资源，对所发送的信息没有限制。</p>
<p>GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值，</p>
<p>也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。</p>
<p>然而，在以下情况中，请使用 POST 请求：</p>
<p>无法使用缓存文件（更新服务器上的文件或数据库）</p>
<p>向服务器发送大量数据（POST 没有数据量限制）</p>
<p>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</p>
<h2 id="cssjs">哪些地方会出现css阻塞，哪些地方会出现js阻塞？<a class="headerlink" href="#cssjs" title="Permanent link">&para;</a></h2>
<p>js的阻塞特性：所有浏览器在下载<code>JS</code>的时候，会阻止一切其他活动，比如其他资源的下载，内容的呈现等等。直到<code>JS</code>下载、解析、执行完毕后才开始继续<code>并行下载</code>其他资源并呈现内容。为了提高用户体验，新一代浏览器都支持并行下载<code>JS</code>，但是<code>JS</code>下载仍然会阻塞其它资源的下载（例如.图片，css文件等）。</p>
<p>由于浏览器为了防止出现<code>JS</code>修改<code>DOM</code>树，需要重新构建<code>DOM</code>树的情况，所以就会阻塞其他的下载和呈现。</p>
<p>嵌入<code>JS</code>会阻塞所有内容的呈现，而外部<code>JS</code>只会阻塞其后内容的显示，2种方式都会阻塞其后资源的下载。也就是说外部样式不会阻塞外部脚本的加载，但会阻塞外部脚本的执行。</p>
<p><code>CSS</code>怎么会阻塞加载了？<code>CSS</code>本来是可以并行下载的，在什么情况下会出现阻塞加载了(在测试观察中，<code>IE6</code>下<code>CSS</code>都是阻塞加载）</p>
<p>当<code>CSS</code>后面跟着嵌入的<code>JS</code>的时候，该<code>CSS</code>就会出现阻塞后面资源下载的情况。而当把嵌入<code>JS</code>放到<code>CSS</code>前面，就不会出现阻塞的情况了。</p>
<p>根本原因：因为浏览器会维持<code>html</code>中<code>css</code>和<code>js</code>的顺序，样式表必须在嵌入的JS执行前先加载、解析完。而嵌入的<code>JS</code>会阻塞后面的资源加载，所以就会出现上面<code>CSS</code>阻塞下载的情况。</p>
<p>嵌入<code>JS</code>应该放在什么位置？</p>
<p>1、放在底部，虽然放在底部照样会阻塞所有呈现，但不会阻塞资源下载。</p>
<p>2、如果嵌入JS放在head中，请把嵌入JS放在CSS头部。</p>
<p>3、使用defer（只支持IE）</p>
<p>4、不要在嵌入的JS中调用运行时间较长的函数，如果一定要用，可以用<code>setTimeout</code>来调用</p>
<h3 id="javascript_4">Javascript无阻塞加载具体方式<a class="headerlink" href="#javascript_4" title="Permanent link">&para;</a></h3>
<ul>
<li>将脚本放在底部。<code>还是放在`head`中，用以保证在`js`加载前，能加载出正常显示的页面。</code>标签放在前。</li>
<li>成组脚本：由于每个<code>标签下载时阻塞页面解析过程，所以限制页面的</code>总数也可以改善性能。适用于内联脚本和外部脚本。</li>
<li>非阻塞脚本：等页面完成加载后，再加载<code>js</code>代码。也就是，在<code>window.onload</code>事件发出后开始下载代码。
  （1）<code>defer</code>属性：支持IE4和<code>fierfox3.5</code>更高版本浏览器
  （2）动态脚本元素：文档对象模型（DOM）允许你使用js动态创建<code>HTML</code>的几乎全部文档内容。代码如下：</li>
</ul>
<p>此技术的重点在于：无论在何处启动下载，文件额下载和运行都不会阻塞其他页面处理过程。即使在head里（除了用于下载文件的http链接）。</p>
<h2 id="_110">闭包相关问题？<a class="headerlink" href="#_110" title="Permanent link">&para;</a></h2>
<p>详情请见：<a href="http://segmentfault.com/blog/trigkit4/1190000000652891">详解js闭包</a></p>
<h2 id="js_1">js事件处理程序问题？<a class="headerlink" href="#js_1" title="Permanent link">&para;</a></h2>
<p>详情请见：<a href="http://segmentfault.com/blog/trigkit4/1190000002174034">JavaScript学习总结（九）事件详解</a></p>
<h2 id="eval">eval是做什么的？<a class="headerlink" href="#eval" title="Permanent link">&para;</a></h2>
<p>javascript
它的功能是把对应的字符串解析成JS代码并运行；</p>
<p>应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。</p>
<h2 id="_111">写一个通用的事件侦听器函数?<a class="headerlink" href="#_111" title="Permanent link">&para;</a></h2>
<p>javascript
// event(事件)工具集，来源：github.com/markyun</p>
<p>markyun.Event = {</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 页面加载完成后</span>
<span class="nx">readyEvent</span> <span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">fn</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">fn</span><span class="o">==</span><span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">fn</span><span class="o">=</span><span class="nb">document</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kd">var</span> <span class="nx">oldonload</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nx">onload</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nb">window</span><span class="p">.</span><span class="nx">onload</span> <span class="o">!=</span> <span class="s1">&#39;function&#39;</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">window</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="nx">fn</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nb">window</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
            <span class="nx">oldonload</span><span class="p">();</span>
            <span class="nx">fn</span><span class="p">();</span>
        <span class="p">};</span>
    <span class="p">}</span>
<span class="p">},</span>
<span class="c1">// 视能力分别使用dom0||dom2||IE方式 来绑定事件</span>
<span class="c1">// 参数： 操作的元素,事件名称 ,事件处理程序</span>
<span class="nx">addEvent</span> <span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">element</span><span class="p">,</span> <span class="nx">type</span><span class="p">,</span> <span class="nx">handler</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">element</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">//事件类型、需要执行的函数、是否捕捉</span>
        <span class="nx">element</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="nx">type</span><span class="p">,</span> <span class="nx">handler</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">element</span><span class="p">.</span><span class="nx">attachEvent</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">element</span><span class="p">.</span><span class="nx">attachEvent</span><span class="p">(</span><span class="s1">&#39;on&#39;</span> <span class="o">+</span> <span class="nx">type</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
            <span class="nx">handler</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">element</span><span class="p">);</span>
        <span class="p">});</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">element</span><span class="p">[</span><span class="s1">&#39;on&#39;</span> <span class="o">+</span> <span class="nx">type</span><span class="p">]</span> <span class="o">=</span> <span class="nx">handler</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">},</span>
<span class="c1">// 移除事件</span>
<span class="nx">removeEvent</span> <span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">element</span><span class="p">,</span> <span class="nx">type</span><span class="p">,</span> <span class="nx">handler</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">element</span><span class="p">.</span><span class="nx">removeEnentListener</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">element</span><span class="p">.</span><span class="nx">removeEnentListener</span><span class="p">(</span><span class="nx">type</span><span class="p">,</span> <span class="nx">handler</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">element</span><span class="p">.</span><span class="nx">datachEvent</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">element</span><span class="p">.</span><span class="nx">detachEvent</span><span class="p">(</span><span class="s1">&#39;on&#39;</span> <span class="o">+</span> <span class="nx">type</span><span class="p">,</span> <span class="nx">handler</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">element</span><span class="p">[</span><span class="s1">&#39;on&#39;</span> <span class="o">+</span> <span class="nx">type</span><span class="p">]</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">},</span> 
<span class="c1">// 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获)</span>
<span class="nx">stopPropagation</span> <span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">ev</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">ev</span><span class="p">.</span><span class="nx">stopPropagation</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">ev</span><span class="p">.</span><span class="nx">stopPropagation</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">ev</span><span class="p">.</span><span class="nx">cancelBubble</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">},</span>
<span class="c1">// 取消事件的默认行为</span>
<span class="nx">preventDefault</span> <span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">preventDefault</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">event</span><span class="p">.</span><span class="nx">preventDefault</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">event</span><span class="p">.</span><span class="nx">returnValue</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">},</span>
<span class="c1">// 获取事件目标</span>
<span class="nx">getTarget</span> <span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">event</span><span class="p">.</span><span class="nx">target</span> <span class="o">||</span> <span class="nx">event</span><span class="p">.</span><span class="nx">srcElement</span><span class="p">;</span>
<span class="p">},</span>
<span class="c1">// 获取event对象的引用，取到事件的所有信息，确保随时能使用event；</span>
<span class="nx">getEvent</span> <span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">ev</span> <span class="o">=</span> <span class="nx">e</span> <span class="o">||</span> <span class="nb">window</span><span class="p">.</span><span class="nx">event</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">ev</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">getEvent</span><span class="p">.</span><span class="nx">caller</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">ev</span> <span class="o">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">arguments</span><span class="p">[</span><span class="mf">0</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">ev</span> <span class="o">&amp;&amp;</span> <span class="nx">Event</span> <span class="o">==</span> <span class="nx">ev</span><span class="p">.</span><span class="nx">constructor</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="nx">c</span> <span class="o">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">caller</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">ev</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>}; </p>
<h2 id="nodejs">Node.js的适用场景？<a class="headerlink" href="#nodejs" title="Permanent link">&para;</a></h2>
<p>高并发、聊天、实时消息推送   </p>
<h2 id="javascript_5">JavaScript原型，原型链 ? 有什么特点？<a class="headerlink" href="#javascript_5" title="Permanent link">&para;</a></h2>
<ul>
<li>原型对象也是普通的对象，是对象一个自带隐式的 <strong>proto</strong> 属性，原型也有可能有自己的原型，如果一个原型对象的原型不为null的话，我们就称之为原型链。</li>
<li>原型链是由一些用来继承和共享属性的对象组成的（有限的）对象链。</li>
</ul>
<h2 id="_112">页面重构怎么操作？<a class="headerlink" href="#_112" title="Permanent link">&para;</a></h2>
<p>编写 CSS、让页面结构更合理化，提升用户体验，实现良好的页面效果和提升性能。</p>
<h2 id="webdata_1">WEB应用从服务器主动推送Data到客户端有那些方式？<a class="headerlink" href="#webdata_1" title="Permanent link">&para;</a></h2>
<p>html5 websoket</p>
<p>WebSocket通过Flash</p>
<p>XHR长时间连接</p>
<p>XHR Multipart Streaming</p>
<p>不可见的Iframe</p>
<h1 id="_113">前端日常开发必背知识点<a class="headerlink" href="#_113" title="Permanent link">&para;</a></h1>
<hr />
<h3 id="1">1.基本类型和引用类型<a class="headerlink" href="#1" title="Permanent link">&para;</a></h3>
<p>基本类型：<code>Number, String, Null, Undefined, Boolean, Symbol(ES6数据类型)</code>
引用类型：<code>Object、Array、RegExp、Date、Function、单体内置对象(Global、Math)</code>
区别：基本类型，操作和保存在变量的实际的值（保存在栈区）；引用类型，值指向内存空间的引用，就是地址，所指向的内存中保存着变量所表示的一个值或一组值，所以操作的是对象的引用（引用存放在栈区，实际对象保存在堆区）。</p>
<h4 id="11">1.1 类型检测<a class="headerlink" href="#11" title="Permanent link">&para;</a></h4>
<p>使用 <code>typeof</code>进行基本类型检测，使用<code>instanceof</code>检测对象还是数组
| 类型                        | 结果        |
| --------------------------- | ----------- |
| Undefined                   | "undefined" |
| Null                        | "object"    |
| Boolean                     | "boolean"   |
| Number                      | "number"    |
| String                      | "string"    |
| Symbol（ECMAScript 6 新增） | "symbol"    |
| 函数对象                    | "function"  |
| 任何其他对象                | "object"    |</p>
<div class="codehilite"><pre><span></span><code>检测数组和对象：（Array其实是Object 的子类）
var a = [];
console.log(a instanceof Array); // true
console.log(a instanceof Object); // true
var a = {};
console.log(a instanceof Array); // false
console.log(a instanceof Object); // true
</code></pre></div>

<hr />
<h4 id="12-string">1.2 String操作<a class="headerlink" href="#12-string" title="Permanent link">&para;</a></h4>
<div class="codehilite"><pre><span></span><code>String &lt;=&gt; Number:
</code></pre></div>

<div class="codehilite"><pre><span></span><code>字符串转数字：
parseInt(str, 进制) // 默认十进制, 转化为整数，小数点后默认不保留
parseFloat(str) // 转化为浮点数
+str // 屌屌的转化方法, 但字符串包含非数字会报错
数字转字符串：
let str1 = num.toString();
let str2 = String(num);
let str3 = num +  &#39;&#39;;
String &lt;=&gt; Array:
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="err">字符串转数组</span>
<span class="k">let</span> <span class="n">arr</span> <span class="p">=</span> <span class="n">str</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="sc">&#39;,&#39;</span><span class="p">)</span> <span class="c1">// 一般是空格或者逗号</span>
<span class="err">数组转字符串</span>
<span class="k">let</span> <span class="n">str</span> <span class="p">=</span> <span class="n">arr</span><span class="p">.</span><span class="k">join</span><span class="p">(</span><span class="err">&#39;&#39;</span><span class="p">);</span>
</code></pre></div>

<p>模板字符串</p>
<div class="codehilite"><pre><span></span><code>`Hello, ${变量}`
</code></pre></div>

<hr />
<h4 id="13">1.3 常用正则<a class="headerlink" href="#13" title="Permanent link">&para;</a></h4>
<div class="codehilite"><pre><span></span><code>去逗号
let newStr = str.replace(/,/g,&#39;&#39;);
去空格(一般输入框输入都要做这个)
let newStr = str.replace(/(^\s*)|(\s*$)/g, &#39;&#39;); // 去除左右空格
let newStr = str.replace(/\s+/g,&quot;&quot;);  // 去除所有空格
用户名
let userPattern = /^[a-zA-Z0-9_-]{4,16}$/; // 4到16位（字母,数字,下划线,减号）
userPattern.test(str);
电话号码
let mPattern = /^1[34578]\d{9}$/;
附：密码/身份证号/E-mail/URL就不上了，太长了背了没意义，用的时候查就好了
</code></pre></div>

<hr />
<h4 id="14-array">1.4 Array操作<a class="headerlink" href="#14-array" title="Permanent link">&para;</a></h4>
<p><em>在阿里腾讯头条的笔试机试中，对数组的操作可以说是前端算法的核心，数组操作的基本方法全是必背的重中之重。</em></p>
<h5 id="141-arrayfrom">1.4.1 Array.from()<a class="headerlink" href="#141-arrayfrom" title="Permanent link">&para;</a></h5>
<ol>
<li>将<a href="https://www.jianshu.com/p/ca6110ebabb9">伪数组对象和可迭代对象</a>[见附录]转化为数组：
   <code>jsx
    let arr = Array.from(str/new Set()/new map());</code></li>
<li>转化数组后对每项进行操作
   <code>tsx
    let arr = Array.from('123', item =&gt; parseInt(item) + 1); // 2, 3, 4</code></li>
<li>去重(可以说这是最精彩的地方了)
   <code>jsx
    Array.from(new Set(arr));</code></li>
</ol>
<h5 id="142">1.4.2 拷贝数组<a class="headerlink" href="#142" title="Permanent link">&para;</a></h5>
<p>使用以下方法能复制数组保存在堆内存中的值，但不能深拷贝数组(数组中的数组或者对象依旧只是复制了引用没有复制到其在堆内存中的值)。[<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000008838101">数组和对象的深浅拷贝以及for循环递归实现方式本文不涉及</a>]</p>
<div class="codehilite"><pre><span></span><code><span class="k">let</span> <span class="n">arr2</span> <span class="p">=</span> <span class="p">[...</span><span class="n">arr1</span><span class="p">];</span>
<span class="k">let</span> <span class="n">arr2</span> <span class="p">=</span> <span class="n">arr1</span><span class="p">.</span><span class="n">slice</span><span class="p">();</span>
<span class="k">let</span> <span class="n">arr2</span> <span class="p">=</span> <span class="n">arr1</span><span class="p">.</span><span class="n">concat</span><span class="p">([]);</span> <span class="c1">// 此方法不常用</span>
</code></pre></div>

<p>深拷贝(对象也是如此)</p>
<div class="codehilite"><pre><span></span><code>let arr2 = JSON.parse(JSON.stringify(arr1));
</code></pre></div>

<h5 id="143">1.4.3 找出最大最小值<a class="headerlink" href="#143" title="Permanent link">&para;</a></h5>
<div class="codehilite"><pre><span></span><code>Math.max.apply(null, arr);
Math.min.apply(null, arr);
// ES6的写法
Math.max(...arr);
</code></pre></div>

<h5 id="144">1.4.4 数组排序<a class="headerlink" href="#144" title="Permanent link">&para;</a></h5>
<ol>
<li>sort()
   <code>jsx
    1.数组排序
    function compare(a, b) { return a-b; }
    arr.sort(compare);
    2.数组对象排序(开发中常用)
    function compare(property) {
        return (obj1, obj2) =&gt; {
            return obj1[property] - obj2[property];
        }
    }
    let students = [{name: "xx", age: 20}, {name: "hh", age: 19}];
    students.sort(compare('age'));</code></li>
<li><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fblog.csdn.net%2Fu012075670%2Farticle%2Fdetails%2F60340372">快排</a></li>
</ol>
<h5 id="145">1.4.5 其他方法<a class="headerlink" href="#145" title="Permanent link">&para;</a></h5>
<div class="codehilite"><pre><span></span><code><span class="n">push</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="c1">// 末尾添加</span>
<span class="n">pop</span><span class="p">()</span> <span class="c1">// 删除末尾</span>
<span class="n">shift</span><span class="p">()</span> <span class="c1">// 删除开头</span>
<span class="n">unshift</span><span class="p">()</span> <span class="c1">// 开头添加</span>
<span class="n">sort</span><span class="p">()</span> <span class="c1">// 排序</span>
<span class="n">reverse</span><span class="p">()</span> <span class="c1">// 反转</span>
<span class="n">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span> <span class="c1">// 截断拷贝, 接收起始和结束位置两参数并返回相应的数组，不影响原数组</span>
<span class="n">splice</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span> <span class="c1">// 切片，取出从index位置开始的num个值，原数组被截取</span>
<span class="n">splice</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sth</span><span class="p">)</span> <span class="c1">// 插入sth</span>
<span class="n">splice</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sth</span><span class="p">)</span> <span class="c1">// 替换为sth</span>
<span class="err">▲</span>  <span class="n">forEach</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">array</span><span class="p">)</span> <span class="c1">// 对每一项执行某些操作</span>
<span class="err">▲</span>  <span class="n">filter</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">array</span><span class="p">)</span> <span class="c1">// 返回满足条件(true)的项组成的数组</span>
<span class="err">▲</span>  <span class="n">map</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">array</span><span class="p">)</span> <span class="c1">// 返回对每一项执行某些操作组成的数组</span>
<span class="n">every</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">array</span><span class="p">)</span> <span class="c1">// 如果该函数对每一项都返回true，则返回true</span>
<span class="n">some</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">array</span><span class="p">)</span> <span class="c1">// 如果该函数对某一项返回true，则返回true</span>
<span class="n">reduce</span><span class="p">()</span> <span class="c1">// 从头到尾逐个遍历，迭代数组中的所有项</span>
<span class="n">includes</span><span class="p">(</span><span class="n">sth</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span> <span class="c1">// 检测数组中是否含有sth，index代表开始查找的位置，返回布尔值</span>
</code></pre></div>

<p>另：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.cnblogs.com%2Fzuojiayi%2Fp%2F6229902.html">二分查找</a></p>
<h5 id="145-key">1.4.5 对象数组根据对象某key值去重（日常工作常用）<a class="headerlink" href="#145-key" title="Permanent link">&para;</a></h5>
<div class="codehilite"><pre><span></span><code>let arr = [{showId: &#39;C&#39;, age: &#39;11&#39;}, {showId: &#39;A&#39;, age: &#39;11&#39; },
{ showId: &#39;B&#39;, age: &#39;11&#39;}, { showId: &#39;B&#39;, age: &#39;11&#39;},
{ showId: &#39;B&#39;, age: &#39;12&#39;},{ showId: &#39;B&#39;, age: &#39;13&#39;}];
// 根据showId去重到新数组newArr
const newArr = [];
arr.forEach(item =&gt; {
  // 过滤，如果有重复项就添加到过滤数组，那么长度就不为0就不会推入新数组。
  // 如果没有重复项长度就为0就推入新数组。
  newArr.filter(m =&gt; m.showId === item.showId).length === 0 &amp;&amp; 
  newArr.push(item);
});
</code></pre></div>

<hr />
<h4 id="15-object">1.5 Object操作<a class="headerlink" href="#15-object" title="Permanent link">&para;</a></h4>
<h5 id="151">1.5.1 创建<a class="headerlink" href="#151" title="Permanent link">&para;</a></h5>
<p>创建方式：工厂模式、构造函数模式、原型模式、动态原型模式、寄生构造函数模式、稳妥构造函数模式。</p>
<h6 id="_114">工厂模式<a class="headerlink" href="#_114" title="Permanent link">&para;</a></h6>
<div class="codehilite"><pre><span></span><code>function createObj(key) {
    const obj = new Object();
    obj.key = key;
    obj.sayKey = function(){ 方法 };
    return obj;
}
// 使用：const xuqingfeng = createObj(&#39;xuqingfeng&#39;);
</code></pre></div>

<p><strong>构造函数(对象属性最好用构造函数) + 原型(对象方法最好用原型)</strong>，这样的话每个实例都会有自己的一份实例属性的副本，同时又共享着对方法的引用，最大限度地节省了内存：</p>
<div class="codehilite"><pre><span></span><code>// 构造函数模式用于定义实例属性
function Person(name) {
    this.name = name;
}
// 原型模式用于定义方法和共享的属性
Person.prototype = {
    /* 默认情况下，所有原型对象都会自动获得一个constructor属性，
    这个属性是一个指向prototype属性所在函数的指针,
    这里的Person.prototype.constructor指向Person */
    constructor : Person, 
    sayName : function() { 方法 }
}
</code></pre></div>

<h6 id="es6">ES6的简写(简直不要太好用, 三大框架很多写法基于此)：<a class="headerlink" href="#es6" title="Permanent link">&para;</a></h6>
<div class="codehilite"><pre><span></span><code><span class="err">属性简写：</span>
<span class="k">let</span> <span class="n">keyVal</span> <span class="p">=</span> <span class="err">&#39;</span><span class="n">xuqingfeng</span><span class="err">&#39;</span><span class="p">;</span>
<span class="k">const</span> <span class="n">obj</span> <span class="p">=</span> <span class="p">{</span><span class="n">keyVal</span><span class="p">};</span> <span class="c1">// obj: { keyVal: &#39;xuqingfeng&#39; }</span>
<span class="err">方法简写：</span>
<span class="k">const</span> <span class="n">obj</span> <span class="p">=</span> <span class="p">{</span>
    <span class="n">method</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>
<span class="err">获取对象属性：</span>
 <span class="k">const</span> <span class="p">{</span> <span class="n">keyVal</span> <span class="p">}</span> <span class="p">=</span> <span class="n">obj</span><span class="p">;</span> <span class="c1">// React的const { data } = this.props; 就是这么个原理，前提是对象中也有对应属性(key)</span>
</code></pre></div>

<h5 id="152">1.5.2 继承<a class="headerlink" href="#152" title="Permanent link">&para;</a></h5>
<p>继承方式：原型链、借用构造函数、组合继承、原型式继承、寄生式继承、寄生组合式继承。</p>
<h6 id="_115">组合继承<a class="headerlink" href="#_115" title="Permanent link">&para;</a></h6>
<p>这种方式既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。</p>
<div class="codehilite"><pre><span></span><code>function A_Obj(name) {
    this.name = name;
}
A_Obj.prototype.sayName = function() { A_Obj的方法 };
function B_Obj(name, age) {
    A_Obj.call(this, name); // 继承属性
    this.age = age;
}
B_Obj.prototype = new A_Obj(); // 继承A_Obj的所有方法
B_Obj.prototype.constructor = B_Obj; // 改变指向非常关键
B_Obj.prototype.sayAge = function() { B_Obj的方法 };
</code></pre></div>

<p><strong>object.create()实现对象继承</strong> - 特别地提及下这个方法，它可以直接使用创建一个新对象</p>
<div class="codehilite"><pre><span></span><code>// 实现继承 - 方法
let extend = (Child, Parent) =&gt; {
    Child.prototype = Object.create(Parent.prototype); // 拷贝Parent原型对象
    Child.prototype.constructor = Child; // 将Child构造函数赋值给Child的原型对象
}
// 实例
const Par = function () { this.name = &#39;xuqingfeng&#39;; }
Par.prototype.getName = function () { return this.name; }
// 继承
const Cld = function () { Par.call(this); }
extend(Cld, Par);
// 使用
let testChild = new Cld();
console.log(testChild.getName())
</code></pre></div>

<h5 id="153">1.5.3 拷贝<a class="headerlink" href="#153" title="Permanent link">&para;</a></h5>
<p>浅拷贝：</p>
<div class="codehilite"><pre><span></span><code><span class="k">const</span> <span class="n">copyObj</span> <span class="o">=</span> <span class="kt">Object</span><span class="p">.</span><span class="n">assign</span><span class="p">({},</span> <span class="n">obj</span><span class="p">);</span>
<span class="k">const</span> <span class="n">Obj2</span> <span class="o">=</span> <span class="p">{...</span><span class="n">Obj1</span><span class="p">};</span>
</code></pre></div>

<p>浅拷贝并修改key的value或添加key与value: <code>const Obj2 = {...Obj1, ['key']: 'newOrCover'}</code>,示例如下</p>
<div class="codehilite"><pre><span></span><code>const firObj = { a: &#39;1&#39;, s: { ss: &#39;sss&#39; } };
const secObj = { ...firObj, [&#39;b&#39;]: &#39;2&#39; }
secObj.a = &#39;777&#39;;
firObj.a = &#39;666&#39;;
secObj.s.ss = &#39;secObj-s&#39;;
firObj.s.ss = &#39;firObj-s&#39;;
console.log(firObj, secObj);  // { a: &#39;666&#39;, s: { ss: &#39;firObj-s&#39; } } { a: &#39;777&#39;, s: { ss: &#39;firObj-s&#39; }, b: &#39;2&#39; }
</code></pre></div>

<p>并集-合并两个对象/数组，后者覆盖前者(深度覆盖)，最终形成并集： <code>const Obj3 = Object.assign({}, Obj1, Obj2);</code>，示例如下</p>
<div class="codehilite"><pre><span></span><code>const firObj = { a: &#39;1&#39;, b: &#39;b&#39;, s: { ss: &#39;fir-s&#39; } };
const secObj = { a: &#39;2&#39;, c: &#39;c&#39;, s: { ss: &#39;sec-s&#39; } }
const newObj = Object.assign({}, firObj, secObj);
console.log(newObj); // { a: &#39;2&#39;, b: &#39;b&#39;, s: { ss: &#39;sec-s&#39; }, c: &#39;c&#39; }
const firArr = [1, 2, 3, &#39;a&#39;, &#39;b&#39;];
const secArr = [1, 3, 5, 7];
const newArr = Object.assign([], firArr, secArr);
console.log(newArr); // [ 1, 3, 5, 7, &#39;b&#39; ]
</code></pre></div>

<p>深拷贝[ for循环递归深拷贝见上面数组，<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FObject%2Fassign"><code>Object.assign</code>合并对象和深拷贝移步MDN</a> ]：</p>
<div class="codehilite"><pre><span></span><code>let obj2 = JSON.parse(JSON.stringify(obj1)); 
</code></pre></div>

<h5 id="154">1.5.4 其他方法<a class="headerlink" href="#154" title="Permanent link">&para;</a></h5>
<div class="codehilite"><pre><span></span><code><span class="kt">Object</span><span class="p">.</span><span class="n">freeze</span><span class="p">()</span> <span class="c1">// 冻结对象：其他代码不能删除或更改任何属性。</span>
<span class="kt">Object</span><span class="p">.</span><span class="n">keys</span><span class="p">()</span> <span class="c1">// 返回一个包含所有给定对象自身可枚举属性名称的数组。</span>
<span class="kt">Object</span><span class="p">.</span><span class="n">values</span><span class="p">()</span> <span class="c1">// 返回给定对象自身可枚举值的数组。</span>
<span class="kt">Object</span><span class="p">.</span><span class="n">entries</span><span class="p">()</span> <span class="c1">// 返回给定对象自身可枚举属性的[key, value]数组</span>
<span class="kt">Object</span><span class="p">.</span><span class="n">defineProperty</span><span class="p">()</span> <span class="c1">// vue数据双向绑定的核心方法，建议上 MDN 一观</span>
</code></pre></div>

<hr />
<h4 id="16-function">1.6 Function操作<a class="headerlink" href="#16-function" title="Permanent link">&para;</a></h4>
<h5 id="161">1.6.1 参数转化为数组(不知参数个数)<a class="headerlink" href="#161" title="Permanent link">&para;</a></h5>
<p><strong>数组原型slice方法</strong></p>
<div class="codehilite"><pre><span></span><code>function fc() {
    Array.prototype.slice.call(arguments) ; // 这个方法可以将只要具有length属性的对象转成数组
}
</code></pre></div>

<p><strong>▲ rest 参数</strong></p>
<div class="codehilite"><pre><span></span><code>function fc(...arr) { console.log(arr); }
</code></pre></div>

<p><strong>参数cancat为数组</strong></p>
<div class="codehilite"><pre><span></span><code>function fc() { return [].concat.apply([], arguments); }
</code></pre></div>

<h5 id="162-sth">1.6.2 检测函数参数是否含有某个值(sth)<a class="headerlink" href="#162-sth" title="Permanent link">&para;</a></h5>
<div class="codehilite"><pre><span></span><code><span class="o">[]</span><span class="p">.</span><span class="nc">includes</span><span class="p">.</span><span class="nc">call</span><span class="o">(</span><span class="nt">arguments</span><span class="o">,</span> <span class="nt">sth</span><span class="o">)</span>
</code></pre></div>

<h5 id="163">1.6.3 函数设置可改的默认参数<a class="headerlink" href="#163" title="Permanent link">&para;</a></h5>
<div class="codehilite"><pre><span></span><code>function func1(a, b=&#39;123123&#39;,c={id: 1}){
    console.log(a,b,c)
}
func1(&#39;徐清风&#39;,&#39;xuqingfeng&#39;, 44) // 徐清风, xuqingfeng, 44
</code></pre></div>

<hr />
<h4 id="17-math-date">1.7 <code>Math</code> 与 <code>Date</code><a class="headerlink" href="#17-math-date" title="Permanent link">&para;</a></h4>
<p><strong>Math方法：</strong></p>
<div class="codehilite"><pre><span></span><code>Math.ceil() // 执行向上舍入
Math.floor() // 执行向下舍入
Math.round() // 执行标准舍入
▲ Math.random() // 返回大于等于0小于1的随机数
</code></pre></div>

<p><strong>获取当前时间：</strong></p>
<div class="codehilite"><pre><span></span><code>let now = new Date();
console.log(now.toLocaleString()); // 2018-8-23 17:48:47
console.log([now.getFullYear(), now.getMonth()+1, now.getDate()].join(&#39;-&#39;)); // 2018-8-23
</code></pre></div>

<hr />
<h3 id="2js">2.JS编程基本操作<a class="headerlink" href="#2js" title="Permanent link">&para;</a></h3>
<h4 id="21-">2.1 三元运算 - 用起来超刺激<a class="headerlink" href="#21-" title="Permanent link">&para;</a></h4>
<p>公式：<code>条件1 ? 真结果1 : ( 条件1.1 ? 真结果1.1 : (条件1.1.1 ? 真结果1.1.1:假结果1.1.1))</code>, 一个常用示例：</p>
<div class="codehilite"><pre><span></span><code>node.style.display <span class="o">=</span> <span class="o">(</span>node.style.display <span class="o">===</span> <span class="s2">&quot;block&quot;</span> ? <span class="s2">&quot;none&quot;</span> :  <span class="s2">&quot;block&quot;</span><span class="o">)</span><span class="p">;</span>
</code></pre></div>

<h4 id="22-js-truefalse-if">2.2 在做JS判断时的 <code>true</code>与<code>false</code> (if判断、与非判断、三元运算判断等)<a class="headerlink" href="#22-js-truefalse-if" title="Permanent link">&para;</a></h4>
<p>值为<code>false</code> ：<code>false</code>、<code>null</code>、<code>undefined</code>、<code>''(空字符串，空格不代表空)</code>、<code>0</code>、<code>NaN</code>
值为<code>true</code> ：<code>true</code>、<code>对象</code>、<code>字符串(包括空格)</code>、<code>任意非0数值(包括Infinity)</code></p>
<h4 id="23">2.3 与或非运算<a class="headerlink" href="#23" title="Permanent link">&para;</a></h4>
<p>&amp;&amp; ：如果第一个值为 true，则 &amp;&amp; 后面的值将显示在输出中，否则值为第一个值。</p>
<div class="codehilite"><pre><span></span><code><span class="k">let</span> <span class="n">a</span> <span class="p">=</span> <span class="k">false</span> <span class="p">&amp;&amp;</span> <span class="m">123</span><span class="p">;</span> <span class="c1">// false</span>
<span class="k">let</span> <span class="n">b</span> <span class="p">=</span> <span class="sc">&#39; &#39;</span> <span class="p">&amp;&amp;</span> <span class="m">123</span><span class="p">;</span> <span class="c1">// 123, 注意这里是空格不是空</span>
</code></pre></div>

<p>|| ：如果第一个值为 false，则 || 后面的值将显示在输出中，否则值为第一个值。</p>
<div class="codehilite"><pre><span></span><code><span class="n">let</span> <span class="n">a</span> <span class="o">=</span> <span class="kp">false</span> <span class="o">||</span> <span class="mi">123</span><span class="p">;</span> <span class="sr">//</span> <span class="mi">123</span>
<span class="n">let</span> <span class="n">b</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span> <span class="o">||</span> <span class="mi">123</span><span class="p">;</span> <span class="sr">//</span> <span class="s1">&#39; &#39;</span>
</code></pre></div>

<hr />
<h4 id="_116">附录：<a class="headerlink" href="#_116" title="Permanent link">&para;</a></h4>
<ol>
<li>伪数组对象和可迭代对象：</li>
<li>伪数组对象（拥有一个 <code>length</code> 属性和若干索引属性的任意对象）</li>
<li>可迭代对象（可以获取对象中的元素,如 <code>Map</code>和 <code>Set</code> 等）</li>
<li>福利-今年春秋招阿里腾讯头条机试(远程视频直接撸代码)题：
   ```kotlin<ol>
<li>正则电话号码</li>
<li>两个超过JS数值范围的数字相加</li>
<li>一片英文文章重复出现次数最多的单词及其出现次数</li>
<li>创建一个 Person 类，其包含公有属性 name 和私有属性 age 以及公有方法 setAge；
   创建一个 Teacher 类，使其继承 Person ，并包含私有属性 studentCount 和私有方法 setStudentCount</li>
<li>兼容的事件监听方法</li>
<li>快排</li>
<li>拖拽一个方块随机移动</li>
<li>事件观察者</li>
<li>promise按序执行三个函数</li>
<li>封装一个flat方法，将多维数组扁平化为一维数组</li>
<li>实现一个简易的JQ选择器功能（要求能够获取标签、类、Id）</li>
<li>实现简易的虚拟DOM（意味着用对象构造DOM），然后生成DOM结构，
    只要求属性值（比如class、id等属性能够正常获取和调用），
    不要求节点增删查改（这涉及到diff算法）。</li>
<li>对象数组根据某个属性去重【这个上面有提到】
   ```</li>
</ol>
</li>
</ol>
<h1 id="_117">菜鸟教程<a class="headerlink" href="#_117" title="Permanent link">&para;</a></h1>
<h2 id="1-viewport">1、 viewport<a class="headerlink" href="#1-viewport" title="Permanent link">&para;</a></h2>
<div class="codehilite"><pre><span></span><code><span class="p">&lt;</span><span class="nt">meta</span> <span class="na">name</span><span class="o">=</span><span class="s">&quot;viewport&quot;</span> <span class="na">content</span><span class="o">=</span><span class="s">&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot;</span> <span class="p">/&gt;</span>
</code></pre></div>

<ul>
<li><strong>width</strong>: 设置viewport宽度，为一个正整数，或字符串 device-width</li>
<li><strong>device-width</strong>: 设备宽度</li>
<li><strong>height</strong>: 设置viewport高度，一般设置了宽度，会自动解析出高度，可以不用设置</li>
<li><strong>initial-scale</strong>: 默认缩放比例（初始缩放比例），为一个数字，可以带小数</li>
<li><strong>minimum-scale</strong>: 允许用户最小缩放比例，为一个数字，可以带小数</li>
<li><strong>maximum-scale</strong>: 允许用户最大缩放比例，为一个数字，可以带小数</li>
<li><strong>user-scalable</strong>: 是否允许手动缩放
<strong>延伸提问：怎样处理 移动端 1px 被渲染成 2px 问题？</strong>
1、局部处理
meta 标签中的 viewport 属性 ，initial-scale 设置为 1
rem 按照设计稿标准走，外加利用 transfrome 的 scale(0.5) 缩小一倍即可；
2、全局处理
meta 标签中的 viewport 属性 ，initial-scale 设置为 0.5
rem 按照设计稿标准走即可</li>
</ul>
<hr />
<h2 id="2_1">2、跨域的几种方式<a class="headerlink" href="#2_1" title="Permanent link">&para;</a></h2>
<p><strong>首先了解下浏览器的同源策略</strong>
同源策略/SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSRF等攻击。所谓同源是指"协议+域名+端口"三者相同，即便两个不同的域名指向同一个ip地址，也非同源。
那么怎样解决跨域问题的呢？
<strong>1 通过jsonp跨域，原生实现：</strong></p>
<div class="codehilite"><pre><span></span><code>&lt;script&gt;
var script = document.createElement(&#39;script&#39;);
script.type = &#39;text/javascript&#39;;
// 传参并指定回调执行函数为onBack
script.src = &#39;http://www.....:8080/login?user=admin&amp;callback=onBack&#39;;
document.head.appendChild(script);
// 回调执行函数
function onBack(res) {
    alert(JSON.stringify(res));
}
&lt;/script&gt;
</code></pre></div>

<p><strong>2、document.domain + iframe 跨域</strong>
此方案仅限主域相同，子域不同的跨域应用场景。
1.）父窗口：(http://www.domain.com/a.html)</p>
<div class="codehilite"><pre><span></span><code>&lt;iframe id=&quot;iframe&quot; src=&quot;http://child.domain.com/b.html&quot;&gt;&lt;/iframe&gt;
&lt;script&gt;
document.domain = &#39;domain.com&#39;;
var user = &#39;admin&#39;;
&lt;/script&gt;
</code></pre></div>

<p>2.）子窗口：(http://child.domain.com/b.html)</p>
<div class="codehilite"><pre><span></span><code>&lt;script&gt;
document.domain = &#39;domain.com&#39;;
// 获取父窗口中变量
alert(&#39;get js data from parent ---&gt; &#39; + window.parent.user);
&lt;/script&gt;
</code></pre></div>

<p>弊端：请看下面渲染加载优化
3、nginx 代理跨域</p>
<p>4、nodejs 中间件代理跨域</p>
<p>5、后端在头部信息里面设置安全域名</p>
<h2 id="3">3、渲染优化<a class="headerlink" href="#3" title="Permanent link">&para;</a></h2>
<p>1.禁止使用iframe（阻塞父文档onload事件）
- iframe会阻塞主页面的Onload事件；
- 搜索引擎的检索程序无法解读这种页面，不利于SEO;
- iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。
使用 iframe 之前需要考虑这两个缺点。如果需要使用 iframe，最好是通过 javascript 动态给 iframe 添加 src 属性值，这样可以绕开以上两个问题。
2.禁止使用gif图片实现loading效果（降低CPU消耗，提升渲染性能）；
3、使用CSS3代码代替JS动画（尽可能避免重绘重排以及回流）；
4、对于一些小图标，可以使用base64位编码，以减少网络请求。但不建议大图使用，比较耗费CPU；
小图标优势在于：
- 1.减少HTTP请求；
- 2.避免文件跨域；
- 3.修改及时生效；
5、页面头部的 会阻塞页面；（因为 Renderer进程中 JS线程和渲染线程是互斥的）；
6、页面头部 会阻塞页面；（因为 Renderer进程中 JS线程和渲染线程是互斥的）；
7、页面中空的 href 和 src 会阻塞页面其他资源的加载 (阻塞下载进程)；
8、网页Gzip，CDN托管，data缓存 ，图片服务器；
9、前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数
10、用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。
11、当需要设置的样式很多时设置className而不是直接操作style。
12、少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。
13、避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。
14、图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳。
15、 避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢。
对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘IO。 向前端优化指的是，在不影响功能和体验的情况下，能在浏览器执行的不要在服务端执行，能在缓存服务器上直接返回的不要到应用服务器，程序能直接取得的结果不要到外部取得，本机内能取得的数据不要到远程取，内存能取到的不要到磁盘取，缓存中有的不要去数据库查询。减少数据库操作指减少更新次数、缓存结果减少查询次数、将数据库执行的操作尽可能的让你的程序完成（例如join查询），减少磁盘IO指尽量不使用文件系统作为缓存、减少读写文件次数等。程序优化永远要优化慢的部分，换语言是无法"优化"的。</p>
<hr />
<h2 id="4">4、事件的各个阶段<a class="headerlink" href="#4" title="Permanent link">&para;</a></h2>
<div class="codehilite"><pre><span></span><code>1：捕获阶段 ---&gt; 2：目标阶段 ---&gt; 3：冒泡阶段
document   ---&gt; target目标 ----&gt; document
</code></pre></div>

<p>由此，addEventListener 的第三个参数设置为 true 和 false 的区别已经非常清晰了：
- true 表示该元素在事件的"捕获阶段"（由外往内传递时）响应事件；
- false 表示该元素在事件的"冒泡阶段"（由内向外传递时）响应事件。</p>
<hr />
<h2 id="5let-var-const">5、let var const<a class="headerlink" href="#5let-var-const" title="Permanent link">&para;</a></h2>
<ul>
<li><strong>let</strong>: 允许你声明一个作用域被限制在块级中的变量、语句或者表达式 let 绑定不受变量提升的约束，这意味着let声明不会被提升到当前，该变量处于从块开始到初始化处理的"暂存死区"。</li>
<li><strong>var</strong>: 声明变量的作用域限制在其声明位置的上下文中，而非声明变量总是全局的, 由于变量声明（以及其他声明）总是在任意代码执行之前处理的，所以在代码中的任意位置声明变量总是等效于在代码开头声明。</li>
<li>const 声明创建一个值的只读引用 (即指针)，这里就要介绍下 JS 常用类型: String、Number、Boolean、Array、Object、Null、Undefined。其中基本类型有 Undefined、Null、Boolean、Number、String，保存在栈中；复合类型 有 Array、Object ，保存在堆中； 基本数据当值发生改变时，那么其对应的指针也将发生改变，故造成 const申明基本数据类型时，再将其值改变时，将会造成报错， 例如 const a = 3 ; a = 5 时 将会报错；但是如果是复合类型时，如果只改变复合类型的其中某个Value项时， 将还是正常使用；</li>
</ul>
<hr />
<h2 id="6">6、箭头函数<a class="headerlink" href="#6" title="Permanent link">&para;</a></h2>
<p>语法比函数表达式更短，并且不绑定自己的 this，arguments，super 或 new.target。这些函数表达式最适合用于非方法函数，并且它们不能用作构造函数。</p>
<h2 id="7">7、快速的让一个数组乱序<a class="headerlink" href="#7" title="Permanent link">&para;</a></h2>
<div class="codehilite"><pre><span></span><code>var arr = [1,2,3,4,5,6,7,8,9,10];
arr.sort(function(){
    return Math.random() - 0.5;
})
console.log(arr);
</code></pre></div>

<p>此处解释：（语言组织能力不足，请勿吐槽）
首先，当 return 的值：</p>
<ul>
<li>小于 0 ，那么 a 会被排列到 b 之前；</li>
<li>等于 0 ， a 和 b 的相对位置不变；</li>
<li>大于 0 ， b 会被排列到 a 之前；
这里你会发现起始的时候数组是正序排列，每当进行一次排列的时候， 都会先随机一个随机数（注意这里的每一次排列 指 每一个红框指一次排列， 共9次排列 ， 一次排列中可能存在多次比较）；
当一次排列的随机数大于 0.5 时 将会进行第二次比较， 当第二次随机数 仍然大于 0.5 时 ，将会再进行一次比较， 直到 随机数大于 0.5 或者排列到第一位；
当一次排列的随机数 小于 0.5 时 当前比较的两项索引将不会改变 ，继续下一次的排列；</li>
</ul>
<hr />
<h2 id="8font-family">8、字体font-family<a class="headerlink" href="#8font-family" title="Permanent link">&para;</a></h2>
<div class="codehilite"><pre><span></span><code>@ 宋体      SimSun
@ 黑体      SimHei
@ 微软雅黑   Microsoft Yahei
@ 微软正黑体 Microsoft JhengHei
@ 新宋体    NSimSun
@ 新细明体  MingLiU
@ 细明体    MingLiU
@ 标楷体    DFKai-SB
@ 仿宋     FangSong
@ 楷体     KaiTi
@ 仿宋_GB2312  FangSong_GB2312
@ 楷体_GB2312  KaiTi_GB2312  
@
@ 说明：中文字体多数使用宋体、雅黑，英文用Helvetica
body { font-family: Microsoft Yahei,SimSun,Helvetica; }
</code></pre></div>

<hr />
<h2 id="9meta">9、可能用到的meta标签<a class="headerlink" href="#9meta" title="Permanent link">&para;</a></h2>
<div class="codehilite"><pre><span></span><code>&lt;!-- 设置缩放 --&gt;
&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable=no, minimal-ui&quot; /&gt;
&lt;!-- 可隐藏地址栏，仅针对IOS的Safari（注：IOS7.0版本以后，safari上已看不到效果） --&gt;
&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; /&gt;
&lt;!-- 仅针对IOS的Safari顶端状态条的样式（可选default/black/black-translucent ） --&gt;
&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot; /&gt;
&lt;!-- IOS中禁用将数字识别为电话号码/忽略Android平台中对邮箱地址的识别 --&gt;
&lt;meta name=&quot;format-detection&quot;content=&quot;telephone=no, email=no&quot; /&gt;
</code></pre></div>

<p>其他meta标签</p>
<div class="codehilite"><pre><span></span><code>&lt;!-- 启用360浏览器的极速模式(webkit) --&gt;
&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;
&lt;!-- 避免IE使用兼容模式 --&gt;
&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
&lt;!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --&gt;
&lt;meta name=&quot;HandheldFriendly&quot; content=&quot;true&quot;&gt;
&lt;!-- 微软的老式浏览器 --&gt;
&lt;meta name=&quot;MobileOptimized&quot; content=&quot;320&quot;&gt;
&lt;!-- uc强制竖屏 --&gt;
&lt;meta name=&quot;screen-orientation&quot; content=&quot;portrait&quot;&gt;
&lt;!-- QQ强制竖屏 --&gt;
&lt;meta name=&quot;x5-orientation&quot; content=&quot;portrait&quot;&gt;
&lt;!-- UC强制全屏 --&gt;
&lt;meta name=&quot;full-screen&quot; content=&quot;yes&quot;&gt;
&lt;!-- QQ强制全屏 --&gt;
&lt;meta name=&quot;x5-fullscreen&quot; content=&quot;true&quot;&gt;
&lt;!-- UC应用模式 --&gt;
&lt;meta name=&quot;browsermode&quot; content=&quot;application&quot;&gt;
&lt;!-- QQ应用模式 --&gt;
&lt;meta name=&quot;x5-page-mode&quot; content=&quot;app&quot;&gt;
&lt;!-- windows phone 点击无高光 --&gt;
&lt;meta name=&quot;msapplication-tap-highlight&quot; content=&quot;no&quot;&gt;
</code></pre></div>

<hr />
<h2 id="10-transition">10、消除 transition 闪屏<a class="headerlink" href="#10-transition" title="Permanent link">&para;</a></h2>
<div class="codehilite"><pre><span></span><code>.css {
    -webkit-transform-style: preserve-3d;
    -webkit-backface-visibility: hidden;
    -webkit-perspective: 1000;
}
</code></pre></div>

<p>过渡动画（在没有启动硬件加速的情况下）会出现抖动的现象， 以上的解决方案只是改变视角来启动硬件加速的一种方式；启动硬件加速的另外一种方式：</p>
<div class="codehilite"><pre><span></span><code>.css {
    -webkit-transform: translate3d(0,0,0);
    -moz-transform: translate3d(0,0,0);
    -ms-transform: translate3d(0,0,0);
    transform: translate3d(0,0,0);
}
</code></pre></div>

<p><strong>启动硬件加速</strong>
最常用的方式：translate3d、translateZ、transform
opacity 属性/过渡动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态）
will-chang 属性（这个比较偏僻），一般配合opacity与translate使用（而且经测试，除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层）。</p>
<p>弊端：硬件加速会导致 CPU 性能占用量过大，电池电量消耗加大 ；因此尽量避免泛滥使用硬件加速。</p>
<h2 id="11android-4x-bug">11、android 4.x bug<a class="headerlink" href="#11android-4x-bug" title="Permanent link">&para;</a></h2>
<ul>
<li>1.三星 Galaxy S4中自带浏览器不支持border-radius缩写</li>
<li>2.同时设置border-radius和背景色的时候，背景色会溢出到圆角以外部分</li>
<li>3.部分手机(如三星)，a链接支持鼠标:visited事件，也就是说链接访问后文字变为紫色</li>
<li>4.android无法同时播放多音频audio</li>
<li>5.oppo 的border-radius 会失效</li>
</ul>
<hr />
<h2 id="12js">12、JS 判断设备来源<a class="headerlink" href="#12js" title="Permanent link">&para;</a></h2>
<div class="codehilite"><pre><span></span><code>// 判断移动端设备
function deviceType(){
    var ua = navigator.userAgent;
    var agent = [&quot;Android&quot;, &quot;iPhone&quot;, &quot;SymbianOS&quot;, &quot;Windows Phone&quot;, &quot;iPad&quot;, &quot;iPod&quot;];    
    for(var i=0; i&lt;len,len = agent.length; i++){
        if(ua.indexOf(agent[i])&gt;0){         
            break;
        }
    }
}
deviceType();
window.addEventListener(&#39;resize&#39;, function(){
    deviceType();
})
// 判断微信浏览器
function isWeixin(){
    var ua = navigator.userAgent.toLowerCase();
    if(ua.match(/MicroMessenger/i)==&#39;micromessenger&#39;){
        return true;
    }else{
        return false;
    }
}
</code></pre></div>

<hr />
<h2 id="13audiovideoiosandriod">13、audio元素和video元素在ios和andriod中无法自动播放<a class="headerlink" href="#13audiovideoiosandriod" title="Permanent link">&para;</a></h2>
<p><strong>原因：</strong>因为各大浏览器都为了节省流量，做出了优化，在用户没有行为动作时（交互）不予许自动播放；</p>
<div class="codehilite"><pre><span></span><code>//音频，写法一
&lt;audio src=&quot;music/bg.mp3&quot; autoplay loop controls&gt;你的浏览器还不支持哦&lt;/audio&gt;
//音频，写法二
&lt;audio controls=&quot;controls&quot;&gt; 
    &lt;source src=&quot;music/bg.ogg&quot; type=&quot;audio/ogg&quot;&gt;&lt;/source&gt;
    &lt;source src=&quot;music/bg.mp3&quot; type=&quot;audio/mpeg&quot;&gt;&lt;/source&gt;
    优先播放音乐bg.ogg，不支持在播放bg.mp3
&lt;/audio&gt;
//JS绑定自动播放（操作window时，播放音乐）
$(window).one(&#39;touchstart&#39;, function(){
    music.play();
})
//微信下兼容处理
document.addEventListener(&quot;WeixinJSBridgeReady&quot;, function () {
    music.play();
}, false);
//小结
//1.audio元素的autoplay属性在IOS及Android上无法使用，在PC端正常；
//2.audio元素没有设置controls时，在IOS及Android会占据空间大小，而在PC端Chrome是不会占据任何空间；
//3.注意不要遗漏微信的兼容处理需要引用微信JS；
</code></pre></div>

<hr />
<h2 id="14css">14、css实现单行文本溢出显示 ...<a class="headerlink" href="#14css" title="Permanent link">&para;</a></h2>
<p>直接上效果：相对于多行文本溢出做处理， 单行要简单多，且更容易理解。
<img alt="img" src="https://www.runoob.com/wp-content/uploads/2018/03/3313696839-5a8f7bb9864cc_articlex.png" />
实现方法:</p>
<div class="codehilite"><pre><span></span><code>overflow: hidden;
text-overflow:ellipsis;
white-space: nowrap;
</code></pre></div>

<h2 id="width">当然还需要加宽度width属来兼容部分浏览。<a class="headerlink" href="#width" title="Permanent link">&para;</a></h2>
<h2 id="15">15、实现多行文本溢出显示...<a class="headerlink" href="#15" title="Permanent link">&para;</a></h2>
<p>效果：
<img alt="img" src="https://www.runoob.com/wp-content/uploads/2018/03/3820353650-5a8f7bb98a123_articlex.png" />
实现方法：</p>
<div class="codehilite"><pre><span></span><code>display: -webkit-box;
-webkit-box-orient: vertical;
-webkit-line-clamp: 3;
overflow: hidden;
</code></pre></div>

<p>适用范围：
因使用了WebKit的CSS扩展属性，该方法适用于WebKit浏览器及移动端；
注：
1、-webkit-line-clamp 用来限制在一个块元素显示的文本的行数。 为了实现该效果，它需要组合其他的WebKit属性。常见结合属性：
2、display: -webkit-box; 必须结合的属性，将对象作为弹性伸缩盒子模型显示 。
3、-webkit-box-orient 必须结合的属性，设置或检索伸缩盒对象的子元素的排列方式 。
如果你觉着这样还不够美观， 那么就接着往下看效果：
<img alt="img" src="https://www.runoob.com/wp-content/uploads/2018/03/2039871283-5a8f7bb9883e8_articlex.png" />
<strong>这样 是不是你想要的呢？</strong>
实现方法：</p>
<div class="codehilite"><pre><span></span><code>div {
    position: relative;
    line-height: 20px;
    max-height: 40px;
    overflow: hidden;
}
div:after {
    content: &quot;...&quot;; position: absolute; bottom: 0; right: 0; padding-left: 40px;
    background: -webkit-linear-gradient(left, transparent, #fff 55%);
    background: -o-linear-gradient(right, transparent, #fff 55%);
    background: -moz-linear-gradient(right, transparent, #fff 55%);
    background: linear-gradient(to right, transparent, #fff 55%);
}
</code></pre></div>

<p>不要只顾着吃，要注意胃口，此方法有个弊端 那就是 【未超出行的情况下也会出现省略号】 ，这样会不会很挫！！！ 没办法，只能结合JS 进行优化该方法了。
注：
- 1、将height设置为line-height的整数倍，防止超出的文字露出。
- 2、给p::after添加渐变背景可避免文字只显示一半。
- 3、由于ie6-7不显示content内容，所以要添加标签兼容ie6-7（如：…）；兼容ie8需要将::after替换成:after。</p>
<hr />
<h2 id="16">16、让图文不可复制<a class="headerlink" href="#16" title="Permanent link">&para;</a></h2>
<p>这点应该大家 都很熟悉了， 某些时候【你懂的】为了快捷搜索答案，可是打死也不让你复制:</p>
<div class="codehilite"><pre><span></span><code>-webkit-user-select: none; 
-ms-user-select: none;
-moz-user-select: none;
-khtml-user-select: none;
user-select: none;
</code></pre></div>

<hr />
<h2 id="17">17、盒子垂直水平居中<a class="headerlink" href="#17" title="Permanent link">&para;</a></h2>
<p>这个问题好像面试必问的吔！反正我是必问的，哈哈！！！ 其实无关多少种实现思路，只要你能实现就可以！
提供4种方法:
- 1、定位 盒子宽高已知， position: absolute; left: 50%; top: 50%; margin-left:-自身一半宽度; margin-top: -自身一半高度;
- 2、table-cell布局 父级 display: table-cell; vertical-align: middle; 子级 margin: 0 auto;
- 3、定位 + transform ; 适用于 子盒子 宽高不定时； （这里是本人常用方法）
  <code>position: relative / absolute;
  /*top和left偏移各为50%*/
     top: 50%;
     left: 50%;
  /*translate(-50%,-50%) 偏移自身的宽和高的-50%*/
  transform: translate(-50%, -50%); 注意这里启动了3D硬件加速哦 会增加耗电量的 （至于何是3D加速 请看浏览器进程与线程篇）</code>
- 4、flex 布局
  <code>父级： 
  /*flex 布局*/
  display: flex;
  /*实现垂直居中*/
  align-items: center;
  /*实现水平居中*/
  justify-content: center;</code>
再加一种水平方向上居中 ：<strong>margin-left : 50% ; transform: translateX(-50%);</strong>
那有些网页为了尊重原创，复制的文本 都会被加上一段来源说明，是如何做到的呢？问的好！ 等的就是你这个问题 -_- 。
大致思路：
- 1、答案区域监听copy事件，并阻止这个事件的默认行为。
- 2、获取选中的内容（window.getSelection()）加上版权信息，然后设置到剪切板（clipboarddata.setData()）。</p>
<hr />
<h2 id="18-placeholder">18、改变 placeholder 的字体颜色大小<a class="headerlink" href="#18-placeholder" title="Permanent link">&para;</a></h2>
<p>其实这个方法也就在 PC 端可以，真机上屁用都没有，当时我就哭了。 但还是贴出来吧</p>
<div class="codehilite"><pre><span></span><code>input::-webkit-input-placeholder { 
    /* WebKit browsers */ 
    font-size:14px;
    color: #333;
} 
input::-moz-placeholder { 
    /* Mozilla Firefox 19+ */ 
    font-size:14px;
    color: #333;
} 
input:-ms-input-placeholder { 
    /* Internet Explorer 10+ */ 
    font-size:14px;
    color: #333;
}
</code></pre></div>

<hr />
<h2 id="19">19、最快捷的数组求最大值<a class="headerlink" href="#19" title="Permanent link">&para;</a></h2>
<div class="codehilite"><pre><span></span><code>var arr = [ 1,5,1,7,5,9];
Math.max(...arr)  // 9 
</code></pre></div>

<hr />
<h2 id="20">20、更短的数组去重写法<a class="headerlink" href="#20" title="Permanent link">&para;</a></h2>
<div class="codehilite"><pre><span></span><code>[...new Set([2,&quot;12&quot;,2,12,1,2,1,6,12,13,6])]
 // [2, &quot;12&quot;, 12, 1, 6, 13]
</code></pre></div>

<hr />
<h2 id="21-vue">21、 vue 父子组件嵌套时，组件内部的各个生命周期钩子触发先后顺序<a class="headerlink" href="#21-vue" title="Permanent link">&para;</a></h2>
<p>首先 我们可以把 子组件当做function函数来看待，当父组件 import 子组件的时候， 就当是声明了 并加载了这个函数，在调用的时候才会去执行这个函数（子组件）。那么父子组件中的各个声明周期钩子触发的先后顺序是怎样的呢？如下图：
<img alt="img" src="https://www.runoob.com/wp-content/uploads/2018/03/225705772-5a8f7bbc255fe_articlex.png" /></p>
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid" aria-label="Footer">
        
          <a href="../15%20JavaScript%20%E5%9F%BA%E7%A1%80/" class="md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-footer-nav__button md-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
            </div>
            <div class="md-footer-nav__title">
              <div class="md-ellipsis">
                <span class="md-footer-nav__direction">
                  Previous
                </span>
                15 JavaScript 基础
              </div>
            </div>
          </a>
        
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
          <div class="md-footer-copyright__highlight">
            Copyright &copy; Michael An
          </div>
        
        Made with
        <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
          Material for MkDocs
        </a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../assets/javascripts/vendor.18f0862e.min.js"></script>
      <script src="../../assets/javascripts/bundle.994580cf.min.js"></script><script id="__lang" type="application/json">{"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.term.missing": "Missing"}</script>
      
      <script>
        app = initialize({
          base: "../..",
          features: [],
          search: Object.assign({
            worker: "../../assets/javascripts/worker/search.9c0e82ba.min.js"
          }, typeof search !== "undefined" && search)
        })
      </script>
      
    
  </body>
</html>