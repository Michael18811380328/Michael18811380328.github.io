
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <meta name="author" content="Michael An">
      
      
        <link rel="canonical" href="https://michael18811380328.github.io/other/JS%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">
      
      <link rel="shortcut icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.1.2, mkdocs-material-6.2.8">
    
    
      
        <title>JS 数据结构 - Michale An Blog</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.cb6bc1d0.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.39b8e14a.min.css">
        
          
          
          <meta name="theme-color" content="#2094f3">
        
      
    
    
    
      
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>body,input{font-family:"Roboto",-apple-system,BlinkMacSystemFont,Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono",SFMono-Regular,Consolas,Menlo,monospace}</style>
      
    
    
    
    
      
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="blue" data-md-color-accent="">
      
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#data-structure" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid" aria-label="Header">
    <a href="https://michael18811380328.github.io/" title="Michale An Blog" class="md-header-nav__button md-logo" aria-label="Michale An Blog">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    <label class="md-header-nav__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header-nav__title" data-md-component="header-title">
      <div class="md-header-nav__ellipsis">
        <div class="md-header-nav__topic">
          <span class="md-ellipsis">
            Michale An Blog
          </span>
        </div>
        <div class="md-header-nav__topic">
          <span class="md-ellipsis">
            
              JS 数据结构
            
          </span>
        </div>
      </div>
    </div>
    
      <label class="md-header-nav__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" data-md-state="active" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <button type="reset" class="md-search__icon md-icon" aria-label="Clear" data-md-component="search-reset" tabindex="-1">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header-nav__source">
        
<a href="https://github.com/Michael18811380328/Michael18811380328.github.io/" title="Go to repository" class="md-source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 00-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 01-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 000 40.81l195.61 195.6a28.86 28.86 0 0040.8 0l194.69-194.69a28.86 28.86 0 000-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    Michael18811380328/Michael18811380328.github.io
  </div>
</a>
      </div>
    
  </nav>
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    




<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="https://michael18811380328.github.io/" title="Michale An Blog" class="md-nav__button md-logo" aria-label="Michale An Blog">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    Michale An Blog
  </label>
  
    <div class="md-nav__source">
      
<a href="https://github.com/Michael18811380328/Michael18811380328.github.io/" title="Go to repository" class="md-source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 00-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 01-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 000 40.81l195.61 195.6a28.86 28.86 0 0040.8 0l194.69-194.69a28.86 28.86 0 000-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    Michael18811380328/Michael18811380328.github.io
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="nav-1" type="checkbox" id="nav-1" checked>
      
      <label class="md-nav__link" for="nav-1">
        人生思考
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="人生思考" data-md-level="1">
        <label class="md-nav__title" for="nav-1">
          <span class="md-nav__icon md-icon"></span>
          人生思考
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        说明
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../40%E9%80%80%E4%BC%91/" class="md-nav__link">
        40退休
      </a>
    </li>
  

          
            
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          JS 数据结构
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        JS 数据结构
      </a>
      
        
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#data-structure" class="md-nav__link">
    data structure
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    第一章 概述
  </a>
  
    <nav class="md-nav" aria-label="第一章 概述">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    数据结构
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#o" class="md-nav__link">
    大O表示法和时间复杂度
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    第六章 集合
  </a>
  
    <nav class="md-nav" aria-label="第六章 集合">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    集合
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    第七章 字典和散列表
  </a>
  
    <nav class="md-nav" aria-label="第七章 字典和散列表">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    字典
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    散列表（哈希表）
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    第八章 树
  </a>
  
    <nav class="md-nav" aria-label="第八章 树">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    概念
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    二叉树
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    第九章 图
  </a>
  
    <nav class="md-nav" aria-label="第九章 图">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    概念
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    图的三种表示
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_15" class="md-nav__link">
    创建图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_16" class="md-nav__link">
    遍历图
  </a>
  
    <nav class="md-nav" aria-label="遍历图">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1-bfs" class="md-nav__link">
    1、广度优先算法 bfs
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-dfs" class="md-nav__link">
    2、深度优先算法 dfs
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_17" class="md-nav__link">
    第十章 排序和搜索算法
  </a>
  
    <nav class="md-nav" aria-label="第十章 排序和搜索算法">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_18" class="md-nav__link">
    排序算法
  </a>
  
    <nav class="md-nav" aria-label="排序算法">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1" class="md-nav__link">
    1 冒泡排序法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2" class="md-nav__link">
    2 选择排序法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3" class="md-nav__link">
    3 插入排序法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#4" class="md-nav__link">
    4 并归排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#5" class="md-nav__link">
    5 快速排序
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_19" class="md-nav__link">
    搜索算法
  </a>
  
    <nav class="md-nav" aria-label="搜索算法">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1_1" class="md-nav__link">
    1 顺序搜索
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2_1" class="md-nav__link">
    2 二分搜索
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_20" class="md-nav__link">
    第十一章 算法补充
  </a>
  
    <nav class="md-nav" aria-label="第十一章 算法补充">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_21" class="md-nav__link">
    递归
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_22" class="md-nav__link">
    迭代
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_23" class="md-nav__link">
    动态规划
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_24" class="md-nav__link">
    最少硬币找零算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_25" class="md-nav__link">
    贪心算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#o_1" class="md-nav__link">
    大O表示法与时间复杂度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_26" class="md-nav__link">
    算法比赛网站
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../Poor-and-busy/" class="md-nav__link">
        Poor-and-busy
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../Reflections%20on%20Pre-Tirement/" class="md-nav__link">
        Reflections on Pre-Tirement
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../The%20art%20of%20Execution%20%E6%89%A7%E8%A1%8C%E5%8A%9B%E7%9A%84%E8%89%BA%E6%9C%AF/" class="md-nav__link">
        The art of Execution 执行力的艺术
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../Who%20Wants%20to%20Be%20a%20Millionaire/" class="md-nav__link">
        Who Wants to Be a Millionaire
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../b%E8%AE%A1%E5%88%92/" class="md-nav__link">
        b计划
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../data%20structure%20basic/" class="md-nav__link">
        data structure basic
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../" class="md-nav__link">
        index
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../leanpub-auto-the-road-to-ecmascript-6/" class="md-nav__link">
        leanpub-auto-the-road-to-ecmascript-6
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%86%B5%E5%A2%9E/" class="md-nav__link">
        熵增
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../%E4%B8%AA%E4%BA%BA%E9%80%89%E6%8B%A9/" class="md-nav__link">
        个人选择
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../%E4%BA%BA%E7%94%9F%E7%9C%9F%E7%9B%B8/" class="md-nav__link">
        人生真相
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%85%B6%E4%BB%96%E4%B9%A6%E5%8D%95/" class="md-nav__link">
        其他书单
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../%E4%B8%B9%E5%B0%BC%E6%96%AF%E4%B8%8EUnix/" class="md-nav__link">
        丹尼斯与Unix
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../%E8%A9%B9%E5%AE%8F%E5%BF%97%E8%AF%BB%E4%B9%A6/" class="md-nav__link">
        詹宏志读书
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../%E9%AA%A1%E5%AD%90%E5%92%8C%E4%BA%BA%E7%94%9F/" class="md-nav__link">
        骡子和人生
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" class="md-nav__link">
        代码整洁之道 读书笔记
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%A6%82%E4%BD%95%E5%8F%98%E5%BE%97%E5%BC%BA%E5%A4%A7/" class="md-nav__link">
        如何变得强大
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../%E4%B8%93%E4%B8%9A%E6%95%99%E8%82%B2%E7%9A%84%E5%85%B4%E8%B5%B7/" class="md-nav__link">
        专业教育的兴起
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../%E4%B8%AD%E5%9B%BD%E7%BB%8F%E6%B5%8E%E7%9A%84%E8%BD%AC%E5%8F%98/" class="md-nav__link">
        中国经济的转变
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%A1%95%E5%A3%AB%E5%AD%A6%E4%BD%8D%E7%9A%84%E8%B4%AC%E5%80%BC/" class="md-nav__link">
        硕士学位的贬值
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../%E4%BB%BB%E6%AD%A3%E9%9D%9E%E7%9A%84%E7%AE%A1%E7%90%86%E6%80%9D%E6%83%B3/" class="md-nav__link">
        任正非的管理思想
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%8A%80%E6%9C%AF%E5%92%8C%E7%A8%B3%E5%AE%9A%E7%9A%84%E5%B7%A5%E4%BD%9C/" class="md-nav__link">
        技术和稳定的工作
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%A4%A7%E5%AD%A6%E6%95%99%E8%82%B2%E5%92%8C%E7%BD%91%E7%BB%9C%E6%96%87%E5%87%AD/" class="md-nav__link">
        大学教育和网络文凭
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E5%88%B0%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" class="md-nav__link">
        思维导图到深度学习
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../%E4%B8%AD%E5%9B%BD%E7%9A%84%E6%88%BF%E4%BB%B7%E4%BC%9A%E6%80%8E%E4%B9%88%E6%94%B6%E5%9C%BA/" class="md-nav__link">
        中国的房价会怎么收场
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%B7%A5%E4%B8%9A%E6%96%87%E6%98%8E%E5%AF%B9%E4%BA%8E%E7%A4%BE%E4%BC%9A%E7%9A%84%E5%86%B2%E5%87%BB/" class="md-nav__link">
        工业文明对于社会的冲击
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83%E5%92%8C%E5%AF%B9%E6%95%B0%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83/" class="md-nav__link">
        正态分布和对数正态分布
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2" >
      
      <label class="md-nav__link" for="nav-2">
        JS 基础
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="JS 基础" data-md-level="1">
        <label class="md-nav__title" for="nav-2">
          <span class="md-nav__icon md-icon"></span>
          JS 基础
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-JS-basic/01-%E5%85%A5%E9%97%A8/" class="md-nav__link">
        01-入门
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-JS-basic/02-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" class="md-nav__link">
        02-数据类型
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-JS-basic/03-%E8%BF%90%E7%AE%97%E7%AC%A6/" class="md-nav__link">
        03-运算符
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-JS-basic/04-%E8%AF%AD%E6%B3%95%E4%B8%93%E9%A2%98/" class="md-nav__link">
        04-语法专题
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-JS-basic/05-%E6%A0%87%E5%87%86%E5%BA%93/" class="md-nav__link">
        05-标准库
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-JS-basic/06-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/" class="md-nav__link">
        06-面向对象编程
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-JS-basic/07-%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C/" class="md-nav__link">
        07-异步操作
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-JS-basic/08-DOM/" class="md-nav__link">
        08-DOM
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-JS-basic/09-Event/" class="md-nav__link">
        09-Event
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-JS-basic/10-BOM/" class="md-nav__link">
        10-BOM
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-JS-basic/11-%E7%BD%91%E9%A1%B5%E5%85%83%E7%B4%A0%E6%8E%A5%E5%8F%A3/" class="md-nav__link">
        11-网页元素接口
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-JS-basic/readme/" class="md-nav__link">
        readme
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3" >
      
      <label class="md-nav__link" for="nav-3">
        网易云课堂笔记
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="网易云课堂笔记" data-md-level="1">
        <label class="md-nav__title" for="nav-3">
          <span class="md-nav__icon md-icon"></span>
          网易云课堂笔记
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-netease-senior-frontend/02-v8%E5%BC%95%E6%93%8E%E5%9B%9E%E6%94%B6%E5%86%85%E5%AD%98%E7%AE%80%E4%BB%8B/" class="md-nav__link">
        02-v8引擎回收内存简介
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-netease-senior-frontend/03-node%E4%B8%8B%E9%9D%A2%E7%9A%84Restful%E5%AE%9E%E7%8E%B0/" class="md-nav__link">
        03-node下面的Restful实现
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-netease-senior-frontend/04-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%9A%84%E6%8F%90%E5%8D%87%E2%80%94%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E6%88%91%E4%BB%AC%E4%BB%A3%E7%A0%81%E7%9A%84%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7/" class="md-nav__link">
        04-编程思想的提升—如何提高我们代码的可扩展性
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-netease-senior-frontend/06-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%E5%92%8Cssr/" class="md-nav__link">
        06-浏览器渲染原理和ssr
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-netease-senior-frontend/07-%E7%BD%91%E6%98%93%E7%9C%9F%E5%AE%9E%E9%A1%B9%E7%9B%AEwebpack%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90/" class="md-nav__link">
        07-网易真实项目webpack配置解析
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-netease-senior-frontend/08-%E4%BB%8E%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90API%E5%B1%82/" class="md-nav__link">
        08-从架构分析API层
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-netease-senior-frontend/09-%E5%89%8D%E7%AB%AF%E8%B4%9F%E8%B4%A3%E4%BA%BA%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AE%B9/" class="md-nav__link">
        09-前端负责人的工作内容
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-netease-senior-frontend/10-%E5%88%86%E6%9E%90%E6%BA%90%E7%A0%81%E5%AD%A6%E6%9E%B6%E6%9E%84/" class="md-nav__link">
        10-分析源码学架构
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-netease-senior-frontend/11-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81/" class="md-nav__link">
        11-设计模式高质量代码
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-netease-senior-frontend/12-nodeJS%2BMongoDB%E7%99%BB%E5%BD%95%E7%B3%BB%E7%BB%9F/" class="md-nav__link">
        12-nodeJS+MongoDB登录系统
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-netease-senior-frontend/12-nodejs-mongodb-mongoose/" class="md-nav__link">
        12-nodejs-mongodb-mongoose
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-netease-senior-frontend/13-%E4%BD%BF%E7%94%A8VUE%E5%88%9B%E5%BB%BA%E7%BB%84%E4%BB%B6%EF%BC%88%E6%B2%A1%E5%AD%A6%E5%AE%8C%EF%BC%89/" class="md-nav__link">
        13-使用VUE创建组件（没学完）
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-netease-senior-frontend/16-%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6%E5%B7%A5%E5%85%B7/" class="md-nav__link">
        16-构建自己的脚手架工具
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-netease-senior-frontend/17-webpack%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/" class="md-nav__link">
        17-webpack编译原理分析
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-netease-senior-frontend/20-%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%8A%80%E8%83%BD-VUE%EF%BC%88%E6%B2%A1%E5%AD%A6%E5%AE%8C%EF%BC%89/" class="md-nav__link">
        20-组件封装的基本技能-VUE（没学完）
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-netease-senior-frontend/21-ssr/" class="md-nav__link">
        21-ssr
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-netease-senior-frontend/24-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%A6%82%E4%BD%95%E5%81%9A/" class="md-nav__link">
        24-单元测试如何做
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-netease-senior-frontend/25-%E5%9F%BA%E4%BA%8ENodeJS%E6%89%93%E9%80%A0Web%E6%9E%B6%E6%9E%84%E4%B8%AD%E9%97%B4%E5%B1%82/" class="md-nav__link">
        25-基于NodeJS打造Web架构中间层
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-netease-senior-frontend/26-webpack%E7%9A%84%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7/" class="md-nav__link">
        26-webpack的高级技巧
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-netease-senior-frontend/readme/" class="md-nav__link">
        readme
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4" >
      
      <label class="md-nav__link" for="nav-4">
        开课吧笔记
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="开课吧笔记" data-md-level="1">
        <label class="md-nav__title" for="nav-4">
          <span class="md-nav__icon md-icon"></span>
          开课吧笔记
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-kaikeba-frontend/01%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" class="md-nav__link">
        01 性能优化
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-kaikeba-frontend/02%20%E5%89%8D%E7%AB%AF%E6%B5%8B%E8%AF%95/" class="md-nav__link">
        02 前端测试
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-kaikeba-frontend/03%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="md-nav__link">
        03 设计模式
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-kaikeba-frontend/04%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" class="md-nav__link">
        04 数据结构与算法
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-kaikeba-frontend/05%20%E9%9D%A2%E8%AF%95%E9%A2%98/" class="md-nav__link">
        05 面试题
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-kaikeba-frontend/06%20%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7/" class="md-nav__link">
        06 面试技巧
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="nav-5" type="checkbox" id="nav-5" >
      
      <label class="md-nav__link" for="nav-5">
        前端工程化笔记
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="前端工程化笔记" data-md-level="1">
        <label class="md-nav__title" for="nav-5">
          <span class="md-nav__icon md-icon"></span>
          前端工程化笔记
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-jstraining-RYF/" class="md-nav__link">
        README
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-jstraining-RYF/engineering/" class="md-nav__link">
        engineering
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-jstraining-RYF/history/" class="md-nav__link">
        history
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-jstraining-RYF/node/" class="md-nav__link">
        node
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-jstraining-RYF/preparation/" class="md-nav__link">
        preparation
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-jstraining-RYF/react/" class="md-nav__link">
        react
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="nav-6" type="checkbox" id="nav-6" >
      
      <label class="md-nav__link" for="nav-6">
        JS ES6 语法
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="JS ES6 语法" data-md-level="1">
        <label class="md-nav__title" for="nav-6">
          <span class="md-nav__icon md-icon"></span>
          JS ES6 语法
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-JSES6-RYF/readme/" class="md-nav__link">
        说明
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-JSES6-RYF/01-%E4%BB%8B%E7%BB%8D/" class="md-nav__link">
        01-介绍
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-JSES6-RYF/02-%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC/" class="md-nav__link">
        02-变量赋值
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-JSES6-RYF/03-%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/" class="md-nav__link">
        03-解构赋值
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-JSES6-RYF/04-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95/" class="md-nav__link">
        04-字符串的扩展
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-JSES6-RYF/05-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95/" class="md-nav__link">
        05-字符串方法
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-JSES6-RYF/06-%E6%AD%A3%E5%88%99/" class="md-nav__link">
        06-正则
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-JSES6-RYF/07-%E6%95%B0%E5%80%BC/" class="md-nav__link">
        07-数值
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-JSES6-RYF/08-%E5%87%BD%E6%95%B0/" class="md-nav__link">
        08-函数
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-JSES6-RYF/09-%E6%95%B0%E7%BB%84/" class="md-nav__link">
        09-数组
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-JSES6-RYF/10-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B0%E5%A2%9E%E5%B1%9E%E6%80%A7/" class="md-nav__link">
        10-对象的新增属性
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-JSES6-RYF/11-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B0%E5%A2%9E%E6%96%B9%E6%B3%95/" class="md-nav__link">
        11-对象的新增方法
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-JSES6-RYF/12-Symbol/" class="md-nav__link">
        12-Symbol
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-JSES6-RYF/13-Set%20%E5%92%8C%20Map%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="md-nav__link">
        13-Set 和 Map 数据结构
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-JSES6-RYF/14-Proxy/" class="md-nav__link">
        14-Proxy
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-JSES6-RYF/15-Reflect/" class="md-nav__link">
        15-Reflect
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-JSES6-RYF/16-Promise/" class="md-nav__link">
        16-Promise
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-JSES6-RYF/17-%E9%81%8D%E5%8E%86%E5%99%A8%E7%9A%84%E5%BE%AA%E7%8E%AF/" class="md-nav__link">
        17-遍历器的循环
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-JSES6-RYF/18-Generator/" class="md-nav__link">
        18-Generator
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-JSES6-RYF/19-Generator%E5%BC%82%E6%AD%A5%E5%BA%94%E7%94%A8/" class="md-nav__link">
        19-Generator异步应用
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-JSES6-RYF/20-async%20%E5%87%BD%E6%95%B0/" class="md-nav__link">
        20-async 函数
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-JSES6-RYF/21-Class%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/" class="md-nav__link">
        21-Class 的基本语法
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-JSES6-RYF/22-Class%20%E7%9A%84%E7%BB%A7%E6%89%BF/" class="md-nav__link">
        22-Class 的继承
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-JSES6-RYF/23-Module%20%E7%9A%84%E8%AF%AD%E6%B3%95/" class="md-nav__link">
        23-Module 的语法
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-JSES6-RYF/24-Module%20%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%AE%9E%E7%8E%B0/" class="md-nav__link">
        24-Module 的加载实现
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-JSES6-RYF/25-%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC/" class="md-nav__link">
        25-编程风格
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="nav-7" type="checkbox" id="nav-7" >
      
      <label class="md-nav__link" for="nav-7">
        Javascript 高级教程
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="Javascript 高级教程" data-md-level="1">
        <label class="md-nav__title" for="nav-7">
          <span class="md-nav__icon md-icon"></span>
          Javascript 高级教程
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../book-JS-primer-code-design/08-window/" class="md-nav__link">
        08-window
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../book-JS-primer-code-design/10-nodes/" class="md-nav__link">
        10-nodes
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../book-JS-primer-code-design/11-choose/" class="md-nav__link">
        11-choose
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../book-JS-primer-code-design/22-%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/" class="md-nav__link">
        22-高级用法
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../book-JS-primer-code-design/24-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/" class="md-nav__link">
        24-最佳实践
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../book-JS-primer-code-design/readme/" class="md-nav__link">
        readme
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="nav-8" type="checkbox" id="nav-8" >
      
      <label class="md-nav__link" for="nav-8">
        其他书籍
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="其他书籍" data-md-level="1">
        <label class="md-nav__title" for="nav-8">
          <span class="md-nav__icon md-icon"></span>
          其他书籍
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../book-JS-The-good-parts/JS-the-good-parts/" class="md-nav__link">
        JS-the-good-parts
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../book-JS-The-good-parts/curry-function/" class="md-nav__link">
        curry-function
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-javascript-secret-garden/JavaScript%20%E7%A7%98%E5%AF%86%E8%8A%B1%E5%9B%AD-zh/" class="md-nav__link">
        JavaScript 秘密花园
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ebook-javascript-secret-garden/readme.md" class="md-nav__link">
        readme
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#data-structure" class="md-nav__link">
    data structure
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    第一章 概述
  </a>
  
    <nav class="md-nav" aria-label="第一章 概述">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    数据结构
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#o" class="md-nav__link">
    大O表示法和时间复杂度
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    第六章 集合
  </a>
  
    <nav class="md-nav" aria-label="第六章 集合">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    集合
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    第七章 字典和散列表
  </a>
  
    <nav class="md-nav" aria-label="第七章 字典和散列表">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    字典
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    散列表（哈希表）
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    第八章 树
  </a>
  
    <nav class="md-nav" aria-label="第八章 树">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    概念
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    二叉树
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    第九章 图
  </a>
  
    <nav class="md-nav" aria-label="第九章 图">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    概念
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    图的三种表示
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_15" class="md-nav__link">
    创建图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_16" class="md-nav__link">
    遍历图
  </a>
  
    <nav class="md-nav" aria-label="遍历图">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1-bfs" class="md-nav__link">
    1、广度优先算法 bfs
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-dfs" class="md-nav__link">
    2、深度优先算法 dfs
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_17" class="md-nav__link">
    第十章 排序和搜索算法
  </a>
  
    <nav class="md-nav" aria-label="第十章 排序和搜索算法">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_18" class="md-nav__link">
    排序算法
  </a>
  
    <nav class="md-nav" aria-label="排序算法">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1" class="md-nav__link">
    1 冒泡排序法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2" class="md-nav__link">
    2 选择排序法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3" class="md-nav__link">
    3 插入排序法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#4" class="md-nav__link">
    4 并归排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#5" class="md-nav__link">
    5 快速排序
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_19" class="md-nav__link">
    搜索算法
  </a>
  
    <nav class="md-nav" aria-label="搜索算法">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1_1" class="md-nav__link">
    1 顺序搜索
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2_1" class="md-nav__link">
    2 二分搜索
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_20" class="md-nav__link">
    第十一章 算法补充
  </a>
  
    <nav class="md-nav" aria-label="第十一章 算法补充">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_21" class="md-nav__link">
    递归
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_22" class="md-nav__link">
    迭代
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_23" class="md-nav__link">
    动态规划
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_24" class="md-nav__link">
    最少硬币找零算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_25" class="md-nav__link">
    贪心算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#o_1" class="md-nav__link">
    大O表示法与时间复杂度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_26" class="md-nav__link">
    算法比赛网站
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="https://github.com/Michael18811380328/Michael18811380328.github.io/edit/master/docs/other/JS 数据结构.md" title="Edit this page" class="md-content__button md-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75L3 17.25z"/></svg>
                  </a>
                
                
                  <h1>JS 数据结构</h1>
                
                <h2 id="data-structure">data structure<a class="headerlink" href="#data-structure" title="Permanent link">&para;</a></h2>
<p>数据结构</p>
<ol>
<li>数组 array</li>
<li>链表 linked list</li>
<li>队列 queue</li>
<li>栈 stack</li>
<li>堆 heap</li>
<li>树 tree</li>
<li>散列(哈希) hash</li>
<li>图 graph</li>
</ol>
<p>这部分内容需要不断复习，核心代码自己抄三次，需要默写关键逻辑</p>
<p>参考书</p>
<p>《学习JavaScript数据结构与算法》巴西 格罗纳（Loiane Groner）</p>
<p>《实用数据结构》清华大学林小茶写（C语言）</p>
<h2 id="_1">第一章 概述<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h2>
<h3 id="_2">数据结构<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h3>
<p>数据结构：把数据做到有效的安排，并建立数据之间的关系（数据+数据间的关系）。</p>
<p>数据结构三个要点：信息之间的逻辑关系，信息在计算机中的物理存储方式，对信息的运算（增删改查排序）。数据的逻辑结构：分为线性结构（线性表）和非线性结构（树和图）。数据的物理结构：顺序存储结构（逻辑上相邻的节点在物理存储上也相邻）、链式存储结构（逻辑上相邻的节点在物理上不一定相邻，节点的逻辑关系由指针描述）、索引存储结构（建立索引表来标识节点的地址）、散列存储结构（根据节点的关键字直接计算出节点的存储地址）。</p>
<p>数据&gt;数据元素&gt;数据项：数据对应数据表，数据元素对应数据表的一条信息，数据项是最小的信息单元（对应某条信息的某个属性）</p>
<h3 id="_3">算法<a class="headerlink" href="#_3" title="Permanent link">&para;</a></h3>
<p>计算和算法的区别：计算简单的四则运算直接使用数学函数，计算复杂的问题（例如迷宫和贪吃蛇）需要算法。同一个算法用不同的数据结构会产生不同的执行效率。所以要定量分析不同数据结构表示的效率和适用的场合。这就是数据结构和算法的联系。</p>
<p>解决问题的数据结构很好理解，但是实现数据结构的算法比较难。</p>
<p>算法的特点：具有输入输出，有穷性（避免死循环），确定性（每一步是明确的结果），可行性（算法中每一步通过有限次运行可以实现）。</p>
<h3 id="o">大O表示法和时间复杂度<a class="headerlink" href="#o" title="Permanent link">&para;</a></h3>
<p>时间复杂度：把算法中包含简单操作的次数叫做算法的时间复杂度，衡量算法的性能。大O表示法将简单操作的次数取极限获取（常见的优劣记住）。</p>
<p>空间复杂度：计算过程中需要消耗的内存（存储int和object消耗内存不同）。</p>
<h2 id="_4">第六章 集合<a class="headerlink" href="#_4" title="Permanent link">&para;</a></h2>
<h3 id="_5">集合<a class="headerlink" href="#_5" title="Permanent link">&para;</a></h3>
<p>集合是唯一的项的集合，类似于数学中的有限级。如果集合中没有元素就是空集。计算机中的集合也有交集、并集、差集的计算。集合基于 ES6 的 Set。集合中的元素是无序的，所以可以使用对象实现（也可以使用数组）</p>
<div class="highlight"><pre><span></span><code><span class="kd">function</span> <span class="nx">Set</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">items</span> <span class="o">=</span> <span class="p">{};</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">has</span> <span class="o">=</span> <span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="c1">// return value in items;</span>
    <span class="k">return</span> <span class="nx">items</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span> <span class="c1">// better</span>
  <span class="p">}</span>

  <span class="k">this</span><span class="p">.</span><span class="nx">add</span> <span class="o">=</span> <span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">value</span><span class="p">))</span> <span class="p">{</span>
      <span class="nx">items</span><span class="p">[</span><span class="nx">value</span><span class="p">]</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
      <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">this</span><span class="p">.</span><span class="nx">remove</span> <span class="o">=</span> <span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">value</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">delete</span> <span class="nx">items</span><span class="p">[</span><span class="nx">value</span><span class="p">];</span>
      <span class="k">return</span> <span class="kc">true</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">this</span><span class="p">.</span><span class="nx">clear</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">items</span> <span class="o">=</span> <span class="p">{};</span>
  <span class="p">}</span>

  <span class="k">this</span><span class="p">.</span><span class="nx">size</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">items</span><span class="p">).</span><span class="nx">length</span><span class="p">;</span> <span class="c1">//es5</span>
  <span class="p">}</span>

  <span class="k">this</span><span class="p">.</span><span class="nx">sizeLegacy</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">count</span> <span class="o">=</span> <span class="mf">0</span><span class="p">;</span>
    <span class="c1">// 这里不能直接使用for-in循环，这样会遍历到继承的属性（继承的属性不属于集合的属性）；所以需要使用hasOwnProperty 监测是否属于对象自己的属性</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">key</span> <span class="k">in</span> <span class="nx">items</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">items</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">key</span><span class="p">))</span> <span class="p">{</span>
        <span class="nx">count</span><span class="o">++</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">count</span><span class="p">;</span> <span class="c1">//es3</span>
  <span class="p">}</span>

  <span class="k">this</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">items</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">();</span>
<span class="nx">set</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="mf">1</span><span class="p">);</span>
<span class="nx">set</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="mf">2</span><span class="p">);</span>
</code></pre></div>
<p>下面是集合的运算</p>
<div class="highlight"><pre><span></span><code><span class="kd">function</span> <span class="nx">Set</span><span class="p">()</span> <span class="p">{</span>

  <span class="c1">// 并集</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">unionSet</span> <span class="o">=</span> <span class="p">(</span><span class="nx">set</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">unionSet</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">();</span>
    <span class="kd">let</span> <span class="nx">values</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">values</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mf">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">values</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">unionSet</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">values</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="nx">values</span> <span class="o">=</span> <span class="nx">set</span><span class="p">.</span><span class="nx">values</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="mf">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">values</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">unionSet</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">values</span><span class="p">[</span><span class="nx">j</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">unionSet</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 交集</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">interSection</span> <span class="o">=</span> <span class="p">(</span><span class="nx">otherSet</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">interSection</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">();</span>
    <span class="kd">let</span> <span class="nx">values</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">values</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mf">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">values</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">other</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">values</span><span class="p">[</span><span class="nx">i</span><span class="p">]))</span> <span class="p">{</span>
        <span class="nx">interSection</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">values</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">interSection</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 差集</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">difference</span> <span class="o">=</span> <span class="p">(</span><span class="nx">otherSet</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">differenceSet</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">();</span>
    <span class="kd">let</span> <span class="nx">values</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">values</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mf">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">values</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">otherSet</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">values</span><span class="p">[</span><span class="nx">i</span><span class="p">]))</span> <span class="p">{</span>
        <span class="nx">differenceSet</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">values</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">differenceSet</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 子集</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">sebSet</span> <span class="o">=</span> <span class="p">(</span><span class="nx">otherSet</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="nx">otherSet</span><span class="p">.</span><span class="nx">size</span><span class="p">())</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kc">false</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="kd">let</span> <span class="nx">values</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">values</span><span class="p">();</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mf">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">values</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">otherSet</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">values</span><span class="p">[</span><span class="nx">i</span><span class="p">]))</span> <span class="p">{</span>
          <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="_6">第七章 字典和散列表<a class="headerlink" href="#_6" title="Permanent link">&para;</a></h2>
<p>集合、字典、散列表都是存储唯一值的数据结构（不重复）。集合关注的是值，字典和散列表关注的是键值对。</p>
<h3 id="_7">字典<a class="headerlink" href="#_7" title="Permanent link">&para;</a></h3>
<p>字典的实际使用：地址簿或者英语字典</p>
<p>字典对应于JS中的 Map 对象</p>
<div class="highlight"><pre><span></span><code><span class="kd">function</span> <span class="nx">Dictionary</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">items</span> <span class="o">=</span> <span class="p">{};</span>

  <span class="k">this</span><span class="p">.</span><span class="nx">has</span> <span class="o">=</span> <span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">key</span> <span class="k">in</span> <span class="nx">items</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">this</span><span class="p">.</span><span class="nx">set</span> <span class="o">=</span> <span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">items</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">this</span><span class="p">.</span><span class="nx">remove</span> <span class="o">=</span> <span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">items</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">key</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">delete</span> <span class="nx">items</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span>
      <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">this</span><span class="p">.</span><span class="nx">get</span> <span class="o">=</span> <span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">items</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="o">?</span> <span class="nx">items</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">:</span> <span class="kc">undefined</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">this</span><span class="p">.</span><span class="nx">values</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">values</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">key</span> <span class="k">in</span> <span class="nx">items</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">key</span><span class="p">))</span> <span class="p">{</span>
        <span class="nx">values</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">items</span><span class="p">[</span><span class="nx">key</span><span class="p">]);</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">values</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">this</span><span class="p">.</span><span class="nx">clear</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">items</span> <span class="o">=</span> <span class="p">{};</span>
  <span class="p">}</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">keys</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">items</span><span class="p">.</span><span class="nx">keys</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">this</span><span class="p">.</span><span class="nx">size</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">items</span><span class="p">).</span><span class="nx">length</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">this</span><span class="p">.</span><span class="nx">getItems</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">items</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="_8">散列表（哈希表）<a class="headerlink" href="#_8" title="Permanent link">&para;</a></h3>
<p>散列表，HashTable 又称哈希表。</p>
<p>散列算法：在数据结构中尽快找到一个值。给定一个键值对，散列函数可以获取一个地址，因此能够快速检索到这个值。</p>
<p>最简单的散列函数：把一个键的每一个字母的ASCII值相加，得到散列值。</p>
<div class="highlight"><pre><span></span><code><span class="kd">function</span> <span class="nx">HashTable</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">table</span> <span class="o">=</span> <span class="p">[];</span>

  <span class="c1">// 散列函数(工具函数) 下面简写为 loseHashCode</span>
    <span class="nx">loseloseHashCode</span> <span class="o">=</span> <span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">hash</span> <span class="o">=</span> <span class="mf">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mf">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">key</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">hash</span> <span class="o">+=</span> <span class="nx">key</span><span class="p">.</span><span class="nx">charCodeAt</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">hash</span> <span class="o">%</span> <span class="mf">37</span><span class="p">;</span>
    <span class="c1">// 为了获取一个较小的数值，所以用hash值除以一个数，获取余数</span>
  <span class="p">}</span>

  <span class="k">this</span><span class="p">.</span><span class="nx">put</span> <span class="o">=</span> <span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">position</span> <span class="o">=</span> <span class="nx">loseHashCode</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span>
    <span class="nx">table</span><span class="p">[</span><span class="nx">position</span><span class="p">]</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">this</span><span class="p">.</span><span class="nx">get</span> <span class="o">=</span> <span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">table</span><span class="p">[</span><span class="nx">loseHashCode</span><span class="p">(</span><span class="nx">key</span><span class="p">)];</span>
  <span class="p">}</span>

  <span class="k">this</span><span class="p">.</span><span class="nx">remove</span> <span class="o">=</span> <span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">table</span><span class="p">[</span><span class="nx">loseHashCode</span><span class="p">(</span><span class="nx">key</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">this</span><span class="p">.</span><span class="nx">print</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mf">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">table</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">table</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="nx">table</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

<span class="p">}</span>
</code></pre></div>
<p>对于哈希表，不需要把数组中对应的位置删掉。因为哈希表一部分项没有元素（空位），默认是undefined。如果删除一个位置后，下次获取或者删除一个项时，这个元素不在散列函数求出的位置上。</p>
<p>如果地址簿中 key = 'John' 根据散列函数计算的散列值是29，那么存储在 table[29] 中。当然，现在还有散列函数中冲突等问题，稍后解决。</p>
<p><mark>处理哈希表中的冲突</mark>：可能不同的键转化的散列值是相同的，所以产生了多对一的情况，就会产生冲突。解决这个问题的方法是：分离链接、线性探查、双散列法。</p>
<p><mark>分离链接</mark>：在每一个哈希值的位置，放置一个线性链表。如果多个数据对应一个散列值，可以放在对应的链表中。缺点是需要开辟新的内存存放这部分数据。</p>
<div class="highlight"><pre><span></span><code><span class="c1">// 分离链接：首先写一个辅助类（在哈希表内部），把键值对存放在一个对象实例中</span>
<span class="kd">let</span> <span class="nx">ValuePair</span> <span class="o">=</span> <span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">key</span> <span class="o">=</span> <span class="nx">key</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// 注意：上面是一个类（可以把key value 设置到当前类的属性上）</span>

<span class="c1">// 下面改写散列表的方法</span>
<span class="k">this</span><span class="p">.</span><span class="nx">put</span> <span class="o">=</span> <span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">position</span> <span class="o">=</span> <span class="nx">lostHashCode</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">table</span><span class="p">[</span><span class="nx">position</span><span class="p">]</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">table</span><span class="p">[</span><span class="nx">position</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">LinkedList</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ValuePair</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
  <span class="nx">table</span><span class="p">[</span><span class="nx">position</span><span class="p">].</span><span class="nx">append</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">this</span><span class="p">.</span><span class="nx">get</span> <span class="o">=</span> <span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">position</span> <span class="o">=</span> <span class="nx">loseHashCode</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">table</span><span class="p">[</span><span class="nx">position</span><span class="p">]</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">var</span> <span class="nx">current</span> <span class="o">=</span> <span class="nx">table</span><span class="p">[</span><span class="nx">position</span><span class="p">].</span><span class="nx">getHead</span><span class="p">();</span>
  <span class="k">while</span> <span class="p">(</span><span class="nx">current</span><span class="p">.</span><span class="nx">next</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">current</span><span class="p">.</span><span class="nx">element</span><span class="p">.</span><span class="nx">key</span> <span class="o">===</span> <span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">current</span><span class="p">.</span><span class="nx">element</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nx">current</span> <span class="o">=</span> <span class="nx">current</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">current</span><span class="p">.</span><span class="nx">element</span><span class="p">.</span><span class="nx">key</span> <span class="o">===</span> <span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">current</span><span class="p">.</span><span class="nx">element</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">this</span><span class="p">.</span><span class="nx">remove</span> <span class="o">=</span> <span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">position</span> <span class="o">=</span> <span class="nx">loseHashCode</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">table</span><span class="p">[</span><span class="nx">position</span><span class="p">]</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">current</span> <span class="o">=</span> <span class="nx">table</span><span class="p">[</span><span class="nx">position</span><span class="p">].</span><span class="nx">getHead</span><span class="p">();</span>
    <span class="k">while</span> <span class="p">(</span><span class="nx">current</span><span class="p">.</span><span class="nx">next</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">current</span><span class="p">.</span><span class="nx">element</span><span class="p">.</span><span class="nx">key</span> <span class="o">===</span> <span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">table</span><span class="p">[</span><span class="nx">position</span><span class="p">].</span><span class="nx">remove</span><span class="p">(</span><span class="nx">current</span><span class="p">.</span><span class="nx">element</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">table</span><span class="p">[</span><span class="nx">position</span><span class="p">].</span><span class="nx">isEmpty</span><span class="p">())</span> <span class="p">{</span>
          <span class="nx">table</span><span class="p">[</span><span class="nx">position</span><span class="p">]</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="kc">true</span>
      <span class="p">}</span>
      <span class="nx">current</span> <span class="o">=</span> <span class="nx">current</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">current</span><span class="p">.</span><span class="nx">element</span><span class="p">.</span><span class="nx">key</span> <span class="o">===</span> <span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">table</span><span class="p">[</span><span class="nx">position</span><span class="p">].</span><span class="nx">remove</span><span class="p">(</span><span class="nx">current</span><span class="p">.</span><span class="nx">element</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">table</span><span class="p">[</span><span class="nx">position</span><span class="p">].</span><span class="nx">isEmpty</span><span class="p">())</span> <span class="p">{</span>
        <span class="nx">table</span><span class="p">[</span><span class="nx">position</span><span class="p">]</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p><mark>线性探查</mark>：如果产生冲突 table[i] 已经有值，继续查询table[i+1]，只到下一个空位。好处：不需要建立新的数据结构。散列表的相关方法也要改动。</p>
<div class="highlight"><pre><span></span><code><span class="k">this</span><span class="p">.</span><span class="nx">put</span> <span class="o">=</span> <span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">position</span> <span class="o">=</span> <span class="nx">loseHashCode</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">table</span><span class="p">[</span><span class="nx">position</span><span class="p">]</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">table</span><span class="p">[</span><span class="nx">position</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ValuePair</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">index</span> <span class="o">=</span> <span class="o">++</span><span class="nx">position</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="nx">table</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">index</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nx">table</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ValuePair</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// 注意：在JS中数组的长度可以自动增加，所以线性探查不会出问题。在C语言中数组的长度是固定的，如果数组的位置用完了，需要开辟新的内存地址。</span>

<span class="k">this</span><span class="p">.</span><span class="nx">get</span> <span class="o">=</span> <span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">position</span> <span class="o">=</span> <span class="nx">loseHashCode</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">table</span><span class="p">[</span><span class="nx">position</span><span class="p">]</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">table</span><span class="p">[</span><span class="nx">position</span><span class="p">].</span><span class="nx">key</span> <span class="o">===</span> <span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">table</span><span class="p">[</span><span class="nx">position</span><span class="p">].</span><span class="nx">value</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
      <span class="kd">let</span> <span class="nx">index</span> <span class="o">=</span> <span class="o">++</span><span class="nx">position</span><span class="p">;</span>
      <span class="k">while</span> <span class="p">(</span><span class="nx">table</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span> <span class="o">===</span> <span class="kc">undefined</span> <span class="o">||</span> <span class="nx">table</span><span class="p">[</span><span class="nx">index</span><span class="p">].</span><span class="nx">key</span> <span class="o">!==</span> <span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">index</span><span class="o">++</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">table</span><span class="p">[</span><span class="nx">index</span><span class="p">].</span><span class="nx">key</span> <span class="o">===</span> <span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">table</span><span class="p">[</span><span class="nx">index</span><span class="p">.</span><span class="nx">value</span><span class="p">];</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">this</span><span class="p">.</span><span class="nx">remove</span> <span class="o">=</span> <span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">position</span> <span class="o">=</span> <span class="nx">loseHashCode</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">table</span><span class="p">[</span><span class="nx">position</span><span class="p">]</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">table</span><span class="p">[</span><span class="nx">position</span><span class="p">].</span><span class="nx">key</span> <span class="o">===</span> <span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">table</span><span class="p">[</span><span class="nx">position</span><span class="p">]</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span>
      <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="kd">let</span> <span class="nx">index</span> <span class="o">=</span> <span class="o">++</span><span class="nx">position</span><span class="p">;</span>
      <span class="k">while</span> <span class="p">(</span><span class="nx">table</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span> <span class="o">===</span> <span class="kc">undefined</span> <span class="o">||</span> <span class="nx">table</span><span class="p">[</span><span class="nx">index</span><span class="p">].</span><span class="nx">key</span> <span class="o">!==</span> <span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">index</span><span class="o">++</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">table</span><span class="p">[</span><span class="nx">index</span><span class="p">].</span><span class="nx">key</span> <span class="o">===</span> <span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">table</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span>
        <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p><mark>更好的散列函数</mark> 之前的散列函数会产生很多散列冲突，所以我们需要写一个冲突少，性能好的函数。下面的函数是社区推荐的较好的散列函数。</p>
<div class="highlight"><pre><span></span><code><span class="kd">function</span> <span class="nx">djb2HashCode</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">hash</span> <span class="o">=</span> <span class="mf">5381</span><span class="p">;</span> <span class="c1">// 设置一个初始质数（现在使用5381）</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mf">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">key</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">hash</span> <span class="o">=</span> <span class="nx">hash</span> <span class="o">*</span> <span class="mf">33</span> <span class="o">+</span> <span class="nx">key</span><span class="p">.</span><span class="nx">charCodeAt</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span> <span class="c1">// 5381 * 33 获取一个魔力数 </span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">hash</span> <span class="o">%</span> <span class="mf">1013</span><span class="p">;</span> <span class="c1">// 这里的值是大于散列个数的一个质数（如果散列有1000，那么这个选择1013）</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="_9">第八章 树<a class="headerlink" href="#_9" title="Permanent link">&para;</a></h2>
<h3 id="_10">概念<a class="headerlink" href="#_10" title="Permanent link">&para;</a></h3>
<p>树：N个有限数据的集合，可以是一个空树。树只有一个根节点，没有子节点的节点是叶节点。每一个子节点本身又是一棵树（递归）。适应于快速存储查找数据。</p>
<p>结点：一个数据元素及其指向子树的分支信息。</p>
<p>结点的度：一个节点的子节点的个数</p>
<p>树的度：节点的度的最大值。</p>
<p>树的层数：根节点是1，从上到下增加。</p>
<p>树的深度：树共计有多少层，等于树的层数的最大值。</p>
<p>有序树和无序树：如果子树的顺序可以变化，就是无序树。（DOM树中，如果子树可以变化，那么界面排布就混乱了，所以DOM树是有序树）。</p>
<h3 id="_11">二叉树<a class="headerlink" href="#_11" title="Permanent link">&para;</a></h3>
<p>二叉树：一个节点最多只有两个子树（左子树右子树）。普通的树可以和二叉树互相转换：左子树表示当前节点的第一个子树，右子树表示当前节点的兄弟节点。二叉树可以由顺序存储结构或者链式存储结构表示。二叉树的遍历：前序遍历（根左右）、中序遍历（左根右）、后续遍历（左右根）。</p>
<p>二叉搜索树：左节点&lt;自身&lt;右节点（BST，binary search tree）这里经常使用递归。</p>
<div class="highlight"><pre><span></span><code><span class="kd">function</span> <span class="nx">BinarySearchTree</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">Node</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">key</span> <span class="o">=</span> <span class="nx">key</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">left</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">right</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// 这里使用指针表示节点的指向，左右指针分别指向左节点和右节点。</span>
  <span class="kd">var</span> <span class="nx">root</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span> <span class="c1">// 根元素</span>

  <span class="c1">// 插入节点函数(处理根节点)</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">insert</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">newNode</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Node</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">root</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">root</span> <span class="o">=</span> <span class="nx">newNode</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">insertNode</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="nx">newNode</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="c1">// 插入节点辅助函数（递归比较插入节点）</span>
  <span class="kd">let</span> <span class="nx">insertNode</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="nx">newNode</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 如果当前节点的值大于新节点，那么放在左节点处理</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">newNode</span><span class="p">.</span><span class="nx">key</span> <span class="o">&lt;</span> <span class="nx">node</span><span class="p">.</span><span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">node</span><span class="p">.</span><span class="nx">left</span> <span class="o">=</span> <span class="nx">newNode</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">insertNode</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">,</span> <span class="nx">newNode</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// 如果当前节点的值小于等于新节点，那么新节点放在右节点处理。插入后，当前节点的值和右节点的值可能相同</span>
    <span class="k">else</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">node</span><span class="p">.</span><span class="nx">right</span> <span class="o">=</span> <span class="nx">newNode</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">insertNode</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">,</span> <span class="nx">newNode</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// 遍历节点</span>
  <span class="c1">//（中序遍历，按照大小顺序遍历节点）</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">inOrderTraverse</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">inOrderTraverseNode</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="nx">callback</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kd">let</span> <span class="nx">inOrderTraverseNode</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">node</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">inOrderTraverseNode</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">);</span>
      <span class="nx">callback</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">key</span><span class="p">);</span>
      <span class="nx">inOrderTraverseNode</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="c1">// 先序遍历(根左右，打印一个结构化的文档)</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">preOrderTraverse</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">preOrderTraverseNode</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="kd">let</span> <span class="nx">preOrderTraverseNode</span><span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">node</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">callback</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">key</span><span class="p">);</span>
      <span class="nx">preOrderTraverseNode</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">);</span>
      <span class="nx">preOrderTraverseNode</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="c1">// 后续遍历（左右根，计算文件或者文件夹的大小）</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">postOrderTraverse</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">postOrderTraverseNode</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="nx">callback</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kd">let</span> <span class="nx">postOrderTraverseNode</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">node</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">postOrderTraverseNode</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">);</span>
      <span class="nx">postOrderTraverseNode</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">);</span>
      <span class="nx">callback</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">key</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// search(第一个函数是对外暴露的API，下面的辅助函数是内部函数)</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">min</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">minNode</span><span class="p">(</span><span class="nx">root</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kd">let</span> <span class="nx">minNode</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// the left node is min node</span>
      <span class="k">while</span> <span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">node</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">node</span><span class="p">.</span><span class="nx">key</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">this</span><span class="p">.</span><span class="nx">max</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">maxNode</span><span class="p">(</span><span class="nx">root</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kd">let</span> <span class="nx">maxNode</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">while</span> <span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">node</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">node</span><span class="p">.</span><span class="nx">key</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">this</span><span class="p">.</span><span class="nx">search</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">searchNode</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="nx">key</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kd">let</span> <span class="nx">searchNode</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">node</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">key</span> <span class="o">&lt;</span> <span class="nx">node</span><span class="p">.</span><span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">searchNode</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">,</span> <span class="nx">key</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">key</span> <span class="o">&gt;</span> <span class="nx">node</span><span class="p">.</span><span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">searchNode</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">,</span> <span class="nx">key</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// remove Node 较复杂</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">remove</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">root</span> <span class="o">=</span> <span class="nx">removeNode</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="nx">key</span><span class="p">);</span> 
  <span class="p">}</span>
  <span class="kd">let</span> <span class="nx">removeNode</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">node</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">key</span> <span class="o">&lt;</span> <span class="nx">node</span><span class="p">.</span><span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">node</span><span class="p">.</span><span class="nx">left</span> <span class="o">=</span> <span class="nx">removeNode</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">);</span>
      <span class="k">return</span> <span class="nx">node</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">key</span> <span class="o">&gt;</span> <span class="nx">node</span><span class="p">.</span><span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">node</span><span class="p">.</span><span class="nx">right</span> <span class="o">=</span> <span class="nx">removeNode</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">);</span>
      <span class="k">return</span> <span class="nx">node</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">key</span> <span class="o">===</span> <span class="nx">node</span><span class="p">.</span><span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span> <span class="o">===</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="nx">node</span><span class="p">.</span><span class="nx">right</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">node</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
        <span class="k">return</span> <span class="nx">node</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">node</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">;</span>
        <span class="k">return</span> <span class="nx">node</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">node</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">;</span>
        <span class="k">return</span> <span class="nx">node</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="c1">// 被删除的节点具有左右子节点(删除当前节点，将右侧最小节点作为父节点，或者把左侧最大节点作为父节点)</span>
        <span class="kd">let</span> <span class="nx">aux</span> <span class="o">=</span> <span class="nx">findMinNode</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">);</span>
      <span class="nx">node</span><span class="p">.</span><span class="nx">key</span> <span class="o">=</span> <span class="nx">aux</span><span class="p">.</span><span class="nx">key</span><span class="p">;</span>
      <span class="nx">node</span><span class="p">.</span><span class="nx">right</span> <span class="o">=</span> <span class="nx">removeNode</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">.</span> <span class="nx">aux</span><span class="p">.</span><span class="nx">key</span><span class="p">);</span>
      <span class="k">return</span> <span class="nx">node</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>二叉搜索树的不足：可能一部分分支特别长或者特别短，不平衡。这样操作某个长分支会消耗性能。</p>
<p>改进版：自平衡二叉搜索树（AVL树， 阿德尔森-维尔斯和兰迪斯树）任意节点左右子节点高度的差最大是1。</p>
<p>还有红黑树（进行高效的中序遍历）和堆积树。</p>
<h2 id="_12">第九章 图<a class="headerlink" href="#_12" title="Permanent link">&para;</a></h2>
<p>社交网络、通信道路等都可以使用图描述。</p>
<h3 id="_13">概念<a class="headerlink" href="#_13" title="Permanent link">&para;</a></h3>
<p>G = (V, E) 图是由一系列节点和边组成</p>
<p>相邻顶点：相邻的两个顶点（由一条边连接）</p>
<p>顶点的度：一个顶点相邻顶点的个数</p>
<p>路径：若干相邻的边构成的序列</p>
<p>简单路径：不包括重复顶点的路径</p>
<p>环：简单路径中首尾相同</p>
<p>无环路径</p>
<p>连通路径：任意两个顶点间存在路径</p>
<p>有向图：边是一个向量，具有方向（交通图）；无向图：边没有方向（人际圈）；强连通（每两个顶点间双向连通）</p>
<p>加权：边具有权值</p>
<p>图相对之前的数据结构最复杂，解决方法很多。</p>
<h3 id="_14">图的三种表示<a class="headerlink" href="#_14" title="Permanent link">&para;</a></h3>
<p>邻接矩阵：使用一个二维数组，如果两个点有边那么对应的二维数组就是1，否则就是0.（如果加权图，那么数值就是权重）。弊端：如果一个稀疏图（内部联系较少），那么这个矩阵需要存储很多0，占用内容。新开辟一个顶点会占用较多内存，需要迭代一行。</p>
<p>邻接表：使用链表，散列表，字典表示。描述每一个顶点的链接关系。</p>
<p>关联矩阵：使用顶点和边作为矩阵的两边，适应于边的数量很多。</p>
<h3 id="_15">创建图<a class="headerlink" href="#_15" title="Permanent link">&para;</a></h3>
<p>使用邻接表方式（字典）</p>
<div class="highlight"><pre><span></span><code><span class="kd">function</span> <span class="nx">Graph</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">vertices</span> <span class="o">=</span> <span class="p">[];</span> <span class="c1">// 存放顶点数组</span>
  <span class="kd">let</span> <span class="nx">adjList</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Dictionary</span><span class="p">();</span> <span class="c1">// 存放顶点的邻接表</span>

  <span class="c1">// 增加一个顶点：将顶点添加到顶点数组中，并且在顶点的邻接表中加入对应的属性（空数组）</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">addVertex</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">point</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">vertices</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">point</span><span class="p">);</span>
    <span class="nx">adjList</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">point</span><span class="p">,</span> <span class="p">[]);</span>
  <span class="p">},</span>

  <span class="c1">// 增加一个边：传入两个顶点，增加邻接表中两点间边</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">addEdge</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">point</span><span class="p">,</span> <span class="nx">point2</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">adjList</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">point</span><span class="p">).</span><span class="nx">push</span><span class="p">(</span><span class="nx">point2</span><span class="p">);</span>
    <span class="nx">adjList</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">point2</span><span class="p">).</span><span class="nx">push</span><span class="p">(</span><span class="nx">point</span><span class="p">);</span> <span class="c1">// 如果是有向图，需要单向添加边；无向图需要添加两个边</span>
  <span class="p">},</span>

  <span class="k">this</span><span class="p">.</span><span class="nx">toString</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">s</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mf">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">vertices</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">s</span> <span class="o">+=</span> <span class="nx">vertices</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span><span class="p">;</span>
      <span class="kd">let</span> <span class="nx">neighbors</span> <span class="o">=</span> <span class="nx">adjList</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">vertices</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="mf">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">neighbor</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">s</span> <span class="o">+=</span> <span class="nx">neighbor</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>
      <span class="p">}</span>
      <span class="nx">s</span> <span class="o">+=</span> <span class="s1">&#39;\n&#39;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">s</span><span class="p">;</span>
  <span class="p">},</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="_16">遍历图<a class="headerlink" href="#_16" title="Permanent link">&para;</a></h3>
<p>遍历的目的：寻找某个顶点；计算两个顶点的距离；检查图是否连通或者有环结构</p>
<p>算法：获取第一次访问的节点，并且记录没有被访问的节点（加入到列表中）</p>
<p>遍历的方法：广度优先搜索；深度优先搜索。广度优先搜索使用队列，把待访问的节点放入队列中，先入的节点先探索（先访问兄弟节点）；深度优先搜索使用栈，如果存在新的顶点就去访问（先访问孙子节点）。为了效率，每个节点最多访问两次。</p>
<p>顶点分为三种状态：没有访问到，已经访问但是没有深入探索；已经深入探索；</p>
<h4 id="1-bfs">1、广度优先算法 bfs<a class="headerlink" href="#1-bfs" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code> <span class="kd">let</span> <span class="nx">initializeColor</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// 辅助函数：初始化图：全部的节点是白色（未访问）</span>
  <span class="kd">let</span> <span class="nx">color</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mf">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">vertices</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">color</span><span class="p">[</span><span class="nx">vertices</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span> <span class="o">=</span> <span class="s1">&#39;white&#39;</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">color</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">this</span><span class="p">.</span><span class="nx">bfs</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 初始化图（全部节点是白色）</span>
  <span class="kd">let</span> <span class="nx">color</span> <span class="o">=</span> <span class="nx">initializeColor</span><span class="p">();</span>
  <span class="kd">let</span> <span class="nx">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Queue</span><span class="p">();</span>
  <span class="c1">// 把当前节点入队列</span>
  <span class="nx">queue</span><span class="p">.</span><span class="nx">enqueue</span><span class="p">(</span><span class="nx">v</span><span class="p">);</span>

  <span class="c1">// 当队列时非空时</span>
  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="nx">queue</span><span class="p">.</span><span class="nx">isEmpty</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// 第一个元素出队列</span>
    <span class="kd">let</span> <span class="nx">u</span> <span class="o">=</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">dequeue</span><span class="p">();</span>
    <span class="c1">// 从字典中获取当前节点的全部相邻节点</span>
    <span class="kd">let</span> <span class="nx">neighbors</span> <span class="o">=</span> <span class="nx">adjList</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">u</span><span class="p">);</span>
    <span class="c1">// 设置节点是灰色（已经访问，但是没有深入）</span>
    <span class="nx">color</span><span class="p">[</span><span class="nx">u</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;grey&#39;</span><span class="p">;</span>
    <span class="c1">// 遍历每一个相邻节点</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mf">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">neighbors</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">let</span> <span class="nx">w</span> <span class="o">=</span> <span class="nx">neighbors</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
      <span class="c1">// 如果相邻节点没有被访问，那么设置这个节点被访问，并且放入待遍历的队列中</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">color</span><span class="p">[</span><span class="nx">w</span><span class="p">]</span> <span class="o">===</span> <span class="s1">&#39;white&#39;</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">color</span><span class="p">[</span><span class="nx">w</span><span class="p">]</span> <span class="o">===</span> <span class="s1">&#39;grey&#39;</span><span class="p">;</span>
        <span class="nx">queue</span><span class="p">.</span><span class="nx">enqueue</span><span class="p">(</span><span class="nx">w</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// 深入后的节点设置属性为黑色</span>
    <span class="nx">color</span><span class="p">[</span><span class="nx">u</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;black&#39;</span><span class="p">;</span>
    <span class="c1">// 如果传入回调函数，出队列的节点执行回调函数</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">callback</span><span class="p">)</span> <span class="nx">callback</span><span class="p">(</span><span class="nx">u</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>改进算法：使用BFS算法计算不同节点的距离：在遍历相邻节点时，增加一个距离变量，这样可以存储不同相邻节点和初始节点的位置。下面是优化后的算法</p>
<p>疑问：如果是子节点有不同的路径，通过多个路径可以访问一个节点，那么哪个路径是最短对的路径？</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span> <span class="nx">BFS</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">color</span> <span class="o">=</span> <span class="nx">initializeColor</span><span class="p">();</span>
  <span class="kd">let</span> <span class="nx">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Queue</span><span class="p">();</span>
  <span class="kd">let</span> <span class="nx">d</span> <span class="o">=</span> <span class="p">[];</span> <span class="c1">// 存放不同节点的路径</span>
  <span class="kd">let</span> <span class="nx">pred</span> <span class="o">=</span> <span class="p">[];</span> <span class="c1">// 存放前一个节点，用来计算最短距离</span>

  <span class="nx">queue</span><span class="p">.</span><span class="nx">enqueue</span><span class="p">(</span><span class="nx">v</span><span class="p">);</span>

  <span class="c1">// 初始化全部的路径距离是0，前一个节点是空</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mf">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">vertices</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">d</span><span class="p">[</span><span class="nx">vertices</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span> <span class="o">=</span> <span class="mf">0</span><span class="p">;</span>
    <span class="nx">pred</span><span class="p">[</span><span class="nx">vertices</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="nx">queue</span><span class="p">.</span><span class="nx">isEmpty</span><span class="p">())</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">u</span> <span class="o">=</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">dequeue</span><span class="p">();</span>
    <span class="kd">let</span> <span class="nx">neighbors</span> <span class="o">=</span> <span class="nx">adjList</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">u</span><span class="p">);</span>
    <span class="nx">color</span><span class="p">[</span><span class="nx">u</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;grey&#39;</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mf">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">neighbors</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">let</span> <span class="nx">w</span> <span class="o">=</span> <span class="nx">neighbors</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">color</span><span class="p">[</span><span class="nx">w</span><span class="p">]</span> <span class="o">===</span> <span class="s1">&#39;white&#39;</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">color</span><span class="p">[</span><span class="nx">w</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;grey&#39;</span><span class="p">;</span>
        <span class="c1">// 路径增加，设置前一个节点为父节点</span>
        <span class="nx">d</span><span class="p">[</span><span class="nx">w</span><span class="p">]</span> <span class="o">=</span> <span class="nx">d</span><span class="p">[</span><span class="nx">u</span><span class="p">]</span> <span class="o">+</span> <span class="mf">1</span><span class="p">;</span>
        <span class="nx">pred</span><span class="p">[</span><span class="nx">w</span><span class="p">]</span> <span class="o">=</span> <span class="nx">u</span><span class="p">;</span>
        <span class="nx">queue</span><span class="p">.</span><span class="nx">enqueue</span><span class="p">(</span><span class="nx">w</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="nx">color</span><span class="p">[</span><span class="nx">u</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;black&#39;</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="p">{</span>
    <span class="nx">distances</span><span class="o">:</span> <span class="nx">d</span><span class="p">,</span>
    <span class="nx">predecessors</span><span class="o">:</span> <span class="nx">pred</span><span class="p">,</span>
  <span class="p">};</span>
<span class="p">};</span>

<span class="c1">// distances: [A: 0, B: 1, C: 1, D: 1, E: 2, F: 2, G: 2, H: 2 , I: 3],</span>
<span class="c1">// predecessors: [A: null, B: &quot;A&quot;, C: &quot;A&quot;, D: &quot;A&quot;, E: &quot;B&quot;, F: &quot;B&quot;, G:&quot;C&quot;, H: &quot;D&quot;, I: &quot;E&quot;]</span>

<span class="c1">// 然后计算顶点（A）到其他节点的路径</span>
</code></pre></div>
<h4 id="2-dfs">2、深度优先算法 dfs<a class="headerlink" href="#2-dfs" title="Permanent link">&para;</a></h4>
<p>首先探索一个分支，沿着路径探索，直到这个路径被全部探索，然后原路返回探索下一个路径。深度优先算法是递归的，所以使用栈更合适。</p>
<div class="highlight"><pre><span></span><code><span class="c1">// 辅助函数和上面相同</span>
<span class="c1">// 开始第一个节点</span>
<span class="k">this</span><span class="p">.</span><span class="nx">des</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">color</span> <span class="o">=</span> <span class="nx">initializeColor</span><span class="p">();</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mf">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">vertices</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">color</span><span class="p">[</span><span class="nx">vertices</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span> <span class="o">===</span> <span class="s1">&#39;white&#39;</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">dfsVisit</span><span class="p">(</span><span class="nx">vertices</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">color</span><span class="p">,</span> <span class="nx">callback</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// 访问节点函数</span>
<span class="kd">let</span> <span class="nx">dfsVisit</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">u</span><span class="p">,</span> <span class="nx">color</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">color</span><span class="p">[</span><span class="nx">u</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;grey&#39;</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">callback</span><span class="p">)</span> <span class="nx">callback</span><span class="p">(</span><span class="nx">u</span><span class="p">);</span>
  <span class="kd">let</span> <span class="nx">neighbors</span> <span class="o">=</span> <span class="nx">adjList</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">u</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mf">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">neighbors</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">w</span> <span class="o">=</span> <span class="nx">neighbors</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">color</span><span class="p">[</span><span class="nx">w</span><span class="p">]</span> <span class="o">===</span> <span class="s1">&#39;white&#39;</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// 递归遍历这个节点</span>
      <span class="nx">dfsVisit</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">color</span><span class="p">,</span> <span class="nx">callback</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="c1">// 遍历结束后，设置当前节点是黑色</span>
  <span class="nx">color</span><span class="p">[</span><span class="nx">u</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;black&#39;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>深度优先算法改进：我们需要知道一个节点变成灰色（开始探索）的时间，一个节点变成黑色（结束探索的时间）以及这个节点的前一个节点（node）</p>
<p>下面是改进的 DFS 算法</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span> <span class="nx">time</span><span class="p">;</span>

<span class="k">this</span><span class="p">.</span><span class="nx">DFS</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">color</span> <span class="o">=</span> <span class="nx">initializeColor</span><span class="p">();</span>
  <span class="c1">// 设置初始时间是0</span>
  <span class="nx">time</span> <span class="o">=</span> <span class="mf">0</span><span class="p">;</span>
  <span class="c1">// 创建开始时间和结束时间的数组</span>
  <span class="kd">let</span> <span class="nx">discovery</span> <span class="o">=</span> <span class="p">[];</span> 
  <span class="kd">let</span> <span class="nx">finished</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="c1">// 存储前一个节点的数组</span>
  <span class="kd">let</span> <span class="nx">predecessors</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mf">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">vertices</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">discovery</span><span class="p">[</span><span class="nx">vertices</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span> <span class="o">=</span> <span class="mf">0</span><span class="p">;</span>
    <span class="nx">finished</span><span class="p">[</span><span class="nx">vertices</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span> <span class="o">=</span> <span class="mf">0</span><span class="p">;</span>
    <span class="nx">predecessors</span><span class="p">[</span><span class="nx">vertices</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mf">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">vertices</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">color</span><span class="p">[</span><span class="nx">vertices</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span> <span class="o">===</span> <span class="s1">&#39;white&#39;</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">dfsVisit</span><span class="p">(</span><span class="nx">vertices</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">color</span><span class="p">,</span> <span class="nx">discovery</span><span class="p">,</span> <span class="nx">finished</span><span class="p">,</span> <span class="nx">predecessors</span><span class="p">,</span> <span class="nx">callback</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="p">{</span> <span class="nx">discovery</span><span class="p">,</span> <span class="nx">finished</span><span class="p">,</span> <span class="nx">predecessors</span> <span class="p">};</span>
<span class="p">}</span>

<span class="nx">dfsVisit</span> <span class="o">=</span> <span class="p">(</span><span class="nx">u</span><span class="p">,</span> <span class="nx">color</span><span class="p">,</span> <span class="nx">d</span><span class="p">,</span> <span class="nx">f</span><span class="p">,</span> <span class="nx">p</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="c1">// 开始探索U节点</span>
  <span class="nx">color</span><span class="p">[</span><span class="nx">u</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;grey&#39;</span><span class="p">;</span>
  <span class="nx">d</span><span class="p">[</span><span class="nx">u</span><span class="p">]</span> <span class="o">=</span> <span class="o">++</span><span class="nx">time</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">callback</span><span class="p">)</span> <span class="nx">callback</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">neighbors</span> <span class="o">=</span> <span class="nx">adjList</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">u</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mf">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">neighbors</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">w</span> <span class="o">=</span> <span class="nx">neighbors</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">color</span><span class="p">[</span><span class="nx">w</span><span class="p">]</span> <span class="o">===</span> <span class="s1">&#39;white&#39;</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">dfsVisit</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">color</span><span class="p">,</span> <span class="nx">d</span><span class="p">,</span> <span class="nx">f</span><span class="p">,</span> <span class="nx">p</span><span class="p">,</span> <span class="nx">callback</span><span class="p">);</span>
      <span class="nx">p</span><span class="p">[</span><span class="nx">w</span><span class="p">]</span> <span class="o">=</span> <span class="nx">u</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nx">color</span><span class="p">[</span><span class="nx">u</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;black&#39;</span><span class="p">;</span>
    <span class="nx">f</span><span class="p">[</span><span class="nx">u</span><span class="p">]</span> <span class="o">=</span> <span class="o">++</span><span class="nx">time</span><span class="p">;</span>
    <span class="c1">// 结束探索U节点</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>改进后的算法满足（V表示节点的数量）通过 d[u] / f[u] 可以计算不同节点的时间比值，可以用于拓扑排序</p>
<p>1 ≤ d[u] &lt; f[u] ≤2 |V|</p>
<p>拓扑排序（DFS扩展）</p>
<p>实例：如果一些任务的执行时连续的（需要步骤）然后不同的任务构成不同的节点，节点之间可以获取最短路径，可以计算具体遍历节点的时间，可以计算多种遍历节点的情况。</p>
<h2 id="_17">第十章 排序和搜索算法<a class="headerlink" href="#_17" title="Permanent link">&para;</a></h2>
<p>排序算法是搜索算法的基础</p>
<h3 id="_18">排序算法<a class="headerlink" href="#_18" title="Permanent link">&para;</a></h3>
<p>用数组构建一个简单的数据结构来排序</p>
<div class="highlight"><pre><span></span><code><span class="kd">function</span> <span class="nx">ArrayList</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">insert</span> <span class="o">=</span> <span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">arr</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">item</span><span class="p">);</span>
  <span class="p">};</span>
  <span class="c1">// 验证排序的结果</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">toString</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arr</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">));</span>
  <span class="p">}</span>
<span class="p">}</span> 
</code></pre></div>
<p>下面是五个排序算法，由差变好</p>
<h4 id="1">1 冒泡排序法<a class="headerlink" href="#1" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code><span class="kd">function</span> <span class="nx">ArrayList</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">insert</span> <span class="o">=</span> <span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">arr</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">item</span><span class="p">);</span>
  <span class="p">};</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">toString</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arr</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="c1">// 缺点：内循环和外循环消耗时间，频繁交换数组的位置消耗内存。</span>
  <span class="nx">bubbleSort</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mf">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="mf">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">len</span> <span class="o">-</span> <span class="mf">1</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span> <span class="o">+</span> <span class="mf">1</span><span class="p">])</span> <span class="p">{</span>
          <span class="kd">let</span> <span class="nx">k</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span> <span class="o">+</span> <span class="mf">1</span><span class="p">];</span>
          <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span> <span class="o">+</span> <span class="mf">1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">];</span>
          <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="nx">k</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="c1">// 改进版冒泡排序法（内循环次数减半）</span>
  <span class="nx">bubbleSortUpdate</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mf">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="mf">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">len</span> <span class="o">-</span> <span class="nx">i</span> <span class="o">-</span> <span class="mf">1</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span> <span class="o">+</span> <span class="mf">1</span><span class="p">])</span> <span class="p">{</span>
          <span class="c1">// 交换函数，交换数组中两个项的位置；</span>
          <span class="nx">swap</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span> <span class="o">+</span> <span class="mf">1</span><span class="p">]);</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="2">2 选择排序法<a class="headerlink" href="#2" title="Permanent link">&para;</a></h4>
<p>（遍历数组获取最小值，然后和第一位交换）时间复杂度n平方</p>
<div class="highlight"><pre><span></span><code><span class="nx">selectionSort</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">minItem</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mf">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">minItem</span> <span class="o">=</span> <span class="nx">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="nx">i</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">minItem</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">])</span> <span class="p">{</span>
        <span class="nx">minItem</span> <span class="o">=</span> <span class="nx">j</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">i</span> <span class="o">!==</span> <span class="nx">minItem</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">swap</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">minItem</span><span class="p">]);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="3">3 插入排序法<a class="headerlink" href="#3" title="Permanent link">&para;</a></h4>
<p><sub>~</sub>js
insertSort = () =&gt; {
  let len = arr.length;
  let j , temp;
  for (let i = 0; i &lt; len; i++) {
    j = i;
    temp = arr[i];
    while (j &gt; 0 &amp;&amp; arr[j - 1] &gt; temp) {
      arr[j] = arr[j - 1];
      j--;
    }
    arr[j] = temp;
  }
}
  // 前三个性能不好，后面两个排序可以用在实际工作中
  // 上面的代码把一部分变量定义的函数内部开始位置，不定义在循环内部，这样可以节省内存。
  <sub>~</sub></p>
<h4 id="4">4 并归排序<a class="headerlink" href="#4" title="Permanent link">&para;</a></h4>
<p>nlogn 火狐浏览器使用</p>
<p>思路：把一个数组切分成很多小数组，然后对每个小数组排序，最后将小数组并归一个排序完整的大数组。</p>
<div class="highlight"><pre><span></span><code><span class="k">this</span><span class="p">.</span><span class="nx">mergeSort</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">array</span> <span class="o">=</span> <span class="nx">mergeSortRect</span><span class="p">(</span><span class="nx">array</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">mergeSortRect</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">array</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">array</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">len</span> <span class="o">===</span> <span class="mf">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">array</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">let</span> <span class="nx">mid</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nx">len</span> <span class="o">/</span> <span class="mf">2</span><span class="p">);</span>
  <span class="kd">let</span> <span class="nx">left</span> <span class="o">=</span> <span class="nx">array</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span> <span class="nx">mid</span><span class="p">);</span>
  <span class="kd">let</span> <span class="nx">right</span> <span class="o">=</span> <span class="nx">array</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="nx">mid</span><span class="p">,</span> <span class="nx">len</span><span class="p">);</span>
  <span class="k">return</span> <span class="nx">merge</span><span class="p">(</span><span class="nx">mergeSortRect</span><span class="p">(</span><span class="nx">left</span><span class="p">),</span> <span class="nx">mergeSortRect</span><span class="p">(</span><span class="nx">right</span><span class="p">));</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">merge</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">left</span><span class="p">,</span> <span class="nx">right</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="kd">let</span> <span class="nx">il</span> <span class="o">=</span> <span class="mf">0</span><span class="p">,</span> <span class="nx">ir</span> <span class="o">=</span> <span class="mf">0</span><span class="p">;</span>
  <span class="c1">// 用新数组迭代两个旧数组</span>
  <span class="k">while</span> <span class="p">(</span><span class="nx">il</span> <span class="o">&lt;</span> <span class="nx">left</span><span class="p">.</span><span class="nx">length</span> <span class="o">&amp;&amp;</span> <span class="nx">ir</span> <span class="o">&lt;</span> <span class="nx">right</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">left</span><span class="p">[</span><span class="nx">il</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">right</span><span class="p">[</span><span class="nx">ir</span><span class="p">])</span> <span class="p">{</span>
      <span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">left</span><span class="p">[</span><span class="nx">il</span><span class="p">]);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">right</span><span class="p">[</span><span class="nx">ir</span><span class="p">]);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">while</span> <span class="p">(</span><span class="nx">il</span> <span class="o">&lt;</span> <span class="nx">left</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">left</span><span class="p">[</span><span class="nx">il</span><span class="p">]);</span>
  <span class="p">}</span>
  <span class="k">while</span> <span class="p">(</span><span class="nx">ir</span> <span class="o">&lt;</span> <span class="nx">right</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">right</span><span class="p">[</span><span class="nx">ir</span><span class="p">]);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>并归排序的思路：先把复杂问题分成小问题，然后从多个简单的小问题中找到统一的解决方法，然后使用小问题，最后将不同的小问题并归后，大问题就解决了。</p>
<h4 id="5">5 快速排序<a class="headerlink" href="#5" title="Permanent link">&para;</a></h4>
<p>快速排序法较复杂，性能最好 nLogn。</p>
<p>思想：首先获取数组的中间项（主元）；然后设置第一个项为前指针，最后一个项是后指针。前指针向后移动，直到找到一个比中间项大的元素，后指针向前移动，找到一个比中间项小的元素，交换两个元素的位置。然后继续执行，直到前指针大于后指针。那么这样一轮过后，前面的项都比中间项小，后面的项都比中间项大；之后利用递归的思想，把数组划分成前后两部分，继续排序，最后排序结束。</p>
<div class="highlight"><pre><span></span><code><span class="k">this</span><span class="p">.</span><span class="nx">quickSort</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">quick</span><span class="p">(</span><span class="nx">array</span><span class="p">,</span> <span class="mf">0</span><span class="p">,</span> <span class="nx">array</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mf">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">quick</span><span class="p">(</span><span class="nx">array</span><span class="p">,</span> <span class="nx">left</span><span class="p">,</span> <span class="nx">right</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">index</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">array</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mf">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">index</span> <span class="o">=</span> <span class="nx">partition</span><span class="p">(</span><span class="nx">array</span><span class="p">,</span> <span class="nx">left</span><span class="p">,</span> <span class="nx">right</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">left</span> <span class="o">&lt;</span> <span class="nx">index</span> <span class="o">-</span> <span class="mf">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">quick</span><span class="p">(</span><span class="nx">array</span><span class="p">,</span> <span class="nx">left</span><span class="p">,</span> <span class="nx">index</span> <span class="o">-</span> <span class="mf">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">index</span> <span class="o">&lt;</span> <span class="nx">right</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">quick</span><span class="p">(</span><span class="nx">array</span><span class="p">,</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">right</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">partition</span><span class="p">(</span><span class="nx">array</span><span class="p">,</span> <span class="nx">left</span><span class="p">,</span> <span class="nx">right</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 主元可以随机选择；通常选择中间一个排序性能较好</span>
  <span class="kd">let</span> <span class="nx">middle</span> <span class="o">=</span> <span class="nx">array</span><span class="p">[</span><span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">((</span><span class="nx">left</span> <span class="o">+</span> <span class="nx">right</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2</span><span class="p">)];</span>
  <span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">left</span><span class="p">,</span> <span class="nx">j</span> <span class="o">=</span> <span class="nx">right</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">j</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="nx">array</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">middle</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">i</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">while</span> <span class="p">(</span><span class="nx">array</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">middle</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">j</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">j</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">swapQuickSort</span><span class="p">(</span><span class="nx">array</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">);</span>
      <span class="nx">i</span><span class="o">++</span><span class="p">;</span>
      <span class="nx">j</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">swapQuickSort</span><span class="p">(</span><span class="nx">array</span><span class="p">,</span> <span class="nx">index1</span><span class="p">,</span> <span class="nx">index2</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">temp</span> <span class="o">=</span> <span class="nx">array</span><span class="p">[</span><span class="nx">index1</span><span class="p">];</span>
  <span class="nx">array</span><span class="p">[</span><span class="nx">index1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">array</span><span class="p">[</span><span class="nx">index2</span><span class="p">];</span>
  <span class="nx">array</span><span class="p">[</span><span class="nx">index2</span><span class="p">]</span> <span class="o">=</span> <span class="nx">temp</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="_19">搜索算法<a class="headerlink" href="#_19" title="Permanent link">&para;</a></h3>
<h4 id="1_1">1 顺序搜索<a class="headerlink" href="#1_1" title="Permanent link">&para;</a></h4>
<p>最低效的搜索方法，需要遍历整个数组。</p>
<div class="highlight"><pre><span></span><code><span class="kd">function</span> <span class="nx">sequentialSearch</span><span class="p">(</span><span class="nx">array</span><span class="p">,</span> <span class="nx">target</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mf">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">array</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">array</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">===</span> <span class="nx">target</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">i</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="o">-</span><span class="mf">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="2_1">2 二分搜索<a class="headerlink" href="#2_1" title="Permanent link">&para;</a></h4>
<p>要求被搜索的数组已经排序，然后找到中间的值，和目标值相比较，直到找到目标值。</p>
<div class="highlight"><pre><span></span><code><span class="k">this</span><span class="p">.</span><span class="nx">binarySearch</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">target</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">quickSort</span><span class="p">();</span>
  <span class="kd">let</span> <span class="nx">low</span> <span class="o">=</span> <span class="mf">0</span><span class="p">,</span> <span class="nx">height</span> <span class="o">=</span> <span class="nx">array</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mf">1</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">middle</span><span class="p">,</span> <span class="nx">element</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="nx">low</span> <span class="o">&lt;=</span> <span class="nx">height</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">mid</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">((</span><span class="nx">low</span> <span class="o">+</span> <span class="nx">height</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2</span><span class="p">);</span>
    <span class="nx">element</span> <span class="o">=</span> <span class="nx">array</span><span class="p">[</span><span class="nx">mid</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">element</span> <span class="o">&lt;</span> <span class="nx">target</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">low</span> <span class="o">=</span> <span class="nx">middle</span> <span class="o">+</span> <span class="mf">1</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">element</span> <span class="o">&gt;</span> <span class="nx">target</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">height</span> <span class="o">=</span> <span class="nx">middle</span> <span class="o">-</span> <span class="mf">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">middle</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="o">-</span><span class="mf">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="_20">第十一章 算法补充<a class="headerlink" href="#_20" title="Permanent link">&para;</a></h2>
<h3 id="_21">递归<a class="headerlink" href="#_21" title="Permanent link">&para;</a></h3>
<p>递归：把一个复杂问题转化成多步重复计算。可以一个函数调用自己，可以两个函数互相调用。</p>
<p>在ES6中，可以使用尾调用（函数最后一句代码调用函数）进行优化。其他语言中递归性能不好，ES6通过尾递归可以优化性能。
注意：递归需要有边界条件，避免无限递归造成浏览器内存溢出（stack overflow error）。例如斐波那契数列：</p>
<div class="highlight"><pre><span></span><code><span class="kd">function</span> <span class="nx">fibonacci</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">n</span> <span class="o">===</span> <span class="mf">1</span> <span class="o">||</span> <span class="nx">n</span> <span class="o">===</span> <span class="mf">2</span><span class="p">)</span> <span class="k">return</span> <span class="mf">1</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">fibonacci</span><span class="p">(</span><span class="nx">n</span> <span class="o">-</span> <span class="mf">1</span><span class="p">)</span> <span class="o">+</span> <span class="nx">fibonacci</span><span class="p">(</span><span class="nx">n</span> <span class="o">-</span> <span class="mf">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 非递归写法</span>
<span class="kd">function</span> <span class="nx">fib</span><span class="p">(</span><span class="nx">num</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="mf">1</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">n1</span> <span class="o">=</span> <span class="mf">1</span><span class="p">,</span> <span class="nx">n2</span> <span class="o">=</span> <span class="mf">1</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mf">3</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">num</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">result</span> <span class="o">=</span> <span class="nx">n1</span> <span class="o">+</span> <span class="nx">n2</span><span class="p">;</span>
    <span class="nx">n1</span> <span class="o">=</span> <span class="nx">n2</span><span class="p">;</span>
    <span class="nx">n2</span> <span class="o">=</span> <span class="nx">result</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>递归代码量很少，更容易理解；难点是边界条件和开始条件。</p>
<h3 id="_22">迭代<a class="headerlink" href="#_22" title="Permanent link">&para;</a></h3>
<p>函数的递归可能占用大量内存。每次进行递归，都需要临时存储父函数的计算结果，在某些情况下会造成内存问题，可以使用迭代法解决。</p>
<p>递归类似 DFS，迭代类似 BFS。迭代使用一个临时的栈存储当时的结果，每次执行一次计算后，判断当前结果是否满足条件。</p>
<p>递归和迭代可以互相转换。</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span> <span class="nx">stack</span> <span class="o">=</span> <span class="p">[];</span>
<span class="k">while</span> <span class="p">(</span><span class="nx">stack</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mf">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">curr</span> <span class="o">=</span> <span class="nx">stack</span><span class="p">.</span><span class="nx">pop</span><span class="p">();</span>
  <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">fn</span><span class="p">(</span><span class="nx">curr</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">stack</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="_23">动态规划<a class="headerlink" href="#_23" title="Permanent link">&para;</a></h3>
<p>分而治之：把一个复杂的问题分解成很多无关联的小问题（例如接雨水）。</p>
<p>动态规划：把一个复杂的问题分解成很多关联的小问题（识别子问题和边界条件）下面是典型问题</p>
<ul>
<li>
<p>背包问题:给出一组项目，各自有值和容量，目标是找出总值最大的项目的集合。这个 问题的限制是，总容量必须小于等于“背包”的容量。</p>
</li>
<li>
<p>最长公共子序列:找出一组序列的最长公共子序列(可由另一序列删除元素但不改变余 下元素的顺序而得到)。</p>
</li>
<li>
<p>矩阵链相乘:给出一系列矩阵，目标是找到这些矩阵相乘的最高效办法(计算次数尽可 能少)。相乘操作不会进行，解决方案是找到这些矩阵各自相乘的顺序。</p>
</li>
<li>
<p>硬币找零:给出面额为d1...dn的一定数量的硬币和要找零的钱数，找出有多少种找零的 方法。</p>
</li>
<li>
<p>图的全源最短路径:对所有顶点对(u, v)，找出从顶点u到顶点v的最短路径。</p>
</li>
</ul>
<h3 id="_24">最少硬币找零算法<a class="headerlink" href="#_24" title="Permanent link">&para;</a></h3>
<p>硬币找零问题是给出要找零的钱数，以及可 用的硬币面额d1...dn及其数量，找出有多少种找零方法。</p>
<p>最少硬币找零问题是给出要找零的钱数， 以及可用的硬币面额d1...dn及其数量，找到所需的最少的硬币个数（就是上面硬币找零算法结果中，硬币最少的一种算法）。 </p>
<p>例如：美国有以下面额(硬币):d1=1，d2=5，d3=10，d4=25。 如果要找36美分的零钱，我们可以用1个25美分、1个10美分和1个便士(1美分)。 </p>
<div class="highlight"><pre><span></span><code><span class="kd">function</span> <span class="nx">MinCoinChange</span><span class="p">(</span><span class="nx">coins</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">cache</span> <span class="o">=</span> <span class="p">{};</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">makeChange</span> <span class="o">=</span> <span class="p">(</span><span class="nx">amount</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">me</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">amount</span><span class="p">)</span> <span class="k">return</span> <span class="p">[];</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">cache</span><span class="p">[</span><span class="nx">amount</span><span class="p">])</span> <span class="k">return</span> <span class="nx">cache</span><span class="p">[</span><span class="nx">amount</span><span class="p">];</span>

    <span class="kd">let</span> <span class="nx">min</span> <span class="o">=</span> <span class="p">[],</span> <span class="nx">newMin</span><span class="p">,</span> <span class="nx">newAmount</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mf">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">coins</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">let</span> <span class="nx">coin</span> <span class="o">=</span> <span class="nx">coins</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
      <span class="nx">newAmount</span> <span class="o">=</span> <span class="nx">amount</span> <span class="o">-</span> <span class="nx">coin</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">newAmount</span> <span class="o">&gt;=</span> <span class="mf">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 递归获取最小值</span>
        <span class="nx">newMin</span> <span class="o">=</span> <span class="nx">me</span><span class="p">.</span><span class="nx">makeChange</span><span class="p">(</span><span class="nx">newAmount</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">newAmount</span> <span class="o">&gt;=</span><span class="mf">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">newMin</span><span class="p">.</span><span class="nx">length</span> <span class="o">&lt;</span> <span class="nx">min</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mf">1</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="nx">min</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">newMin</span><span class="p">.</span><span class="nx">length</span> <span class="o">||</span> <span class="o">!</span><span class="nx">newAmount</span><span class="p">))</span> <span class="p">{</span>
        <span class="nx">min</span> <span class="o">=</span> <span class="p">[</span><span class="nx">coin</span><span class="p">].</span><span class="nx">concat</span><span class="p">(</span><span class="nx">newMin</span><span class="p">);</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">min</span><span class="p">,</span> <span class="nx">amount</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="p">(</span><span class="nx">cache</span><span class="p">[</span><span class="nx">amount</span><span class="p">]</span> <span class="o">=</span> <span class="nx">min</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="_25">贪心算法<a class="headerlink" href="#_25" title="Permanent link">&para;</a></h3>
<p>贪心算法：追求每一个局部的问题的最优解。大部分情况下可以获取正确的值，少出情况不是最优解，这样写性能很好。</p>
<div class="highlight"><pre><span></span><code><span class="kd">function</span> <span class="nx">MinCoinChange</span><span class="p">(</span><span class="nx">coins</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">coins</span> <span class="o">=</span> <span class="nx">coins</span><span class="p">;</span>
  <span class="c1">// 这里的coins是从小到大排序的，然后依次把最大的值加入到total中，然后把coin存储在change中</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">makeChange</span> <span class="o">=</span> <span class="p">(</span><span class="nx">amount</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">change</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="kd">let</span> <span class="nx">total</span> <span class="o">=</span> <span class="mf">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">coins</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mf">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">let</span> <span class="nx">coin</span> <span class="o">=</span> <span class="nx">coins</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
      <span class="k">while</span> <span class="p">(</span><span class="nx">total</span> <span class="o">+</span> <span class="nx">coin</span> <span class="o">&lt;=</span> <span class="nx">amount</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">change</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">coin</span><span class="p">);</span>
        <span class="nx">total</span> <span class="o">+=</span> <span class="nx">coin</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">change</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>如果是 [1, 5, 10, 25] target 36 可以算对；如果是[1, 3, 4] target 6 就会算错</p>
<p>如果对算法精度要求不高，贪心算法可以在较好的时间内计算出可以接受的答案。</p>
<h3 id="o_1">大O表示法与时间复杂度<a class="headerlink" href="#o_1" title="Permanent link">&para;</a></h3>
<p>如果算法的计算时间和传入参数大小无关，即算法的耗时是一个常数，那么复杂度就是O1</p>
<div class="highlight"><pre><span></span><code><span class="kd">function</span> <span class="nx">add</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>如果算法的计算时间和传入的数组的参数个数相等，那么就是On</p>
<div class="highlight"><pre><span></span><code><span class="kd">function</span> <span class="nx">index</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">target</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mf">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">===</span> <span class="nx">target</span><span class="p">)</span> <span class="k">return</span> <span class="nx">i</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="o">-</span><span class="mf">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>如果计算时间和数组的参数的平方相等，就是On2，例如冒泡排序法的内循环*外循环</p>
<p>常见的算法复杂度的计算</p>
<h3 id="_26">算法比赛网站<a class="headerlink" href="#_26" title="Permanent link">&para;</a></h3>
<ul>
<li>
<p>UVa Online Judge(<a href="http://uva.onlinejudge.org/):这个网站包含了世界各大赛事的题目">http://uva.onlinejudge.org/):这个网站包含了世界各大赛事的题目</a>， 包括由IBM赞助的ACM国际大学生程序竞赛 ICPC </p>
</li>
<li>
<p>Sphere Online Judge(<a href="http://www.spoj.com/">http://www.spoj.com/</a>): 这个网站和UVa Online Judge差不多，但支 </p>
</li>
</ul>
<p>持用更多语言解题(包括JavaScript)。 </p>
<ul>
<li>Coder Byte(<a href="http://coderbyte.com/):这个网站包含了74个可以用JavaScript解答的题目(简">http://coderbyte.com/):这个网站包含了74个可以用JavaScript解答的题目(简</a> </li>
</ul>
<p>单、中等难度和非常困难)。 </p>
<ul>
<li>Project Euler(<a href="https://projecteuler.net/):这个网站包含了一系列数学/计算机的编程题目">https://projecteuler.net/):这个网站包含了一系列数学/计算机的编程题目</a>。 </li>
</ul>
<p>你所要做的就是输入那些题目的答案，不过我们可以用算法来找到正确的解答。 Hacker Rank(<a href="https://www.hackerrank.com):这个网站包含了263个挑战">https://www.hackerrank.com):这个网站包含了263个挑战</a>，分为16个类别 </p>
<p>(可以应用本书中的算法和更多其他算法)。它也支持JavaScript和其他语言。 </p>
<ul>
<li>
<p>Code Chef(<a href="http://www.codechef.com/):这个网站包含一些题目">http://www.codechef.com/):这个网站包含一些题目</a>，并会举办在线比赛。 </p>
</li>
<li>
<p>Top Coder(<a href="http://www.topcoder.com/):此网站会举办算法联赛">http://www.topcoder.com/):此网站会举办算法联赛</a>，这些联赛通常由NASA、 </p>
</li>
</ul>
<p>Google、Yahoo!、Amazon和Facebook这样的公司赞助。参加其中一些赛事，你可以获得 到赞助公司工作的机会，而参与另一些赛事会赢得奖金。这个网站也提供很棒的解题和 算法教程。 </p>
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid" aria-label="Footer">
        
          <a href="../40%E9%80%80%E4%BC%91/" class="md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-footer-nav__button md-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
            </div>
            <div class="md-footer-nav__title">
              <div class="md-ellipsis">
                <span class="md-footer-nav__direction">
                  Previous
                </span>
                40退休
              </div>
            </div>
          </a>
        
        
          <a href="../Poor-and-busy/" class="md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-footer-nav__title">
              <div class="md-ellipsis">
                <span class="md-footer-nav__direction">
                  Next
                </span>
                Poor-and-busy
              </div>
            </div>
            <div class="md-footer-nav__button md-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"/></svg>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
          <div class="md-footer-copyright__highlight">
            Copyright &copy; Michael An
          </div>
        
        Made with
        <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
          Material for MkDocs
        </a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../assets/javascripts/vendor.18f0862e.min.js"></script>
      <script src="../../assets/javascripts/bundle.994580cf.min.js"></script><script id="__lang" type="application/json">{"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.term.missing": "Missing"}</script>
      
      <script>
        app = initialize({
          base: "../..",
          features: [],
          search: Object.assign({
            worker: "../../assets/javascripts/worker/search.9c0e82ba.min.js"
          }, typeof search !== "undefined" && search)
        })
      </script>
      
        <script src="../../js/baidu-statistics.js"></script>
      
    
  </body>
</html>