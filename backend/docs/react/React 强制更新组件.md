**当你遇到需要同时获取多个子组件数据，或者两个组件之间需要相互通讯的情况时，把子组件的 state 数据提升至其共同的父组件当中保存。之后父组件可以通过 props 将状态数据传递到子组件当中。这样应用当中的状态数据就能够更方便地交流共享了。**



### 为什么不可变性在React当中非常重要

在上一节内容当中，我们通过使用 `.slice()` 方法对已有的数组数据进行了浅拷贝，以此来防止对已有数据的改变。接下来我们稍微了解一下为什么这样的操作是一种非常重要的概念。

改变应用数据的方式一般分为两种。第一种是直接修改已有的变量的值。第二种则是将已有的变量替换为一个新的变量。

#### 在 React 当中判定何时重新渲染

运用不可变性原则给 React 带来最大的好处是，既然我们现在可以很方便地判断对象数据是否发生改变了，那么也就很好决定何时根据数据的改变重新渲染组件。尤其是当我们编写的都属于 **纯组件 pure components** 的时候，这种好处的效果更为明显。

你用肉眼可以很轻易地分辨，Alexa 被移到了最后，多出来一个 Claudia。可是 React 只是电脑里运行地程序，它无从知晓这些改变。所以我们必须为列表中的每一项添加一个 *key* 作为唯一的标识符。标识符必须是唯一的，比方说刚才这个例子中的 `alexa`, `ben`, `claudia` 就可以用来做标识符。更普遍的一种情况，假如我们的数据是从数据库获取的话，表单每一项的 ID 就很适合当作它的 *key* ：

`<li key={user.id}>{user.name}: {user.taskCount} tasks left</li>`

`key` 是 React 当中使用的一种特殊的属性（除此之外还有 `ref` 属性）。当元素被创建时，React 会将元素的 `key` 值和对应元素绑定存储起来。尽管 `key` 看起来像是 props 的一部分，可是事实上我们无法通过 `this.props.key` 获取到 `key` 的值。React 会自动的在判断元素更新时使用 `key` ，而组件自己是无法获取到 `key` 的。

当一个列表被重新渲染时，React 会根据较新的元素内容依据相应的 key 值来匹配之前的元素内容。当一个新的 key 值添加到列表当中时，表示有一个组件被创建；被删除时表示有一个组件被销毁。Key 值可以让 React 明确标识每个组件，这样它才能在每次重新渲染时保有对应的状态数据。假如你去改变某个组件的 key 值的话，它会在下次渲染时被销毁并当作新的组件重新渲染进来。

假如你不提供任何 key 值，React 会提示警告，并且默认使用数组的索引作为默认的 key ，但只要你想在列表中对项目进行重新排列、添加或删除的话，这都不是一个好选择（因为对应的键值都会改变，也就会出现我们上面提到的组件key值被改变就会被当作新创建的组件处理那种情况）。手动添加列表索引值 `key={i}` 可以消除警告，但也会存在相同的问题，因此在大多数情况下都不推荐这种做法。

组件的 keys 值并不需要在全局都保证唯一，只需要在当前的节点里保证唯一即可。

### React 强制更新组件

有时候需要对一个组件进行强制更新（不是由于state变化造成组件更新）。react原则上不需要强制进行更新，原理就是根据state和props进行数据传递，根据diff算法进行渲染组件得到局部更新。

那么强制更新就需要从state和props进行分析；如果逻辑问题就从生命周期函数角度分析。

~~~jsx
class menu extends React.Component {
  // 第一次加载组件调用
  componentDidMount = () => {
    this.getInfo(this.props.xxx);
    this.hasInfo();
  }
  // 每次接收到新props调用
  componentWillReceiveProps = (nextProps) => {
    if (nextProps !== this.props) {
      this.getInfo(nextProps);
      this.haveInfo();
    }
  }
  
  render() {
    return (
    	<div></div>
    );
  }
}
~~~

